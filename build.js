(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var weeks = require('./schedule');
var ractiveStateRouter = require('ractive-state-router');
var abstractStateRouter = require('abstract-state-router');
var ractiveStateRenderer = ractiveStateRouter(require('ractive'));
var stateRouter = abstractStateRouter(ractiveStateRenderer, '#app-content');
var model = require('./model');

function dayName(date) {
	var day = date.getDay();
	return ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][day];
}

function monthName(date) {
	var month = date.getMonth();
	return ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'][month];
}

var colors = {
	walk: 'blue',
	cooldown: 'aqua',
	warmup: 'olive',
	jog: 'orange'
};

stateRouter.addState({
	name: 'day-selection',
	template: '#day-selection',
	route: '/select',
	resolve: function resolve(data, params, cb) {
		cb(null, {
			allPlans: weeks,
			model: model.load(),
			monthName: monthName,
			dayName: dayName
		});
	}
});

stateRouter.addState({
	name: 'timer',
	template: {
		template: '#timer',
		computed: {
			currentPlan: function currentPlan() {
				return this.get('plan')[this.get('currentStep')];
			},
			percentage: function percentage() {
				return Math.min(this.get('secondsThisStep') / this.get('currentPlan').seconds * 100, 100);
			},
			color: function color() {
				return colors[this.get('currentPlan').action];
			}
		}
	},
	route: '/timer/:week(\\d+)/:day(\\d+)',
	resolve: function resolve(data, params, cb) {
		cb(null, {
			plan: weeks[params.week][params.day],
			parameters: params,
			currentStep: 0,
			secondsThisStep: 0
		});
	},
	activate: function activate(context) {
		var ractive = context.domApi;
		var parameters = context.parameters;

		// if I start at 23:45 and finish at 00:15, it counts as being the day before

		var runDate = new Date();

		function incrementStep() {
			var nextStep = ractive.get('currentStep') + 1;
			var lastStepNumber = ractive.get('plan').length;

			if (nextStep >= lastStepNumber) {
				ractive.fire('done');
			} else {
				ractive.set({
					currentStep: nextStep,
					secondsThisStep: 0
				});
			}
		}

		var clear = timerTick(100, debounceToNextFrame(function (seconds, resetClock) {
			var doneWithThisStep = ractive.get('secondsThisStep') >= ractive.get('currentPlan').seconds;
			if (doneWithThisStep) {
				incrementStep();
				resetClock();
			} else {
				ractive.set({
					secondsThisStep: seconds
				});
			}
		}));

		ractive.on('cancel', function () {
			return stateRouter.go('day-selection');
		});

		ractive.on('done', function () {
			model.storeDay({
				week: parameters.week,
				day: parameters.day,
				date: runDate
			});
			stateRouter.go('congrats');
		});

		context.on('destroy', clear);
	}
});

stateRouter.addState({
	name: 'congrats',
	template: '#congrats',
	route: '/complete',
	activate: function activate(context) {
		var timeout = setTimeout(function () {
			stateRouter.go('day-selection');
		}, 3000);

		context.on('destroy', function () {
			return clearTimeout(timeout);
		});
	}
});

function timerTick(frequency, tickCb) {
	var started = void 0;

	function resetClock() {
		started = performance.now();
	}

	var interval = setInterval(function () {
		return tickCb((performance.now() - started) / 1000, resetClock);
	}, frequency);

	resetClock();

	return function () {
		return clearInterval(interval);
	};
}

function debounceToNextFrame(fn) {
	var happening = false;
	return function () {
		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		if (!happening) {
			happening = true;
			window.requestAnimationFrame(function () {
				happening = false;
				fn.apply(null, args);
			});
		}
	};
}

stateRouter.evaluateCurrentRoute('day-selection');

},{"./model":2,"./schedule":30,"abstract-state-router":4,"ractive":27,"ractive-state-router":26}],2:[function(require,module,exports){
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var extend = require('xtend');

var KEY = 'C25K';

module.exports = {
	load: function load() {
		return addMethods(loadFromLocalstorage());
	},
	storeDay: function storeDay(_ref) {
		var week = _ref.week;
		var day = _ref.day;
		var date = _ref.date;

		return setDay({ model: loadFromLocalstorage(), week: week, day: day, date: date });
	}
};

function loadFromLocalstorage() {
	var fromStorage = localStorage.getItem(KEY);

	return fromStorage ? JSON.parse(fromStorage) : {};
}

function store(model) {
	localStorage.setItem(KEY, JSON.stringify(model));
}

function addMethods(model) {
	model.getWeek = getWeek.bind(null, model);
	model.getDay = getDay.bind(null, model);
	return model;
}

function getWeek(model, week) {
	return model[week] || {};
}

function getDay(model, week, day) {
	var timestamp = getWeek(model, week)[day];
	return timestamp ? new Date(timestamp) : null;
}

function setDay(_ref2) {
	var model = _ref2.model;
	var week = _ref2.week;
	var day = _ref2.day;
	var date = _ref2.date;

	var newModel = extend(model, _defineProperty({}, week, extend(model[week], _defineProperty({}, day, date.valueOf()))));

	store(newModel);

	return addMethods(newModel);
}

},{"xtend":29}],3:[function(require,module,exports){
module.exports = { reverse: false }
},{}],4:[function(require,module,exports){
(function (process){
var StateState = require('./lib/state-state')
var StateComparison = require('./lib/state-comparison')
var CurrentState = require('./lib/current-state')
var stateChangeLogic = require('./lib/state-change-logic')
var parse = require('./lib/state-string-parser')
var StateTransitionManager = require('./lib/state-transition-manager')
var defaultRouterOptions = require('./default-router-options.js')

var series = require('./lib/promise-map-series')
var denodeify = require('then-denodeify')

var EventEmitter = require('events').EventEmitter
var extend = require('xtend')
var newHashBrownRouter = require('hash-brown-router')
var combine = require('combine-arrays')
var buildPath = require('page-path-builder')

require('native-promise-only/npo')

var expectedPropertiesOfAddState = ['name', 'route', 'defaultChild', 'data', 'template', 'resolve', 'activate', 'querystringParameters', 'defaultQuerystringParameters']

module.exports = function StateProvider(makeRenderer, rootElement, stateRouterOptions) {
	var prototypalStateHolder = StateState()
	var lastCompletelyLoadedState = CurrentState()
	var lastStateStartedActivating = CurrentState()
	var stateProviderEmitter = new EventEmitter()
	StateTransitionManager(stateProviderEmitter)
	stateRouterOptions = extend({
		throwOnError: true,
		pathPrefix: '#'
	}, stateRouterOptions)

	if (!stateRouterOptions.router) {
		stateRouterOptions.router = newHashBrownRouter(defaultRouterOptions)
	}

	stateRouterOptions.router.setDefault(function(route, parameters) {
		stateProviderEmitter.emit('routeNotFound', route, parameters)
	})

	var destroyDom = null
	var getDomChild = null
	var renderDom = null
	var resetDom = null

	var activeDomApis = {}
	var activeStateResolveContent = {}
	var activeEmitters = {}

	function handleError(event, err) {
		process.nextTick(function() {
			stateProviderEmitter.emit(event, err)
			console.error(event + ' - ' + err.message)
			if (stateRouterOptions.throwOnError) {
				throw err
			}
		})
	}

	function destroyStateName(stateName) {
		var state = prototypalStateHolder.get(stateName)
		stateProviderEmitter.emit('beforeDestroyState', {
			state: state,
			domApi: activeDomApis[stateName]
		})

		activeEmitters[stateName].emit('destroy')
		activeEmitters[stateName].removeAllListeners()
		delete activeEmitters[stateName]
		delete activeStateResolveContent[stateName]

		return destroyDom(activeDomApis[stateName]).then(function() {
			delete activeDomApis[stateName]
			stateProviderEmitter.emit('afterDestroyState', {
				state: state
			})
		})
	}

	function resetStateName(parameters, stateName) {
		var domApi = activeDomApis[stateName]
		var content = getContentObject(activeStateResolveContent, stateName)
		var state = prototypalStateHolder.get(stateName)

		stateProviderEmitter.emit('beforeResetState', {
			domApi: domApi,
			content: content,
			state: state,
			parameters: parameters
		})

		activeEmitters[stateName].emit('destroy')
		delete activeEmitters[stateName]

		return resetDom({
			domApi: domApi,
			content: content,
			template: state.template,
			parameters: parameters
		}).then(function() {
			stateProviderEmitter.emit('afterResetState', {
				domApi: domApi,
				content: content,
				state: state,
				parameters: parameters
			})
		})
	}

	function getChildElementForStateName(stateName) {
		return new Promise(function(resolve) {
			var parent = prototypalStateHolder.getParent(stateName)
			if (parent) {
				var parentDomApi = activeDomApis[parent.name]
				resolve(getDomChild(parentDomApi))
			} else {
				resolve(rootElement)
			}
		})
	}

	function renderStateName(parameters, stateName) {
		return getChildElementForStateName(stateName).then(function(childElement) {
			var state = prototypalStateHolder.get(stateName)
			var content = getContentObject(activeStateResolveContent, stateName)

			stateProviderEmitter.emit('beforeCreateState', {
				state: state,
				content: content,
				parameters: parameters
			})

			return renderDom({
				element: childElement,
				template: state.template,
				content: content,
				parameters: parameters
			}).then(function(domApi) {
				activeDomApis[stateName] = domApi
				stateProviderEmitter.emit('afterCreateState', {
					state: state,
					domApi: domApi,
					content: content,
					parameters: parameters
				})
				return domApi
			})
		})
	}

	function renderAll(stateNames, parameters) {
		return series(stateNames, renderStateName.bind(null, parameters))
	}

	function onRouteChange(state, parameters) {
		try {
			var finalDestinationStateName = prototypalStateHolder.applyDefaultChildStates(state.name)

			if (finalDestinationStateName === state.name) {
				emitEventAndAttemptStateChange(finalDestinationStateName, parameters)
			} else {
				// There are default child states that need to be applied

				var theRouteWeNeedToEndUpAt = makePath(finalDestinationStateName, parameters)
				var currentRoute = stateRouterOptions.router.location.get()

				if (theRouteWeNeedToEndUpAt === currentRoute) {
					// the child state has the same route as the current one, just start navigating there
					emitEventAndAttemptStateChange(finalDestinationStateName, parameters)
				} else {
					// change the url to match the full default child state route
					stateProviderEmitter.go(finalDestinationStateName, parameters, { replace: true })
				}
			}
		} catch (err) {
			handleError('stateError', err)
		}
	}

	function addState(state) {
		if (typeof state === 'undefined') {
			throw new Error('Expected \'state\' to be passed in.')
		} else if (typeof state.name === 'undefined') {
			throw new Error('Expected the \'name\' option to be passed in.')
		} else if (typeof state.template === 'undefined') {
			throw new Error('Expected the \'template\' option to be passed in.')
		}
		Object.keys(state).filter(function(key) {
			return expectedPropertiesOfAddState.indexOf(key) === -1
		}).forEach(function(key) {
			console.warn('Unexpected property passed to addState:', key)
		})

		prototypalStateHolder.add(state.name, state)

		var route = prototypalStateHolder.buildFullStateRoute(state.name)

		stateRouterOptions.router.add(route, onRouteChange.bind(null, state))
	}

	function getStatesToResolve(stateChanges) {
		return stateChanges.change.concat(stateChanges.create).map(prototypalStateHolder.get)
	}

	function emitEventAndAttemptStateChange(newStateName, parameters) {
		stateProviderEmitter.emit('stateChangeAttempt', function stateGo(transition) {
			attemptStateChange(newStateName, parameters, transition)
		})
	}

	function attemptStateChange(newStateName, parameters, transition) {
		function ifNotCancelled(fn) {
			return function() {
				if (transition.cancelled) {
					var err = new Error('The transition to ' + newStateName + 'was cancelled')
					err.wasCancelledBySomeoneElse = true
					throw err
				} else {
					return fn.apply(null, arguments)
				}
			}
		}

		return promiseMe(prototypalStateHolder.guaranteeAllStatesExist, newStateName)
		.then(function applyDefaultParameters() {
			var state = prototypalStateHolder.get(newStateName)
			var defaultParams = state.defaultQuerystringParameters || {}
			var needToApplyDefaults = Object.keys(defaultParams).some(function missingParameterValue(param) {
				return !parameters[param]
			})

			if (needToApplyDefaults) {
				throw redirector(newStateName, extend(defaultParams, parameters))
			}
			return state
		}).then(ifNotCancelled(function(state) {
			stateProviderEmitter.emit('stateChangeStart', state, parameters)
			lastStateStartedActivating.set(state.name, parameters)
		})).then(function getStateChanges() {
			var stateComparisonResults = StateComparison(prototypalStateHolder)(lastCompletelyLoadedState.get().name, lastCompletelyLoadedState.get().parameters, newStateName, parameters)
			return stateChangeLogic(stateComparisonResults) // { destroy, change, create }
		}).then(ifNotCancelled(function resolveDestroyAndActivateStates(stateChanges) {
			return resolveStates(getStatesToResolve(stateChanges), extend(parameters)).catch(function onResolveError(e) {
				e.stateChangeError = true
				throw e
			}).then(ifNotCancelled(function destroyAndActivate(stateResolveResultsObject) {
				transition.cancellable = false

				function activateAll() {
					var statesToActivate = stateChanges.change.concat(stateChanges.create)

					return activateStates(statesToActivate)
				}

				activeStateResolveContent = extend(activeStateResolveContent, stateResolveResultsObject)

				return series(reverse(stateChanges.destroy), destroyStateName).then(function() {
					return series(reverse(stateChanges.change), resetStateName.bind(null, extend(parameters)))
				}).then(function() {
					return renderAll(stateChanges.create, extend(parameters)).then(activateAll)
				})
			}))

			function activateStates(stateNames) {
				return stateNames.map(prototypalStateHolder.get).forEach(function(state) {
					var emitter = new EventEmitter()
					var context = Object.create(emitter)
					context.domApi = activeDomApis[state.name]
					context.data = state.data
					context.parameters = parameters
					context.content = getContentObject(activeStateResolveContent, state.name)
					activeEmitters[state.name] = emitter

					try {
						state.activate && state.activate(context)
					} catch (e) {
						process.nextTick(function() {
							throw e
						})
					}
				})
			}
		})).then(function stateChangeComplete() {
			lastCompletelyLoadedState.set(newStateName, parameters)
			try {
				stateProviderEmitter.emit('stateChangeEnd', prototypalStateHolder.get(newStateName), parameters)
			} catch (e) {
				handleError('stateError', e)
			}
		}).catch(ifNotCancelled(function handleStateChangeError(err) {
			if (err && err.redirectTo) {
				stateProviderEmitter.emit('stateChangeCancelled', err)
				return stateProviderEmitter.go(err.redirectTo.name, err.redirectTo.params, { replace: true })
			} else if (err) {
				handleError('stateChangeError', err)
			}
		})).catch(function handleCancellation(err) {
			if (err && err.wasCancelledBySomeoneElse) {
				// we don't care, the state transition manager has already emitted the stateChangeCancelled for us
			} else {
				throw new Error("This probably shouldn't happen, maybe file an issue or something " + err)
			}
		})
	}

	function makePath(stateName, parameters, options) {
		if (options && options.inherit) {
			parameters = extend(lastStateStartedActivating.get().parameters, parameters)
		}

		prototypalStateHolder.guaranteeAllStatesExist(stateName)
		var route = prototypalStateHolder.buildFullStateRoute(stateName)
		return buildPath(route, parameters || {})
	}

	var defaultOptions = {
		replace: false
	}

	stateProviderEmitter.addState = addState
	stateProviderEmitter.go = function go(newStateName, parameters, options) {
		options = extend(defaultOptions, options)
		var goFunction = options.replace ? stateRouterOptions.router.replace : stateRouterOptions.router.go

		return promiseMe(makePath, newStateName, parameters, options).then(goFunction, handleError.bind(null, 'stateChangeError'))
	}
	stateProviderEmitter.evaluateCurrentRoute = function evaluateCurrentRoute(defaultState, defaultParams) {
		return promiseMe(makePath, defaultState, defaultParams).then(function(defaultPath) {
			stateRouterOptions.router.evaluateCurrent(defaultPath)
		}).catch(function(err) {
			handleError('stateError', err)
		})
	}
	stateProviderEmitter.makePath = function makePathAndPrependHash(stateName, parameters, options) {
		return stateRouterOptions.pathPrefix + makePath(stateName, parameters, options)
	}
	stateProviderEmitter.stateIsActive = function stateIsActive(stateName, opts) {
		var currentState = lastCompletelyLoadedState.get()
		return (currentState.name === stateName || currentState.name.indexOf(stateName + '.') === 0) && (typeof opts === 'undefined' || Object.keys(opts).every(function matches(key) {
			return opts[key] === currentState.parameters[key]
		}))
	}

	var renderer = makeRenderer(stateProviderEmitter)

	destroyDom = denodeify(renderer.destroy)
	getDomChild = denodeify(renderer.getChildElement)
	renderDom = denodeify(renderer.render)
	resetDom = denodeify(renderer.reset)

	return stateProviderEmitter
}

function getContentObject(stateResolveResultsObject, stateName) {
	var allPossibleResolvedStateNames = parse(stateName)

	return allPossibleResolvedStateNames.filter(function(stateName) {
		return stateResolveResultsObject[stateName]
	}).reduce(function(obj, stateName) {
		return extend(obj, stateResolveResultsObject[stateName])
	}, {})
}

function redirector(newStateName, parameters) {
	return {
		redirectTo: {
			name: newStateName,
			params: parameters
		}
	}
}

// { [stateName]: resolveResult }
function resolveStates(states, parameters) {
	var statesWithResolveFunctions = states.filter(isFunction('resolve'))
	var stateNamesWithResolveFunctions = statesWithResolveFunctions.map(property('name'))
	var resolves = Promise.all(statesWithResolveFunctions.map(function(state) {
		return new Promise(function (resolve, reject) {
			function resolveCb(err, content) {
				err ? reject(err) : resolve(content)
			}

			resolveCb.redirect = function redirect(newStateName, parameters) {
				reject(redirector(newStateName, parameters))
			}

			var res = state.resolve(state.data, parameters, resolveCb)
			if (res && (typeof res === 'object' || typeof res === 'function') && typeof res.then === 'function') {
				resolve(res)
			}
		})
	}))

	return resolves.then(function(resolveResults) {
		return combine({
			stateName: stateNamesWithResolveFunctions,
			resolveResult: resolveResults
		}).reduce(function(obj, result) {
			obj[result.stateName] = result.resolveResult
			return obj
		}, {})
	})
}

function property(name) {
	return function(obj) {
		return obj[name]
	}
}

function reverse(ary) {
	return ary.slice().reverse()
}

function isFunction(property) {
	return function(obj) {
		return typeof obj[property] === 'function'
	}
}

function promiseMe() {
	var fn = Array.prototype.shift.apply(arguments)
	var args = arguments
	return new Promise(function(resolve) {
		resolve(fn.apply(null, args))
	})
}

}).call(this,require('_process'))

},{"./default-router-options.js":3,"./lib/current-state":5,"./lib/promise-map-series":6,"./lib/state-change-logic":7,"./lib/state-comparison":8,"./lib/state-state":9,"./lib/state-string-parser":10,"./lib/state-transition-manager":11,"_process":22,"combine-arrays":13,"events":14,"hash-brown-router":16,"native-promise-only/npo":17,"page-path-builder":18,"then-denodeify":28,"xtend":29}],5:[function(require,module,exports){
module.exports = function CurrentState() {
	var current = {
		name: '',
		parameters: {}
	}

	return {
		get: function() {
			return current
		},
		set: function(name, parameters) {
			current = {
				name: name,
				parameters: parameters
			}
		}
	}
}

},{}],6:[function(require,module,exports){
// Pulled from https://github.com/joliss/promise-map-series and prettied up a bit

var Promise = require('native-promise-only/npo')

module.exports = function sequence(array, iterator, thisArg) {
	var current = Promise.resolve()
	var cb = arguments.length > 2 ? iterator.bind(thisArg) : iterator

	var results = array.map(function(value, i) {
		return current = current.then(function(j) {
			return cb(value, j, array)
		}.bind(null, i))
	})

	return Promise.all(results)
}

},{"native-promise-only/npo":17}],7:[function(require,module,exports){
module.exports = function stateChangeLogic(stateComparisonResults) {
	var hitChangingState = false
	var hitDestroyedState = false

	var output = {
		destroy: [],
		change: [],
		create: []
	}

	stateComparisonResults.forEach(function(state) {
		hitChangingState = hitChangingState || state.stateParametersChanged
		hitDestroyedState = hitDestroyedState || state.stateNameChanged

		if (state.nameBefore) {
			if (hitDestroyedState) {
				output.destroy.push(state.nameBefore)
			} else if (hitChangingState) {
				output.change.push(state.nameBefore)
			}
		}

		if (state.nameAfter && hitDestroyedState) {
			output.create.push(state.nameAfter)
		}
	})

	return output
}

},{}],8:[function(require,module,exports){
var stateStringParser = require('./state-string-parser')
var combine = require('combine-arrays')
var pathToRegexp = require('path-to-regexp-with-reversible-keys')

module.exports = function StateComparison(stateState) {
	var getPathParameters = pathParameters()

	var parametersChanged = parametersThatMatterWereChanged.bind(null, stateState, getPathParameters)

	return stateComparison.bind(null, parametersChanged)
}

function pathParameters() {
	var parameters = {}

	return function getPathParameters(path) {
		if (!path) {
			return []
		}

		if (!parameters[path]) {
			parameters[path] = pathToRegexp(path).keys.map(function(key) {
				return key.name
			})
		}

		return parameters[path]
	}
}

function parametersThatMatterWereChanged(stateState, getPathParameters, stateName, fromParameters, toParameters) {
	var state = stateState.get(stateName)
	var querystringParameters = state.querystringParameters || []
	var parameters = getPathParameters(state.route).concat(querystringParameters)

	return Array.isArray(parameters) && parameters.some(function(key) {
		return fromParameters[key] !== toParameters[key]
	})
}

function stateComparison(parametersChanged, originalState, originalParameters, newState, newParameters) {
	var states = combine({
		start: stateStringParser(originalState),
		end: stateStringParser(newState)
	})

	return states.map(function(states) {
		return {
			nameBefore: states.start,
			nameAfter: states.end,
			stateNameChanged: states.start !== states.end,
			stateParametersChanged: states.start === states.end && parametersChanged(states.start, originalParameters, newParameters)
		}
	})
}

},{"./state-string-parser":10,"combine-arrays":13,"path-to-regexp-with-reversible-keys":20}],9:[function(require,module,exports){
var stateStringParser = require('./state-string-parser')
var parse = require('./state-string-parser')

module.exports = function StateState() {
	var states = {}

	function getHierarchy(name) {
		var names = stateStringParser(name)

		return names.map(function(name) {
			if (!states[name]) {
				throw new Error('State ' + name + ' not found')
			}
			return states[name]
		})
	}

	function getParent(name) {
		var parentName = getParentName(name)

		return parentName && states[parentName]
	}

	function getParentName(name) {
		var names = stateStringParser(name)

		if (names.length > 1) {
			var secondToLast = names.length - 2

			return names[secondToLast]
		} else {
			return null
		}
	}

	function guaranteeAllStatesExist(newStateName) {
		var stateNames = parse(newStateName)
		var statesThatDontExist = stateNames.filter(function(name) {
			return !states[name]
		})

		if (statesThatDontExist.length > 0) {
			throw new Error('State ' + statesThatDontExist[statesThatDontExist.length - 1] + ' does not exist')
		}
	}

	function buildFullStateRoute(stateName) {
		return getHierarchy(stateName).map(function(state) {
			return '/' + (state.route || '')
		}).join('').replace(/\/{2,}/g, '/')
	}

	function applyDefaultChildStates(stateName) {
		var state = states[stateName]

		function getDefaultChildStateName() {
			return state && (typeof state.defaultChild === 'function'
				? state.defaultChild()
				: state.defaultChild)
		}

		var defaultChildStateName = getDefaultChildStateName()

		if (!defaultChildStateName) {
			return stateName
		}

		var fullStateName = stateName + '.' + defaultChildStateName

		return applyDefaultChildStates(fullStateName)
	}


	return {
		add: function(name, state) {
			states[name] = state
		},
		get: function(name) {
			return name && states[name]
		},
		getHierarchy: getHierarchy,
		getParent: getParent,
		getParentName: getParentName,
		guaranteeAllStatesExist: guaranteeAllStatesExist,
		buildFullStateRoute: buildFullStateRoute,
		applyDefaultChildStates: applyDefaultChildStates
	}
}

},{"./state-string-parser":10}],10:[function(require,module,exports){
module.exports = function(stateString) {
	return stateString.split('.').reduce(function(stateNames, latestNameChunk) {
		if (stateNames.length) {
			latestNameChunk = stateNames[stateNames.length - 1] + '.' + latestNameChunk
		}
		stateNames.push(latestNameChunk)
		return stateNames
	}, [])
}

},{}],11:[function(require,module,exports){
module.exports = function (emitter) {
	var currentTransitionAttempt = null
	var nextTransition = null

	function doneTransitioning() {
		currentTransitionAttempt = null
		if (nextTransition) {
			beginNextTransitionAttempt()
		}
	}

	function isTransitioning() {
		return !!currentTransitionAttempt
	}

	function beginNextTransitionAttempt() {
		currentTransitionAttempt = nextTransition
		nextTransition = null
		currentTransitionAttempt.beginStateChange()
	}

	function cancelCurrentTransition() {
		currentTransitionAttempt.transition.cancelled = true
		var err = new Error('State transition cancelled by the state transition manager')
		err.wasCancelledBySomeoneElse = true
		emitter.emit('stateChangeCancelled', err)
	}

	emitter.on('stateChangeAttempt', function(beginStateChange) {
		nextTransition = createStateTransitionAttempt(beginStateChange)

		if (isTransitioning() && currentTransitionAttempt.transition.cancellable) {
			cancelCurrentTransition()
		} else if (!isTransitioning()) {
			beginNextTransitionAttempt()
		}
	})

	emitter.on('stateChangeError', doneTransitioning)
	emitter.on('stateChangeCancelled', doneTransitioning)
	emitter.on('stateChangeEnd', doneTransitioning)

	function createStateTransitionAttempt(beginStateChange) {
		var transition = {
			cancelled: false,
			cancellable: true
		}
		return {
			transition: transition,
			beginStateChange: beginStateChange.bind(null, transition)
		}
	}
}

},{}],12:[function(require,module,exports){
// Array.prototype.find - MIT License (c) 2013 Paul Miller <http://paulmillr.com>
// For all details and docs: https://github.com/paulmillr/array.prototype.find
// Fixes and tests supplied by Duncan Hall <http://duncanhall.net> 
(function(globals){
  if (Array.prototype.find) return;

  var find = function(predicate) {
    var list = Object(this);
    var length = list.length < 0 ? 0 : list.length >>> 0; // ES.ToUint32;
    if (length === 0) return undefined;
    if (typeof predicate !== 'function' || Object.prototype.toString.call(predicate) !== '[object Function]') {
      throw new TypeError('Array#find: predicate must be a function');
    }
    var thisArg = arguments[1];
    for (var i = 0, value; i < length; i++) {
      value = list[i];
      if (predicate.call(thisArg, value, i, list)) return value;
    }
    return undefined;
  };

  if (Object.defineProperty) {
    try {
      Object.defineProperty(Array.prototype, 'find', {
        value: find, configurable: true, enumerable: false, writable: true
      });
    } catch(e) {}
  }

  if (!Array.prototype.find) {
    Array.prototype.find = find;
  }
})(this);

},{}],13:[function(require,module,exports){
module.exports = function(obj) {
	var keys = Object.keys(obj)

	keys.forEach(function(key) {
		if (!Array.isArray(obj[key])) {
			throw new Error(key + ' is not an array')
		}
	})

	var maxIndex = keys.reduce(function(maxSoFar, key) {
		var len = obj[key].length
		return maxSoFar > len ? maxSoFar : len
	}, 0)

	var output = []

	function getObject(index) {
		var o = {}
		keys.forEach(function(key) {
			o[key] = obj[key][index]
		})
		return o
	}

	for (var i = 0; i < maxIndex; ++i) {
		output.push(getObject(i))
	}

	return output
}

},{}],14:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],15:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter

module.exports = function HashLocation(window) {
	var emitter = new EventEmitter()
	var last = ''
	var needToDecode = getNeedToDecode()

	window.addEventListener('hashchange', function() {
		if (last !== emitter.get()) {
			last = emitter.get()
			emitter.emit('hashchange')
		}
	})

	emitter.go = go.bind(null, window)
	emitter.replace = replace.bind(null, window)
	emitter.get = get.bind(null, window, needToDecode)

	return emitter
}

function replace(window, newPath) {
	window.location.replace(everythingBeforeTheSlash(window.location.href) + '#' + newPath)
}

function everythingBeforeTheSlash(url) {
	var hashIndex = url.indexOf('#')
	return hashIndex === -1 ? url : url.substring(0, hashIndex)
}

function go(window, newPath) {
	window.location.hash = newPath
}

function get(window, needToDecode) {
	var hash = removeHashFromPath(window.location.hash)
	return needToDecode ? decodeURI(hash) : hash
}

function removeHashFromPath(path) {
	return (path && path[0] === '#') ? path.substr(1) : path
}

function getNeedToDecode() {
	var a = document.createElement('a')
	a.href = '#x x'
	return !/x x/.test(a.hash)
}

},{"events":14}],16:[function(require,module,exports){
var pathToRegexp = require('path-to-regexp-with-reversible-keys')
var qs = require('querystring')
var xtend = require('xtend')
var browserHashLocation = require('./hash-location.js')
require('array.prototype.find')

module.exports = function Router(opts, hashLocation) {
	if (isHashLocation(opts)) {
		hashLocation = opts
		opts = null
	}

	opts = opts || {}

	if (!hashLocation) {
		hashLocation = browserHashLocation(window)
	}

	var routes = []

	var onHashChange = evaluateCurrentPath.bind(null, routes, hashLocation, !!opts.reverse)

	hashLocation.on('hashchange', onHashChange)

	function stop() {
		hashLocation.removeListener('hashchange', onHashChange)
	}

	return {
		add: add.bind(null, routes),
		stop: stop,
		evaluateCurrent: evaluateCurrentPathOrGoToDefault.bind(null, routes, hashLocation, !!opts.reverse),
		setDefault: setDefault.bind(null, routes),
		replace: hashLocation.replace,
		go: hashLocation.go,
		location: hashLocation
	}
}

function evaluateCurrentPath(routes, hashLocation, reverse) {
	evaluatePath(routes, hashLocation.get(), reverse)
}

function getPathParts(path) {
	var chunks = path.split('?')
	return {
		path: chunks.shift(),
		queryString: qs.parse(chunks.join(''))
	}
}

function evaluatePath(routes, path, reverse) {
	var pathParts = getPathParts(path)
	path = pathParts.path
	var queryStringParameters = pathParts.queryString

	var matchingRoute = (reverse ? reverseArray(routes) : routes).find("".match, path)

	if (matchingRoute) {
		var regexResult = matchingRoute.exec(path)
		var routeParameters = makeParametersObjectFromRegexResult(matchingRoute.keys, regexResult)
		var params = xtend(queryStringParameters, routeParameters)
		matchingRoute.fn(params)
	} else if (routes.defaultFn) {
		routes.defaultFn(path, queryStringParameters)
	}
}

function reverseArray(ary) {
	return ary.slice().reverse()
}

function makeParametersObjectFromRegexResult(keys, regexResult) {
	return keys.reduce(function(memo, urlKey, index) {
		memo[urlKey.name] = regexResult[index + 1]
		return memo
	}, {})
}

function add(routes, routeString, routeFunction) {
	if (typeof routeFunction !== 'function') {
		throw new Error('The router add function must be passed a callback function')
	}
	var newRoute = pathToRegexp(routeString)
	newRoute.fn = routeFunction
	routes.push(newRoute)
}

function evaluateCurrentPathOrGoToDefault(routes, hashLocation, reverse, defaultPath) {
	if (hashLocation.get()) {
		var routesCopy = routes.slice()
		routesCopy.defaultFn = function() {
			hashLocation.go(defaultPath)
		}
		evaluateCurrentPath(routesCopy, hashLocation, reverse)
	} else {
		hashLocation.go(defaultPath)
	}
}

function setDefault(routes, defaultFn) {
	routes.defaultFn = defaultFn
}

function isHashLocation(hashLocation) {
	return hashLocation && hashLocation.go && hashLocation.replace && hashLocation.on
}
},{"./hash-location.js":15,"array.prototype.find":12,"path-to-regexp-with-reversible-keys":20,"querystring":25,"xtend":29}],17:[function(require,module,exports){
(function (global){
/*! Native Promise Only
    v0.8.1 (c) Kyle Simpson
    MIT License: http://getify.mit-license.org
*/
!function(t,n,e){n[t]=n[t]||e(),"undefined"!=typeof module&&module.exports?module.exports=n[t]:"function"==typeof define&&define.amd&&define(function(){return n[t]})}("Promise","undefined"!=typeof global?global:this,function(){"use strict";function t(t,n){l.add(t,n),h||(h=y(l.drain))}function n(t){var n,e=typeof t;return null==t||"object"!=e&&"function"!=e||(n=t.then),"function"==typeof n?n:!1}function e(){for(var t=0;t<this.chain.length;t++)o(this,1===this.state?this.chain[t].success:this.chain[t].failure,this.chain[t]);this.chain.length=0}function o(t,e,o){var r,i;try{e===!1?o.reject(t.msg):(r=e===!0?t.msg:e.call(void 0,t.msg),r===o.promise?o.reject(TypeError("Promise-chain cycle")):(i=n(r))?i.call(r,o.resolve,o.reject):o.resolve(r))}catch(c){o.reject(c)}}function r(o){var c,u=this;if(!u.triggered){u.triggered=!0,u.def&&(u=u.def);try{(c=n(o))?t(function(){var t=new f(u);try{c.call(o,function(){r.apply(t,arguments)},function(){i.apply(t,arguments)})}catch(n){i.call(t,n)}}):(u.msg=o,u.state=1,u.chain.length>0&&t(e,u))}catch(a){i.call(new f(u),a)}}}function i(n){var o=this;o.triggered||(o.triggered=!0,o.def&&(o=o.def),o.msg=n,o.state=2,o.chain.length>0&&t(e,o))}function c(t,n,e,o){for(var r=0;r<n.length;r++)!function(r){t.resolve(n[r]).then(function(t){e(r,t)},o)}(r)}function f(t){this.def=t,this.triggered=!1}function u(t){this.promise=t,this.state=0,this.triggered=!1,this.chain=[],this.msg=void 0}function a(n){if("function"!=typeof n)throw TypeError("Not a function");if(0!==this.__NPO__)throw TypeError("Not a promise");this.__NPO__=1;var o=new u(this);this.then=function(n,r){var i={success:"function"==typeof n?n:!0,failure:"function"==typeof r?r:!1};return i.promise=new this.constructor(function(t,n){if("function"!=typeof t||"function"!=typeof n)throw TypeError("Not a function");i.resolve=t,i.reject=n}),o.chain.push(i),0!==o.state&&t(e,o),i.promise},this["catch"]=function(t){return this.then(void 0,t)};try{n.call(void 0,function(t){r.call(o,t)},function(t){i.call(o,t)})}catch(c){i.call(o,c)}}var s,h,l,p=Object.prototype.toString,y="undefined"!=typeof setImmediate?function(t){return setImmediate(t)}:setTimeout;try{Object.defineProperty({},"x",{}),s=function(t,n,e,o){return Object.defineProperty(t,n,{value:e,writable:!0,configurable:o!==!1})}}catch(d){s=function(t,n,e){return t[n]=e,t}}l=function(){function t(t,n){this.fn=t,this.self=n,this.next=void 0}var n,e,o;return{add:function(r,i){o=new t(r,i),e?e.next=o:n=o,e=o,o=void 0},drain:function(){var t=n;for(n=e=h=void 0;t;)t.fn.call(t.self),t=t.next}}}();var g=s({},"constructor",a,!1);return a.prototype=g,s(g,"__NPO__",0,!1),s(a,"resolve",function(t){var n=this;return t&&"object"==typeof t&&1===t.__NPO__?t:new n(function(n,e){if("function"!=typeof n||"function"!=typeof e)throw TypeError("Not a function");n(t)})}),s(a,"reject",function(t){return new this(function(n,e){if("function"!=typeof n||"function"!=typeof e)throw TypeError("Not a function");e(t)})}),s(a,"all",function(t){var n=this;return"[object Array]"!=p.call(t)?n.reject(TypeError("Not an array")):0===t.length?n.resolve([]):new n(function(e,o){if("function"!=typeof e||"function"!=typeof o)throw TypeError("Not a function");var r=t.length,i=Array(r),f=0;c(n,t,function(t,n){i[t]=n,++f===r&&e(i)},o)})}),s(a,"race",function(t){var n=this;return"[object Array]"!=p.call(t)?n.reject(TypeError("Not an array")):new n(function(e,o){if("function"!=typeof e||"function"!=typeof o)throw TypeError("Not a function");c(n,t,function(t,n){e(n)},o)})}),a});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],18:[function(require,module,exports){
var parser = require('./path-parser')
var stringifyQuerystring = require('querystring').stringify

module.exports = function(pathStr, parameters) {

	var parsed = typeof pathStr === 'string' ? parser(pathStr) : pathStr
	var allTokens = parsed.allTokens
	var regex = parsed.regex

	if (parameters) {
		var path = allTokens.map(function(bit) {
			if (bit.string) {
				return bit.string
			}

			var defined = typeof parameters[bit.name] !== 'undefined'
			if (!bit.optional && !defined) {
				throw new Error('Must supply argument ' + bit.name + ' for path ' + pathStr)
			}

			return defined ? (bit.delimiter + encodeURIComponent(parameters[bit.name])) : ''
		}).join('')

		if (!regex.test(path)) {
			throw new Error('Provided arguments do not match the original arguments')
		}

		return buildPathWithQuerystring(path, parameters, allTokens)
	} else {
		return parsed
	}
}

function buildPathWithQuerystring(path, parameters, tokenArray) {
	var parametersInQuerystring = getParametersWithoutMatchingToken(parameters, tokenArray)

	if (Object.keys(parametersInQuerystring).length === 0) {
		return path
	}

	return path + '?' + stringifyQuerystring(parametersInQuerystring)
}

function getParametersWithoutMatchingToken(parameters, tokenArray) {
	var tokenHash = tokenArray.reduce(function(memo, bit) {
		if (!bit.string) {
			memo[bit.name] = bit
		}
		return memo
	}, {})

	return Object.keys(parameters).filter(function(param) {
		return !tokenHash[param]
	}).reduce(function(newParameters, param) {
		newParameters[param] = parameters[param]
		return newParameters
	}, {})
}

},{"./path-parser":19,"querystring":25}],19:[function(require,module,exports){
// This file to be replaced with an official implementation maintained by
// the page.js crew if and when that becomes an option

var pathToRegexp = require('path-to-regexp-with-reversible-keys')

module.exports = function(pathString) {
	var parseResults = pathToRegexp(pathString)

	// The only reason I'm returning a new object instead of the results of the pathToRegexp
	// function is so that if the official implementation ends up returning an
	// allTokens-style array via some other mechanism, I may be able to change this file
	// without having to change the rest of the module in index.js
	return {
		regex: parseResults,
		allTokens: parseResults.allTokens
	}
}

},{"path-to-regexp-with-reversible-keys":20}],20:[function(require,module,exports){
var isArray = require('isarray');

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?"]
  // "/route(\\d+)" => [undefined, undefined, undefined, "\d+", undefined]
  '([\\/.])?(?:\\:(\\w+)(?:\\(((?:\\\\.|[^)])*)\\))?|\\(((?:\\\\.|[^)])*)\\))([+*?])?',
  // Match regexp special characters that are always escaped.
  '([.+*?=^!:${}()[\\]|\\/])'
].join('|'), 'g');

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {String} group
 * @return {String}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {RegExp} re
 * @param  {Array}  keys
 * @return {RegExp}
 */
function attachKeys (re, keys, allTokens) {
  re.keys = keys;
  re.allTokens = allTokens;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {String}
 */
function flags (options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {RegExp} path
 * @param  {Array}  keys
 * @return {RegExp}
 */
function regexpToRegexp (path, keys, allTokens) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name:      i,
        delimiter: null,
        optional:  false,
        repeat:    false
      });
    }
  }

  return attachKeys(path, keys, allTokens);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {Array}  path
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */
function arrayToRegexp (path, keys, options, allTokens) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options, allTokens).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));
  return attachKeys(regexp, keys, allTokens);
}

/**
 * Replace the specific tags with regexp strings.
 *
 * @param  {String} path
 * @param  {Array}  keys
 * @return {String}
 */
function replacePath (path, keys, allTokens) {
  var index = 0;
  var lastEndIndex = 0

  function addLastToken(lastToken) {
    if (lastEndIndex === 0 && lastToken[0] !== '/') {
      lastToken = '/' + lastToken
    }
    allTokens.push({
      string: lastToken
    });
  }


  function replace (match, escaped, prefix, key, capture, group, suffix, escape, offset) {
    if (escaped) {
      return escaped;
    }

    if (escape) {
      return '\\' + escape;
    }

    var repeat   = suffix === '+' || suffix === '*';
    var optional = suffix === '?' || suffix === '*';

    if (offset > lastEndIndex) {
      addLastToken(path.substring(lastEndIndex, offset));
    }

    lastEndIndex = offset + match.length;

    var newKey = {
      name:      key || index++,
      delimiter: prefix || '/',
      optional:  optional,
      repeat:    repeat
    }

    keys.push(newKey);
    allTokens.push(newKey);

    prefix = prefix ? ('\\' + prefix) : '';
    capture = escapeGroup(capture || group || '[^' + (prefix || '\\/') + ']+?');

    if (repeat) {
      capture = capture + '(?:' + prefix + capture + ')*';
    }

    if (optional) {
      return '(?:' + prefix + '(' + capture + '))?';
    }

    // Basic parameter support.
    return prefix + '(' + capture + ')';
  }

  var newPath = path.replace(PATH_REGEXP, replace);

  if (lastEndIndex < path.length) {
    addLastToken(path.substring(lastEndIndex))
  }

  return newPath;
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(String|RegExp|Array)} path
 * @param  {Array}                 [keys]
 * @param  {Object}                [options]
 * @return {RegExp}
 */
function pathToRegexp (path, keys, options, allTokens) {
  keys = keys || [];
  allTokens = allTokens || [];

  if (!isArray(keys)) {
    options = keys;
    keys = [];
  } else if (!options) {
    options = {};
  }

  if (path instanceof RegExp) {
    return regexpToRegexp(path, keys, options, allTokens);
  }

  if (isArray(path)) {
    return arrayToRegexp(path, keys, options, allTokens);
  }

  var strict = options.strict;
  var end = options.end !== false;
  var route = replacePath(path, keys, allTokens);
  var endsWithSlash = path.charAt(path.length - 1) === '/';

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithSlash ? '' : '(?=\\/|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys, allTokens);
}

},{"isarray":21}],21:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],22:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

(function () {
  try {
    cachedSetTimeout = setTimeout;
  } catch (e) {
    cachedSetTimeout = function () {
      throw new Error('setTimeout is not defined');
    }
  }
  try {
    cachedClearTimeout = clearTimeout;
  } catch (e) {
    cachedClearTimeout = function () {
      throw new Error('clearTimeout is not defined');
    }
  }
} ())
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = cachedSetTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    cachedClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        cachedSetTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],23:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],24:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],25:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":23,"./encode":24}],26:[function(require,module,exports){
var extend = require('xtend')

function wrapWackyPromise(promise, cb) {
	promise.then(function() {
		cb()
	}, function(err) {
		cb(err)
	})
}

module.exports = function RactiveStateRouter(Ractive, ractiveOptions, options) {
	function copyIfAppropriate(value) {
		if (options && options.deepCopyDataOnSet) {
			return copy(value)
		} else {
			return value
		}
	}
	return function makeRenderer(stateRouter) {
		var ExtendedRactive = Ractive.extend(ractiveOptions || {})
		var extendedData = ExtendedRactive.defaults.data
		var ractiveData = Ractive.defaults.data

		extendedData.makePath = ractiveData.makePath = stateRouter.makePath

		extendedData.active = ractiveData.active = function active(stateName) {
			return stateRouter.stateIsActive(stateName) ? 'active' : ''
		}

		return {
			render: function render(context, cb) {
				var element = context.element
				var inputTemplate = context.template

				var defaultDecorators = {
					active: activeStateDecarator.bind(null, stateRouter)
				}

				function getData() {
					var copyOfContent = copyIfAppropriate(context.content)
					return isTemplate(inputTemplate) ? copyOfContent : extend(inputTemplate.data, copyOfContent)
				}
				function getDecorators() {
					return isTemplate(inputTemplate) ? defaultDecorators : extend(defaultDecorators, inputTemplate.decorators)
				}
				function getOptions() {
					var bareOptions = isTemplate(inputTemplate) ? { template: inputTemplate } : inputTemplate

					return extend(bareOptions, {
						decorators: getDecorators(),
						data: getData(),
						el: element
					})
				}

				try {
					var ractive = new ExtendedRactive(getOptions())
					cb(null, ractive)
				} catch (e) {
					cb(e)
				}
			},
			reset: function reset(context, cb) {
				var ractive = context.domApi
				ractive.off()
				wrapWackyPromise(ractive.reset(copyIfAppropriate(context.content)), cb)
			},
			destroy: function destroy(ractive, cb) {
				wrapWackyPromise(ractive.teardown(), cb)
			},
			getChildElement: function getChildElement(ractive, cb) {
				try {
					var child = ractive.find('ui-view')
					cb(null, child)
				} catch (e) {
					cb(e)
				}
			}
		}
	}
}

function copy(value) {
	if (Array.isArray(value)) {
		return value.map(copy)
	} else if (object(value)) {
		var target = {}
		Object.keys(value).forEach(function(key) {
			target[key] = copy(value[key])
		})
		return target
	} else {
		return value
	}
}

function object(o) {
	return o && typeof o === 'object'
}

function activeStateDecarator(stateRouter, element, stateName) {
	var parametersToMatch = parseParameters(arguments)
	function onStateChange() {
		var active = stateRouter.stateIsActive(stateName, parametersToMatch)

		if (active) {
			element.classList.add('active')
		} else {
			element.classList.remove('active')
		}

	}

	stateRouter.on('stateChangeEnd', onStateChange)

	function teardown() {
		stateRouter.removeListener('stateChangeEnd', onStateChange)
	}

	return {
		teardown: teardown
	}
}

function parseParameters(args) {
	args = Array.prototype.slice.call(args, 2)
	return args.reduce(function(allParameters, parameterPair) {
		var keyAndValue = parameterPair.split(':')
		if (keyAndValue.length > 1) {
			allParameters[keyAndValue[0]] = keyAndValue[1]
		}
		return allParameters
	}, {})
}

function allParametersMatch(toMatch, parameters) {
	return Object.keys(toMatch).every(function(key) {
		return toMatch[key] == parameters[key]
	})
}

function isTemplate(inputTemplate) {
	return typeof inputTemplate === 'string' || isRactiveTemplateObject(inputTemplate)
}

function isRactiveTemplateObject(template) {
	// Based on https://github.com/ractivejs/ractive/blob/b1c9e1e5c22daac3210ee7db0f511065b31aac3c/src/Ractive/config/custom/template/template.js#L113-L116
	return template && typeof template.v === 'number'
}

},{"xtend":29}],27:[function(require,module,exports){
/*
	Ractive.js v0.7.3
	Sat Apr 25 2015 13:52:38 GMT-0400 (EDT) - commit da40f81c660ba2f09c45a09a9c20fdd34ee36d80

	http://ractivejs.org
	http://twitter.com/RactiveJS

	Released under the MIT License.
*/

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  global.Ractive = factory()
}(this, function () { 'use strict';

  var TEMPLATE_VERSION = 3;

  var defaultOptions = {

  	// render placement:
  	el: void 0,
  	append: false,

  	// template:
  	template: { v: TEMPLATE_VERSION, t: [] },

  	// parse:     // TODO static delimiters?
  	preserveWhitespace: false,
  	sanitize: false,
  	stripComments: true,
  	delimiters: ["{{", "}}"],
  	tripleDelimiters: ["{{{", "}}}"],
  	interpolate: false,

  	// data & binding:
  	data: {},
  	computed: {},
  	magic: false,
  	modifyArrays: true,
  	adapt: [],
  	isolated: false,
  	twoway: true,
  	lazy: false,

  	// transitions:
  	noIntro: false,
  	transitionsEnabled: true,
  	complete: void 0,

  	// css:
  	css: null,
  	noCssTransform: false
  };

  var config_defaults = defaultOptions;

  // These are a subset of the easing equations found at
  // https://raw.github.com/danro/easing-js - license info
  // follows:

  // --------------------------------------------------
  // easing.js v0.5.4
  // Generic set of easing functions with AMD support
  // https://github.com/danro/easing-js
  // This code may be freely distributed under the MIT license
  // http://danro.mit-license.org/
  // --------------------------------------------------
  // All functions adapted from Thomas Fuchs & Jeremy Kahn
  // Easing Equations (c) 2003 Robert Penner, BSD license
  // https://raw.github.com/danro/easing-js/master/LICENSE
  // --------------------------------------------------

  // In that library, the functions named easeIn, easeOut, and
  // easeInOut below are named easeInCubic, easeOutCubic, and
  // (you guessed it) easeInOutCubic.
  //
  // You can add additional easing functions to this list, and they
  // will be globally available.

  var static_easing = {
  	linear: function (pos) {
  		return pos;
  	},
  	easeIn: function (pos) {
  		return Math.pow(pos, 3);
  	},
  	easeOut: function (pos) {
  		return Math.pow(pos - 1, 3) + 1;
  	},
  	easeInOut: function (pos) {
  		if ((pos /= 0.5) < 1) {
  			return 0.5 * Math.pow(pos, 3);
  		}
  		return 0.5 * (Math.pow(pos - 2, 3) + 2);
  	}
  };

  /*global console, navigator */
  var isClient, isJsdom, hasConsole, environment__magic, namespaces, svg, vendors;

  isClient = typeof document === "object";

  isJsdom = typeof navigator !== "undefined" && /jsDom/.test(navigator.appName);

  hasConsole = typeof console !== "undefined" && typeof console.warn === "function" && typeof console.warn.apply === "function";

  try {
  	Object.defineProperty({}, "test", { value: 0 });
  	environment__magic = true;
  } catch (e) {
  	environment__magic = false;
  }

  namespaces = {
  	html: "http://www.w3.org/1999/xhtml",
  	mathml: "http://www.w3.org/1998/Math/MathML",
  	svg: "http://www.w3.org/2000/svg",
  	xlink: "http://www.w3.org/1999/xlink",
  	xml: "http://www.w3.org/XML/1998/namespace",
  	xmlns: "http://www.w3.org/2000/xmlns/"
  };

  if (typeof document === "undefined") {
  	svg = false;
  } else {
  	svg = document && document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
  }

  vendors = ["o", "ms", "moz", "webkit"];

  var createElement, matches, dom__div, methodNames, unprefixed, prefixed, dom__i, j, makeFunction;

  // Test for SVG support
  if (!svg) {
  	createElement = function (type, ns) {
  		if (ns && ns !== namespaces.html) {
  			throw "This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you're trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information";
  		}

  		return document.createElement(type);
  	};
  } else {
  	createElement = function (type, ns) {
  		if (!ns || ns === namespaces.html) {
  			return document.createElement(type);
  		}

  		return document.createElementNS(ns, type);
  	};
  }

  function getElement(input) {
  	var output;

  	if (!input || typeof input === "boolean") {
  		return;
  	}

  	if (typeof window === "undefined" || !document || !input) {
  		return null;
  	}

  	// We already have a DOM node - no work to do. (Duck typing alert!)
  	if (input.nodeType) {
  		return input;
  	}

  	// Get node from string
  	if (typeof input === "string") {
  		// try ID first
  		output = document.getElementById(input);

  		// then as selector, if possible
  		if (!output && document.querySelector) {
  			output = document.querySelector(input);
  		}

  		// did it work?
  		if (output && output.nodeType) {
  			return output;
  		}
  	}

  	// If we've been given a collection (jQuery, Zepto etc), extract the first item
  	if (input[0] && input[0].nodeType) {
  		return input[0];
  	}

  	return null;
  }

  if (!isClient) {
  	matches = null;
  } else {
  	dom__div = createElement("div");
  	methodNames = ["matches", "matchesSelector"];

  	makeFunction = function (methodName) {
  		return function (node, selector) {
  			return node[methodName](selector);
  		};
  	};

  	dom__i = methodNames.length;

  	while (dom__i-- && !matches) {
  		unprefixed = methodNames[dom__i];

  		if (dom__div[unprefixed]) {
  			matches = makeFunction(unprefixed);
  		} else {
  			j = vendors.length;
  			while (j--) {
  				prefixed = vendors[dom__i] + unprefixed.substr(0, 1).toUpperCase() + unprefixed.substring(1);

  				if (dom__div[prefixed]) {
  					matches = makeFunction(prefixed);
  					break;
  				}
  			}
  		}
  	}

  	// IE8...
  	if (!matches) {
  		matches = function (node, selector) {
  			var nodes, parentNode, i;

  			parentNode = node.parentNode;

  			if (!parentNode) {
  				// empty dummy <div>
  				dom__div.innerHTML = "";

  				parentNode = dom__div;
  				node = node.cloneNode();

  				dom__div.appendChild(node);
  			}

  			nodes = parentNode.querySelectorAll(selector);

  			i = nodes.length;
  			while (i--) {
  				if (nodes[i] === node) {
  					return true;
  				}
  			}

  			return false;
  		};
  	}
  }

  function detachNode(node) {
  	if (node && typeof node.parentNode !== "unknown" && node.parentNode) {
  		node.parentNode.removeChild(node);
  	}

  	return node;
  }

  function safeToStringValue(value) {
  	return value == null || !value.toString ? "" : value;
  }

  var legacy = null;

  var create, defineProperty, defineProperties;

  try {
  	Object.defineProperty({}, "test", { value: 0 });

  	if (isClient) {
  		Object.defineProperty(document.createElement("div"), "test", { value: 0 });
  	}

  	defineProperty = Object.defineProperty;
  } catch (err) {
  	// Object.defineProperty doesn't exist, or we're in IE8 where you can
  	// only use it with DOM objects (what were you smoking, MSFT?)
  	defineProperty = function (obj, prop, desc) {
  		obj[prop] = desc.value;
  	};
  }

  try {
  	try {
  		Object.defineProperties({}, { test: { value: 0 } });
  	} catch (err) {
  		// TODO how do we account for this? noMagic = true;
  		throw err;
  	}

  	if (isClient) {
  		Object.defineProperties(createElement("div"), { test: { value: 0 } });
  	}

  	defineProperties = Object.defineProperties;
  } catch (err) {
  	defineProperties = function (obj, props) {
  		var prop;

  		for (prop in props) {
  			if (props.hasOwnProperty(prop)) {
  				defineProperty(obj, prop, props[prop]);
  			}
  		}
  	};
  }

  try {
  	Object.create(null);

  	create = Object.create;
  } catch (err) {
  	// sigh
  	create = (function () {
  		var F = function () {};

  		return function (proto, props) {
  			var obj;

  			if (proto === null) {
  				return {};
  			}

  			F.prototype = proto;
  			obj = new F();

  			if (props) {
  				Object.defineProperties(obj, props);
  			}

  			return obj;
  		};
  	})();
  }

  function utils_object__extend(target) {
  	for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		sources[_key - 1] = arguments[_key];
  	}

  	var prop, source;

  	while (source = sources.shift()) {
  		for (prop in source) {
  			if (hasOwn.call(source, prop)) {
  				target[prop] = source[prop];
  			}
  		}
  	}

  	return target;
  }

  function fillGaps(target) {
  	for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		sources[_key - 1] = arguments[_key];
  	}

  	sources.forEach(function (s) {
  		for (var key in s) {
  			if (s.hasOwnProperty(key) && !(key in target)) {
  				target[key] = s[key];
  			}
  		}
  	});

  	return target;
  }

  var hasOwn = Object.prototype.hasOwnProperty;

  // thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
  var is__toString = Object.prototype.toString,
      arrayLikePattern = /^\[object (?:Array|FileList)\]$/;
  function isArray(thing) {
  	return is__toString.call(thing) === "[object Array]";
  }

  function isArrayLike(obj) {
  	return arrayLikePattern.test(is__toString.call(obj));
  }

  function isEqual(a, b) {
  	if (a === null && b === null) {
  		return true;
  	}

  	if (typeof a === "object" || typeof b === "object") {
  		return false;
  	}

  	return a === b;
  }

  function is__isNumeric(thing) {
  	return !isNaN(parseFloat(thing)) && isFinite(thing);
  }

  function isObject(thing) {
  	return thing && is__toString.call(thing) === "[object Object]";
  }

  var noop = function () {};

  /* global console */
  var alreadyWarned = {},
      log,
      printWarning,
      welcome;

  if (hasConsole) {
  	(function () {
  		var welcomeIntro = ["%cRactive.js %c0.7.3 %cin debug mode, %cmore...", "color: rgb(114, 157, 52); font-weight: normal;", "color: rgb(85, 85, 85); font-weight: normal;", "color: rgb(85, 85, 85); font-weight: normal;", "color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;"];
  		var welcomeMessage = "You're running Ractive 0.7.3 in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\n\nTo disable debug mode, add this line at the start of your app:\n  Ractive.DEBUG = false;\n\nTo disable debug mode when your app is minified, add this snippet:\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\n\nGet help and support:\n  http://docs.ractivejs.org\n  http://stackoverflow.com/questions/tagged/ractivejs\n  http://groups.google.com/forum/#!forum/ractive-js\n  http://twitter.com/ractivejs\n\nFound a bug? Raise an issue:\n  https://github.com/ractivejs/ractive/issues\n\n";

  		welcome = function () {
  			var hasGroup = !!console.groupCollapsed;
  			console[hasGroup ? "groupCollapsed" : "log"].apply(console, welcomeIntro);
  			console.log(welcomeMessage);
  			if (hasGroup) {
  				console.groupEnd(welcomeIntro);
  			}

  			welcome = noop;
  		};

  		printWarning = function (message, args) {
  			welcome();

  			// extract information about the instance this message pertains to, if applicable
  			if (typeof args[args.length - 1] === "object") {
  				var options = args.pop();
  				var ractive = options ? options.ractive : null;

  				if (ractive) {
  					// if this is an instance of a component that we know the name of, add
  					// it to the message
  					var _name = undefined;
  					if (ractive.component && (_name = ractive.component.name)) {
  						message = "<" + _name + "> " + message;
  					}

  					var node = undefined;
  					if (node = options.node || ractive.fragment && ractive.fragment.rendered && ractive.find("*")) {
  						args.push(node);
  					}
  				}
  			}

  			console.warn.apply(console, ["%cRactive.js: %c" + message, "color: rgb(114, 157, 52);", "color: rgb(85, 85, 85);"].concat(args));
  		};

  		log = function () {
  			console.log.apply(console, arguments);
  		};
  	})();
  } else {
  	printWarning = log = welcome = noop;
  }

  function format(message, args) {
  	return message.replace(/%s/g, function () {
  		return args.shift();
  	});
  }

  function fatal(message) {
  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		args[_key - 1] = arguments[_key];
  	}

  	message = format(message, args);
  	throw new Error(message);
  }

  function logIfDebug() {
  	if (_Ractive.DEBUG) {
  		log.apply(null, arguments);
  	}
  }

  function warn(message) {
  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		args[_key - 1] = arguments[_key];
  	}

  	message = format(message, args);
  	printWarning(message, args);
  }

  function warnOnce(message) {
  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		args[_key - 1] = arguments[_key];
  	}

  	message = format(message, args);

  	if (alreadyWarned[message]) {
  		return;
  	}

  	alreadyWarned[message] = true;
  	printWarning(message, args);
  }

  function warnIfDebug() {
  	if (_Ractive.DEBUG) {
  		warn.apply(null, arguments);
  	}
  }

  function warnOnceIfDebug() {
  	if (_Ractive.DEBUG) {
  		warnOnce.apply(null, arguments);
  	}
  }

  // Error messages that are used (or could be) in multiple places
  var badArguments = "Bad arguments";
  var noRegistryFunctionReturn = "A function was specified for \"%s\" %s, but no %s was returned";
  var missingPlugin = function (name, type) {
    return "Missing \"" + name + "\" " + type + " plugin. You may need to download a plugin via http://docs.ractivejs.org/latest/plugins#" + type + "s";
  };

  function findInViewHierarchy(registryName, ractive, name) {
  	var instance = findInstance(registryName, ractive, name);
  	return instance ? instance[registryName][name] : null;
  }

  function findInstance(registryName, ractive, name) {
  	while (ractive) {
  		if (name in ractive[registryName]) {
  			return ractive;
  		}

  		if (ractive.isolated) {
  			return null;
  		}

  		ractive = ractive.parent;
  	}
  }

  var interpolate = function (from, to, ractive, type) {
  	if (from === to) {
  		return snap(to);
  	}

  	if (type) {

  		var interpol = findInViewHierarchy("interpolators", ractive, type);
  		if (interpol) {
  			return interpol(from, to) || snap(to);
  		}

  		fatal(missingPlugin(type, "interpolator"));
  	}

  	return static_interpolators.number(from, to) || static_interpolators.array(from, to) || static_interpolators.object(from, to) || snap(to);
  };

  var shared_interpolate = interpolate;

  function snap(to) {
  	return function () {
  		return to;
  	};
  }

  var interpolators = {
  	number: function (from, to) {
  		var delta;

  		if (!is__isNumeric(from) || !is__isNumeric(to)) {
  			return null;
  		}

  		from = +from;
  		to = +to;

  		delta = to - from;

  		if (!delta) {
  			return function () {
  				return from;
  			};
  		}

  		return function (t) {
  			return from + t * delta;
  		};
  	},

  	array: function (from, to) {
  		var intermediate, interpolators, len, i;

  		if (!isArray(from) || !isArray(to)) {
  			return null;
  		}

  		intermediate = [];
  		interpolators = [];

  		i = len = Math.min(from.length, to.length);
  		while (i--) {
  			interpolators[i] = shared_interpolate(from[i], to[i]);
  		}

  		// surplus values - don't interpolate, but don't exclude them either
  		for (i = len; i < from.length; i += 1) {
  			intermediate[i] = from[i];
  		}

  		for (i = len; i < to.length; i += 1) {
  			intermediate[i] = to[i];
  		}

  		return function (t) {
  			var i = len;

  			while (i--) {
  				intermediate[i] = interpolators[i](t);
  			}

  			return intermediate;
  		};
  	},

  	object: function (from, to) {
  		var properties, len, interpolators, intermediate, prop;

  		if (!isObject(from) || !isObject(to)) {
  			return null;
  		}

  		properties = [];
  		intermediate = {};
  		interpolators = {};

  		for (prop in from) {
  			if (hasOwn.call(from, prop)) {
  				if (hasOwn.call(to, prop)) {
  					properties.push(prop);
  					interpolators[prop] = shared_interpolate(from[prop], to[prop]);
  				} else {
  					intermediate[prop] = from[prop];
  				}
  			}
  		}

  		for (prop in to) {
  			if (hasOwn.call(to, prop) && !hasOwn.call(from, prop)) {
  				intermediate[prop] = to[prop];
  			}
  		}

  		len = properties.length;

  		return function (t) {
  			var i = len,
  			    prop;

  			while (i--) {
  				prop = properties[i];

  				intermediate[prop] = interpolators[prop](t);
  			}

  			return intermediate;
  		};
  	}
  };

  var static_interpolators = interpolators;

  // This function takes a keypath such as 'foo.bar.baz', and returns
  // all the variants of that keypath that include a wildcard in place
  // of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.
  // These are then checked against the dependants map (ractive.viewmodel.depsMap)
  // to see if any pattern observers are downstream of one or more of
  // these wildcard keypaths (e.g. 'foo.bar.*.status')
  var utils_getPotentialWildcardMatches = getPotentialWildcardMatches;

  var starMaps = {};
  function getPotentialWildcardMatches(keypath) {
  	var keys, starMap, mapper, i, result, wildcardKeypath;

  	keys = keypath.split(".");
  	if (!(starMap = starMaps[keys.length])) {
  		starMap = getStarMap(keys.length);
  	}

  	result = [];

  	mapper = function (star, i) {
  		return star ? "*" : keys[i];
  	};

  	i = starMap.length;
  	while (i--) {
  		wildcardKeypath = starMap[i].map(mapper).join(".");

  		if (!result.hasOwnProperty(wildcardKeypath)) {
  			result.push(wildcardKeypath);
  			result[wildcardKeypath] = true;
  		}
  	}

  	return result;
  }

  // This function returns all the possible true/false combinations for
  // a given number - e.g. for two, the possible combinations are
  // [ true, true ], [ true, false ], [ false, true ], [ false, false ].
  // It does so by getting all the binary values between 0 and e.g. 11
  function getStarMap(num) {
  	var ones = "",
  	    max,
  	    binary,
  	    starMap,
  	    mapper,
  	    i,
  	    j,
  	    l,
  	    map;

  	if (!starMaps[num]) {
  		starMap = [];

  		while (ones.length < num) {
  			ones += 1;
  		}

  		max = parseInt(ones, 2);

  		mapper = function (digit) {
  			return digit === "1";
  		};

  		for (i = 0; i <= max; i += 1) {
  			binary = i.toString(2);
  			while (binary.length < num) {
  				binary = "0" + binary;
  			}

  			map = [];
  			l = binary.length;
  			for (j = 0; j < l; j++) {
  				map.push(mapper(binary[j]));
  			}
  			starMap[i] = map;
  		}

  		starMaps[num] = starMap;
  	}

  	return starMaps[num];
  }

  var refPattern = /\[\s*(\*|[0-9]|[1-9][0-9]+)\s*\]/g;
  var patternPattern = /\*/;
  var keypathCache = {};

  var Keypath = function (str) {
  	var keys = str.split(".");

  	this.str = str;

  	if (str[0] === "@") {
  		this.isSpecial = true;
  		this.value = decodeKeypath(str);
  	}

  	this.firstKey = keys[0];
  	this.lastKey = keys.pop();

  	this.isPattern = patternPattern.test(str);

  	this.parent = str === "" ? null : getKeypath(keys.join("."));
  	this.isRoot = !str;
  };

  Keypath.prototype = {
  	equalsOrStartsWith: function (keypath) {
  		return keypath === this || this.startsWith(keypath);
  	},

  	join: function (str) {
  		return getKeypath(this.isRoot ? String(str) : this.str + "." + str);
  	},

  	replace: function (oldKeypath, newKeypath) {
  		if (this === oldKeypath) {
  			return newKeypath;
  		}

  		if (this.startsWith(oldKeypath)) {
  			return newKeypath === null ? newKeypath : getKeypath(this.str.replace(oldKeypath.str + ".", newKeypath.str + "."));
  		}
  	},

  	startsWith: function (keypath) {
  		if (!keypath) {
  			// TODO under what circumstances does this happen?
  			return false;
  		}

  		return keypath && this.str.substr(0, keypath.str.length + 1) === keypath.str + ".";
  	},

  	toString: function () {
  		throw new Error("Bad coercion");
  	},

  	valueOf: function () {
  		throw new Error("Bad coercion");
  	},

  	wildcardMatches: function () {
  		return this._wildcardMatches || (this._wildcardMatches = utils_getPotentialWildcardMatches(this.str));
  	}
  };
  function assignNewKeypath(target, property, oldKeypath, newKeypath) {
  	var existingKeypath = target[property];

  	if (existingKeypath && (existingKeypath.equalsOrStartsWith(newKeypath) || !existingKeypath.equalsOrStartsWith(oldKeypath))) {
  		return;
  	}

  	target[property] = existingKeypath ? existingKeypath.replace(oldKeypath, newKeypath) : newKeypath;
  	return true;
  }

  function decodeKeypath(keypath) {
  	var value = keypath.slice(2);

  	if (keypath[1] === "i") {
  		return is__isNumeric(value) ? +value : value;
  	} else {
  		return value;
  	}
  }

  function getKeypath(str) {
  	if (str == null) {
  		return str;
  	}

  	// TODO it *may* be worth having two versions of this function - one where
  	// keypathCache inherits from null, and one for IE8. Depends on how
  	// much of an overhead hasOwnProperty is - probably negligible
  	if (!keypathCache.hasOwnProperty(str)) {
  		keypathCache[str] = new Keypath(str);
  	}

  	return keypathCache[str];
  }

  function getMatchingKeypaths(ractive, keypath) {
  	var keys, key, matchingKeypaths;

  	keys = keypath.str.split(".");
  	matchingKeypaths = [rootKeypath];

  	while (key = keys.shift()) {
  		if (key === "*") {
  			// expand to find all valid child keypaths
  			matchingKeypaths = matchingKeypaths.reduce(expand, []);
  		} else {
  			if (matchingKeypaths[0] === rootKeypath) {
  				// first key
  				matchingKeypaths[0] = getKeypath(key);
  			} else {
  				matchingKeypaths = matchingKeypaths.map(concatenate(key));
  			}
  		}
  	}

  	return matchingKeypaths;

  	function expand(matchingKeypaths, keypath) {
  		var wrapper, value, keys;

  		if (keypath.isRoot) {
  			keys = [].concat(Object.keys(ractive.viewmodel.data), Object.keys(ractive.viewmodel.mappings), Object.keys(ractive.viewmodel.computations));
  		} else {
  			wrapper = ractive.viewmodel.wrapped[keypath.str];
  			value = wrapper ? wrapper.get() : ractive.viewmodel.get(keypath);

  			keys = value ? Object.keys(value) : null;
  		}

  		if (keys) {
  			keys.forEach(function (key) {
  				if (key !== "_ractive" || !isArray(value)) {
  					matchingKeypaths.push(keypath.join(key));
  				}
  			});
  		}

  		return matchingKeypaths;
  	}
  }

  function concatenate(key) {
  	return function (keypath) {
  		return keypath.join(key);
  	};
  }
  function normalise(ref) {
  	return ref ? ref.replace(refPattern, ".$1") : "";
  }

  var rootKeypath = getKeypath("");

  var shared_add = add;
  var shared_add__errorMessage = "Cannot add to a non-numeric value";
  function add(root, keypath, d) {
  	if (typeof keypath !== "string" || !is__isNumeric(d)) {
  		throw new Error("Bad arguments");
  	}

  	var value = undefined,
  	    changes = undefined;

  	if (/\*/.test(keypath)) {
  		changes = {};

  		getMatchingKeypaths(root, getKeypath(normalise(keypath))).forEach(function (keypath) {
  			var value = root.viewmodel.get(keypath);

  			if (!is__isNumeric(value)) {
  				throw new Error(shared_add__errorMessage);
  			}

  			changes[keypath.str] = value + d;
  		});

  		return root.set(changes);
  	}

  	value = root.get(keypath);

  	if (!is__isNumeric(value)) {
  		throw new Error(shared_add__errorMessage);
  	}

  	return root.set(keypath, +value + d);
  }

  var prototype_add = Ractive$add;
  function Ractive$add(keypath, d) {
  	return shared_add(this, keypath, d === undefined ? 1 : +d);
  }

  var requestAnimationFrame;

  // If window doesn't exist, we don't need requestAnimationFrame
  if (typeof window === "undefined") {
  	requestAnimationFrame = null;
  } else {
  	// https://gist.github.com/paulirish/1579671
  	(function (vendors, lastTime, window) {

  		var x, setTimeout;

  		if (window.requestAnimationFrame) {
  			return;
  		}

  		for (x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
  			window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
  		}

  		if (!window.requestAnimationFrame) {
  			setTimeout = window.setTimeout;

  			window.requestAnimationFrame = function (callback) {
  				var currTime, timeToCall, id;

  				currTime = Date.now();
  				timeToCall = Math.max(0, 16 - (currTime - lastTime));
  				id = setTimeout(function () {
  					callback(currTime + timeToCall);
  				}, timeToCall);

  				lastTime = currTime + timeToCall;
  				return id;
  			};
  		}
  	})(vendors, 0, window);

  	requestAnimationFrame = window.requestAnimationFrame;
  }

  var rAF = requestAnimationFrame;

  var getTime;

  if (typeof window !== "undefined" && window.performance && typeof window.performance.now === "function") {
  	getTime = function () {
  		return window.performance.now();
  	};
  } else {
  	getTime = function () {
  		return Date.now();
  	};
  }

  var utils_getTime = getTime;

  var deprecations = {
  	construct: {
  		deprecated: "beforeInit",
  		replacement: "onconstruct"
  	},
  	render: {
  		deprecated: "init",
  		message: "The \"init\" method has been deprecated " + "and will likely be removed in a future release. " + "You can either use the \"oninit\" method which will fire " + "only once prior to, and regardless of, any eventual ractive " + "instance being rendered, or if you need to access the " + "rendered DOM, use \"onrender\" instead. " + "See http://docs.ractivejs.org/latest/migrating for more information."
  	},
  	complete: {
  		deprecated: "complete",
  		replacement: "oncomplete"
  	}
  };

  function Hook(event) {
  	this.event = event;
  	this.method = "on" + event;
  	this.deprecate = deprecations[event];
  }

  Hook.prototype.fire = function (ractive, arg) {
  	function call(method) {
  		if (ractive[method]) {
  			arg ? ractive[method](arg) : ractive[method]();
  			return true;
  		}
  	}

  	call(this.method);

  	if (!ractive[this.method] && this.deprecate && call(this.deprecate.deprecated)) {
  		if (this.deprecate.message) {
  			warnIfDebug(this.deprecate.message);
  		} else {
  			warnIfDebug("The method \"%s\" has been deprecated in favor of \"%s\" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.", this.deprecate.deprecated, this.deprecate.replacement);
  		}
  	}

  	arg ? ractive.fire(this.event, arg) : ractive.fire(this.event);
  };

  var hooks_Hook = Hook;

  function addToArray(array, value) {
  	var index = array.indexOf(value);

  	if (index === -1) {
  		array.push(value);
  	}
  }

  function arrayContains(array, value) {
  	for (var i = 0, c = array.length; i < c; i++) {
  		if (array[i] == value) {
  			return true;
  		}
  	}

  	return false;
  }

  function arrayContentsMatch(a, b) {
  	var i;

  	if (!isArray(a) || !isArray(b)) {
  		return false;
  	}

  	if (a.length !== b.length) {
  		return false;
  	}

  	i = a.length;
  	while (i--) {
  		if (a[i] !== b[i]) {
  			return false;
  		}
  	}

  	return true;
  }

  function ensureArray(x) {
  	if (typeof x === "string") {
  		return [x];
  	}

  	if (x === undefined) {
  		return [];
  	}

  	return x;
  }

  function lastItem(array) {
  	return array[array.length - 1];
  }

  function removeFromArray(array, member) {
  	var index = array.indexOf(member);

  	if (index !== -1) {
  		array.splice(index, 1);
  	}
  }

  function toArray(arrayLike) {
  	var array = [],
  	    i = arrayLike.length;
  	while (i--) {
  		array[i] = arrayLike[i];
  	}

  	return array;
  }

  var _Promise,
      PENDING = {},
      FULFILLED = {},
      REJECTED = {};

  if (typeof Promise === "function") {
  	// use native Promise
  	_Promise = Promise;
  } else {
  	_Promise = function (callback) {
  		var fulfilledHandlers = [],
  		    rejectedHandlers = [],
  		    state = PENDING,
  		    result,
  		    dispatchHandlers,
  		    makeResolver,
  		    fulfil,
  		    reject,
  		    promise;

  		makeResolver = function (newState) {
  			return function (value) {
  				if (state !== PENDING) {
  					return;
  				}

  				result = value;
  				state = newState;

  				dispatchHandlers = makeDispatcher(state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result);

  				// dispatch onFulfilled and onRejected handlers asynchronously
  				wait(dispatchHandlers);
  			};
  		};

  		fulfil = makeResolver(FULFILLED);
  		reject = makeResolver(REJECTED);

  		try {
  			callback(fulfil, reject);
  		} catch (err) {
  			reject(err);
  		}

  		promise = {
  			// `then()` returns a Promise - 2.2.7
  			then: function (onFulfilled, onRejected) {
  				var promise2 = new _Promise(function (fulfil, reject) {

  					var processResolutionHandler = function (handler, handlers, forward) {

  						// 2.2.1.1
  						if (typeof handler === "function") {
  							handlers.push(function (p1result) {
  								var x;

  								try {
  									x = handler(p1result);
  									utils_Promise__resolve(promise2, x, fulfil, reject);
  								} catch (err) {
  									reject(err);
  								}
  							});
  						} else {
  							// Forward the result of promise1 to promise2, if resolution handlers
  							// are not given
  							handlers.push(forward);
  						}
  					};

  					// 2.2
  					processResolutionHandler(onFulfilled, fulfilledHandlers, fulfil);
  					processResolutionHandler(onRejected, rejectedHandlers, reject);

  					if (state !== PENDING) {
  						// If the promise has resolved already, dispatch the appropriate handlers asynchronously
  						wait(dispatchHandlers);
  					}
  				});

  				return promise2;
  			}
  		};

  		promise["catch"] = function (onRejected) {
  			return this.then(null, onRejected);
  		};

  		return promise;
  	};

  	_Promise.all = function (promises) {
  		return new _Promise(function (fulfil, reject) {
  			var result = [],
  			    pending,
  			    i,
  			    processPromise;

  			if (!promises.length) {
  				fulfil(result);
  				return;
  			}

  			processPromise = function (promise, i) {
  				if (promise && typeof promise.then === "function") {
  					promise.then(function (value) {
  						result[i] = value;
  						--pending || fulfil(result);
  					}, reject);
  				} else {
  					result[i] = promise;
  					--pending || fulfil(result);
  				}
  			};

  			pending = i = promises.length;
  			while (i--) {
  				processPromise(promises[i], i);
  			}
  		});
  	};

  	_Promise.resolve = function (value) {
  		return new _Promise(function (fulfil) {
  			fulfil(value);
  		});
  	};

  	_Promise.reject = function (reason) {
  		return new _Promise(function (fulfil, reject) {
  			reject(reason);
  		});
  	};
  }

  var utils_Promise = _Promise;

  // TODO use MutationObservers or something to simulate setImmediate
  function wait(callback) {
  	setTimeout(callback, 0);
  }

  function makeDispatcher(handlers, result) {
  	return function () {
  		var handler;

  		while (handler = handlers.shift()) {
  			handler(result);
  		}
  	};
  }

  function utils_Promise__resolve(promise, x, fulfil, reject) {
  	// Promise Resolution Procedure
  	var then;

  	// 2.3.1
  	if (x === promise) {
  		throw new TypeError("A promise's fulfillment handler cannot return the same promise");
  	}

  	// 2.3.2
  	if (x instanceof _Promise) {
  		x.then(fulfil, reject);
  	}

  	// 2.3.3
  	else if (x && (typeof x === "object" || typeof x === "function")) {
  		try {
  			then = x.then; // 2.3.3.1
  		} catch (e) {
  			reject(e); // 2.3.3.2
  			return;
  		}

  		// 2.3.3.3
  		if (typeof then === "function") {
  			var called, resolvePromise, rejectPromise;

  			resolvePromise = function (y) {
  				if (called) {
  					return;
  				}
  				called = true;
  				utils_Promise__resolve(promise, y, fulfil, reject);
  			};

  			rejectPromise = function (r) {
  				if (called) {
  					return;
  				}
  				called = true;
  				reject(r);
  			};

  			try {
  				then.call(x, resolvePromise, rejectPromise);
  			} catch (e) {
  				if (!called) {
  					// 2.3.3.3.4.1
  					reject(e); // 2.3.3.3.4.2
  					called = true;
  					return;
  				}
  			}
  		} else {
  			fulfil(x);
  		}
  	} else {
  		fulfil(x);
  	}
  }

  var getInnerContext = function (fragment) {
  	do {
  		if (fragment.context !== undefined) {
  			return fragment.context;
  		}
  	} while (fragment = fragment.parent);

  	return rootKeypath;
  };

  var shared_resolveRef = resolveRef;

  function resolveRef(ractive, ref, fragment) {
  	var keypath;

  	ref = normalise(ref);

  	// If a reference begins '~/', it's a top-level reference
  	if (ref.substr(0, 2) === "~/") {
  		keypath = getKeypath(ref.substring(2));
  		createMappingIfNecessary(ractive, keypath.firstKey, fragment);
  	}

  	// If a reference begins with '.', it's either a restricted reference or
  	// an ancestor reference...
  	else if (ref[0] === ".") {
  		keypath = resolveAncestorRef(getInnerContext(fragment), ref);

  		if (keypath) {
  			createMappingIfNecessary(ractive, keypath.firstKey, fragment);
  		}
  	}

  	// ...otherwise we need to figure out the keypath based on context
  	else {
  		keypath = resolveAmbiguousReference(ractive, getKeypath(ref), fragment);
  	}

  	return keypath;
  }

  function resolveAncestorRef(baseContext, ref) {
  	var contextKeys;

  	// TODO...
  	if (baseContext != undefined && typeof baseContext !== "string") {
  		baseContext = baseContext.str;
  	}

  	// {{.}} means 'current context'
  	if (ref === ".") return getKeypath(baseContext);

  	contextKeys = baseContext ? baseContext.split(".") : [];

  	// ancestor references (starting "../") go up the tree
  	if (ref.substr(0, 3) === "../") {
  		while (ref.substr(0, 3) === "../") {
  			if (!contextKeys.length) {
  				throw new Error("Could not resolve reference - too many \"../\" prefixes");
  			}

  			contextKeys.pop();
  			ref = ref.substring(3);
  		}

  		contextKeys.push(ref);
  		return getKeypath(contextKeys.join("."));
  	}

  	// not an ancestor reference - must be a restricted reference (prepended with "." or "./")
  	if (!baseContext) {
  		return getKeypath(ref.replace(/^\.\/?/, ""));
  	}

  	return getKeypath(baseContext + ref.replace(/^\.\//, "."));
  }

  function resolveAmbiguousReference(ractive, ref, fragment, isParentLookup) {
  	var context, key, parentValue, hasContextChain, parentKeypath;

  	if (ref.isRoot) {
  		return ref;
  	}

  	key = ref.firstKey;

  	while (fragment) {
  		context = fragment.context;
  		fragment = fragment.parent;

  		if (!context) {
  			continue;
  		}

  		hasContextChain = true;
  		parentValue = ractive.viewmodel.get(context);

  		if (parentValue && (typeof parentValue === "object" || typeof parentValue === "function") && key in parentValue) {
  			return context.join(ref.str);
  		}
  	}

  	// Root/computed/mapped property?
  	if (isRootProperty(ractive.viewmodel, key)) {
  		return ref;
  	}

  	// If this is an inline component, and it's not isolated, we
  	// can try going up the scope chain
  	if (ractive.parent && !ractive.isolated) {
  		hasContextChain = true;
  		fragment = ractive.component.parentFragment;

  		key = getKeypath(key);

  		if (parentKeypath = resolveAmbiguousReference(ractive.parent, key, fragment, true)) {
  			// We need to create an inter-component binding
  			ractive.viewmodel.map(key, {
  				origin: ractive.parent.viewmodel,
  				keypath: parentKeypath
  			});

  			return ref;
  		}
  	}

  	// If there's no context chain, and the instance is either a) isolated or
  	// b) an orphan, then we know that the keypath is identical to the reference
  	if (!isParentLookup && !hasContextChain) {
  		// the data object needs to have a property by this name,
  		// to prevent future failed lookups
  		ractive.viewmodel.set(ref, undefined);
  		return ref;
  	}
  }

  function createMappingIfNecessary(ractive, key) {
  	var parentKeypath;

  	if (!ractive.parent || ractive.isolated || isRootProperty(ractive.viewmodel, key)) {
  		return;
  	}

  	key = getKeypath(key);

  	if (parentKeypath = resolveAmbiguousReference(ractive.parent, key, ractive.component.parentFragment, true)) {
  		ractive.viewmodel.map(key, {
  			origin: ractive.parent.viewmodel,
  			keypath: parentKeypath
  		});
  	}
  }

  function isRootProperty(viewmodel, key) {
  	// special case for reference to root
  	return key === "" || key in viewmodel.data || key in viewmodel.computations || key in viewmodel.mappings;
  }

  function teardown(x) {
    x.teardown();
  }

  function methodCallers__unbind(x) {
    x.unbind();
  }

  function methodCallers__unrender(x) {
    x.unrender();
  }

  function cancel(x) {
    x.cancel();
  }

  var TransitionManager = function (callback, parent) {
  	this.callback = callback;
  	this.parent = parent;

  	this.intros = [];
  	this.outros = [];

  	this.children = [];
  	this.totalChildren = this.outroChildren = 0;

  	this.detachQueue = [];
  	this.decoratorQueue = [];
  	this.outrosComplete = false;

  	if (parent) {
  		parent.addChild(this);
  	}
  };

  TransitionManager.prototype = {
  	addChild: function (child) {
  		this.children.push(child);

  		this.totalChildren += 1;
  		this.outroChildren += 1;
  	},

  	decrementOutros: function () {
  		this.outroChildren -= 1;
  		check(this);
  	},

  	decrementTotal: function () {
  		this.totalChildren -= 1;
  		check(this);
  	},

  	add: function (transition) {
  		var list = transition.isIntro ? this.intros : this.outros;
  		list.push(transition);
  	},

  	addDecorator: function (decorator) {
  		this.decoratorQueue.push(decorator);
  	},

  	remove: function (transition) {
  		var list = transition.isIntro ? this.intros : this.outros;
  		removeFromArray(list, transition);
  		check(this);
  	},

  	init: function () {
  		this.ready = true;
  		check(this);
  	},

  	detachNodes: function () {
  		this.decoratorQueue.forEach(teardown);
  		this.detachQueue.forEach(detach);
  		this.children.forEach(detachNodes);
  	}
  };

  function detach(element) {
  	element.detach();
  }

  function detachNodes(tm) {
  	tm.detachNodes();
  }

  function check(tm) {
  	if (!tm.ready || tm.outros.length || tm.outroChildren) return;

  	// If all outros are complete, and we haven't already done this,
  	// we notify the parent if there is one, otherwise
  	// start detaching nodes
  	if (!tm.outrosComplete) {
  		if (tm.parent) {
  			tm.parent.decrementOutros(tm);
  		} else {
  			tm.detachNodes();
  		}

  		tm.outrosComplete = true;
  	}

  	// Once everything is done, we can notify parent transition
  	// manager and call the callback
  	if (!tm.intros.length && !tm.totalChildren) {
  		if (typeof tm.callback === "function") {
  			tm.callback();
  		}

  		if (tm.parent) {
  			tm.parent.decrementTotal();
  		}
  	}
  }

  var global_TransitionManager = TransitionManager;

  var batch,
      runloop,
      unresolved = [],
      changeHook = new hooks_Hook("change");

  runloop = {
  	start: function (instance, returnPromise) {
  		var promise, fulfilPromise;

  		if (returnPromise) {
  			promise = new utils_Promise(function (f) {
  				return fulfilPromise = f;
  			});
  		}

  		batch = {
  			previousBatch: batch,
  			transitionManager: new global_TransitionManager(fulfilPromise, batch && batch.transitionManager),
  			views: [],
  			tasks: [],
  			ractives: [],
  			instance: instance
  		};

  		if (instance) {
  			batch.ractives.push(instance);
  		}

  		return promise;
  	},

  	end: function () {
  		flushChanges();

  		batch.transitionManager.init();
  		if (!batch.previousBatch && !!batch.instance) batch.instance.viewmodel.changes = [];
  		batch = batch.previousBatch;
  	},

  	addRactive: function (ractive) {
  		if (batch) {
  			addToArray(batch.ractives, ractive);
  		}
  	},

  	registerTransition: function (transition) {
  		transition._manager = batch.transitionManager;
  		batch.transitionManager.add(transition);
  	},

  	registerDecorator: function (decorator) {
  		batch.transitionManager.addDecorator(decorator);
  	},

  	addView: function (view) {
  		batch.views.push(view);
  	},

  	addUnresolved: function (thing) {
  		unresolved.push(thing);
  	},

  	removeUnresolved: function (thing) {
  		removeFromArray(unresolved, thing);
  	},

  	// synchronise node detachments with transition ends
  	detachWhenReady: function (thing) {
  		batch.transitionManager.detachQueue.push(thing);
  	},

  	scheduleTask: function (task, postRender) {
  		var _batch;

  		if (!batch) {
  			task();
  		} else {
  			_batch = batch;
  			while (postRender && _batch.previousBatch) {
  				// this can't happen until the DOM has been fully updated
  				// otherwise in some situations (with components inside elements)
  				// transitions and decorators will initialise prematurely
  				_batch = _batch.previousBatch;
  			}

  			_batch.tasks.push(task);
  		}
  	}
  };

  var global_runloop = runloop;

  function flushChanges() {
  	var i, thing, changeHash;

  	while (batch.ractives.length) {
  		thing = batch.ractives.pop();
  		changeHash = thing.viewmodel.applyChanges();

  		if (changeHash) {
  			changeHook.fire(thing, changeHash);
  		}
  	}

  	attemptKeypathResolution();

  	// Now that changes have been fully propagated, we can update the DOM
  	// and complete other tasks
  	for (i = 0; i < batch.views.length; i += 1) {
  		batch.views[i].update();
  	}
  	batch.views.length = 0;

  	for (i = 0; i < batch.tasks.length; i += 1) {
  		batch.tasks[i]();
  	}
  	batch.tasks.length = 0;

  	// If updating the view caused some model blowback - e.g. a triple
  	// containing <option> elements caused the binding on the <select>
  	// to update - then we start over
  	if (batch.ractives.length) return flushChanges();
  }

  function attemptKeypathResolution() {
  	var i, item, keypath, resolved;

  	i = unresolved.length;

  	// see if we can resolve any unresolved references
  	while (i--) {
  		item = unresolved[i];

  		if (item.keypath) {
  			// it resolved some other way. TODO how? two-way binding? Seems
  			// weird that we'd still end up here
  			unresolved.splice(i, 1);
  			continue; // avoid removing the wrong thing should the next condition be true
  		}

  		if (keypath = shared_resolveRef(item.root, item.ref, item.parentFragment)) {
  			(resolved || (resolved = [])).push({
  				item: item,
  				keypath: keypath
  			});

  			unresolved.splice(i, 1);
  		}
  	}

  	if (resolved) {
  		resolved.forEach(global_runloop__resolve);
  	}
  }

  function global_runloop__resolve(resolved) {
  	resolved.item.resolve(resolved.keypath);
  }

  var queue = [];

  var animations = {
  	tick: function () {
  		var i, animation, now;

  		now = utils_getTime();

  		global_runloop.start();

  		for (i = 0; i < queue.length; i += 1) {
  			animation = queue[i];

  			if (!animation.tick(now)) {
  				// animation is complete, remove it from the stack, and decrement i so we don't miss one
  				queue.splice(i--, 1);
  			}
  		}

  		global_runloop.end();

  		if (queue.length) {
  			rAF(animations.tick);
  		} else {
  			animations.running = false;
  		}
  	},

  	add: function (animation) {
  		queue.push(animation);

  		if (!animations.running) {
  			animations.running = true;
  			rAF(animations.tick);
  		}
  	},

  	// TODO optimise this
  	abort: function (keypath, root) {
  		var i = queue.length,
  		    animation;

  		while (i--) {
  			animation = queue[i];

  			if (animation.root === root && animation.keypath === keypath) {
  				animation.stop();
  			}
  		}
  	}
  };

  var shared_animations = animations;

  var Animation = function (options) {
  	var key;

  	this.startTime = Date.now();

  	// from and to
  	for (key in options) {
  		if (options.hasOwnProperty(key)) {
  			this[key] = options[key];
  		}
  	}

  	this.interpolator = shared_interpolate(this.from, this.to, this.root, this.interpolator);
  	this.running = true;

  	this.tick();
  };

  Animation.prototype = {
  	tick: function () {
  		var elapsed, t, value, timeNow, index, keypath;

  		keypath = this.keypath;

  		if (this.running) {
  			timeNow = Date.now();
  			elapsed = timeNow - this.startTime;

  			if (elapsed >= this.duration) {
  				if (keypath !== null) {
  					global_runloop.start(this.root);
  					this.root.viewmodel.set(keypath, this.to);
  					global_runloop.end();
  				}

  				if (this.step) {
  					this.step(1, this.to);
  				}

  				this.complete(this.to);

  				index = this.root._animations.indexOf(this);

  				// TODO investigate why this happens
  				if (index === -1) {
  					warnIfDebug("Animation was not found");
  				}

  				this.root._animations.splice(index, 1);

  				this.running = false;
  				return false; // remove from the stack
  			}

  			t = this.easing ? this.easing(elapsed / this.duration) : elapsed / this.duration;

  			if (keypath !== null) {
  				value = this.interpolator(t);
  				global_runloop.start(this.root);
  				this.root.viewmodel.set(keypath, value);
  				global_runloop.end();
  			}

  			if (this.step) {
  				this.step(t, value);
  			}

  			return true; // keep in the stack
  		}

  		return false; // remove from the stack
  	},

  	stop: function () {
  		var index;

  		this.running = false;

  		index = this.root._animations.indexOf(this);

  		// TODO investigate why this happens
  		if (index === -1) {
  			warnIfDebug("Animation was not found");
  		}

  		this.root._animations.splice(index, 1);
  	}
  };

  var animate_Animation = Animation;

  var prototype_animate = Ractive$animate;

  var noAnimation = { stop: noop };
  function Ractive$animate(keypath, to, options) {
  	var promise, fulfilPromise, k, animation, animations, easing, duration, step, complete, makeValueCollector, currentValues, collectValue, dummy, dummyOptions;

  	promise = new utils_Promise(function (fulfil) {
  		return fulfilPromise = fulfil;
  	});

  	// animate multiple keypaths
  	if (typeof keypath === "object") {
  		options = to || {};
  		easing = options.easing;
  		duration = options.duration;

  		animations = [];

  		// we don't want to pass the `step` and `complete` handlers, as they will
  		// run for each animation! So instead we'll store the handlers and create
  		// our own...
  		step = options.step;
  		complete = options.complete;

  		if (step || complete) {
  			currentValues = {};

  			options.step = null;
  			options.complete = null;

  			makeValueCollector = function (keypath) {
  				return function (t, value) {
  					currentValues[keypath] = value;
  				};
  			};
  		}

  		for (k in keypath) {
  			if (keypath.hasOwnProperty(k)) {
  				if (step || complete) {
  					collectValue = makeValueCollector(k);
  					options = { easing: easing, duration: duration };

  					if (step) {
  						options.step = collectValue;
  					}
  				}

  				options.complete = complete ? collectValue : noop;
  				animations.push(animate(this, k, keypath[k], options));
  			}
  		}

  		// Create a dummy animation, to facilitate step/complete
  		// callbacks, and Promise fulfilment
  		dummyOptions = { easing: easing, duration: duration };

  		if (step) {
  			dummyOptions.step = function (t) {
  				return step(t, currentValues);
  			};
  		}

  		if (complete) {
  			promise.then(function (t) {
  				return complete(t, currentValues);
  			});
  		}

  		dummyOptions.complete = fulfilPromise;

  		dummy = animate(this, null, null, dummyOptions);
  		animations.push(dummy);

  		promise.stop = function () {
  			var animation;

  			while (animation = animations.pop()) {
  				animation.stop();
  			}

  			if (dummy) {
  				dummy.stop();
  			}
  		};

  		return promise;
  	}

  	// animate a single keypath
  	options = options || {};

  	if (options.complete) {
  		promise.then(options.complete);
  	}

  	options.complete = fulfilPromise;
  	animation = animate(this, keypath, to, options);

  	promise.stop = function () {
  		return animation.stop();
  	};
  	return promise;
  }

  function animate(root, keypath, to, options) {
  	var easing, duration, animation, from;

  	if (keypath) {
  		keypath = getKeypath(normalise(keypath));
  	}

  	if (keypath !== null) {
  		from = root.viewmodel.get(keypath);
  	}

  	// cancel any existing animation
  	// TODO what about upstream/downstream keypaths?
  	shared_animations.abort(keypath, root);

  	// don't bother animating values that stay the same
  	if (isEqual(from, to)) {
  		if (options.complete) {
  			options.complete(options.to);
  		}

  		return noAnimation;
  	}

  	// easing function
  	if (options.easing) {
  		if (typeof options.easing === "function") {
  			easing = options.easing;
  		} else {
  			easing = root.easing[options.easing];
  		}

  		if (typeof easing !== "function") {
  			easing = null;
  		}
  	}

  	// duration
  	duration = options.duration === undefined ? 400 : options.duration;

  	// TODO store keys, use an internal set method
  	animation = new animate_Animation({
  		keypath: keypath,
  		from: from,
  		to: to,
  		root: root,
  		duration: duration,
  		easing: easing,
  		interpolator: options.interpolator,

  		// TODO wrap callbacks if necessary, to use instance as context
  		step: options.step,
  		complete: options.complete
  	});

  	shared_animations.add(animation);
  	root._animations.push(animation);

  	return animation;
  }

  var prototype_detach = Ractive$detach;
  var prototype_detach__detachHook = new hooks_Hook("detach");
  function Ractive$detach() {
  	if (this.detached) {
  		return this.detached;
  	}

  	if (this.el) {
  		removeFromArray(this.el.__ractive_instances__, this);
  	}
  	this.detached = this.fragment.detach();
  	prototype_detach__detachHook.fire(this);
  	return this.detached;
  }

  var prototype_find = Ractive$find;

  function Ractive$find(selector) {
  	if (!this.el) {
  		return null;
  	}

  	return this.fragment.find(selector);
  }

  var test = Query$test;
  function Query$test(item, noDirty) {
  	var itemMatches;

  	if (this._isComponentQuery) {
  		itemMatches = !this.selector || item.name === this.selector;
  	} else {
  		itemMatches = item.node ? matches(item.node, this.selector) : null;
  	}

  	if (itemMatches) {
  		this.push(item.node || item.instance);

  		if (!noDirty) {
  			this._makeDirty();
  		}

  		return true;
  	}
  }

  var makeQuery_cancel = function () {
  	var liveQueries, selector, index;

  	liveQueries = this._root[this._isComponentQuery ? "liveComponentQueries" : "liveQueries"];
  	selector = this.selector;

  	index = liveQueries.indexOf(selector);

  	if (index !== -1) {
  		liveQueries.splice(index, 1);
  		liveQueries[selector] = null;
  	}
  };

  var sortByItemPosition = function (a, b) {
  	var ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;

  	ancestryA = getAncestry(a.component || a._ractive.proxy);
  	ancestryB = getAncestry(b.component || b._ractive.proxy);

  	oldestA = lastItem(ancestryA);
  	oldestB = lastItem(ancestryB);

  	// remove items from the end of both ancestries as long as they are identical
  	// - the final one removed is the closest mutual ancestor
  	while (oldestA && oldestA === oldestB) {
  		ancestryA.pop();
  		ancestryB.pop();

  		mutualAncestor = oldestA;

  		oldestA = lastItem(ancestryA);
  		oldestB = lastItem(ancestryB);
  	}

  	// now that we have the mutual ancestor, we can find which is earliest
  	oldestA = oldestA.component || oldestA;
  	oldestB = oldestB.component || oldestB;

  	fragmentA = oldestA.parentFragment;
  	fragmentB = oldestB.parentFragment;

  	// if both items share a parent fragment, our job is easy
  	if (fragmentA === fragmentB) {
  		indexA = fragmentA.items.indexOf(oldestA);
  		indexB = fragmentB.items.indexOf(oldestB);

  		// if it's the same index, it means one contains the other,
  		// so we see which has the longest ancestry
  		return indexA - indexB || ancestryA.length - ancestryB.length;
  	}

  	// if mutual ancestor is a section, we first test to see which section
  	// fragment comes first
  	if (fragments = mutualAncestor.fragments) {
  		indexA = fragments.indexOf(fragmentA);
  		indexB = fragments.indexOf(fragmentB);

  		return indexA - indexB || ancestryA.length - ancestryB.length;
  	}

  	throw new Error("An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!");
  };

  function getParent(item) {
  	var parentFragment;

  	if (parentFragment = item.parentFragment) {
  		return parentFragment.owner;
  	}

  	if (item.component && (parentFragment = item.component.parentFragment)) {
  		return parentFragment.owner;
  	}
  }

  function getAncestry(item) {
  	var ancestry, ancestor;

  	ancestry = [item];

  	ancestor = getParent(item);

  	while (ancestor) {
  		ancestry.push(ancestor);
  		ancestor = getParent(ancestor);
  	}

  	return ancestry;
  }

  var sortByDocumentPosition = function (node, otherNode) {
  	var bitmask;

  	if (node.compareDocumentPosition) {
  		bitmask = node.compareDocumentPosition(otherNode);
  		return bitmask & 2 ? 1 : -1;
  	}

  	// In old IE, we can piggy back on the mechanism for
  	// comparing component positions
  	return sortByItemPosition(node, otherNode);
  };

  var sort = function () {
  	this.sort(this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition);
  	this._dirty = false;
  };

  var makeQuery_dirty = function () {
  	var _this = this;

  	if (!this._dirty) {
  		this._dirty = true;

  		// Once the DOM has been updated, ensure the query
  		// is correctly ordered
  		global_runloop.scheduleTask(function () {
  			_this._sort();
  		});
  	}
  };

  var remove = function (nodeOrComponent) {
  	var index = this.indexOf(this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent);

  	if (index !== -1) {
  		this.splice(index, 1);
  	}
  };

  var _makeQuery = makeQuery;
  function makeQuery(ractive, selector, live, isComponentQuery) {
  	var query = [];

  	defineProperties(query, {
  		selector: { value: selector },
  		live: { value: live },

  		_isComponentQuery: { value: isComponentQuery },
  		_test: { value: test }
  	});

  	if (!live) {
  		return query;
  	}

  	defineProperties(query, {
  		cancel: { value: makeQuery_cancel },

  		_root: { value: ractive },
  		_sort: { value: sort },
  		_makeDirty: { value: makeQuery_dirty },
  		_remove: { value: remove },

  		_dirty: { value: false, writable: true }
  	});

  	return query;
  }

  var prototype_findAll = Ractive$findAll;
  function Ractive$findAll(selector, options) {
  	var liveQueries, query;

  	if (!this.el) {
  		return [];
  	}

  	options = options || {};
  	liveQueries = this._liveQueries;

  	// Shortcut: if we're maintaining a live query with this
  	// selector, we don't need to traverse the parallel DOM
  	if (query = liveQueries[selector]) {

  		// Either return the exact same query, or (if not live) a snapshot
  		return options && options.live ? query : query.slice();
  	}

  	query = _makeQuery(this, selector, !!options.live, false);

  	// Add this to the list of live queries Ractive needs to maintain,
  	// if applicable
  	if (query.live) {
  		liveQueries.push(selector);
  		liveQueries["_" + selector] = query;
  	}

  	this.fragment.findAll(selector, query);
  	return query;
  }

  var prototype_findAllComponents = Ractive$findAllComponents;
  function Ractive$findAllComponents(selector, options) {
  	var liveQueries, query;

  	options = options || {};
  	liveQueries = this._liveComponentQueries;

  	// Shortcut: if we're maintaining a live query with this
  	// selector, we don't need to traverse the parallel DOM
  	if (query = liveQueries[selector]) {

  		// Either return the exact same query, or (if not live) a snapshot
  		return options && options.live ? query : query.slice();
  	}

  	query = _makeQuery(this, selector, !!options.live, true);

  	// Add this to the list of live queries Ractive needs to maintain,
  	// if applicable
  	if (query.live) {
  		liveQueries.push(selector);
  		liveQueries["_" + selector] = query;
  	}

  	this.fragment.findAllComponents(selector, query);
  	return query;
  }

  var prototype_findComponent = Ractive$findComponent;

  function Ractive$findComponent(selector) {
  	return this.fragment.findComponent(selector);
  }

  var findContainer = Ractive$findContainer;

  function Ractive$findContainer(selector) {
  	if (this.container) {
  		if (this.container.component && this.container.component.name === selector) {
  			return this.container;
  		} else {
  			return this.container.findContainer(selector);
  		}
  	}

  	return null;
  }

  var findParent = Ractive$findParent;

  function Ractive$findParent(selector) {

  	if (this.parent) {
  		if (this.parent.component && this.parent.component.name === selector) {
  			return this.parent;
  		} else {
  			return this.parent.findParent(selector);
  		}
  	}

  	return null;
  }

  var eventStack = {
  	enqueue: function (ractive, event) {
  		if (ractive.event) {
  			ractive._eventQueue = ractive._eventQueue || [];
  			ractive._eventQueue.push(ractive.event);
  		}
  		ractive.event = event;
  	},
  	dequeue: function (ractive) {
  		if (ractive._eventQueue && ractive._eventQueue.length) {
  			ractive.event = ractive._eventQueue.pop();
  		} else {
  			delete ractive.event;
  		}
  	}
  };

  var shared_eventStack = eventStack;

  var shared_fireEvent = fireEvent;

  function fireEvent(ractive, eventName) {
  	var options = arguments[2] === undefined ? {} : arguments[2];

  	if (!eventName) {
  		return;
  	}

  	if (!options.event) {
  		options.event = {
  			name: eventName,
  			// until event not included as argument default
  			_noArg: true
  		};
  	} else {
  		options.event.name = eventName;
  	}

  	var eventNames = getKeypath(eventName).wildcardMatches();
  	fireEventAs(ractive, eventNames, options.event, options.args, true);
  }

  function fireEventAs(ractive, eventNames, event, args) {
  	var initialFire = arguments[4] === undefined ? false : arguments[4];

  	var subscribers,
  	    i,
  	    bubble = true;

  	shared_eventStack.enqueue(ractive, event);

  	for (i = eventNames.length; i >= 0; i--) {
  		subscribers = ractive._subs[eventNames[i]];

  		if (subscribers) {
  			bubble = notifySubscribers(ractive, subscribers, event, args) && bubble;
  		}
  	}

  	shared_eventStack.dequeue(ractive);

  	if (ractive.parent && bubble) {

  		if (initialFire && ractive.component) {
  			var fullName = ractive.component.name + "." + eventNames[eventNames.length - 1];
  			eventNames = getKeypath(fullName).wildcardMatches();

  			if (event) {
  				event.component = ractive;
  			}
  		}

  		fireEventAs(ractive.parent, eventNames, event, args);
  	}
  }

  function notifySubscribers(ractive, subscribers, event, args) {
  	var originalEvent = null,
  	    stopEvent = false;

  	if (event && !event._noArg) {
  		args = [event].concat(args);
  	}

  	// subscribers can be modified inflight, e.g. "once" functionality
  	// so we need to copy to make sure everyone gets called
  	subscribers = subscribers.slice();

  	for (var i = 0, len = subscribers.length; i < len; i += 1) {
  		if (subscribers[i].apply(ractive, args) === false) {
  			stopEvent = true;
  		}
  	}

  	if (event && !event._noArg && stopEvent && (originalEvent = event.original)) {
  		originalEvent.preventDefault && originalEvent.preventDefault();
  		originalEvent.stopPropagation && originalEvent.stopPropagation();
  	}

  	return !stopEvent;
  }

  var prototype_fire = Ractive$fire;
  function Ractive$fire(eventName) {

  	var options = {
  		args: Array.prototype.slice.call(arguments, 1)
  	};

  	shared_fireEvent(this, eventName, options);
  }

  var prototype_get = Ractive$get;
  var options = {
  	capture: true, // top-level calls should be intercepted
  	noUnwrap: true, // wrapped values should NOT be unwrapped
  	fullRootGet: true // root get should return mappings
  };
  function Ractive$get(keypath) {
  	var value;

  	keypath = getKeypath(normalise(keypath));
  	value = this.viewmodel.get(keypath, options);

  	// Create inter-component binding, if necessary
  	if (value === undefined && this.parent && !this.isolated) {
  		if (shared_resolveRef(this, keypath.str, this.component.parentFragment)) {
  			// creates binding as side-effect, if appropriate
  			value = this.viewmodel.get(keypath);
  		}
  	}

  	return value;
  }

  var insert = Ractive$insert;

  var insertHook = new hooks_Hook("insert");
  function Ractive$insert(target, anchor) {
  	if (!this.fragment.rendered) {
  		// TODO create, and link to, documentation explaining this
  		throw new Error("The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.");
  	}

  	target = getElement(target);
  	anchor = getElement(anchor) || null;

  	if (!target) {
  		throw new Error("You must specify a valid target to insert into");
  	}

  	target.insertBefore(this.detach(), anchor);
  	this.el = target;

  	(target.__ractive_instances__ || (target.__ractive_instances__ = [])).push(this);
  	this.detached = null;

  	fireInsertHook(this);
  }

  function fireInsertHook(ractive) {
  	insertHook.fire(ractive);

  	ractive.findAllComponents("*").forEach(function (child) {
  		fireInsertHook(child.instance);
  	});
  }

  var prototype_merge = Ractive$merge;
  function Ractive$merge(keypath, array, options) {
  	var currentArray, promise;

  	keypath = getKeypath(normalise(keypath));
  	currentArray = this.viewmodel.get(keypath);

  	// If either the existing value or the new value isn't an
  	// array, just do a regular set
  	if (!isArray(currentArray) || !isArray(array)) {
  		return this.set(keypath, array, options && options.complete);
  	}

  	// Manage transitions
  	promise = global_runloop.start(this, true);
  	this.viewmodel.merge(keypath, currentArray, array, options);
  	global_runloop.end();

  	return promise;
  }

  var Observer = function (ractive, keypath, callback, options) {
  	this.root = ractive;
  	this.keypath = keypath;
  	this.callback = callback;
  	this.defer = options.defer;

  	// default to root as context, but allow it to be overridden
  	this.context = options && options.context ? options.context : ractive;
  };

  Observer.prototype = {
  	init: function (immediate) {
  		this.value = this.root.get(this.keypath.str);

  		if (immediate !== false) {
  			this.update();
  		} else {
  			this.oldValue = this.value;
  		}
  	},

  	setValue: function (value) {
  		var _this = this;

  		if (!isEqual(value, this.value)) {
  			this.value = value;

  			if (this.defer && this.ready) {
  				global_runloop.scheduleTask(function () {
  					return _this.update();
  				});
  			} else {
  				this.update();
  			}
  		}
  	},

  	update: function () {
  		// Prevent infinite loops
  		if (this.updating) {
  			return;
  		}

  		this.updating = true;

  		this.callback.call(this.context, this.value, this.oldValue, this.keypath.str);
  		this.oldValue = this.value;

  		this.updating = false;
  	}
  };

  var observe_Observer = Observer;

  var observe_getPattern = getPattern;
  function getPattern(ractive, pattern) {
  	var matchingKeypaths, values;

  	matchingKeypaths = getMatchingKeypaths(ractive, pattern);

  	values = {};
  	matchingKeypaths.forEach(function (keypath) {
  		values[keypath.str] = ractive.get(keypath.str);
  	});

  	return values;
  }

  var PatternObserver,
      slice = Array.prototype.slice;

  PatternObserver = function (ractive, keypath, callback, options) {
  	this.root = ractive;

  	this.callback = callback;
  	this.defer = options.defer;

  	this.keypath = keypath;
  	this.regex = new RegExp("^" + keypath.str.replace(/\./g, "\\.").replace(/\*/g, "([^\\.]+)") + "$");
  	this.values = {};

  	if (this.defer) {
  		this.proxies = [];
  	}

  	// default to root as context, but allow it to be overridden
  	this.context = options && options.context ? options.context : ractive;
  };

  PatternObserver.prototype = {
  	init: function (immediate) {
  		var values, keypath;

  		values = observe_getPattern(this.root, this.keypath);

  		if (immediate !== false) {
  			for (keypath in values) {
  				if (values.hasOwnProperty(keypath)) {
  					this.update(getKeypath(keypath));
  				}
  			}
  		} else {
  			this.values = values;
  		}
  	},

  	update: function (keypath) {
  		var _this = this;

  		var values;

  		if (keypath.isPattern) {
  			values = observe_getPattern(this.root, keypath);

  			for (keypath in values) {
  				if (values.hasOwnProperty(keypath)) {
  					this.update(getKeypath(keypath));
  				}
  			}

  			return;
  		}

  		// special case - array mutation should not trigger `array.*`
  		// pattern observer with `array.length`
  		if (this.root.viewmodel.implicitChanges[keypath.str]) {
  			return;
  		}

  		if (this.defer && this.ready) {
  			global_runloop.scheduleTask(function () {
  				return _this.getProxy(keypath).update();
  			});
  			return;
  		}

  		this.reallyUpdate(keypath);
  	},

  	reallyUpdate: function (keypath) {
  		var keypathStr, value, keys, args;

  		keypathStr = keypath.str;
  		value = this.root.viewmodel.get(keypath);

  		// Prevent infinite loops
  		if (this.updating) {
  			this.values[keypathStr] = value;
  			return;
  		}

  		this.updating = true;

  		if (!isEqual(value, this.values[keypathStr]) || !this.ready) {
  			keys = slice.call(this.regex.exec(keypathStr), 1);
  			args = [value, this.values[keypathStr], keypathStr].concat(keys);

  			this.values[keypathStr] = value;
  			this.callback.apply(this.context, args);
  		}

  		this.updating = false;
  	},

  	getProxy: function (keypath) {
  		var _this = this;

  		if (!this.proxies[keypath.str]) {
  			this.proxies[keypath.str] = {
  				update: function () {
  					return _this.reallyUpdate(keypath);
  				}
  			};
  		}

  		return this.proxies[keypath.str];
  	}
  };

  var observe_PatternObserver = PatternObserver;

  var observe_getObserverFacade = getObserverFacade;
  var emptyObject = {};
  function getObserverFacade(ractive, keypath, callback, options) {
  	var observer, isPatternObserver, cancelled;

  	keypath = getKeypath(normalise(keypath));
  	options = options || emptyObject;

  	// pattern observers are treated differently
  	if (keypath.isPattern) {
  		observer = new observe_PatternObserver(ractive, keypath, callback, options);
  		ractive.viewmodel.patternObservers.push(observer);
  		isPatternObserver = true;
  	} else {
  		observer = new observe_Observer(ractive, keypath, callback, options);
  	}

  	observer.init(options.init);
  	ractive.viewmodel.register(keypath, observer, isPatternObserver ? "patternObservers" : "observers");

  	// This flag allows observers to initialise even with undefined values
  	observer.ready = true;

  	var facade = {
  		cancel: function () {
  			var index;

  			if (cancelled) {
  				return;
  			}

  			if (isPatternObserver) {
  				index = ractive.viewmodel.patternObservers.indexOf(observer);

  				ractive.viewmodel.patternObservers.splice(index, 1);
  				ractive.viewmodel.unregister(keypath, observer, "patternObservers");
  			} else {
  				ractive.viewmodel.unregister(keypath, observer, "observers");
  			}
  			cancelled = true;
  		}
  	};

  	ractive._observers.push(facade);
  	return facade;
  }

  var observe = Ractive$observe;
  function Ractive$observe(keypath, callback, options) {

  	var observers, map, keypaths, i;

  	// Allow a map of keypaths to handlers
  	if (isObject(keypath)) {
  		options = callback;
  		map = keypath;

  		observers = [];

  		for (keypath in map) {
  			if (map.hasOwnProperty(keypath)) {
  				callback = map[keypath];
  				observers.push(this.observe(keypath, callback, options));
  			}
  		}

  		return {
  			cancel: function () {
  				while (observers.length) {
  					observers.pop().cancel();
  				}
  			}
  		};
  	}

  	// Allow `ractive.observe( callback )` - i.e. observe entire model
  	if (typeof keypath === "function") {
  		options = callback;
  		callback = keypath;
  		keypath = "";

  		return observe_getObserverFacade(this, keypath, callback, options);
  	}

  	keypaths = keypath.split(" ");

  	// Single keypath
  	if (keypaths.length === 1) {
  		return observe_getObserverFacade(this, keypath, callback, options);
  	}

  	// Multiple space-separated keypaths
  	observers = [];

  	i = keypaths.length;
  	while (i--) {
  		keypath = keypaths[i];

  		if (keypath) {
  			observers.push(observe_getObserverFacade(this, keypath, callback, options));
  		}
  	}

  	return {
  		cancel: function () {
  			while (observers.length) {
  				observers.pop().cancel();
  			}
  		}
  	};
  }

  var observeOnce = Ractive$observeOnce;

  function Ractive$observeOnce(property, callback, options) {

  	var observer = this.observe(property, function () {
  		callback.apply(this, arguments);
  		observer.cancel();
  	}, { init: false, defer: options && options.defer });

  	return observer;
  }

  var shared_trim = function (str) {
    return str.trim();
  };

  var notEmptyString = function (str) {
    return str !== "";
  };

  var off = Ractive$off;
  function Ractive$off(eventName, callback) {
  	var _this = this;

  	var eventNames;

  	// if no arguments specified, remove all callbacks
  	if (!eventName) {
  		// TODO use this code instead, once the following issue has been resolved
  		// in PhantomJS (tests are unpassable otherwise!)
  		// https://github.com/ariya/phantomjs/issues/11856
  		// defineProperty( this, '_subs', { value: create( null ), configurable: true });
  		for (eventName in this._subs) {
  			delete this._subs[eventName];
  		}
  	} else {
  		// Handle multiple space-separated event names
  		eventNames = eventName.split(" ").map(shared_trim).filter(notEmptyString);

  		eventNames.forEach(function (eventName) {
  			var subscribers, index;

  			// If we have subscribers for this event...
  			if (subscribers = _this._subs[eventName]) {
  				// ...if a callback was specified, only remove that
  				if (callback) {
  					index = subscribers.indexOf(callback);
  					if (index !== -1) {
  						subscribers.splice(index, 1);
  					}
  				}

  				// ...otherwise remove all callbacks
  				else {
  					_this._subs[eventName] = [];
  				}
  			}
  		});
  	}

  	return this;
  }

  var on = Ractive$on;
  function Ractive$on(eventName, callback) {
  	var _this = this;

  	var listeners, n, eventNames;

  	// allow mutliple listeners to be bound in one go
  	if (typeof eventName === "object") {
  		listeners = [];

  		for (n in eventName) {
  			if (eventName.hasOwnProperty(n)) {
  				listeners.push(this.on(n, eventName[n]));
  			}
  		}

  		return {
  			cancel: function () {
  				var listener;

  				while (listener = listeners.pop()) {
  					listener.cancel();
  				}
  			}
  		};
  	}

  	// Handle multiple space-separated event names
  	eventNames = eventName.split(" ").map(shared_trim).filter(notEmptyString);

  	eventNames.forEach(function (eventName) {
  		(_this._subs[eventName] || (_this._subs[eventName] = [])).push(callback);
  	});

  	return {
  		cancel: function () {
  			return _this.off(eventName, callback);
  		}
  	};
  }

  var once = Ractive$once;

  function Ractive$once(eventName, handler) {

  	var listener = this.on(eventName, function () {
  		handler.apply(this, arguments);
  		listener.cancel();
  	});

  	// so we can still do listener.cancel() manually
  	return listener;
  }

  // This function takes an array, the name of a mutator method, and the
  // arguments to call that mutator method with, and returns an array that
  // maps the old indices to their new indices.

  // So if you had something like this...
  //
  //     array = [ 'a', 'b', 'c', 'd' ];
  //     array.push( 'e' );
  //
  // ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices
  // have changed. If you then did this...
  //
  //     array.unshift( 'z' );
  //
  // ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved
  // one higher to make room for the 'z'. If you removed an item, the new index
  // would be -1...
  //
  //     array.splice( 2, 2 );
  //
  // ...this would result in [ 0, 1, -1, -1, 2, 3 ].
  //
  // This information is used to enable fast, non-destructive shuffling of list
  // sections when you do e.g. `ractive.splice( 'items', 2, 2 );

  var shared_getNewIndices = getNewIndices;

  function getNewIndices(array, methodName, args) {
  	var spliceArguments,
  	    len,
  	    newIndices = [],
  	    removeStart,
  	    removeEnd,
  	    balance,
  	    i;

  	spliceArguments = getSpliceEquivalent(array, methodName, args);

  	if (!spliceArguments) {
  		return null; // TODO support reverse and sort?
  	}

  	len = array.length;
  	balance = spliceArguments.length - 2 - spliceArguments[1];

  	removeStart = Math.min(len, spliceArguments[0]);
  	removeEnd = removeStart + spliceArguments[1];

  	for (i = 0; i < removeStart; i += 1) {
  		newIndices.push(i);
  	}

  	for (; i < removeEnd; i += 1) {
  		newIndices.push(-1);
  	}

  	for (; i < len; i += 1) {
  		newIndices.push(i + balance);
  	}

  	// there is a net shift for the rest of the array starting with index + balance
  	if (balance !== 0) {
  		newIndices.touchedFrom = spliceArguments[0];
  	} else {
  		newIndices.touchedFrom = array.length;
  	}

  	return newIndices;
  }

  // The pop, push, shift an unshift methods can all be represented
  // as an equivalent splice
  function getSpliceEquivalent(array, methodName, args) {
  	switch (methodName) {
  		case "splice":
  			if (args[0] !== undefined && args[0] < 0) {
  				args[0] = array.length + Math.max(args[0], -array.length);
  			}

  			while (args.length < 2) {
  				args.push(0);
  			}

  			// ensure we only remove elements that exist
  			args[1] = Math.min(args[1], array.length - args[0]);

  			return args;

  		case "sort":
  		case "reverse":
  			return null;

  		case "pop":
  			if (array.length) {
  				return [array.length - 1, 1];
  			}
  			return [0, 0];

  		case "push":
  			return [array.length, 0].concat(args);

  		case "shift":
  			return [0, array.length ? 1 : 0];

  		case "unshift":
  			return [0, 0].concat(args);
  	}
  }

  var arrayProto = Array.prototype;

  var makeArrayMethod = function (methodName) {
  	return function (keypath) {
  		for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  			args[_key - 1] = arguments[_key];
  		}

  		var array,
  		    newIndices = [],
  		    len,
  		    promise,
  		    result;

  		keypath = getKeypath(normalise(keypath));

  		array = this.viewmodel.get(keypath);
  		len = array.length;

  		if (!isArray(array)) {
  			throw new Error("Called ractive." + methodName + "('" + keypath.str + "'), but '" + keypath.str + "' does not refer to an array");
  		}

  		newIndices = shared_getNewIndices(array, methodName, args);

  		result = arrayProto[methodName].apply(array, args);
  		promise = global_runloop.start(this, true).then(function () {
  			return result;
  		});

  		if (!!newIndices) {
  			this.viewmodel.smartUpdate(keypath, array, newIndices);
  		} else {
  			this.viewmodel.mark(keypath);
  		}

  		global_runloop.end();

  		return promise;
  	};
  };

  var pop = makeArrayMethod("pop");

  var push = makeArrayMethod("push");

  var css,
      update,
      styleElement,
      head,
      styleSheet,
      inDom,
      global_css__prefix = "/* Ractive.js component styles */\n",
      styles = [],
      dirty = false;

  if (!isClient) {
  	// TODO handle encapsulated CSS in server-rendered HTML!
  	css = {
  		add: noop,
  		apply: noop
  	};
  } else {
  	styleElement = document.createElement("style");
  	styleElement.type = "text/css";

  	head = document.getElementsByTagName("head")[0];

  	inDom = false;

  	// Internet Exploder won't let you use styleSheet.innerHTML - we have to
  	// use styleSheet.cssText instead
  	styleSheet = styleElement.styleSheet;

  	update = function () {
  		var css = global_css__prefix + styles.map(function (s) {
  			return "\n/* {" + s.id + "} */\n" + s.styles;
  		}).join("\n");

  		if (styleSheet) {
  			styleSheet.cssText = css;
  		} else {
  			styleElement.innerHTML = css;
  		}

  		if (!inDom) {
  			head.appendChild(styleElement);
  			inDom = true;
  		}
  	};

  	css = {
  		add: function (s) {
  			styles.push(s);
  			dirty = true;
  		},

  		apply: function () {
  			if (dirty) {
  				update();
  				dirty = false;
  			}
  		}
  	};
  }

  var global_css = css;

  var prototype_render = Ractive$render;

  var renderHook = new hooks_Hook("render"),
      completeHook = new hooks_Hook("complete");
  function Ractive$render(target, anchor) {
  	var _this = this;

  	var promise, instances, transitionsEnabled;

  	// if `noIntro` is `true`, temporarily disable transitions
  	transitionsEnabled = this.transitionsEnabled;
  	if (this.noIntro) {
  		this.transitionsEnabled = false;
  	}

  	promise = global_runloop.start(this, true);
  	global_runloop.scheduleTask(function () {
  		return renderHook.fire(_this);
  	}, true);

  	if (this.fragment.rendered) {
  		throw new Error("You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first");
  	}

  	target = getElement(target) || this.el;
  	anchor = getElement(anchor) || this.anchor;

  	this.el = target;
  	this.anchor = anchor;

  	if (!this.append && target) {
  		// Teardown any existing instances *before* trying to set up the new one -
  		// avoids certain weird bugs
  		var others = target.__ractive_instances__;
  		if (others && others.length) {
  			removeOtherInstances(others);
  		}

  		// make sure we are the only occupants
  		target.innerHTML = ""; // TODO is this quicker than removeChild? Initial research inconclusive
  	}

  	if (this.cssId) {
  		// ensure encapsulated CSS is up-to-date
  		global_css.apply();
  	}

  	if (target) {
  		if (!(instances = target.__ractive_instances__)) {
  			target.__ractive_instances__ = [this];
  		} else {
  			instances.push(this);
  		}

  		if (anchor) {
  			target.insertBefore(this.fragment.render(), anchor);
  		} else {
  			target.appendChild(this.fragment.render());
  		}
  	}

  	global_runloop.end();

  	this.transitionsEnabled = transitionsEnabled;

  	return promise.then(function () {
  		return completeHook.fire(_this);
  	});
  }

  function removeOtherInstances(others) {
  	others.splice(0, others.length).forEach(teardown);
  }

  var adaptConfigurator = {
  	extend: function (Parent, proto, options) {
  		proto.adapt = custom_adapt__combine(proto.adapt, ensureArray(options.adapt));
  	},

  	init: function () {}
  };

  var custom_adapt = adaptConfigurator;

  function custom_adapt__combine(a, b) {
  	var c = a.slice(),
  	    i = b.length;

  	while (i--) {
  		if (! ~c.indexOf(b[i])) {
  			c.push(b[i]);
  		}
  	}

  	return c;
  }

  var transform = transformCss;

  var selectorsPattern = /(?:^|\})?\s*([^\{\}]+)\s*\{/g,
      commentsPattern = /\/\*.*?\*\//g,
      selectorUnitPattern = /((?:(?:\[[^\]+]\])|(?:[^\s\+\>\~:]))+)((?::[^\s\+\>\~\(]+(?:\([^\)]+\))?)?\s*[\s\+\>\~]?)\s*/g,
      mediaQueryPattern = /^@media/,
      dataRvcGuidPattern = /\[data-ractive-css~="\{[a-z0-9-]+\}"]/g;
  function transformCss(css, id) {
  	var transformed, dataAttr, addGuid;

  	dataAttr = "[data-ractive-css~=\"{" + id + "}\"]";

  	addGuid = function (selector) {
  		var selectorUnits,
  		    match,
  		    unit,
  		    base,
  		    prepended,
  		    appended,
  		    i,
  		    transformed = [];

  		selectorUnits = [];

  		while (match = selectorUnitPattern.exec(selector)) {
  			selectorUnits.push({
  				str: match[0],
  				base: match[1],
  				modifiers: match[2]
  			});
  		}

  		// For each simple selector within the selector, we need to create a version
  		// that a) combines with the id, and b) is inside the id
  		base = selectorUnits.map(extractString);

  		i = selectorUnits.length;
  		while (i--) {
  			appended = base.slice();

  			// Pseudo-selectors should go after the attribute selector
  			unit = selectorUnits[i];
  			appended[i] = unit.base + dataAttr + unit.modifiers || "";

  			prepended = base.slice();
  			prepended[i] = dataAttr + " " + prepended[i];

  			transformed.push(appended.join(" "), prepended.join(" "));
  		}

  		return transformed.join(", ");
  	};

  	if (dataRvcGuidPattern.test(css)) {
  		transformed = css.replace(dataRvcGuidPattern, dataAttr);
  	} else {
  		transformed = css.replace(commentsPattern, "").replace(selectorsPattern, function (match, $1) {
  			var selectors, transformed;

  			// don't transform media queries!
  			if (mediaQueryPattern.test($1)) return match;

  			selectors = $1.split(",").map(trim);
  			transformed = selectors.map(addGuid).join(", ") + " ";

  			return match.replace($1, transformed);
  		});
  	}

  	return transformed;
  }

  function trim(str) {
  	if (str.trim) {
  		return str.trim();
  	}

  	return str.replace(/^\s+/, "").replace(/\s+$/, "");
  }

  function extractString(unit) {
  	return unit.str;
  }

  var css_css__uid = 1;

  var cssConfigurator = {
  	name: "css",

  	extend: function (Parent, proto, options) {
  		if (options.css) {
  			var id = css_css__uid++;
  			var styles = options.noCssTransform ? options.css : transform(options.css, id);

  			proto.cssId = id;
  			global_css.add({ id: id, styles: styles });
  		}
  	},

  	init: function () {}
  };

  var css_css = cssConfigurator;

  function validate(data) {
  	// Warn if userOptions.data is a non-POJO
  	if (data && data.constructor !== Object) {
  		if (typeof data === "function") {} else if (typeof data !== "object") {
  			fatal("data option must be an object or a function, `" + data + "` is not valid");
  		} else {
  			warnIfDebug("If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged");
  		}
  	}
  }

  var dataConfigurator = {
  	name: "data",

  	extend: function (Parent, proto, options) {
  		var key = undefined,
  		    value = undefined;

  		// check for non-primitives, which could cause mutation-related bugs
  		if (options.data && isObject(options.data)) {
  			for (key in options.data) {
  				value = options.data[key];

  				if (value && typeof value === "object") {
  					if (isObject(value) || isArray(value)) {
  						warnIfDebug("Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\n\n  // this...\n  data: function () {\n    return {\n      myObject: {}\n    };\n  })\n\n  // instead of this:\n  data: {\n    myObject: {}\n  }");
  					}
  				}
  			}
  		}

  		proto.data = custom_data__combine(proto.data, options.data);
  	},

  	init: function (Parent, ractive, options) {
  		var result = custom_data__combine(Parent.prototype.data, options.data);

  		if (typeof result === "function") {
  			result = result.call(ractive);
  		}

  		return result || {};
  	},

  	reset: function (ractive) {
  		var result = this.init(ractive.constructor, ractive, ractive.viewmodel);

  		ractive.viewmodel.reset(result);
  		return true;
  	}
  };

  var custom_data = dataConfigurator;

  function custom_data__combine(parentValue, childValue) {
  	validate(childValue);

  	var parentIsFn = typeof parentValue === "function";
  	var childIsFn = typeof childValue === "function";

  	// Very important, otherwise child instance can become
  	// the default data object on Ractive or a component.
  	// then ractive.set() ends up setting on the prototype!
  	if (!childValue && !parentIsFn) {
  		childValue = {};
  	}

  	// Fast path, where we just need to copy properties from
  	// parent to child
  	if (!parentIsFn && !childIsFn) {
  		return fromProperties(childValue, parentValue);
  	}

  	return function () {
  		var child = childIsFn ? callDataFunction(childValue, this) : childValue;
  		var parent = parentIsFn ? callDataFunction(parentValue, this) : parentValue;

  		return fromProperties(child, parent);
  	};
  }

  function callDataFunction(fn, context) {
  	var data = fn.call(context);

  	if (!data) return;

  	if (typeof data !== "object") {
  		fatal("Data function must return an object");
  	}

  	if (data.constructor !== Object) {
  		warnOnceIfDebug("Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged");
  	}

  	return data;
  }

  function fromProperties(primary, secondary) {
  	if (primary && secondary) {
  		for (var key in secondary) {
  			if (!(key in primary)) {
  				primary[key] = secondary[key];
  			}
  		}

  		return primary;
  	}

  	return primary || secondary;
  }

  // TODO do we need to support this in the new Ractive() case?

  var Parser,
      ParseError,
      parse_Parser__leadingWhitespace = /^\s+/;

  ParseError = function (message) {
  	this.name = "ParseError";
  	this.message = message;
  	try {
  		throw new Error(message);
  	} catch (e) {
  		this.stack = e.stack;
  	}
  };

  ParseError.prototype = Error.prototype;

  Parser = function (str, options) {
  	var items,
  	    item,
  	    lineStart = 0;

  	this.str = str;
  	this.options = options || {};
  	this.pos = 0;

  	this.lines = this.str.split("\n");
  	this.lineEnds = this.lines.map(function (line) {
  		var lineEnd = lineStart + line.length + 1; // +1 for the newline

  		lineStart = lineEnd;
  		return lineEnd;
  	}, 0);

  	// Custom init logic
  	if (this.init) this.init(str, options);

  	items = [];

  	while (this.pos < this.str.length && (item = this.read())) {
  		items.push(item);
  	}

  	this.leftover = this.remaining();
  	this.result = this.postProcess ? this.postProcess(items, options) : items;
  };

  Parser.prototype = {
  	read: function (converters) {
  		var pos, i, len, item;

  		if (!converters) converters = this.converters;

  		pos = this.pos;

  		len = converters.length;
  		for (i = 0; i < len; i += 1) {
  			this.pos = pos; // reset for each attempt

  			if (item = converters[i](this)) {
  				return item;
  			}
  		}

  		return null;
  	},

  	getLinePos: function (char) {
  		var lineNum = 0,
  		    lineStart = 0,
  		    columnNum;

  		while (char >= this.lineEnds[lineNum]) {
  			lineStart = this.lineEnds[lineNum];
  			lineNum += 1;
  		}

  		columnNum = char - lineStart;
  		return [lineNum + 1, columnNum + 1, char]; // line/col should be one-based, not zero-based!
  	},

  	error: function (message) {
  		var pos = this.getLinePos(this.pos);
  		var lineNum = pos[0];
  		var columnNum = pos[1];

  		var line = this.lines[pos[0] - 1];
  		var numTabs = 0;
  		var annotation = line.replace(/\t/g, function (match, char) {
  			if (char < pos[1]) {
  				numTabs += 1;
  			}

  			return "  ";
  		}) + "\n" + new Array(pos[1] + numTabs).join(" ") + "^----";

  		var error = new ParseError("" + message + " at line " + lineNum + " character " + columnNum + ":\n" + annotation);

  		error.line = pos[0];
  		error.character = pos[1];
  		error.shortMessage = message;

  		throw error;
  	},

  	matchString: function (string) {
  		if (this.str.substr(this.pos, string.length) === string) {
  			this.pos += string.length;
  			return string;
  		}
  	},

  	matchPattern: function (pattern) {
  		var match;

  		if (match = pattern.exec(this.remaining())) {
  			this.pos += match[0].length;
  			return match[1] || match[0];
  		}
  	},

  	allowWhitespace: function () {
  		this.matchPattern(parse_Parser__leadingWhitespace);
  	},

  	remaining: function () {
  		return this.str.substring(this.pos);
  	},

  	nextChar: function () {
  		return this.str.charAt(this.pos);
  	}
  };

  Parser.extend = function (proto) {
  	var Parent = this,
  	    Child,
  	    key;

  	Child = function (str, options) {
  		Parser.call(this, str, options);
  	};

  	Child.prototype = create(Parent.prototype);

  	for (key in proto) {
  		if (hasOwn.call(proto, key)) {
  			Child.prototype[key] = proto[key];
  		}
  	}

  	Child.extend = Parser.extend;
  	return Child;
  };

  var parse_Parser = Parser;

  var TEXT = 1;
  var INTERPOLATOR = 2;
  var TRIPLE = 3;
  var SECTION = 4;
  var INVERTED = 5;
  var CLOSING = 6;
  var ELEMENT = 7;
  var PARTIAL = 8;
  var COMMENT = 9;
  var DELIMCHANGE = 10;
  var ATTRIBUTE = 13;
  var CLOSING_TAG = 14;
  var COMPONENT = 15;
  var YIELDER = 16;
  var INLINE_PARTIAL = 17;
  var DOCTYPE = 18;

  var NUMBER_LITERAL = 20;
  var STRING_LITERAL = 21;
  var ARRAY_LITERAL = 22;
  var OBJECT_LITERAL = 23;
  var BOOLEAN_LITERAL = 24;
  var REGEXP_LITERAL = 25;

  var GLOBAL = 26;
  var KEY_VALUE_PAIR = 27;

  var REFERENCE = 30;
  var REFINEMENT = 31;
  var MEMBER = 32;
  var PREFIX_OPERATOR = 33;
  var BRACKETED = 34;
  var CONDITIONAL = 35;
  var INFIX_OPERATOR = 36;

  var INVOCATION = 40;

  var SECTION_IF = 50;
  var SECTION_UNLESS = 51;
  var SECTION_EACH = 52;
  var SECTION_WITH = 53;
  var SECTION_IF_WITH = 54;

  var ELSE = 60;
  var ELSEIF = 61;

  var mustache_readDelimiterChange = readDelimiterChange;
  var delimiterChangePattern = /^[^\s=]+/,
      whitespacePattern = /^\s+/;
  function readDelimiterChange(parser) {
  	var start, opening, closing;

  	if (!parser.matchString("=")) {
  		return null;
  	}

  	start = parser.pos;

  	// allow whitespace before new opening delimiter
  	parser.allowWhitespace();

  	opening = parser.matchPattern(delimiterChangePattern);
  	if (!opening) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace (in fact, it's necessary...)
  	if (!parser.matchPattern(whitespacePattern)) {
  		return null;
  	}

  	closing = parser.matchPattern(delimiterChangePattern);
  	if (!closing) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace before closing '='
  	parser.allowWhitespace();

  	if (!parser.matchString("=")) {
  		parser.pos = start;
  		return null;
  	}

  	return [opening, closing];
  }

  var readRegexpLiteral = readRegexpLiteral__readNumberLiteral;
  var regexpPattern = /^(\/(?:[^\n\r\u2028\u2029/\\[]|\\.|\[(?:[^\n\r\u2028\u2029\]\\]|\\.)*])+\/(?:([gimuy])(?![a-z]*\2))*(?![a-zA-Z_$0-9]))/;
  function readRegexpLiteral__readNumberLiteral(parser) {
  	var result;

  	if (result = parser.matchPattern(regexpPattern)) {
  		return {
  			t: REGEXP_LITERAL,
  			v: result
  		};
  	}

  	return null;
  }

  var converters_readMustache = readMustache;

  var delimiterChangeToken = { t: DELIMCHANGE, exclude: true };
  function readMustache(parser) {
  	var mustache, i;

  	// If we're inside a <script> or <style> tag, and we're not
  	// interpolating, bug out
  	if (parser.interpolate[parser.inside] === false) {
  		return null;
  	}

  	for (i = 0; i < parser.tags.length; i += 1) {
  		if (mustache = readMustacheOfType(parser, parser.tags[i])) {
  			return mustache;
  		}
  	}
  }

  function readMustacheOfType(parser, tag) {
  	var start, mustache, reader, i;

  	start = parser.pos;

  	if (parser.matchString("\\" + tag.open)) {
  		if (start === 0 || parser.str[start - 1] !== "\\") {
  			return tag.open;
  		}
  	} else if (!parser.matchString(tag.open)) {
  		return null;
  	}

  	// delimiter change?
  	if (mustache = mustache_readDelimiterChange(parser)) {
  		// find closing delimiter or abort...
  		if (!parser.matchString(tag.close)) {
  			return null;
  		}

  		// ...then make the switch
  		tag.open = mustache[0];
  		tag.close = mustache[1];
  		parser.sortMustacheTags();

  		return delimiterChangeToken;
  	}

  	parser.allowWhitespace();

  	// illegal section closer
  	if (parser.matchString("/")) {
  		parser.pos -= 1;
  		var rewind = parser.pos;
  		if (!readRegexpLiteral(parser)) {
  			parser.pos = rewind - tag.close.length;
  			parser.error("Attempted to close a section that wasn't open");
  		} else {
  			parser.pos = rewind;
  		}
  	}

  	for (i = 0; i < tag.readers.length; i += 1) {
  		reader = tag.readers[i];

  		if (mustache = reader(parser, tag)) {
  			if (tag.isStatic) {
  				mustache.s = true; // TODO make this `1` instead - more compact
  			}

  			if (parser.includeLinePositions) {
  				mustache.p = parser.getLinePos(start);
  			}

  			return mustache;
  		}
  	}

  	parser.pos = start;
  	return null;
  }

  var expectedExpression = "Expected a JavaScript expression";
  var expectedParen = "Expected closing paren";

  var literal_readNumberLiteral = literal_readNumberLiteral__readNumberLiteral;
  var literal_readNumberLiteral__numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
  function literal_readNumberLiteral__readNumberLiteral(parser) {
  	var result;

  	if (result = parser.matchPattern(literal_readNumberLiteral__numberPattern)) {
  		return {
  			t: NUMBER_LITERAL,
  			v: result
  		};
  	}

  	return null;
  }

  var literal_readBooleanLiteral = readBooleanLiteral;
  function readBooleanLiteral(parser) {
  	var remaining = parser.remaining();

  	if (remaining.substr(0, 4) === "true") {
  		parser.pos += 4;
  		return {
  			t: BOOLEAN_LITERAL,
  			v: "true"
  		};
  	}

  	if (remaining.substr(0, 5) === "false") {
  		parser.pos += 5;
  		return {
  			t: BOOLEAN_LITERAL,
  			v: "false"
  		};
  	}

  	return null;
  }

  var stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;

  // Match one or more characters until: ", ', \, or EOL/EOF.
  // EOL/EOF is written as (?!.) (meaning there's no non-newline char next).
  stringMiddlePattern = /^(?=.)[^"'\\]+?(?:(?!.)|(?=["'\\]))/;

  // Match one escape sequence, including the backslash.
  escapeSequencePattern = /^\\(?:['"\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;

  // Match one ES5 line continuation (backslash + line terminator).
  lineContinuationPattern = /^\\(?:\r\n|[\u000A\u000D\u2028\u2029])/;

  // Helper for defining getDoubleQuotedString and getSingleQuotedString.
  var makeQuotedStringMatcher = function (okQuote) {
  	return function (parser) {
  		var start, literal, done, next;

  		start = parser.pos;
  		literal = "\"";
  		done = false;

  		while (!done) {
  			next = parser.matchPattern(stringMiddlePattern) || parser.matchPattern(escapeSequencePattern) || parser.matchString(okQuote);
  			if (next) {
  				if (next === "\"") {
  					literal += "\\\"";
  				} else if (next === "\\'") {
  					literal += "'";
  				} else {
  					literal += next;
  				}
  			} else {
  				next = parser.matchPattern(lineContinuationPattern);
  				if (next) {
  					// convert \(newline-like) into a \u escape, which is allowed in JSON
  					literal += "\\u" + ("000" + next.charCodeAt(1).toString(16)).slice(-4);
  				} else {
  					done = true;
  				}
  			}
  		}

  		literal += "\"";

  		// use JSON.parse to interpret escapes
  		return JSON.parse(literal);
  	};
  };

  var getSingleQuotedString = makeQuotedStringMatcher("\"");
  var getDoubleQuotedString = makeQuotedStringMatcher("'");

  var readStringLiteral = function (parser) {
  	var start, string;

  	start = parser.pos;

  	if (parser.matchString("\"")) {
  		string = getDoubleQuotedString(parser);

  		if (!parser.matchString("\"")) {
  			parser.pos = start;
  			return null;
  		}

  		return {
  			t: STRING_LITERAL,
  			v: string
  		};
  	}

  	if (parser.matchString("'")) {
  		string = getSingleQuotedString(parser);

  		if (!parser.matchString("'")) {
  			parser.pos = start;
  			return null;
  		}

  		return {
  			t: STRING_LITERAL,
  			v: string
  		};
  	}

  	return null;
  };

  var patterns__name = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;

  // http://mathiasbynens.be/notes/javascript-properties
  // can be any name, string literal, or number literal
  var shared_readKey = readKey;
  var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
  function readKey(parser) {
  	var token;

  	if (token = readStringLiteral(parser)) {
  		return identifier.test(token.v) ? token.v : "\"" + token.v.replace(/"/g, "\\\"") + "\"";
  	}

  	if (token = literal_readNumberLiteral(parser)) {
  		return token.v;
  	}

  	if (token = parser.matchPattern(patterns__name)) {
  		return token;
  	}
  }

  var keyValuePair = readKeyValuePair;
  function readKeyValuePair(parser) {
  	var start, key, value;

  	start = parser.pos;

  	// allow whitespace between '{' and key
  	parser.allowWhitespace();

  	key = shared_readKey(parser);
  	if (key === null) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace between key and ':'
  	parser.allowWhitespace();

  	// next character must be ':'
  	if (!parser.matchString(":")) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace between ':' and value
  	parser.allowWhitespace();

  	// next expression must be a, well... expression
  	value = converters_readExpression(parser);
  	if (value === null) {
  		parser.pos = start;
  		return null;
  	}

  	return {
  		t: KEY_VALUE_PAIR,
  		k: key,
  		v: value
  	};
  }

  var objectLiteral_keyValuePairs = readKeyValuePairs;
  function readKeyValuePairs(parser) {
  	var start, pairs, pair, keyValuePairs;

  	start = parser.pos;

  	pair = keyValuePair(parser);
  	if (pair === null) {
  		return null;
  	}

  	pairs = [pair];

  	if (parser.matchString(",")) {
  		keyValuePairs = readKeyValuePairs(parser);

  		if (!keyValuePairs) {
  			parser.pos = start;
  			return null;
  		}

  		return pairs.concat(keyValuePairs);
  	}

  	return pairs;
  }

  var readObjectLiteral = function (parser) {
  	var start, keyValuePairs;

  	start = parser.pos;

  	// allow whitespace
  	parser.allowWhitespace();

  	if (!parser.matchString("{")) {
  		parser.pos = start;
  		return null;
  	}

  	keyValuePairs = objectLiteral_keyValuePairs(parser);

  	// allow whitespace between final value and '}'
  	parser.allowWhitespace();

  	if (!parser.matchString("}")) {
  		parser.pos = start;
  		return null;
  	}

  	return {
  		t: OBJECT_LITERAL,
  		m: keyValuePairs
  	};
  };

  var shared_readExpressionList = readExpressionList;
  function readExpressionList(parser) {
  	var start, expressions, expr, next;

  	start = parser.pos;

  	parser.allowWhitespace();

  	expr = converters_readExpression(parser);

  	if (expr === null) {
  		return null;
  	}

  	expressions = [expr];

  	// allow whitespace between expression and ','
  	parser.allowWhitespace();

  	if (parser.matchString(",")) {
  		next = readExpressionList(parser);
  		if (next === null) {
  			parser.error(expectedExpression);
  		}

  		next.forEach(append);
  	}

  	function append(expression) {
  		expressions.push(expression);
  	}

  	return expressions;
  }

  var readArrayLiteral = function (parser) {
  	var start, expressionList;

  	start = parser.pos;

  	// allow whitespace before '['
  	parser.allowWhitespace();

  	if (!parser.matchString("[")) {
  		parser.pos = start;
  		return null;
  	}

  	expressionList = shared_readExpressionList(parser);

  	if (!parser.matchString("]")) {
  		parser.pos = start;
  		return null;
  	}

  	return {
  		t: ARRAY_LITERAL,
  		m: expressionList
  	};
  };

  var primary_readLiteral = readLiteral;
  function readLiteral(parser) {
  	return literal_readNumberLiteral(parser) || literal_readBooleanLiteral(parser) || readStringLiteral(parser) || readObjectLiteral(parser) || readArrayLiteral(parser) || readRegexpLiteral(parser);
  }

  var primary_readReference = readReference;
  var prefixPattern = /^(?:~\/|(?:\.\.\/)+|\.\/(?:\.\.\/)*|\.)/,
      globals,
      keywords;

  // if a reference is a browser global, we don't deference it later, so it needs special treatment
  globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)\b/;

  // keywords are not valid references, with the exception of `this`
  keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;

  var legalReference = /^[a-zA-Z$_0-9]+(?:(?:\.[a-zA-Z$_0-9]+)|(?:\[[0-9]+\]))*/;
  var relaxedName = /^[a-zA-Z_$][-a-zA-Z_$0-9]*/;
  function readReference(parser) {
  	var startPos, prefix, name, global, reference, lastDotIndex;

  	startPos = parser.pos;

  	name = parser.matchPattern(/^@(?:keypath|index|key)/);

  	if (!name) {
  		prefix = parser.matchPattern(prefixPattern) || "";
  		name = !prefix && parser.relaxedNames && parser.matchPattern(relaxedName) || parser.matchPattern(legalReference);

  		if (!name && prefix === ".") {
  			prefix = "";
  			name = ".";
  		}
  	}

  	if (!name) {
  		return null;
  	}

  	// bug out if it's a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)
  	if (!prefix && !parser.relaxedNames && keywords.test(name)) {
  		parser.pos = startPos;
  		return null;
  	}

  	// if this is a browser global, stop here
  	if (!prefix && globals.test(name)) {
  		global = globals.exec(name)[0];
  		parser.pos = startPos + global.length;

  		return {
  			t: GLOBAL,
  			v: global
  		};
  	}

  	reference = (prefix || "") + normalise(name);

  	if (parser.matchString("(")) {
  		// if this is a method invocation (as opposed to a function) we need
  		// to strip the method name from the reference combo, else the context
  		// will be wrong
  		lastDotIndex = reference.lastIndexOf(".");
  		if (lastDotIndex !== -1) {
  			reference = reference.substr(0, lastDotIndex);
  			parser.pos = startPos + reference.length;
  		} else {
  			parser.pos -= 1;
  		}
  	}

  	return {
  		t: REFERENCE,
  		n: reference.replace(/^this\./, "./").replace(/^this$/, ".")
  	};
  }

  var primary_readBracketedExpression = readBracketedExpression;
  function readBracketedExpression(parser) {
  	var start, expr;

  	start = parser.pos;

  	if (!parser.matchString("(")) {
  		return null;
  	}

  	parser.allowWhitespace();

  	expr = converters_readExpression(parser);
  	if (!expr) {
  		parser.error(expectedExpression);
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString(")")) {
  		parser.error(expectedParen);
  	}

  	return {
  		t: BRACKETED,
  		x: expr
  	};
  }

  var readPrimary = function (parser) {
  	return primary_readLiteral(parser) || primary_readReference(parser) || primary_readBracketedExpression(parser);
  };

  var shared_readRefinement = readRefinement;
  function readRefinement(parser) {
  	var start, name, expr;

  	start = parser.pos;

  	parser.allowWhitespace();

  	// "." name
  	if (parser.matchString(".")) {
  		parser.allowWhitespace();

  		if (name = parser.matchPattern(patterns__name)) {
  			return {
  				t: REFINEMENT,
  				n: name
  			};
  		}

  		parser.error("Expected a property name");
  	}

  	// "[" expression "]"
  	if (parser.matchString("[")) {
  		parser.allowWhitespace();

  		expr = converters_readExpression(parser);
  		if (!expr) {
  			parser.error(expectedExpression);
  		}

  		parser.allowWhitespace();

  		if (!parser.matchString("]")) {
  			parser.error("Expected ']'");
  		}

  		return {
  			t: REFINEMENT,
  			x: expr
  		};
  	}

  	return null;
  }

  var readMemberOrInvocation = function (parser) {
  	var current, expression, refinement, expressionList;

  	expression = readPrimary(parser);

  	if (!expression) {
  		return null;
  	}

  	while (expression) {
  		current = parser.pos;

  		if (refinement = shared_readRefinement(parser)) {
  			expression = {
  				t: MEMBER,
  				x: expression,
  				r: refinement
  			};
  		} else if (parser.matchString("(")) {
  			parser.allowWhitespace();
  			expressionList = shared_readExpressionList(parser);

  			parser.allowWhitespace();

  			if (!parser.matchString(")")) {
  				parser.error(expectedParen);
  			}

  			expression = {
  				t: INVOCATION,
  				x: expression
  			};

  			if (expressionList) {
  				expression.o = expressionList;
  			}
  		} else {
  			break;
  		}
  	}

  	return expression;
  };

  var readTypeOf, makePrefixSequenceMatcher;

  makePrefixSequenceMatcher = function (symbol, fallthrough) {
  	return function (parser) {
  		var expression;

  		if (expression = fallthrough(parser)) {
  			return expression;
  		}

  		if (!parser.matchString(symbol)) {
  			return null;
  		}

  		parser.allowWhitespace();

  		expression = converters_readExpression(parser);
  		if (!expression) {
  			parser.error(expectedExpression);
  		}

  		return {
  			s: symbol,
  			o: expression,
  			t: PREFIX_OPERATOR
  		};
  	};
  };

  // create all prefix sequence matchers, return readTypeOf
  (function () {
  	var i, len, matcher, prefixOperators, fallthrough;

  	prefixOperators = "! ~ + - typeof".split(" ");

  	fallthrough = readMemberOrInvocation;
  	for (i = 0, len = prefixOperators.length; i < len; i += 1) {
  		matcher = makePrefixSequenceMatcher(prefixOperators[i], fallthrough);
  		fallthrough = matcher;
  	}

  	// typeof operator is higher precedence than multiplication, so provides the
  	// fallthrough for the multiplication sequence matcher we're about to create
  	// (we're skipping void and delete)
  	readTypeOf = fallthrough;
  })();

  var readTypeof = readTypeOf;

  var readLogicalOr, makeInfixSequenceMatcher;

  makeInfixSequenceMatcher = function (symbol, fallthrough) {
  	return function (parser) {
  		var start, left, right;

  		left = fallthrough(parser);
  		if (!left) {
  			return null;
  		}

  		// Loop to handle left-recursion in a case like `a * b * c` and produce
  		// left association, i.e. `(a * b) * c`.  The matcher can't call itself
  		// to parse `left` because that would be infinite regress.
  		while (true) {
  			start = parser.pos;

  			parser.allowWhitespace();

  			if (!parser.matchString(symbol)) {
  				parser.pos = start;
  				return left;
  			}

  			// special case - in operator must not be followed by [a-zA-Z_$0-9]
  			if (symbol === "in" && /[a-zA-Z_$0-9]/.test(parser.remaining().charAt(0))) {
  				parser.pos = start;
  				return left;
  			}

  			parser.allowWhitespace();

  			// right operand must also consist of only higher-precedence operators
  			right = fallthrough(parser);
  			if (!right) {
  				parser.pos = start;
  				return left;
  			}

  			left = {
  				t: INFIX_OPERATOR,
  				s: symbol,
  				o: [left, right]
  			};

  			// Loop back around.  If we don't see another occurrence of the symbol,
  			// we'll return left.
  		}
  	};
  };

  // create all infix sequence matchers, and return readLogicalOr
  (function () {
  	var i, len, matcher, infixOperators, fallthrough;

  	// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)
  	// Each sequence matcher will initially fall through to its higher precedence
  	// neighbour, and only attempt to match if one of the higher precedence operators
  	// (or, ultimately, a literal, reference, or bracketed expression) already matched
  	infixOperators = "* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||".split(" ");

  	// A typeof operator is higher precedence than multiplication
  	fallthrough = readTypeof;
  	for (i = 0, len = infixOperators.length; i < len; i += 1) {
  		matcher = makeInfixSequenceMatcher(infixOperators[i], fallthrough);
  		fallthrough = matcher;
  	}

  	// Logical OR is the fallthrough for the conditional matcher
  	readLogicalOr = fallthrough;
  })();

  var expressions_readLogicalOr = readLogicalOr;

  // The conditional operator is the lowest precedence operator, so we start here
  var readConditional = getConditional;
  function getConditional(parser) {
  	var start, expression, ifTrue, ifFalse;

  	expression = expressions_readLogicalOr(parser);
  	if (!expression) {
  		return null;
  	}

  	start = parser.pos;

  	parser.allowWhitespace();

  	if (!parser.matchString("?")) {
  		parser.pos = start;
  		return expression;
  	}

  	parser.allowWhitespace();

  	ifTrue = converters_readExpression(parser);
  	if (!ifTrue) {
  		parser.error(expectedExpression);
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString(":")) {
  		parser.error("Expected \":\"");
  	}

  	parser.allowWhitespace();

  	ifFalse = converters_readExpression(parser);
  	if (!ifFalse) {
  		parser.error(expectedExpression);
  	}

  	return {
  		t: CONDITIONAL,
  		o: [expression, ifTrue, ifFalse]
  	};
  }

  var converters_readExpression = readExpression;
  function readExpression(parser) {
  	// The conditional operator is the lowest precedence operator (except yield,
  	// assignment operators, and commas, none of which are supported), so we
  	// start there. If it doesn't match, it 'falls through' to progressively
  	// higher precedence operators, until it eventually matches (or fails to
  	// match) a 'primary' - a literal or a reference. This way, the abstract syntax
  	// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.
  	return readConditional(parser);
  }

  var utils_flattenExpression = flattenExpression;

  function flattenExpression(expression) {
  	var refs;

  	extractRefs(expression, refs = []);

  	return {
  		r: refs,
  		s: stringify(expression)
  	};

  	function stringify(node) {
  		switch (node.t) {
  			case BOOLEAN_LITERAL:
  			case GLOBAL:
  			case NUMBER_LITERAL:
  			case REGEXP_LITERAL:
  				return node.v;

  			case STRING_LITERAL:
  				return JSON.stringify(String(node.v));

  			case ARRAY_LITERAL:
  				return "[" + (node.m ? node.m.map(stringify).join(",") : "") + "]";

  			case OBJECT_LITERAL:
  				return "{" + (node.m ? node.m.map(stringify).join(",") : "") + "}";

  			case KEY_VALUE_PAIR:
  				return node.k + ":" + stringify(node.v);

  			case PREFIX_OPERATOR:
  				return (node.s === "typeof" ? "typeof " : node.s) + stringify(node.o);

  			case INFIX_OPERATOR:
  				return stringify(node.o[0]) + (node.s.substr(0, 2) === "in" ? " " + node.s + " " : node.s) + stringify(node.o[1]);

  			case INVOCATION:
  				return stringify(node.x) + "(" + (node.o ? node.o.map(stringify).join(",") : "") + ")";

  			case BRACKETED:
  				return "(" + stringify(node.x) + ")";

  			case MEMBER:
  				return stringify(node.x) + stringify(node.r);

  			case REFINEMENT:
  				return node.n ? "." + node.n : "[" + stringify(node.x) + "]";

  			case CONDITIONAL:
  				return stringify(node.o[0]) + "?" + stringify(node.o[1]) + ":" + stringify(node.o[2]);

  			case REFERENCE:
  				return "_" + refs.indexOf(node.n);

  			default:
  				throw new Error("Expected legal JavaScript");
  		}
  	}
  }

  // TODO maybe refactor this?
  function extractRefs(node, refs) {
  	var i, list;

  	if (node.t === REFERENCE) {
  		if (refs.indexOf(node.n) === -1) {
  			refs.unshift(node.n);
  		}
  	}

  	list = node.o || node.m;
  	if (list) {
  		if (isObject(list)) {
  			extractRefs(list, refs);
  		} else {
  			i = list.length;
  			while (i--) {
  				extractRefs(list[i], refs);
  			}
  		}
  	}

  	if (node.x) {
  		extractRefs(node.x, refs);
  	}

  	if (node.r) {
  		extractRefs(node.r, refs);
  	}

  	if (node.v) {
  		extractRefs(node.v, refs);
  	}
  }

  var utils_refineExpression = refineExpression;

  var arrayMemberPattern = /^[0-9][1-9]*$/;
  function refineExpression(expression, mustache) {
  	var referenceExpression;

  	if (expression) {
  		while (expression.t === BRACKETED && expression.x) {
  			expression = expression.x;
  		}

  		// special case - integers should be treated as array members references,
  		// rather than as expressions in their own right
  		if (expression.t === REFERENCE) {
  			mustache.r = expression.n;
  		} else {
  			if (expression.t === NUMBER_LITERAL && arrayMemberPattern.test(expression.v)) {
  				mustache.r = expression.v;
  			} else if (referenceExpression = getReferenceExpression(expression)) {
  				mustache.rx = referenceExpression;
  			} else {
  				mustache.x = utils_flattenExpression(expression);
  			}
  		}

  		return mustache;
  	}
  }

  // TODO refactor this! it's bewildering
  function getReferenceExpression(expression) {
  	var members = [],
  	    refinement;

  	while (expression.t === MEMBER && expression.r.t === REFINEMENT) {
  		refinement = expression.r;

  		if (refinement.x) {
  			if (refinement.x.t === REFERENCE) {
  				members.unshift(refinement.x);
  			} else {
  				members.unshift(utils_flattenExpression(refinement.x));
  			}
  		} else {
  			members.unshift(refinement.n);
  		}

  		expression = expression.x;
  	}

  	if (expression.t !== REFERENCE) {
  		return null;
  	}

  	return {
  		r: expression.n,
  		m: members
  	};
  }

  var mustache_readTriple = readTriple;
  function readTriple(parser, tag) {
  	var expression = converters_readExpression(parser),
  	    triple;

  	if (!expression) {
  		return null;
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	triple = { t: TRIPLE };
  	utils_refineExpression(expression, triple); // TODO handle this differently - it's mysterious

  	return triple;
  }

  var mustache_readUnescaped = readUnescaped;
  function readUnescaped(parser, tag) {
  	var expression, triple;

  	if (!parser.matchString("&")) {
  		return null;
  	}

  	parser.allowWhitespace();

  	expression = converters_readExpression(parser);

  	if (!expression) {
  		return null;
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	triple = { t: TRIPLE };
  	utils_refineExpression(expression, triple); // TODO handle this differently - it's mysterious

  	return triple;
  }

  var mustache_readPartial = readPartial;
  function readPartial(parser, tag) {
  	var start, nameStart, expression, context, partial;

  	start = parser.pos;

  	if (!parser.matchString(">")) {
  		return null;
  	}

  	parser.allowWhitespace();
  	nameStart = parser.pos;

  	// Partial names can include hyphens, so we can't use readExpression
  	// blindly. Instead, we use the `relaxedNames` flag to indicate that
  	// `foo-bar` should be read as a single name, rather than 'subtract
  	// bar from foo'
  	parser.relaxedNames = true;
  	expression = converters_readExpression(parser);
  	parser.relaxedNames = false;

  	parser.allowWhitespace();
  	context = converters_readExpression(parser);
  	parser.allowWhitespace();

  	if (!expression) {
  		return null;
  	}

  	partial = { t: PARTIAL };
  	utils_refineExpression(expression, partial); // TODO...

  	parser.allowWhitespace();

  	// if we have another expression - e.g. `{{>foo bar}}` - then
  	// we turn it into `{{#with bar}}{{>foo}}{{/with}}`
  	if (context) {
  		partial = {
  			t: SECTION,
  			n: SECTION_WITH,
  			f: [partial]
  		};

  		utils_refineExpression(context, partial);
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	return partial;
  }

  var readMustacheComment = readComment;
  function readComment(parser, tag) {
  	var index;

  	if (!parser.matchString("!")) {
  		return null;
  	}

  	index = parser.remaining().indexOf(tag.close);

  	if (index !== -1) {
  		parser.pos += index + tag.close.length;
  		return { t: COMMENT };
  	}
  }

  var converters_readExpressionOrReference = readExpressionOrReference;
  function readExpressionOrReference(parser, expectedFollowers) {
  	var start, expression, i;

  	start = parser.pos;
  	expression = converters_readExpression(parser);

  	if (!expression) {
  		return null;
  	}

  	for (i = 0; i < expectedFollowers.length; i += 1) {
  		if (parser.remaining().substr(0, expectedFollowers[i].length) === expectedFollowers[i]) {
  			return expression;
  		}
  	}

  	parser.pos = start;
  	return primary_readReference(parser);
  }

  var mustache_readInterpolator = readInterpolator;
  function readInterpolator(parser, tag) {
  	var start, expression, interpolator, err;

  	start = parser.pos;

  	// TODO would be good for perf if we could do away with the try-catch
  	try {
  		expression = converters_readExpressionOrReference(parser, [tag.close]);
  	} catch (e) {
  		err = e;
  	}

  	if (!expression) {
  		if (parser.str.charAt(start) === "!") {
  			// special case - comment
  			parser.pos = start;
  			return null;
  		}

  		if (err) {
  			throw err;
  		}
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "' after reference");

  		if (!expression) {
  			// special case - comment
  			if (parser.nextChar() === "!") {
  				return null;
  			}

  			parser.error("Expected expression or legal reference");
  		}
  	}

  	interpolator = { t: INTERPOLATOR };
  	utils_refineExpression(expression, interpolator); // TODO handle this differently - it's mysterious

  	return interpolator;
  }

  var mustache_readYielder = readYielder;
  var yieldPattern = /^yield\s*/;
  function readYielder(parser, tag) {
  	var start, name, yielder;

  	if (!parser.matchPattern(yieldPattern)) {
  		return null;
  	}

  	start = parser.pos;
  	name = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\-]*/);

  	parser.allowWhitespace();

  	if (!parser.matchString(tag.close)) {
  		parser.error("expected legal partial name");
  	}

  	yielder = { t: YIELDER };

  	if (name) {
  		yielder.n = name;
  	}

  	return yielder;
  }

  var section_readClosing = readClosing;
  function readClosing(parser, tag) {
  	var start, remaining, index, closing;

  	start = parser.pos;

  	if (!parser.matchString(tag.open)) {
  		return null;
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString("/")) {
  		parser.pos = start;
  		return null;
  	}

  	parser.allowWhitespace();

  	remaining = parser.remaining();
  	index = remaining.indexOf(tag.close);

  	if (index !== -1) {
  		closing = {
  			t: CLOSING,
  			r: remaining.substr(0, index).split(" ")[0]
  		};

  		parser.pos += index;

  		if (!parser.matchString(tag.close)) {
  			parser.error("Expected closing delimiter '" + tag.close + "'");
  		}

  		return closing;
  	}

  	parser.pos = start;
  	return null;
  }

  var section_readElse = section_readElse__readElse;
  var section_readElse__elsePattern = /^\s*else\s*/;
  function section_readElse__readElse(parser, tag) {
  	var start = parser.pos;

  	if (!parser.matchString(tag.open)) {
  		return null;
  	}

  	if (!parser.matchPattern(section_readElse__elsePattern)) {
  		parser.pos = start;
  		return null;
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	return {
  		t: ELSE
  	};
  }

  var readElseIf = readElseIf__readElse;
  var readElseIf__elsePattern = /^\s*elseif\s+/;
  function readElseIf__readElse(parser, tag) {
  	var start = parser.pos,
  	    expression;

  	if (!parser.matchString(tag.open)) {
  		return null;
  	}

  	if (!parser.matchPattern(readElseIf__elsePattern)) {
  		parser.pos = start;
  		return null;
  	}

  	expression = converters_readExpression(parser);

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	return {
  		t: ELSEIF,
  		x: expression
  	};
  }

  var handlebarsBlockCodes = {
  	each: SECTION_EACH,
  	"if": SECTION_IF,
  	"if-with": SECTION_IF_WITH,
  	"with": SECTION_WITH,
  	unless: SECTION_UNLESS
  };

  var mustache_readSection = readSection;

  var indexRefPattern = /^\s*:\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,
      keyIndexRefPattern = /^\s*,\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,
      handlebarsBlockPattern = new RegExp("^(" + Object.keys(handlebarsBlockCodes).join("|") + ")\\b");
  function readSection(parser, tag) {
  	var start, expression, section, child, children, hasElse, block, unlessBlock, conditions, closed, i, expectedClose;

  	start = parser.pos;

  	if (parser.matchString("^")) {
  		section = { t: SECTION, f: [], n: SECTION_UNLESS };
  	} else if (parser.matchString("#")) {
  		section = { t: SECTION, f: [] };

  		if (parser.matchString("partial")) {
  			parser.pos = start - parser.standardDelimiters[0].length;
  			parser.error("Partial definitions can only be at the top level of the template, or immediately inside components");
  		}

  		if (block = parser.matchPattern(handlebarsBlockPattern)) {
  			expectedClose = block;
  			section.n = handlebarsBlockCodes[block];
  		}
  	} else {
  		return null;
  	}

  	parser.allowWhitespace();

  	expression = converters_readExpression(parser);

  	if (!expression) {
  		parser.error("Expected expression");
  	}

  	// optional index and key references
  	if (i = parser.matchPattern(indexRefPattern)) {
  		var extra = undefined;

  		if (extra = parser.matchPattern(keyIndexRefPattern)) {
  			section.i = i + "," + extra;
  		} else {
  			section.i = i;
  		}
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	parser.sectionDepth += 1;
  	children = section.f;

  	conditions = [];

  	do {
  		if (child = section_readClosing(parser, tag)) {
  			if (expectedClose && child.r !== expectedClose) {
  				parser.error("Expected " + tag.open + "/" + expectedClose + "" + tag.close);
  			}

  			parser.sectionDepth -= 1;
  			closed = true;
  		} else if (child = readElseIf(parser, tag)) {
  			if (section.n === SECTION_UNLESS) {
  				parser.error("{{else}} not allowed in {{#unless}}");
  			}

  			if (hasElse) {
  				parser.error("illegal {{elseif...}} after {{else}}");
  			}

  			if (!unlessBlock) {
  				unlessBlock = createUnlessBlock(expression, section.n);
  			}

  			unlessBlock.f.push({
  				t: SECTION,
  				n: SECTION_IF,
  				x: utils_flattenExpression(mustache_readSection__combine(conditions.concat(child.x))),
  				f: children = []
  			});

  			conditions.push(invert(child.x));
  		} else if (child = section_readElse(parser, tag)) {
  			if (section.n === SECTION_UNLESS) {
  				parser.error("{{else}} not allowed in {{#unless}}");
  			}

  			if (hasElse) {
  				parser.error("there can only be one {{else}} block, at the end of a section");
  			}

  			hasElse = true;

  			// use an unless block if there's no elseif
  			if (!unlessBlock) {
  				unlessBlock = createUnlessBlock(expression, section.n);
  				children = unlessBlock.f;
  			} else {
  				unlessBlock.f.push({
  					t: SECTION,
  					n: SECTION_IF,
  					x: utils_flattenExpression(mustache_readSection__combine(conditions)),
  					f: children = []
  				});
  			}
  		} else {
  			child = parser.read(READERS);

  			if (!child) {
  				break;
  			}

  			children.push(child);
  		}
  	} while (!closed);

  	if (unlessBlock) {
  		// special case - `with` should become `if-with` (TODO is this right?
  		// seems to me that `with` ought to behave consistently, regardless
  		// of the presence/absence of `else`. In other words should always
  		// be `if-with`
  		if (section.n === SECTION_WITH) {
  			section.n = SECTION_IF_WITH;
  		}

  		section.l = unlessBlock;
  	}

  	utils_refineExpression(expression, section);

  	// TODO if a section is empty it should be discarded. Don't do
  	// that here though - we need to clean everything up first, as
  	// it may contain removeable whitespace. As a temporary measure,
  	// to pass the existing tests, remove empty `f` arrays
  	if (!section.f.length) {
  		delete section.f;
  	}

  	return section;
  }

  function createUnlessBlock(expression, sectionType) {
  	var unlessBlock;

  	if (sectionType === SECTION_WITH) {
  		// special case - a `{{#with foo}}` section will render if `foo` is
  		// truthy, so the `{{else}}` section needs to render if `foo` is falsy,
  		// rather than adhering to the normal `{{#unless foo}}` logic (which
  		// treats empty arrays/objects as falsy)
  		unlessBlock = {
  			t: SECTION,
  			n: SECTION_IF,
  			f: []
  		};

  		utils_refineExpression(invert(expression), unlessBlock);
  	} else {
  		unlessBlock = {
  			t: SECTION,
  			n: SECTION_UNLESS,
  			f: []
  		};

  		utils_refineExpression(expression, unlessBlock);
  	}

  	return unlessBlock;
  }

  function invert(expression) {
  	if (expression.t === PREFIX_OPERATOR && expression.s === "!") {
  		return expression.o;
  	}

  	return {
  		t: PREFIX_OPERATOR,
  		s: "!",
  		o: parensIfNecessary(expression)
  	};
  }

  function mustache_readSection__combine(expressions) {
  	if (expressions.length === 1) {
  		return expressions[0];
  	}

  	return {
  		t: INFIX_OPERATOR,
  		s: "&&",
  		o: [parensIfNecessary(expressions[0]), parensIfNecessary(mustache_readSection__combine(expressions.slice(1)))]
  	};
  }

  function parensIfNecessary(expression) {
  	// TODO only wrap if necessary
  	return {
  		t: BRACKETED,
  		x: expression
  	};
  }

  var converters_readHtmlComment = readHtmlComment;
  var OPEN_COMMENT = "<!--",
      CLOSE_COMMENT = "-->";
  function readHtmlComment(parser) {
  	var start, content, remaining, endIndex, comment;

  	start = parser.pos;

  	if (!parser.matchString(OPEN_COMMENT)) {
  		return null;
  	}

  	remaining = parser.remaining();
  	endIndex = remaining.indexOf(CLOSE_COMMENT);

  	if (endIndex === -1) {
  		parser.error("Illegal HTML - expected closing comment sequence ('-->')");
  	}

  	content = remaining.substr(0, endIndex);
  	parser.pos += endIndex + 3;

  	comment = {
  		t: COMMENT,
  		c: content
  	};

  	if (parser.includeLinePositions) {
  		comment.p = parser.getLinePos(start);
  	}

  	return comment;
  }

  var booleanAttributes, voidElementNames, htmlEntities, controlCharacters, entityPattern, lessThan, greaterThan, amp;

  // https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316
  booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;
  voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;

  htmlEntities = { quot: 34, amp: 38, apos: 39, lt: 60, gt: 62, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, int: 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830 };
  controlCharacters = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376];
  entityPattern = new RegExp("&(#?(?:x[\\w\\d]+|\\d+|" + Object.keys(htmlEntities).join("|") + "));?", "g");

  function decodeCharacterReferences(html) {
  	return html.replace(entityPattern, function (match, entity) {
  		var code;

  		// Handle named entities
  		if (entity[0] !== "#") {
  			code = htmlEntities[entity];
  		} else if (entity[1] === "x") {
  			code = parseInt(entity.substring(2), 16);
  		} else {
  			code = parseInt(entity.substring(1), 10);
  		}

  		if (!code) {
  			return match;
  		}

  		return String.fromCharCode(validateCode(code));
  	});
  }

  // some code points are verboten. If we were inserting HTML, the browser would replace the illegal
  // code points with alternatives in some cases - since we're bypassing that mechanism, we need
  // to replace them ourselves
  //
  // Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters
  function validateCode(code) {
  	if (!code) {
  		return 65533;
  	}

  	// line feed becomes generic whitespace
  	if (code === 10) {
  		return 32;
  	}

  	// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
  	if (code < 128) {
  		return code;
  	}

  	// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
  	// to correct the mistake or we'll end up with missing € signs and so on
  	if (code <= 159) {
  		return controlCharacters[code - 128];
  	}

  	// basic multilingual plane
  	if (code < 55296) {
  		return code;
  	}

  	// UTF-16 surrogate halves
  	if (code <= 57343) {
  		return 65533;
  	}

  	// rest of the basic multilingual plane
  	if (code <= 65535) {
  		return code;
  	}

  	return 65533;
  }

  lessThan = /</g;
  greaterThan = />/g;
  amp = /&/g;

  function escapeHtml(str) {
  	return str.replace(amp, "&amp;").replace(lessThan, "&lt;").replace(greaterThan, "&gt;");
  }

  var leadingLinebreak = /^\s*\r?\n/,
      trailingLinebreak = /\r?\n\s*$/;

  var stripStandalones = function (items) {
  	var i, current, backOne, backTwo, lastSectionItem;

  	for (i = 1; i < items.length; i += 1) {
  		current = items[i];
  		backOne = items[i - 1];
  		backTwo = items[i - 2];

  		// if we're at the end of a [text][comment][text] sequence...
  		if (isString(current) && isComment(backOne) && isString(backTwo)) {

  			// ... and the comment is a standalone (i.e. line breaks either side)...
  			if (trailingLinebreak.test(backTwo) && leadingLinebreak.test(current)) {

  				// ... then we want to remove the whitespace after the first line break
  				items[i - 2] = backTwo.replace(trailingLinebreak, "\n");

  				// and the leading line break of the second text token
  				items[i] = current.replace(leadingLinebreak, "");
  			}
  		}

  		// if the current item is a section, and it is preceded by a linebreak, and
  		// its first item is a linebreak...
  		if (isSection(current) && isString(backOne)) {
  			if (trailingLinebreak.test(backOne) && isString(current.f[0]) && leadingLinebreak.test(current.f[0])) {
  				items[i - 1] = backOne.replace(trailingLinebreak, "\n");
  				current.f[0] = current.f[0].replace(leadingLinebreak, "");
  			}
  		}

  		// if the last item was a section, and it is followed by a linebreak, and
  		// its last item is a linebreak...
  		if (isString(current) && isSection(backOne)) {
  			lastSectionItem = lastItem(backOne.f);

  			if (isString(lastSectionItem) && trailingLinebreak.test(lastSectionItem) && leadingLinebreak.test(current)) {
  				backOne.f[backOne.f.length - 1] = lastSectionItem.replace(trailingLinebreak, "\n");
  				items[i] = current.replace(leadingLinebreak, "");
  			}
  		}
  	}

  	return items;
  };

  function isString(item) {
  	return typeof item === "string";
  }

  function isComment(item) {
  	return item.t === COMMENT || item.t === DELIMCHANGE;
  }

  function isSection(item) {
  	return (item.t === SECTION || item.t === INVERTED) && item.f;
  }

  var trimWhitespace = function (items, leadingPattern, trailingPattern) {
  	var item;

  	if (leadingPattern) {
  		item = items[0];
  		if (typeof item === "string") {
  			item = item.replace(leadingPattern, "");

  			if (!item) {
  				items.shift();
  			} else {
  				items[0] = item;
  			}
  		}
  	}

  	if (trailingPattern) {
  		item = lastItem(items);
  		if (typeof item === "string") {
  			item = item.replace(trailingPattern, "");

  			if (!item) {
  				items.pop();
  			} else {
  				items[items.length - 1] = item;
  			}
  		}
  	}
  };

  var utils_cleanup = cleanup;
  var contiguousWhitespace = /[ \t\f\r\n]+/g;
  var preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i;
  var utils_cleanup__leadingWhitespace = /^[ \t\f\r\n]+/;
  var trailingWhitespace = /[ \t\f\r\n]+$/;
  var leadingNewLine = /^(?:\r\n|\r|\n)/;
  var trailingNewLine = /(?:\r\n|\r|\n)$/;
  function cleanup(items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace) {
  	var i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, key;

  	// First pass - remove standalones and comments etc
  	stripStandalones(items);

  	i = items.length;
  	while (i--) {
  		item = items[i];

  		// Remove delimiter changes, unsafe elements etc
  		if (item.exclude) {
  			items.splice(i, 1);
  		}

  		// Remove comments, unless we want to keep them
  		else if (stripComments && item.t === COMMENT) {
  			items.splice(i, 1);
  		}
  	}

  	// If necessary, remove leading and trailing whitespace
  	trimWhitespace(items, removeLeadingWhitespace ? utils_cleanup__leadingWhitespace : null, removeTrailingWhitespace ? trailingWhitespace : null);

  	i = items.length;
  	while (i--) {
  		item = items[i];

  		// Recurse
  		if (item.f) {
  			var isPreserveWhitespaceElement = item.t === ELEMENT && preserveWhitespaceElements.test(item.e);
  			preserveWhitespaceInsideFragment = preserveWhitespace || isPreserveWhitespaceElement;

  			if (!preserveWhitespace && isPreserveWhitespaceElement) {
  				trimWhitespace(item.f, leadingNewLine, trailingNewLine);
  			}

  			if (!preserveWhitespaceInsideFragment) {
  				previousItem = items[i - 1];
  				nextItem = items[i + 1];

  				// if the previous item was a text item with trailing whitespace,
  				// remove leading whitespace inside the fragment
  				if (!previousItem || typeof previousItem === "string" && trailingWhitespace.test(previousItem)) {
  					removeLeadingWhitespaceInsideFragment = true;
  				}

  				// and vice versa
  				if (!nextItem || typeof nextItem === "string" && utils_cleanup__leadingWhitespace.test(nextItem)) {
  					removeTrailingWhitespaceInsideFragment = true;
  				}
  			}

  			cleanup(item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  		}

  		// Split if-else blocks into two (an if, and an unless)
  		if (item.l) {
  			cleanup(item.l.f, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);

  			items.splice(i + 1, 0, item.l);
  			delete item.l; // TODO would be nice if there was a way around this
  		}

  		// Clean up element attributes
  		if (item.a) {
  			for (key in item.a) {
  				if (item.a.hasOwnProperty(key) && typeof item.a[key] !== "string") {
  					cleanup(item.a[key], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  				}
  			}
  		}

  		// Clean up conditional attributes
  		if (item.m) {
  			cleanup(item.m, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  		}

  		// Clean up event handlers
  		if (item.v) {
  			for (key in item.v) {
  				if (item.v.hasOwnProperty(key)) {
  					// clean up names
  					if (isArray(item.v[key].n)) {
  						cleanup(item.v[key].n, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  					}

  					// clean up params
  					if (isArray(item.v[key].d)) {
  						cleanup(item.v[key].d, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  					}
  				}
  			}
  		}
  	}

  	// final pass - fuse text nodes together
  	i = items.length;
  	while (i--) {
  		if (typeof items[i] === "string") {
  			if (typeof items[i + 1] === "string") {
  				items[i] = items[i] + items[i + 1];
  				items.splice(i + 1, 1);
  			}

  			if (!preserveWhitespace) {
  				items[i] = items[i].replace(contiguousWhitespace, " ");
  			}

  			if (items[i] === "") {
  				items.splice(i, 1);
  			}
  		}
  	}
  }

  var element_readClosingTag = readClosingTag;
  var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\-]*)\s*\>/;
  function readClosingTag(parser) {
  	var start, tag;

  	start = parser.pos;

  	// are we looking at a closing tag?
  	if (!parser.matchString("</")) {
  		return null;
  	}

  	if (tag = parser.matchPattern(closingTagPattern)) {
  		if (parser.inside && tag !== parser.inside) {
  			parser.pos = start;
  			return null;
  		}

  		return {
  			t: CLOSING_TAG,
  			e: tag
  		};
  	}

  	// We have an illegal closing tag, report it
  	parser.pos -= 2;
  	parser.error("Illegal closing tag");
  }

  var getLowestIndex = function (haystack, needles) {
  	var i, index, lowest;

  	i = needles.length;
  	while (i--) {
  		index = haystack.indexOf(needles[i]);

  		// short circuit
  		if (!index) {
  			return 0;
  		}

  		if (index === -1) {
  			continue;
  		}

  		if (!lowest || index < lowest) {
  			lowest = index;
  		}
  	}

  	return lowest || -1;
  };

  var element_readAttribute = readAttribute;

  var attributeNamePattern = /^[^\s"'>\/=]+/,
      unquotedAttributeValueTextPattern = /^[^\s"'=<>`]+/;
  function readAttribute(parser) {
  	var attr, name, value;

  	parser.allowWhitespace();

  	name = parser.matchPattern(attributeNamePattern);
  	if (!name) {
  		return null;
  	}

  	attr = { name: name };

  	value = readAttributeValue(parser);
  	if (value != null) {
  		// not null/undefined
  		attr.value = value;
  	}

  	return attr;
  }

  function readAttributeValue(parser) {
  	var start, valueStart, startDepth, value;

  	start = parser.pos;

  	// next character must be `=`, `/`, `>` or whitespace
  	if (!/[=\/>\s]/.test(parser.nextChar())) {
  		parser.error("Expected `=`, `/`, `>` or whitespace");
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString("=")) {
  		parser.pos = start;
  		return null;
  	}

  	parser.allowWhitespace();

  	valueStart = parser.pos;
  	startDepth = parser.sectionDepth;

  	value = readQuotedAttributeValue(parser, "'") || readQuotedAttributeValue(parser, "\"") || readUnquotedAttributeValue(parser);

  	if (value === null) {
  		parser.error("Expected valid attribute value");
  	}

  	if (parser.sectionDepth !== startDepth) {
  		parser.pos = valueStart;
  		parser.error("An attribute value must contain as many opening section tags as closing section tags");
  	}

  	if (!value.length) {
  		return "";
  	}

  	if (value.length === 1 && typeof value[0] === "string") {
  		return decodeCharacterReferences(value[0]);
  	}

  	return value;
  }

  function readUnquotedAttributeValueToken(parser) {
  	var start, text, haystack, needles, index;

  	start = parser.pos;

  	text = parser.matchPattern(unquotedAttributeValueTextPattern);

  	if (!text) {
  		return null;
  	}

  	haystack = text;
  	needles = parser.tags.map(function (t) {
  		return t.open;
  	}); // TODO refactor... we do this in readText.js as well

  	if ((index = getLowestIndex(haystack, needles)) !== -1) {
  		text = text.substr(0, index);
  		parser.pos = start + text.length;
  	}

  	return text;
  }

  function readUnquotedAttributeValue(parser) {
  	var tokens, token;

  	parser.inAttribute = true;

  	tokens = [];

  	token = converters_readMustache(parser) || readUnquotedAttributeValueToken(parser);
  	while (token !== null) {
  		tokens.push(token);
  		token = converters_readMustache(parser) || readUnquotedAttributeValueToken(parser);
  	}

  	if (!tokens.length) {
  		return null;
  	}

  	parser.inAttribute = false;
  	return tokens;
  }

  function readQuotedAttributeValue(parser, quoteMark) {
  	var start, tokens, token;

  	start = parser.pos;

  	if (!parser.matchString(quoteMark)) {
  		return null;
  	}

  	parser.inAttribute = quoteMark;

  	tokens = [];

  	token = converters_readMustache(parser) || readQuotedStringToken(parser, quoteMark);
  	while (token !== null) {
  		tokens.push(token);
  		token = converters_readMustache(parser) || readQuotedStringToken(parser, quoteMark);
  	}

  	if (!parser.matchString(quoteMark)) {
  		parser.pos = start;
  		return null;
  	}

  	parser.inAttribute = false;

  	return tokens;
  }

  function readQuotedStringToken(parser, quoteMark) {
  	var start, index, haystack, needles;

  	start = parser.pos;
  	haystack = parser.remaining();

  	needles = parser.tags.map(function (t) {
  		return t.open;
  	}); // TODO refactor... we do this in readText.js as well
  	needles.push(quoteMark);

  	index = getLowestIndex(haystack, needles);

  	if (index === -1) {
  		parser.error("Quoted attribute value must have a closing quote");
  	}

  	if (!index) {
  		return null;
  	}

  	parser.pos += index;
  	return haystack.substr(0, index);
  }

  var JsonParser, specials, specialsPattern, parseJSON__numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;

  specials = {
  	"true": true,
  	"false": false,
  	undefined: undefined,
  	"null": null
  };

  specialsPattern = new RegExp("^(?:" + Object.keys(specials).join("|") + ")");
  parseJSON__numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
  placeholderPattern = /\$\{([^\}]+)\}/g;
  placeholderAtStartPattern = /^\$\{([^\}]+)\}/;
  onlyWhitespace = /^\s*$/;

  JsonParser = parse_Parser.extend({
  	init: function (str, options) {
  		this.values = options.values;
  		this.allowWhitespace();
  	},

  	postProcess: function (result) {
  		if (result.length !== 1 || !onlyWhitespace.test(this.leftover)) {
  			return null;
  		}

  		return { value: result[0].v };
  	},

  	converters: [function getPlaceholder(parser) {
  		var placeholder;

  		if (!parser.values) {
  			return null;
  		}

  		placeholder = parser.matchPattern(placeholderAtStartPattern);

  		if (placeholder && parser.values.hasOwnProperty(placeholder)) {
  			return { v: parser.values[placeholder] };
  		}
  	}, function getSpecial(parser) {
  		var special;

  		if (special = parser.matchPattern(specialsPattern)) {
  			return { v: specials[special] };
  		}
  	}, function getNumber(parser) {
  		var number;

  		if (number = parser.matchPattern(parseJSON__numberPattern)) {
  			return { v: +number };
  		}
  	}, function getString(parser) {
  		var stringLiteral = readStringLiteral(parser),
  		    values;

  		if (stringLiteral && (values = parser.values)) {
  			return {
  				v: stringLiteral.v.replace(placeholderPattern, function (match, $1) {
  					return $1 in values ? values[$1] : $1;
  				})
  			};
  		}

  		return stringLiteral;
  	}, function getObject(parser) {
  		var result, pair;

  		if (!parser.matchString("{")) {
  			return null;
  		}

  		result = {};

  		parser.allowWhitespace();

  		if (parser.matchString("}")) {
  			return { v: result };
  		}

  		while (pair = getKeyValuePair(parser)) {
  			result[pair.key] = pair.value;

  			parser.allowWhitespace();

  			if (parser.matchString("}")) {
  				return { v: result };
  			}

  			if (!parser.matchString(",")) {
  				return null;
  			}
  		}

  		return null;
  	}, function getArray(parser) {
  		var result, valueToken;

  		if (!parser.matchString("[")) {
  			return null;
  		}

  		result = [];

  		parser.allowWhitespace();

  		if (parser.matchString("]")) {
  			return { v: result };
  		}

  		while (valueToken = parser.read()) {
  			result.push(valueToken.v);

  			parser.allowWhitespace();

  			if (parser.matchString("]")) {
  				return { v: result };
  			}

  			if (!parser.matchString(",")) {
  				return null;
  			}

  			parser.allowWhitespace();
  		}

  		return null;
  	}]
  });

  function getKeyValuePair(parser) {
  	var key, valueToken, pair;

  	parser.allowWhitespace();

  	key = shared_readKey(parser);

  	if (!key) {
  		return null;
  	}

  	pair = { key: key };

  	parser.allowWhitespace();
  	if (!parser.matchString(":")) {
  		return null;
  	}
  	parser.allowWhitespace();

  	valueToken = parser.read();
  	if (!valueToken) {
  		return null;
  	}

  	pair.value = valueToken.v;

  	return pair;
  }

  var parseJSON = function (str, values) {
  	var parser = new JsonParser(str, {
  		values: values
  	});

  	return parser.result;
  };

  // TODO clean this up, it's shocking
  var element_processDirective = processDirective;
  var methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\(/,
      methodCallExcessPattern = /\)\s*$/,
      ExpressionParser;

  ExpressionParser = parse_Parser.extend({
  	converters: [converters_readExpression]
  });
  function processDirective(tokens, parentParser) {
  	var result, match, parser, args, token, colonIndex, directiveName, directiveArgs, parsed;

  	if (typeof tokens === "string") {
  		if (match = methodCallPattern.exec(tokens)) {
  			var end = tokens.lastIndexOf(")");

  			// check for invalid method calls
  			if (!methodCallExcessPattern.test(tokens)) {
  				parentParser.error("Invalid input after method call expression '" + tokens.slice(end + 1) + "'");
  			}

  			result = { m: match[1] };
  			args = "[" + tokens.slice(result.m.length + 1, end) + "]";

  			parser = new ExpressionParser(args);
  			result.a = utils_flattenExpression(parser.result[0]);

  			return result;
  		}

  		if (tokens.indexOf(":") === -1) {
  			return tokens.trim();
  		}

  		tokens = [tokens];
  	}

  	result = {};

  	directiveName = [];
  	directiveArgs = [];

  	if (tokens) {
  		while (tokens.length) {
  			token = tokens.shift();

  			if (typeof token === "string") {
  				colonIndex = token.indexOf(":");

  				if (colonIndex === -1) {
  					directiveName.push(token);
  				} else {

  					// is the colon the first character?
  					if (colonIndex) {
  						// no
  						directiveName.push(token.substr(0, colonIndex));
  					}

  					// if there is anything after the colon in this token, treat
  					// it as the first token of the directiveArgs fragment
  					if (token.length > colonIndex + 1) {
  						directiveArgs[0] = token.substring(colonIndex + 1);
  					}

  					break;
  				}
  			} else {
  				directiveName.push(token);
  			}
  		}

  		directiveArgs = directiveArgs.concat(tokens);
  	}

  	if (!directiveName.length) {
  		result = "";
  	} else if (directiveArgs.length || typeof directiveName !== "string") {
  		result = {
  			// TODO is this really necessary? just use the array
  			n: directiveName.length === 1 && typeof directiveName[0] === "string" ? directiveName[0] : directiveName
  		};

  		if (directiveArgs.length === 1 && typeof directiveArgs[0] === "string") {
  			parsed = parseJSON("[" + directiveArgs[0] + "]");
  			result.a = parsed ? parsed.value : directiveArgs[0].trim();
  		} else {
  			result.d = directiveArgs;
  		}
  	} else {
  		result = directiveName;
  	}

  	return result;
  }

  var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/,
      validTagNameFollower = /^[\s\n\/>]/,
      onPattern = /^on/,
      proxyEventPattern = /^on-([a-zA-Z\\*\\.$_][a-zA-Z\\*\\.$_0-9\-]+)$/,
      reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/,
      directives = { "intro-outro": "t0", intro: "t1", outro: "t2", decorator: "o" },
      exclude = { exclude: true },
      disallowedContents;

  // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
  disallowedContents = {
  	li: ["li"],
  	dt: ["dt", "dd"],
  	dd: ["dt", "dd"],
  	p: "address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul".split(" "),
  	rt: ["rt", "rp"],
  	rp: ["rt", "rp"],
  	optgroup: ["optgroup"],
  	option: ["option", "optgroup"],
  	thead: ["tbody", "tfoot"],
  	tbody: ["tbody", "tfoot"],
  	tfoot: ["tbody"],
  	tr: ["tr", "tbody"],
  	td: ["td", "th", "tr"],
  	th: ["td", "th", "tr"]
  };

  var converters_readElement = readElement;

  function readElement(parser) {
  	var start, element, directiveName, match, addProxyEvent, attribute, directive, selfClosing, children, partials, hasPartials, child, closed, pos, remaining, closingTag;

  	start = parser.pos;

  	if (parser.inside || parser.inAttribute) {
  		return null;
  	}

  	if (!parser.matchString("<")) {
  		return null;
  	}

  	// if this is a closing tag, abort straight away
  	if (parser.nextChar() === "/") {
  		return null;
  	}

  	element = {};
  	if (parser.includeLinePositions) {
  		element.p = parser.getLinePos(start);
  	}

  	if (parser.matchString("!")) {
  		element.t = DOCTYPE;
  		if (!parser.matchPattern(/^doctype/i)) {
  			parser.error("Expected DOCTYPE declaration");
  		}

  		element.a = parser.matchPattern(/^(.+?)>/);
  		return element;
  	}

  	element.t = ELEMENT;

  	// element name
  	element.e = parser.matchPattern(tagNamePattern);
  	if (!element.e) {
  		return null;
  	}

  	// next character must be whitespace, closing solidus or '>'
  	if (!validTagNameFollower.test(parser.nextChar())) {
  		parser.error("Illegal tag name");
  	}

  	addProxyEvent = function (name, directive) {
  		var directiveName = directive.n || directive;

  		if (reservedEventNames.test(directiveName)) {
  			parser.pos -= directiveName.length;
  			parser.error("Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)");
  		}

  		element.v[name] = directive;
  	};

  	parser.allowWhitespace();

  	// directives and attributes
  	while (attribute = converters_readMustache(parser) || element_readAttribute(parser)) {
  		// regular attributes
  		if (attribute.name) {
  			// intro, outro, decorator
  			if (directiveName = directives[attribute.name]) {
  				element[directiveName] = element_processDirective(attribute.value, parser);
  			}

  			// on-click etc
  			else if (match = proxyEventPattern.exec(attribute.name)) {
  				if (!element.v) element.v = {};
  				directive = element_processDirective(attribute.value, parser);
  				addProxyEvent(match[1], directive);
  			} else {
  				if (!parser.sanitizeEventAttributes || !onPattern.test(attribute.name)) {
  					if (!element.a) element.a = {};
  					element.a[attribute.name] = attribute.value || (attribute.value === "" ? "" : 0);
  				}
  			}
  		}

  		// {{#if foo}}class='foo'{{/if}}
  		else {
  			if (!element.m) element.m = [];
  			element.m.push(attribute);
  		}

  		parser.allowWhitespace();
  	}

  	// allow whitespace before closing solidus
  	parser.allowWhitespace();

  	// self-closing solidus?
  	if (parser.matchString("/")) {
  		selfClosing = true;
  	}

  	// closing angle bracket
  	if (!parser.matchString(">")) {
  		return null;
  	}

  	var lowerCaseName = element.e.toLowerCase();
  	var preserveWhitespace = parser.preserveWhitespace;

  	if (!selfClosing && !voidElementNames.test(element.e)) {
  		parser.elementStack.push(lowerCaseName);

  		// Special case - if we open a script element, further tags should
  		// be ignored unless they're a closing script element
  		if (lowerCaseName === "script" || lowerCaseName === "style") {
  			parser.inside = lowerCaseName;
  		}

  		children = [];
  		partials = create(null);

  		do {
  			pos = parser.pos;
  			remaining = parser.remaining();

  			// if for example we're in an <li> element, and we see another
  			// <li> tag, close the first so they become siblings
  			if (!canContain(lowerCaseName, remaining)) {
  				closed = true;
  			}

  			// closing tag
  			else if (closingTag = element_readClosingTag(parser)) {
  				closed = true;

  				var closingTagName = closingTag.e.toLowerCase();

  				// if this *isn't* the closing tag for the current element...
  				if (closingTagName !== lowerCaseName) {
  					// rewind parser
  					parser.pos = pos;

  					// if it doesn't close a parent tag, error
  					if (! ~parser.elementStack.indexOf(closingTagName)) {
  						var errorMessage = "Unexpected closing tag";

  						// add additional help for void elements, since component names
  						// might clash with them
  						if (voidElementNames.test(closingTagName)) {
  							errorMessage += " (<" + closingTagName + "> is a void element - it cannot contain children)";
  						}

  						parser.error(errorMessage);
  					}
  				}
  			}

  			// implicit close by closing section tag. TODO clean this up
  			else if (child = section_readClosing(parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] })) {
  				closed = true;
  				parser.pos = pos;
  			} else {
  				if (child = parser.read(PARTIAL_READERS)) {
  					if (partials[child.n]) {
  						parser.pos = pos;
  						parser.error("Duplicate partial definition");
  					}

  					utils_cleanup(child.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);

  					partials[child.n] = child.f;
  					hasPartials = true;
  				} else {
  					if (child = parser.read(READERS)) {
  						children.push(child);
  					} else {
  						closed = true;
  					}
  				}
  			}
  		} while (!closed);

  		if (children.length) {
  			element.f = children;
  		}

  		if (hasPartials) {
  			element.p = partials;
  		}

  		parser.elementStack.pop();
  	}

  	parser.inside = null;

  	if (parser.sanitizeElements && parser.sanitizeElements.indexOf(lowerCaseName) !== -1) {
  		return exclude;
  	}

  	return element;
  }

  function canContain(name, remaining) {
  	var match, disallowed;

  	match = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec(remaining);
  	disallowed = disallowedContents[name];

  	if (!match || !disallowed) {
  		return true;
  	}

  	return ! ~disallowed.indexOf(match[1].toLowerCase());
  }

  var converters_readText = readText;
  function readText(parser) {
  	var index, remaining, disallowed, barrier;

  	remaining = parser.remaining();

  	barrier = parser.inside ? "</" + parser.inside : "<";

  	if (parser.inside && !parser.interpolate[parser.inside]) {
  		index = remaining.indexOf(barrier);
  	} else {
  		disallowed = parser.tags.map(function (t) {
  			return t.open;
  		});
  		disallowed = disallowed.concat(parser.tags.map(function (t) {
  			return "\\" + t.open;
  		}));

  		// http://developers.whatwg.org/syntax.html#syntax-attributes
  		if (parser.inAttribute === true) {
  			// we're inside an unquoted attribute value
  			disallowed.push("\"", "'", "=", "<", ">", "`");
  		} else if (parser.inAttribute) {
  			// quoted attribute value
  			disallowed.push(parser.inAttribute);
  		} else {
  			disallowed.push(barrier);
  		}

  		index = getLowestIndex(remaining, disallowed);
  	}

  	if (!index) {
  		return null;
  	}

  	if (index === -1) {
  		index = remaining.length;
  	}

  	parser.pos += index;

  	return parser.inside ? remaining.substr(0, index) : decodeCharacterReferences(remaining.substr(0, index));
  }

  var utils_escapeRegExp = escapeRegExp;
  var utils_escapeRegExp__pattern = /[-/\\^$*+?.()|[\]{}]/g;
  function escapeRegExp(str) {
  	return str.replace(utils_escapeRegExp__pattern, "\\$&");
  }

  var converters_readPartialDefinitionComment = readPartialDefinitionComment;

  var startPattern = /^<!--\s*/,
      namePattern = /s*>\s*([a-zA-Z_$][-a-zA-Z_$0-9]*)\s*/,
      finishPattern = /\s*-->/,
      child;

  function readPartialDefinitionComment(parser) {
  	var firstPos = parser.pos,
  	    open = parser.standardDelimiters[0],
  	    close = parser.standardDelimiters[1],
  	    content = undefined,
  	    closed = undefined;

  	if (!parser.matchPattern(startPattern) || !parser.matchString(open)) {
  		parser.pos = firstPos;
  		return null;
  	}

  	var name = parser.matchPattern(namePattern);

  	warnOnceIfDebug("Inline partial comments are deprecated.\nUse this...\n  {{#partial " + name + "}} ... {{/partial}}\n\n...instead of this:\n  <!-- {{>" + name + "}} --> ... <!-- {{/" + name + "}} -->'");

  	// make sure the rest of the comment is in the correct place
  	if (!parser.matchString(close) || !parser.matchPattern(finishPattern)) {
  		parser.pos = firstPos;
  		return null;
  	}

  	content = [];

  	var endPattern = new RegExp("^<!--\\s*" + utils_escapeRegExp(open) + "\\s*\\/\\s*" + name + "\\s*" + utils_escapeRegExp(close) + "\\s*-->");

  	do {
  		if (parser.matchPattern(endPattern)) {
  			closed = true;
  		} else {
  			child = parser.read(READERS);
  			if (!child) {
  				parser.error("expected closing comment ('<!-- " + open + "/" + name + "" + close + " -->')");
  			}

  			content.push(child);
  		}
  	} while (!closed);

  	return {
  		t: INLINE_PARTIAL,
  		f: content,
  		n: name
  	};
  }

  var converters_readPartialDefinitionSection = readPartialDefinitionSection;
  var partialDefinitionSectionPattern = /^#\s*partial\s+/;
  function readPartialDefinitionSection(parser) {
  	var start, name, content, child, closed;

  	start = parser.pos;

  	var delimiters = parser.standardDelimiters;

  	if (!parser.matchString(delimiters[0])) {
  		return null;
  	}

  	if (!parser.matchPattern(partialDefinitionSectionPattern)) {
  		parser.pos = start;
  		return null;
  	}

  	name = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\-]*/);

  	if (!name) {
  		parser.error("expected legal partial name");
  	}

  	if (!parser.matchString(delimiters[1])) {
  		parser.error("Expected closing delimiter '" + delimiters[1] + "'");
  	}

  	content = [];

  	do {
  		// TODO clean this up
  		if (child = section_readClosing(parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] })) {
  			if (!child.r === "partial") {
  				parser.error("Expected " + delimiters[0] + "/partial" + delimiters[1]);
  			}

  			closed = true;
  		} else {
  			child = parser.read(READERS);

  			if (!child) {
  				parser.error("Expected " + delimiters[0] + "/partial" + delimiters[1]);
  			}

  			content.push(child);
  		}
  	} while (!closed);

  	return {
  		t: INLINE_PARTIAL,
  		n: name,
  		f: content
  	};
  }

  var converters_readTemplate = readTemplate;
  function readTemplate(parser) {
  	var fragment = [];
  	var partials = create(null);
  	var hasPartials = false;

  	var preserveWhitespace = parser.preserveWhitespace;

  	while (parser.pos < parser.str.length) {
  		var pos = parser.pos,
  		    item = undefined,
  		    partial = undefined;

  		if (partial = parser.read(PARTIAL_READERS)) {
  			if (partials[partial.n]) {
  				parser.pos = pos;
  				parser.error("Duplicated partial definition");
  			}

  			utils_cleanup(partial.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);

  			partials[partial.n] = partial.f;
  			hasPartials = true;
  		} else if (item = parser.read(READERS)) {
  			fragment.push(item);
  		} else {
  			parser.error("Unexpected template content");
  		}
  	}

  	var result = {
  		v: TEMPLATE_VERSION,
  		t: fragment
  	};

  	if (hasPartials) {
  		result.p = partials;
  	}

  	return result;
  }

  var _parse = parse;

  var STANDARD_READERS = [mustache_readPartial, mustache_readUnescaped, mustache_readSection, mustache_readYielder, mustache_readInterpolator, readMustacheComment];
  var TRIPLE_READERS = [mustache_readTriple];
  var STATIC_READERS = [mustache_readUnescaped, mustache_readSection, mustache_readInterpolator]; // TODO does it make sense to have a static section?

  var StandardParser = undefined;
  function parse(template, options) {
  	return new StandardParser(template, options || {}).result;
  }

  var READERS = [converters_readMustache, converters_readHtmlComment, converters_readElement, converters_readText];
  var PARTIAL_READERS = [converters_readPartialDefinitionComment, converters_readPartialDefinitionSection];

  StandardParser = parse_Parser.extend({
  	init: function (str, options) {
  		var tripleDelimiters = options.tripleDelimiters || ["{{{", "}}}"],
  		    staticDelimiters = options.staticDelimiters || ["[[", "]]"],
  		    staticTripleDelimiters = options.staticTripleDelimiters || ["[[[", "]]]"];

  		this.standardDelimiters = options.delimiters || ["{{", "}}"];

  		this.tags = [{ isStatic: false, isTriple: false, open: this.standardDelimiters[0], close: this.standardDelimiters[1], readers: STANDARD_READERS }, { isStatic: false, isTriple: true, open: tripleDelimiters[0], close: tripleDelimiters[1], readers: TRIPLE_READERS }, { isStatic: true, isTriple: false, open: staticDelimiters[0], close: staticDelimiters[1], readers: STATIC_READERS }, { isStatic: true, isTriple: true, open: staticTripleDelimiters[0], close: staticTripleDelimiters[1], readers: TRIPLE_READERS }];

  		this.sortMustacheTags();

  		this.sectionDepth = 0;
  		this.elementStack = [];

  		this.interpolate = {
  			script: !options.interpolate || options.interpolate.script !== false,
  			style: !options.interpolate || options.interpolate.style !== false
  		};

  		if (options.sanitize === true) {
  			options.sanitize = {
  				// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json
  				elements: "applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title".split(" "),
  				eventAttributes: true
  			};
  		}

  		this.stripComments = options.stripComments !== false;
  		this.preserveWhitespace = options.preserveWhitespace;
  		this.sanitizeElements = options.sanitize && options.sanitize.elements;
  		this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;
  		this.includeLinePositions = options.includeLinePositions;
  	},

  	postProcess: function (result) {
  		// special case - empty string
  		if (!result.length) {
  			return { t: [], v: TEMPLATE_VERSION };
  		}

  		if (this.sectionDepth > 0) {
  			this.error("A section was left open");
  		}

  		utils_cleanup(result[0].t, this.stripComments, this.preserveWhitespace, !this.preserveWhitespace, !this.preserveWhitespace);

  		return result[0];
  	},

  	converters: [converters_readTemplate],

  	sortMustacheTags: function () {
  		// Sort in order of descending opening delimiter length (longer first),
  		// to protect against opening delimiters being substrings of each other
  		this.tags.sort(function (a, b) {
  			return b.open.length - a.open.length;
  		});
  	}
  });

  var parseOptions = ["preserveWhitespace", "sanitize", "stripComments", "delimiters", "tripleDelimiters", "interpolate"];

  var parser = {
  	fromId: fromId, isHashedId: isHashedId, isParsed: isParsed, getParseOptions: getParseOptions, createHelper: template_parser__createHelper,
  	parse: doParse
  };

  function template_parser__createHelper(parseOptions) {
  	var helper = create(parser);
  	helper.parse = function (template, options) {
  		return doParse(template, options || parseOptions);
  	};
  	return helper;
  }

  function doParse(template, parseOptions) {
  	if (!_parse) {
  		throw new Error("Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser");
  	}

  	return _parse(template, parseOptions || this.options);
  }

  function fromId(id, options) {
  	var template;

  	if (!isClient) {
  		if (options && options.noThrow) {
  			return;
  		}
  		throw new Error("Cannot retrieve template #" + id + " as Ractive is not running in a browser.");
  	}

  	if (isHashedId(id)) {
  		id = id.substring(1);
  	}

  	if (!(template = document.getElementById(id))) {
  		if (options && options.noThrow) {
  			return;
  		}
  		throw new Error("Could not find template element with id #" + id);
  	}

  	if (template.tagName.toUpperCase() !== "SCRIPT") {
  		if (options && options.noThrow) {
  			return;
  		}
  		throw new Error("Template element with id #" + id + ", must be a <script> element");
  	}

  	return "textContent" in template ? template.textContent : template.innerHTML;
  }

  function isHashedId(id) {
  	return id && id[0] === "#";
  }

  function isParsed(template) {
  	return !(typeof template === "string");
  }

  function getParseOptions(ractive) {
  	// Could be Ractive or a Component
  	if (ractive.defaults) {
  		ractive = ractive.defaults;
  	}

  	return parseOptions.reduce(function (val, key) {
  		val[key] = ractive[key];
  		return val;
  	}, {});
  }

  var template_parser = parser;

  var templateConfigurator = {
  	name: "template",

  	extend: function extend(Parent, proto, options) {
  		var template;

  		// only assign if exists
  		if ("template" in options) {
  			template = options.template;

  			if (typeof template === "function") {
  				proto.template = template;
  			} else {
  				proto.template = parseIfString(template, proto);
  			}
  		}
  	},

  	init: function init(Parent, ractive, options) {
  		var template, fn;

  		// TODO because of prototypal inheritance, we might just be able to use
  		// ractive.template, and not bother passing through the Parent object.
  		// At present that breaks the test mocks' expectations
  		template = "template" in options ? options.template : Parent.prototype.template;

  		if (typeof template === "function") {
  			fn = template;
  			template = getDynamicTemplate(ractive, fn);

  			ractive._config.template = {
  				fn: fn,
  				result: template
  			};
  		}

  		template = parseIfString(template, ractive);

  		// TODO the naming of this is confusing - ractive.template refers to [...],
  		// but Component.prototype.template refers to {v:1,t:[],p:[]}...
  		// it's unnecessary, because the developer never needs to access
  		// ractive.template
  		ractive.template = template.t;

  		if (template.p) {
  			extendPartials(ractive.partials, template.p);
  		}
  	},

  	reset: function (ractive) {
  		var result = resetValue(ractive),
  		    parsed;

  		if (result) {
  			parsed = parseIfString(result, ractive);

  			ractive.template = parsed.t;
  			extendPartials(ractive.partials, parsed.p, true);

  			return true;
  		}
  	}
  };

  function resetValue(ractive) {
  	var initial = ractive._config.template,
  	    result;

  	// If this isn't a dynamic template, there's nothing to do
  	if (!initial || !initial.fn) {
  		return;
  	}

  	result = getDynamicTemplate(ractive, initial.fn);

  	// TODO deep equality check to prevent unnecessary re-rendering
  	// in the case of already-parsed templates
  	if (result !== initial.result) {
  		initial.result = result;
  		result = parseIfString(result, ractive);
  		return result;
  	}
  }

  function getDynamicTemplate(ractive, fn) {
  	var helper = template_template__createHelper(template_parser.getParseOptions(ractive));
  	return fn.call(ractive, helper);
  }

  function template_template__createHelper(parseOptions) {
  	var helper = create(template_parser);
  	helper.parse = function (template, options) {
  		return template_parser.parse(template, options || parseOptions);
  	};
  	return helper;
  }

  function parseIfString(template, ractive) {
  	if (typeof template === "string") {
  		// ID of an element containing the template?
  		if (template[0] === "#") {
  			template = template_parser.fromId(template);
  		}

  		template = _parse(template, template_parser.getParseOptions(ractive));
  	}

  	// Check that the template even exists
  	else if (template == undefined) {
  		throw new Error("The template cannot be " + template + ".");
  	}

  	// Check the parsed template has a version at all
  	else if (typeof template.v !== "number") {
  		throw new Error("The template parser was passed a non-string template, but the template doesn't have a version.  Make sure you're passing in the template you think you are.");
  	}

  	// Check we're using the correct version
  	else if (template.v !== TEMPLATE_VERSION) {
  		throw new Error("Mismatched template version (expected " + TEMPLATE_VERSION + ", got " + template.v + ") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app");
  	}

  	return template;
  }

  function extendPartials(existingPartials, newPartials, overwrite) {
  	if (!newPartials) return;

  	// TODO there's an ambiguity here - we need to overwrite in the `reset()`
  	// case, but not initially...

  	for (var key in newPartials) {
  		if (overwrite || !existingPartials.hasOwnProperty(key)) {
  			existingPartials[key] = newPartials[key];
  		}
  	}
  }

  var template_template = templateConfigurator;

  var config_registries__registryNames, Registry, registries;

  config_registries__registryNames = ["adaptors", "components", "computed", "decorators", "easing", "events", "interpolators", "partials", "transitions"];

  Registry = function (name, useDefaults) {
  	this.name = name;
  	this.useDefaults = useDefaults;
  };

  Registry.prototype = {
  	constructor: Registry,

  	extend: function (Parent, proto, options) {
  		this.configure(this.useDefaults ? Parent.defaults : Parent, this.useDefaults ? proto : proto.constructor, options);
  	},

  	init: function () {},

  	configure: function (Parent, target, options) {
  		var name = this.name,
  		    option = options[name],
  		    registry;

  		registry = create(Parent[name]);

  		for (var key in option) {
  			registry[key] = option[key];
  		}

  		target[name] = registry;
  	},

  	reset: function (ractive) {
  		var registry = ractive[this.name];
  		var changed = false;
  		Object.keys(registry).forEach(function (key) {
  			var item = registry[key];
  			if (item._fn) {
  				if (item._fn.isOwner) {
  					registry[key] = item._fn;
  				} else {
  					delete registry[key];
  				}
  				changed = true;
  			}
  		});
  		return changed;
  	}
  };

  registries = config_registries__registryNames.map(function (name) {
  	return new Registry(name, name === "computed");
  });

  var config_registries = registries;

  /*this.configure(
  	this.useDefaults ? Parent.defaults : Parent,
  	ractive,
  	options );*/

  var wrapPrototype = wrap;

  function wrap(parent, name, method) {
  	if (!/_super/.test(method)) {
  		return method;
  	}

  	var wrapper = function wrapSuper() {
  		var superMethod = getSuperMethod(wrapper._parent, name),
  		    hasSuper = ("_super" in this),
  		    oldSuper = this._super,
  		    result;

  		this._super = superMethod;

  		result = method.apply(this, arguments);

  		if (hasSuper) {
  			this._super = oldSuper;
  		} else {
  			delete this._super;
  		}

  		return result;
  	};

  	wrapper._parent = parent;
  	wrapper._method = method;

  	return wrapper;
  }

  function getSuperMethod(parent, name) {
  	var value, method;

  	if (name in parent) {
  		value = parent[name];

  		if (typeof value === "function") {
  			method = value;
  		} else {
  			method = function returnValue() {
  				return value;
  			};
  		}
  	} else {
  		method = noop;
  	}

  	return method;
  }

  var config_deprecate = deprecate;
  function getMessage(deprecated, correct, isError) {
  	return "options." + deprecated + " has been deprecated in favour of options." + correct + "." + (isError ? " You cannot specify both options, please use options." + correct + "." : "");
  }

  function deprecateOption(options, deprecatedOption, correct) {
  	if (deprecatedOption in options) {
  		if (!(correct in options)) {
  			warnIfDebug(getMessage(deprecatedOption, correct));
  			options[correct] = options[deprecatedOption];
  		} else {
  			throw new Error(getMessage(deprecatedOption, correct, true));
  		}
  	}
  }
  function deprecate(options) {
  	deprecateOption(options, "beforeInit", "onconstruct");
  	deprecateOption(options, "init", "onrender");
  	deprecateOption(options, "complete", "oncomplete");
  	deprecateOption(options, "eventDefinitions", "events");

  	// Using extend with Component instead of options,
  	// like Human.extend( Spider ) means adaptors as a registry
  	// gets copied to options. So we have to check if actually an array
  	if (isArray(options.adaptors)) {
  		deprecateOption(options, "adaptors", "adapt");
  	}
  }

  var config, order, defaultKeys, custom, isBlacklisted, isStandardKey;

  custom = {
  	adapt: custom_adapt,
  	css: css_css,
  	data: custom_data,
  	template: template_template
  };

  defaultKeys = Object.keys(config_defaults);

  isStandardKey = makeObj(defaultKeys.filter(function (key) {
  	return !custom[key];
  }));

  // blacklisted keys that we don't double extend
  isBlacklisted = makeObj(defaultKeys.concat(config_registries.map(function (r) {
  	return r.name;
  })));

  order = [].concat(defaultKeys.filter(function (key) {
  	return !config_registries[key] && !custom[key];
  }), config_registries, custom.data, custom.template, custom.css);

  config = {
  	extend: function (Parent, proto, options) {
  		return configure("extend", Parent, proto, options);
  	},

  	init: function (Parent, ractive, options) {
  		return configure("init", Parent, ractive, options);
  	},

  	reset: function (ractive) {
  		return order.filter(function (c) {
  			return c.reset && c.reset(ractive);
  		}).map(function (c) {
  			return c.name;
  		});
  	},

  	// this defines the order. TODO this isn't used anywhere in the codebase,
  	// only in the test suite - should get rid of it
  	order: order };

  function configure(method, Parent, target, options) {
  	config_deprecate(options);

  	for (var key in options) {
  		if (isStandardKey.hasOwnProperty(key)) {
  			var value = options[key];

  			// warn the developer if they passed a function and ignore its value

  			// NOTE: we allow some functions on "el" because we duck type element lists
  			// and some libraries or ef'ed-up virtual browsers (phantomJS) return a
  			// function object as the result of querySelector methods
  			if (key !== "el" && typeof value === "function") {
  				warnIfDebug("" + key + " is a Ractive option that does not expect a function and will be ignored", method === "init" ? target : null);
  			} else {
  				target[key] = value;
  			}
  		}
  	}

  	config_registries.forEach(function (registry) {
  		registry[method](Parent, target, options);
  	});

  	custom_adapt[method](Parent, target, options);
  	template_template[method](Parent, target, options);
  	css_css[method](Parent, target, options);

  	extendOtherMethods(Parent.prototype, target, options);
  }

  function extendOtherMethods(parent, target, options) {
  	for (var key in options) {
  		if (!isBlacklisted[key] && options.hasOwnProperty(key)) {
  			var member = options[key];

  			// if this is a method that overwrites a method, wrap it:
  			if (typeof member === "function") {
  				member = wrapPrototype(parent, key, member);
  			}

  			target[key] = member;
  		}
  	}
  }

  function makeObj(array) {
  	var obj = {};
  	array.forEach(function (x) {
  		return obj[x] = true;
  	});
  	return obj;
  }

  var config_config = config;

  var prototype_bubble = Fragment$bubble;

  function Fragment$bubble() {
  	this.dirtyValue = this.dirtyArgs = true;

  	if (this.bound && typeof this.owner.bubble === "function") {
  		this.owner.bubble();
  	}
  }

  var Fragment_prototype_detach = Fragment$detach;

  function Fragment$detach() {
  	var docFrag;

  	if (this.items.length === 1) {
  		return this.items[0].detach();
  	}

  	docFrag = document.createDocumentFragment();

  	this.items.forEach(function (item) {
  		var node = item.detach();

  		// TODO The if {...} wasn't previously required - it is now, because we're
  		// forcibly detaching everything to reorder sections after an update. That's
  		// a non-ideal brute force approach, implemented to get all the tests to pass
  		// - as soon as it's replaced with something more elegant, this should
  		// revert to `docFrag.appendChild( item.detach() )`
  		if (node) {
  			docFrag.appendChild(node);
  		}
  	});

  	return docFrag;
  }

  var Fragment_prototype_find = Fragment$find;

  function Fragment$find(selector) {
  	var i, len, item, queryResult;

  	if (this.items) {
  		len = this.items.length;
  		for (i = 0; i < len; i += 1) {
  			item = this.items[i];

  			if (item.find && (queryResult = item.find(selector))) {
  				return queryResult;
  			}
  		}

  		return null;
  	}
  }

  var Fragment_prototype_findAll = Fragment$findAll;

  function Fragment$findAll(selector, query) {
  	var i, len, item;

  	if (this.items) {
  		len = this.items.length;
  		for (i = 0; i < len; i += 1) {
  			item = this.items[i];

  			if (item.findAll) {
  				item.findAll(selector, query);
  			}
  		}
  	}

  	return query;
  }

  var Fragment_prototype_findAllComponents = Fragment$findAllComponents;

  function Fragment$findAllComponents(selector, query) {
  	var i, len, item;

  	if (this.items) {
  		len = this.items.length;
  		for (i = 0; i < len; i += 1) {
  			item = this.items[i];

  			if (item.findAllComponents) {
  				item.findAllComponents(selector, query);
  			}
  		}
  	}

  	return query;
  }

  var Fragment_prototype_findComponent = Fragment$findComponent;

  function Fragment$findComponent(selector) {
  	var len, i, item, queryResult;

  	if (this.items) {
  		len = this.items.length;
  		for (i = 0; i < len; i += 1) {
  			item = this.items[i];

  			if (item.findComponent && (queryResult = item.findComponent(selector))) {
  				return queryResult;
  			}
  		}

  		return null;
  	}
  }

  var prototype_findNextNode = Fragment$findNextNode;

  function Fragment$findNextNode(item) {
  	var index = item.index,
  	    node;

  	if (this.items[index + 1]) {
  		node = this.items[index + 1].firstNode();
  	}

  	// if this is the root fragment, and there are no more items,
  	// it means we're at the end...
  	else if (this.owner === this.root) {
  		if (!this.owner.component) {
  			// TODO but something else could have been appended to
  			// this.root.el, no?
  			node = null;
  		}

  		// ...unless this is a component
  		else {
  			node = this.owner.component.findNextNode();
  		}
  	} else {
  		node = this.owner.findNextNode(this);
  	}

  	return node;
  }

  var prototype_firstNode = Fragment$firstNode;

  function Fragment$firstNode() {
  	if (this.items && this.items[0]) {
  		return this.items[0].firstNode();
  	}

  	return null;
  }

  var shared_processItems = processItems;

  function processItems(items, values, guid, counter) {
  	counter = counter || 0;

  	return items.map(function (item) {
  		var placeholderId, wrapped, value;

  		if (item.text) {
  			return item.text;
  		}

  		if (item.fragments) {
  			return item.fragments.map(function (fragment) {
  				return processItems(fragment.items, values, guid, counter);
  			}).join("");
  		}

  		placeholderId = guid + "-" + counter++;

  		if (item.keypath && (wrapped = item.root.viewmodel.wrapped[item.keypath.str])) {
  			value = wrapped.value;
  		} else {
  			value = item.getValue();
  		}

  		values[placeholderId] = value;

  		return "${" + placeholderId + "}";
  	}).join("");
  }

  var getArgsList = Fragment$getArgsList;
  function Fragment$getArgsList() {
  	var values, source, parsed, result;

  	if (this.dirtyArgs) {
  		source = shared_processItems(this.items, values = {}, this.root._guid);
  		parsed = parseJSON("[" + source + "]", values);

  		if (!parsed) {
  			result = [this.toString()];
  		} else {
  			result = parsed.value;
  		}

  		this.argsList = result;
  		this.dirtyArgs = false;
  	}

  	return this.argsList;
  }

  var getNode = Fragment$getNode;

  function Fragment$getNode() {
  	var fragment = this;

  	do {
  		if (fragment.pElement) {
  			return fragment.pElement.node;
  		}
  	} while (fragment = fragment.parent);

  	return this.root.detached || this.root.el;
  }

  var prototype_getValue = Fragment$getValue;
  function Fragment$getValue() {
  	var values, source, parsed, result;

  	if (this.dirtyValue) {
  		source = shared_processItems(this.items, values = {}, this.root._guid);
  		parsed = parseJSON(source, values);

  		if (!parsed) {
  			result = this.toString();
  		} else {
  			result = parsed.value;
  		}

  		this.value = result;
  		this.dirtyValue = false;
  	}

  	return this.value;
  }

  var shared_detach = function () {
  	return detachNode(this.node);
  };

  var Text = function (options) {
  	this.type = TEXT;
  	this.text = options.template;
  };

  Text.prototype = {
  	detach: shared_detach,

  	firstNode: function () {
  		return this.node;
  	},

  	render: function () {
  		if (!this.node) {
  			this.node = document.createTextNode(this.text);
  		}

  		return this.node;
  	},

  	toString: function (escape) {
  		return escape ? escapeHtml(this.text) : this.text;
  	},

  	unrender: function (shouldDestroy) {
  		if (shouldDestroy) {
  			return this.detach();
  		}
  	}
  };

  var items_Text = Text;

  var shared_unbind = shared_unbind__unbind;

  function shared_unbind__unbind() {
  	if (this.registered) {
  		// this was registered as a dependant
  		this.root.viewmodel.unregister(this.keypath, this);
  	}

  	if (this.resolver) {
  		this.resolver.unbind();
  	}
  }

  var Mustache_getValue = Mustache$getValue;

  function Mustache$getValue() {
  	return this.value;
  }

  var ReferenceResolver = function (owner, ref, callback) {
  	var keypath;

  	this.ref = ref;
  	this.resolved = false;

  	this.root = owner.root;
  	this.parentFragment = owner.parentFragment;
  	this.callback = callback;

  	keypath = shared_resolveRef(owner.root, ref, owner.parentFragment);
  	if (keypath != undefined) {
  		this.resolve(keypath);
  	} else {
  		global_runloop.addUnresolved(this);
  	}
  };

  ReferenceResolver.prototype = {
  	resolve: function (keypath) {
  		if (this.keypath && !keypath) {
  			// it was resolved, and now it's not. Can happen if e.g. `bar` in
  			// `{{foo[bar]}}` becomes undefined
  			global_runloop.addUnresolved(this);
  		}

  		this.resolved = true;

  		this.keypath = keypath;
  		this.callback(keypath);
  	},

  	forceResolution: function () {
  		this.resolve(getKeypath(this.ref));
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		var keypath;

  		if (this.keypath != undefined) {
  			keypath = this.keypath.replace(oldKeypath, newKeypath);
  			// was a new keypath created?
  			if (keypath !== undefined) {
  				// resolve it
  				this.resolve(keypath);
  			}
  		}
  	},

  	unbind: function () {
  		if (!this.resolved) {
  			global_runloop.removeUnresolved(this);
  		}
  	}
  };

  var Resolvers_ReferenceResolver = ReferenceResolver;

  var SpecialResolver = function (owner, ref, callback) {
  	this.parentFragment = owner.parentFragment;
  	this.ref = ref;
  	this.callback = callback;

  	this.rebind();
  };

  var props = {
  	"@keypath": { prefix: "c", prop: ["context"] },
  	"@index": { prefix: "i", prop: ["index"] },
  	"@key": { prefix: "k", prop: ["key", "index"] }
  };

  function getProp(target, prop) {
  	var value;
  	for (var i = 0; i < prop.prop.length; i++) {
  		if ((value = target[prop.prop[i]]) !== undefined) {
  			return value;
  		}
  	}
  }

  SpecialResolver.prototype = {
  	rebind: function () {
  		var ref = this.ref,
  		    fragment = this.parentFragment,
  		    prop = props[ref],
  		    value;

  		if (!prop) {
  			throw new Error("Unknown special reference \"" + ref + "\" - valid references are @index, @key and @keypath");
  		}

  		// have we already found the nearest parent?
  		if (this.cached) {
  			return this.callback(getKeypath("@" + prop.prefix + getProp(this.cached, prop)));
  		}

  		// special case for indices, which may cross component boundaries
  		if (prop.prop.indexOf("index") !== -1 || prop.prop.indexOf("key") !== -1) {
  			while (fragment) {
  				if (fragment.owner.currentSubtype === SECTION_EACH && (value = getProp(fragment, prop)) !== undefined) {
  					this.cached = fragment;

  					fragment.registerIndexRef(this);

  					return this.callback(getKeypath("@" + prop.prefix + value));
  				}

  				// watch for component boundaries
  				if (!fragment.parent && fragment.owner && fragment.owner.component && fragment.owner.component.parentFragment && !fragment.owner.component.instance.isolated) {
  					fragment = fragment.owner.component.parentFragment;
  				} else {
  					fragment = fragment.parent;
  				}
  			}
  		} else {
  			while (fragment) {
  				if ((value = getProp(fragment, prop)) !== undefined) {
  					return this.callback(getKeypath("@" + prop.prefix + value.str));
  				}

  				fragment = fragment.parent;
  			}
  		}
  	},

  	unbind: function () {
  		if (this.cached) {
  			this.cached.unregisterIndexRef(this);
  		}
  	}
  };

  var Resolvers_SpecialResolver = SpecialResolver;

  var IndexResolver = function (owner, ref, callback) {
  	this.parentFragment = owner.parentFragment;
  	this.ref = ref;
  	this.callback = callback;

  	ref.ref.fragment.registerIndexRef(this);

  	this.rebind();
  };

  IndexResolver.prototype = {
  	rebind: function () {
  		var index,
  		    ref = this.ref.ref;

  		if (ref.ref.t === "k") {
  			index = "k" + ref.fragment.key;
  		} else {
  			index = "i" + ref.fragment.index;
  		}

  		if (index !== undefined) {
  			this.callback(getKeypath("@" + index));
  		}
  	},

  	unbind: function () {
  		this.ref.ref.fragment.unregisterIndexRef(this);
  	}
  };

  var Resolvers_IndexResolver = IndexResolver;

  var Resolvers_findIndexRefs = findIndexRefs;

  function findIndexRefs(fragment, refName) {
  	var result = {},
  	    refs,
  	    fragRefs,
  	    ref,
  	    i,
  	    owner,
  	    hit = false;

  	if (!refName) {
  		result.refs = refs = {};
  	}

  	while (fragment) {
  		if ((owner = fragment.owner) && (fragRefs = owner.indexRefs)) {

  			// we're looking for a particular ref, and it's here
  			if (refName && (ref = owner.getIndexRef(refName))) {
  				result.ref = {
  					fragment: fragment,
  					ref: ref
  				};
  				return result;
  			}

  			// we're collecting refs up-tree
  			else if (!refName) {
  				for (i in fragRefs) {
  					ref = fragRefs[i];

  					// don't overwrite existing refs - they should shadow parents
  					if (!refs[ref.n]) {
  						hit = true;
  						refs[ref.n] = {
  							fragment: fragment,
  							ref: ref
  						};
  					}
  				}
  			}
  		}

  		// watch for component boundaries
  		if (!fragment.parent && fragment.owner && fragment.owner.component && fragment.owner.component.parentFragment && !fragment.owner.component.instance.isolated) {
  			result.componentBoundary = true;
  			fragment = fragment.owner.component.parentFragment;
  		} else {
  			fragment = fragment.parent;
  		}
  	}

  	if (!hit) {
  		return undefined;
  	} else {
  		return result;
  	}
  }

  findIndexRefs.resolve = function resolve(indices) {
  	var refs = {},
  	    k,
  	    ref;

  	for (k in indices.refs) {
  		ref = indices.refs[k];
  		refs[ref.ref.n] = ref.ref.t === "k" ? ref.fragment.key : ref.fragment.index;
  	}

  	return refs;
  };

  var Resolvers_createReferenceResolver = createReferenceResolver;
  function createReferenceResolver(owner, ref, callback) {
  	var indexRef;

  	if (ref.charAt(0) === "@") {
  		return new Resolvers_SpecialResolver(owner, ref, callback);
  	}

  	if (indexRef = Resolvers_findIndexRefs(owner.parentFragment, ref)) {
  		return new Resolvers_IndexResolver(owner, indexRef, callback);
  	}

  	return new Resolvers_ReferenceResolver(owner, ref, callback);
  }

  var shared_getFunctionFromString = getFunctionFromString;
  var cache = {};
  function getFunctionFromString(str, i) {
  	var fn, args;

  	if (cache[str]) {
  		return cache[str];
  	}

  	args = [];
  	while (i--) {
  		args[i] = "_" + i;
  	}

  	fn = new Function(args.join(","), "return(" + str + ")");

  	cache[str] = fn;
  	return fn;
  }

  var ExpressionResolver,
      Resolvers_ExpressionResolver__bind = Function.prototype.bind;

  ExpressionResolver = function (owner, parentFragment, expression, callback) {
  	var _this = this;

  	var ractive;

  	ractive = owner.root;

  	this.root = ractive;
  	this.parentFragment = parentFragment;
  	this.callback = callback;
  	this.owner = owner;
  	this.str = expression.s;
  	this.keypaths = [];

  	// Create resolvers for each reference
  	this.pending = expression.r.length;
  	this.refResolvers = expression.r.map(function (ref, i) {
  		return Resolvers_createReferenceResolver(_this, ref, function (keypath) {
  			_this.resolve(i, keypath);
  		});
  	});

  	this.ready = true;
  	this.bubble();
  };

  ExpressionResolver.prototype = {
  	bubble: function () {
  		if (!this.ready) {
  			return;
  		}

  		this.uniqueString = getUniqueString(this.str, this.keypaths);
  		this.keypath = createExpressionKeypath(this.uniqueString);

  		this.createEvaluator();
  		this.callback(this.keypath);
  	},

  	unbind: function () {
  		var resolver;

  		while (resolver = this.refResolvers.pop()) {
  			resolver.unbind();
  		}
  	},

  	resolve: function (index, keypath) {
  		this.keypaths[index] = keypath;
  		this.bubble();
  	},

  	createEvaluator: function () {
  		var _this = this;

  		var computation, valueGetters, signature, keypath, fn;

  		keypath = this.keypath;
  		computation = this.root.viewmodel.computations[keypath.str];

  		// only if it doesn't exist yet!
  		if (!computation) {
  			fn = shared_getFunctionFromString(this.str, this.refResolvers.length);

  			valueGetters = this.keypaths.map(function (keypath) {
  				var value;

  				if (keypath === "undefined") {
  					return function () {
  						return undefined;
  					};
  				}

  				// 'special' keypaths encode a value
  				if (keypath.isSpecial) {
  					value = keypath.value;
  					return function () {
  						return value;
  					};
  				}

  				return function () {
  					var value = _this.root.viewmodel.get(keypath, { noUnwrap: true, fullRootGet: true });
  					if (typeof value === "function") {
  						value = wrapFunction(value, _this.root);
  					}
  					return value;
  				};
  			});

  			signature = {
  				deps: this.keypaths.filter(isValidDependency),
  				getter: function () {
  					var args = valueGetters.map(call);
  					return fn.apply(null, args);
  				}
  			};

  			computation = this.root.viewmodel.compute(keypath, signature);
  		} else {
  			this.root.viewmodel.mark(keypath);
  		}
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		// TODO only bubble once, no matter how many references are affected by the rebind
  		this.refResolvers.forEach(function (r) {
  			return r.rebind(oldKeypath, newKeypath);
  		});
  	}
  };

  var Resolvers_ExpressionResolver = ExpressionResolver;

  function call(value) {
  	return value.call();
  }

  function getUniqueString(str, keypaths) {
  	// get string that is unique to this expression
  	return str.replace(/_([0-9]+)/g, function (match, $1) {
  		var keypath, value;

  		// make sure we're not replacing a non-keypath _[0-9]
  		if (+$1 >= keypaths.length) {
  			return "_" + $1;
  		}

  		keypath = keypaths[$1];

  		if (keypath === undefined) {
  			return "undefined";
  		}

  		if (keypath.isSpecial) {
  			value = keypath.value;
  			return typeof value === "number" ? value : "\"" + value + "\"";
  		}

  		return keypath.str;
  	});
  }

  function createExpressionKeypath(uniqueString) {
  	// Sanitize by removing any periods or square brackets. Otherwise
  	// we can't split the keypath into keys!
  	// Remove asterisks too, since they mess with pattern observers
  	return getKeypath("${" + uniqueString.replace(/[\.\[\]]/g, "-").replace(/\*/, "#MUL#") + "}");
  }

  function isValidDependency(keypath) {
  	return keypath !== undefined && keypath[0] !== "@";
  }

  function wrapFunction(fn, ractive) {
  	var wrapped, prop, key;

  	if (fn.__ractive_nowrap) {
  		return fn;
  	}

  	prop = "__ractive_" + ractive._guid;
  	wrapped = fn[prop];

  	if (wrapped) {
  		return wrapped;
  	} else if (/this/.test(fn.toString())) {
  		defineProperty(fn, prop, {
  			value: Resolvers_ExpressionResolver__bind.call(fn, ractive),
  			configurable: true
  		});

  		// Add properties/methods to wrapped function
  		for (key in fn) {
  			if (fn.hasOwnProperty(key)) {
  				fn[prop][key] = fn[key];
  			}
  		}

  		ractive._boundFunctions.push({
  			fn: fn,
  			prop: prop
  		});

  		return fn[prop];
  	}

  	defineProperty(fn, "__ractive_nowrap", {
  		value: fn
  	});

  	return fn.__ractive_nowrap;
  }

  var MemberResolver = function (template, resolver, parentFragment) {
  	var _this = this;

  	this.resolver = resolver;
  	this.root = resolver.root;
  	this.parentFragment = parentFragment;
  	this.viewmodel = resolver.root.viewmodel;

  	if (typeof template === "string") {
  		this.value = template;
  	}

  	// Simple reference?
  	else if (template.t === REFERENCE) {
  		this.refResolver = Resolvers_createReferenceResolver(this, template.n, function (keypath) {
  			_this.resolve(keypath);
  		});
  	}

  	// Otherwise we have an expression in its own right
  	else {
  		new Resolvers_ExpressionResolver(resolver, parentFragment, template, function (keypath) {
  			_this.resolve(keypath);
  		});
  	}
  };

  MemberResolver.prototype = {
  	resolve: function (keypath) {
  		if (this.keypath) {
  			this.viewmodel.unregister(this.keypath, this);
  		}

  		this.keypath = keypath;
  		this.value = this.viewmodel.get(keypath);

  		this.bind();

  		this.resolver.bubble();
  	},

  	bind: function () {
  		this.viewmodel.register(this.keypath, this);
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		if (this.refResolver) {
  			this.refResolver.rebind(oldKeypath, newKeypath);
  		}
  	},

  	setValue: function (value) {
  		this.value = value;
  		this.resolver.bubble();
  	},

  	unbind: function () {
  		if (this.keypath) {
  			this.viewmodel.unregister(this.keypath, this);
  		}

  		if (this.refResolver) {
  			this.refResolver.unbind();
  		}
  	},

  	forceResolution: function () {
  		if (this.refResolver) {
  			this.refResolver.forceResolution();
  		}
  	}
  };

  var ReferenceExpressionResolver_MemberResolver = MemberResolver;

  var ReferenceExpressionResolver = function (mustache, template, callback) {
  	var _this = this;

  	var ractive, ref, keypath, parentFragment;

  	this.parentFragment = parentFragment = mustache.parentFragment;
  	this.root = ractive = mustache.root;
  	this.mustache = mustache;

  	this.ref = ref = template.r;
  	this.callback = callback;

  	this.unresolved = [];

  	// Find base keypath
  	if (keypath = shared_resolveRef(ractive, ref, parentFragment)) {
  		this.base = keypath;
  	} else {
  		this.baseResolver = new Resolvers_ReferenceResolver(this, ref, function (keypath) {
  			_this.base = keypath;
  			_this.baseResolver = null;
  			_this.bubble();
  		});
  	}

  	// Find values for members, or mark them as unresolved
  	this.members = template.m.map(function (template) {
  		return new ReferenceExpressionResolver_MemberResolver(template, _this, parentFragment);
  	});

  	this.ready = true;
  	this.bubble(); // trigger initial resolution if possible
  };

  ReferenceExpressionResolver.prototype = {
  	getKeypath: function () {
  		var values = this.members.map(ReferenceExpressionResolver_ReferenceExpressionResolver__getValue);

  		if (!values.every(isDefined) || this.baseResolver) {
  			return null;
  		}

  		return this.base.join(values.join("."));
  	},

  	bubble: function () {
  		if (!this.ready || this.baseResolver) {
  			return;
  		}

  		this.callback(this.getKeypath());
  	},

  	unbind: function () {
  		this.members.forEach(methodCallers__unbind);
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		var changed;

  		if (this.base) {
  			var newBase = this.base.replace(oldKeypath, newKeypath);
  			if (newBase && newBase !== this.base) {
  				this.base = newBase;
  				changed = true;
  			}
  		}

  		this.members.forEach(function (members) {
  			if (members.rebind(oldKeypath, newKeypath)) {
  				changed = true;
  			}
  		});

  		if (changed) {
  			this.bubble();
  		}
  	},

  	forceResolution: function () {
  		if (this.baseResolver) {
  			this.base = getKeypath(this.ref);

  			this.baseResolver.unbind();
  			this.baseResolver = null;
  		}

  		this.members.forEach(forceResolution);
  		this.bubble();
  	}
  };

  function ReferenceExpressionResolver_ReferenceExpressionResolver__getValue(member) {
  	return member.value;
  }

  function isDefined(value) {
  	return value != undefined;
  }

  function forceResolution(member) {
  	member.forceResolution();
  }

  var ReferenceExpressionResolver_ReferenceExpressionResolver = ReferenceExpressionResolver;

  var Mustache_initialise = Mustache$init;
  function Mustache$init(mustache, options) {

  	var ref, parentFragment, template;

  	parentFragment = options.parentFragment;
  	template = options.template;

  	mustache.root = parentFragment.root;
  	mustache.parentFragment = parentFragment;
  	mustache.pElement = parentFragment.pElement;

  	mustache.template = options.template;
  	mustache.index = options.index || 0;
  	mustache.isStatic = options.template.s;

  	mustache.type = options.template.t;

  	mustache.registered = false;

  	// if this is a simple mustache, with a reference, we just need to resolve
  	// the reference to a keypath
  	if (ref = template.r) {
  		mustache.resolver = Resolvers_createReferenceResolver(mustache, ref, resolve);
  	}

  	// if it's an expression, we have a bit more work to do
  	if (options.template.x) {
  		mustache.resolver = new Resolvers_ExpressionResolver(mustache, parentFragment, options.template.x, resolveAndRebindChildren);
  	}

  	if (options.template.rx) {
  		mustache.resolver = new ReferenceExpressionResolver_ReferenceExpressionResolver(mustache, options.template.rx, resolveAndRebindChildren);
  	}

  	// Special case - inverted sections
  	if (mustache.template.n === SECTION_UNLESS && !mustache.hasOwnProperty("value")) {
  		mustache.setValue(undefined);
  	}

  	function resolve(keypath) {
  		mustache.resolve(keypath);
  	}

  	function resolveAndRebindChildren(newKeypath) {
  		var oldKeypath = mustache.keypath;

  		if (newKeypath != oldKeypath) {
  			mustache.resolve(newKeypath);

  			if (oldKeypath !== undefined) {
  				mustache.fragments && mustache.fragments.forEach(function (f) {
  					f.rebind(oldKeypath, newKeypath);
  				});
  			}
  		}
  	}
  }

  var Mustache_resolve = Mustache$resolve;

  function Mustache$resolve(keypath) {
  	var wasResolved, value, twowayBinding;

  	// 'Special' keypaths, e.g. @foo or @7, encode a value
  	if (keypath && keypath.isSpecial) {
  		this.keypath = keypath;
  		this.setValue(keypath.value);
  		return;
  	}

  	// If we resolved previously, we need to unregister
  	if (this.registered) {
  		// undefined or null
  		this.root.viewmodel.unregister(this.keypath, this);
  		this.registered = false;

  		wasResolved = true;
  	}

  	this.keypath = keypath;

  	// If the new keypath exists, we need to register
  	// with the viewmodel
  	if (keypath != undefined) {
  		// undefined or null
  		value = this.root.viewmodel.get(keypath);
  		this.root.viewmodel.register(keypath, this);

  		this.registered = true;
  	}

  	// Either way we need to queue up a render (`value`
  	// will be `undefined` if there's no keypath)
  	this.setValue(value);

  	// Two-way bindings need to point to their new target keypath
  	if (wasResolved && (twowayBinding = this.twowayBinding)) {
  		twowayBinding.rebound();
  	}
  }

  var Mustache_rebind = Mustache$rebind;

  function Mustache$rebind(oldKeypath, newKeypath) {
  	// Children first
  	if (this.fragments) {
  		this.fragments.forEach(function (f) {
  			return f.rebind(oldKeypath, newKeypath);
  		});
  	}

  	// Expression mustache?
  	if (this.resolver) {
  		this.resolver.rebind(oldKeypath, newKeypath);
  	}
  }

  var Mustache = {
  	getValue: Mustache_getValue,
  	init: Mustache_initialise,
  	resolve: Mustache_resolve,
  	rebind: Mustache_rebind
  };

  var Interpolator = function (options) {
  	this.type = INTERPOLATOR;
  	Mustache.init(this, options);
  };

  Interpolator.prototype = {
  	update: function () {
  		this.node.data = this.value == undefined ? "" : this.value;
  	},
  	resolve: Mustache.resolve,
  	rebind: Mustache.rebind,
  	detach: shared_detach,

  	unbind: shared_unbind,

  	render: function () {
  		if (!this.node) {
  			this.node = document.createTextNode(safeToStringValue(this.value));
  		}

  		return this.node;
  	},

  	unrender: function (shouldDestroy) {
  		if (shouldDestroy) {
  			detachNode(this.node);
  		}
  	},

  	getValue: Mustache.getValue,

  	// TEMP
  	setValue: function (value) {
  		var wrapper;

  		// TODO is there a better way to approach this?
  		if (this.keypath && (wrapper = this.root.viewmodel.wrapped[this.keypath.str])) {
  			value = wrapper.get();
  		}

  		if (!isEqual(value, this.value)) {
  			this.value = value;
  			this.parentFragment.bubble();

  			if (this.node) {
  				global_runloop.addView(this);
  			}
  		}
  	},

  	firstNode: function () {
  		return this.node;
  	},

  	toString: function (escape) {
  		var string = "" + safeToStringValue(this.value);
  		return escape ? escapeHtml(string) : string;
  	}
  };

  var items_Interpolator = Interpolator;

  var Section_prototype_bubble = Section$bubble;

  function Section$bubble() {
  	this.parentFragment.bubble();
  }

  var Section_prototype_detach = Section$detach;

  function Section$detach() {
  	var docFrag;

  	if (this.fragments.length === 1) {
  		return this.fragments[0].detach();
  	}

  	docFrag = document.createDocumentFragment();

  	this.fragments.forEach(function (item) {
  		docFrag.appendChild(item.detach());
  	});

  	return docFrag;
  }

  var find = Section$find;

  function Section$find(selector) {
  	var i, len, queryResult;

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		if (queryResult = this.fragments[i].find(selector)) {
  			return queryResult;
  		}
  	}

  	return null;
  }

  var findAll = Section$findAll;

  function Section$findAll(selector, query) {
  	var i, len;

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		this.fragments[i].findAll(selector, query);
  	}
  }

  var findAllComponents = Section$findAllComponents;

  function Section$findAllComponents(selector, query) {
  	var i, len;

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		this.fragments[i].findAllComponents(selector, query);
  	}
  }

  var findComponent = Section$findComponent;

  function Section$findComponent(selector) {
  	var i, len, queryResult;

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		if (queryResult = this.fragments[i].findComponent(selector)) {
  			return queryResult;
  		}
  	}

  	return null;
  }

  var findNextNode = Section$findNextNode;

  function Section$findNextNode(fragment) {
  	if (this.fragments[fragment.index + 1]) {
  		return this.fragments[fragment.index + 1].firstNode();
  	}

  	return this.parentFragment.findNextNode(this);
  }

  var firstNode = Section$firstNode;

  function Section$firstNode() {
  	var len, i, node;

  	if (len = this.fragments.length) {
  		for (i = 0; i < len; i += 1) {
  			if (node = this.fragments[i].firstNode()) {
  				return node;
  			}
  		}
  	}

  	return this.parentFragment.findNextNode(this);
  }

  var shuffle = Section$shuffle;

  function Section$shuffle(newIndices) {
  	var _this = this;

  	var parentFragment, firstChange, i, newLength, reboundFragments, fragmentOptions, fragment;

  	// short circuit any double-updates, and ensure that this isn't applied to
  	// non-list sections
  	if (this.shuffling || this.unbound || this.currentSubtype !== SECTION_EACH) {
  		return;
  	}

  	this.shuffling = true;
  	global_runloop.scheduleTask(function () {
  		return _this.shuffling = false;
  	});

  	parentFragment = this.parentFragment;

  	reboundFragments = [];

  	// TODO: need to update this
  	// first, rebind existing fragments
  	newIndices.forEach(function (newIndex, oldIndex) {
  		var fragment, by, oldKeypath, newKeypath, deps;

  		if (newIndex === oldIndex) {
  			reboundFragments[newIndex] = _this.fragments[oldIndex];
  			return;
  		}

  		fragment = _this.fragments[oldIndex];

  		if (firstChange === undefined) {
  			firstChange = oldIndex;
  		}

  		// does this fragment need to be torn down?
  		if (newIndex === -1) {
  			_this.fragmentsToUnrender.push(fragment);
  			fragment.unbind();
  			return;
  		}

  		// Otherwise, it needs to be rebound to a new index
  		by = newIndex - oldIndex;
  		oldKeypath = _this.keypath.join(oldIndex);
  		newKeypath = _this.keypath.join(newIndex);

  		fragment.index = newIndex;

  		// notify any registered index refs directly
  		if (deps = fragment.registeredIndexRefs) {
  			deps.forEach(shuffle__blindRebind);
  		}

  		fragment.rebind(oldKeypath, newKeypath);
  		reboundFragments[newIndex] = fragment;
  	});

  	newLength = this.root.viewmodel.get(this.keypath).length;

  	// If nothing changed with the existing fragments, then we start adding
  	// new fragments at the end...
  	if (firstChange === undefined) {
  		// ...unless there are no new fragments to add
  		if (this.length === newLength) {
  			return;
  		}

  		firstChange = this.length;
  	}

  	this.length = this.fragments.length = newLength;

  	if (this.rendered) {
  		global_runloop.addView(this);
  	}

  	// Prepare new fragment options
  	fragmentOptions = {
  		template: this.template.f,
  		root: this.root,
  		owner: this
  	};

  	// Add as many new fragments as we need to, or add back existing
  	// (detached) fragments
  	for (i = firstChange; i < newLength; i += 1) {
  		fragment = reboundFragments[i];

  		if (!fragment) {
  			this.fragmentsToCreate.push(i);
  		}

  		this.fragments[i] = fragment;
  	}
  }

  function shuffle__blindRebind(dep) {
  	// the keypath doesn't actually matter here as it won't have changed
  	dep.rebind("", "");
  }

  var prototype_rebind = function (oldKeypath, newKeypath) {
  	Mustache.rebind.call(this, oldKeypath, newKeypath);
  };

  var Section_prototype_render = Section$render;

  function Section$render() {
  	var _this = this;

  	this.docFrag = document.createDocumentFragment();

  	this.fragments.forEach(function (f) {
  		return _this.docFrag.appendChild(f.render());
  	});

  	this.renderedFragments = this.fragments.slice();
  	this.fragmentsToRender = [];

  	this.rendered = true;
  	return this.docFrag;
  }

  var setValue = Section$setValue;

  function Section$setValue(value) {
  	var _this = this;

  	var wrapper, fragmentOptions;

  	if (this.updating) {
  		// If a child of this section causes a re-evaluation - for example, an
  		// expression refers to a function that mutates the array that this
  		// section depends on - we'll end up with a double rendering bug (see
  		// https://github.com/ractivejs/ractive/issues/748). This prevents it.
  		return;
  	}

  	this.updating = true;

  	// with sections, we need to get the fake value if we have a wrapped object
  	if (this.keypath && (wrapper = this.root.viewmodel.wrapped[this.keypath.str])) {
  		value = wrapper.get();
  	}

  	// If any fragments are awaiting creation after a splice,
  	// this is the place to do it
  	if (this.fragmentsToCreate.length) {
  		fragmentOptions = {
  			template: this.template.f || [],
  			root: this.root,
  			pElement: this.pElement,
  			owner: this
  		};

  		this.fragmentsToCreate.forEach(function (index) {
  			var fragment;

  			fragmentOptions.context = _this.keypath.join(index);
  			fragmentOptions.index = index;

  			fragment = new virtualdom_Fragment(fragmentOptions);
  			_this.fragmentsToRender.push(_this.fragments[index] = fragment);
  		});

  		this.fragmentsToCreate.length = 0;
  	} else if (reevaluateSection(this, value)) {
  		this.bubble();

  		if (this.rendered) {
  			global_runloop.addView(this);
  		}
  	}

  	this.value = value;
  	this.updating = false;
  }

  function changeCurrentSubtype(section, value, obj) {
  	if (value === SECTION_EACH) {
  		// make sure ref type is up to date for key or value indices
  		if (section.indexRefs && section.indexRefs[0]) {
  			var ref = section.indexRefs[0];

  			// when switching flavors, make sure the section gets updated
  			if (obj && ref.t === "i" || !obj && ref.t === "k") {
  				// if switching from object to list, unbind all of the old fragments
  				if (!obj) {
  					section.length = 0;
  					section.fragmentsToUnrender = section.fragments.slice(0);
  					section.fragmentsToUnrender.forEach(function (f) {
  						return f.unbind();
  					});
  				}
  			}

  			ref.t = obj ? "k" : "i";
  		}
  	}

  	section.currentSubtype = value;
  }

  function reevaluateSection(section, value) {
  	var fragmentOptions = {
  		template: section.template.f || [],
  		root: section.root,
  		pElement: section.parentFragment.pElement,
  		owner: section
  	};

  	section.hasContext = true;

  	// If we already know the section type, great
  	// TODO can this be optimised? i.e. pick an reevaluateSection function during init
  	// and avoid doing this each time?
  	if (section.subtype) {
  		switch (section.subtype) {
  			case SECTION_IF:
  				section.hasContext = false;
  				return reevaluateConditionalSection(section, value, false, fragmentOptions);

  			case SECTION_UNLESS:
  				section.hasContext = false;
  				return reevaluateConditionalSection(section, value, true, fragmentOptions);

  			case SECTION_WITH:
  				return reevaluateContextSection(section, fragmentOptions);

  			case SECTION_IF_WITH:
  				return reevaluateConditionalContextSection(section, value, fragmentOptions);

  			case SECTION_EACH:
  				if (isObject(value)) {
  					changeCurrentSubtype(section, section.subtype, true);
  					return reevaluateListObjectSection(section, value, fragmentOptions);
  				}

  				// Fallthrough - if it's a conditional or an array we need to continue
  		}
  	}

  	// Otherwise we need to work out what sort of section we're dealing with
  	section.ordered = !!isArrayLike(value);

  	// Ordered list section
  	if (section.ordered) {
  		changeCurrentSubtype(section, SECTION_EACH, false);
  		return reevaluateListSection(section, value, fragmentOptions);
  	}

  	// Unordered list, or context
  	if (isObject(value) || typeof value === "function") {
  		// Index reference indicates section should be treated as a list
  		if (section.template.i) {
  			changeCurrentSubtype(section, SECTION_EACH, true);
  			return reevaluateListObjectSection(section, value, fragmentOptions);
  		}

  		// Otherwise, object provides context for contents
  		changeCurrentSubtype(section, SECTION_WITH, false);
  		return reevaluateContextSection(section, fragmentOptions);
  	}

  	// Conditional section
  	changeCurrentSubtype(section, SECTION_IF, false);
  	section.hasContext = false;
  	return reevaluateConditionalSection(section, value, false, fragmentOptions);
  }

  function reevaluateListSection(section, value, fragmentOptions) {
  	var i, length, fragment;

  	length = value.length;

  	if (length === section.length) {
  		// Nothing to do
  		return false;
  	}

  	// if the array is shorter than it was previously, remove items
  	if (length < section.length) {
  		section.fragmentsToUnrender = section.fragments.splice(length, section.length - length);
  		section.fragmentsToUnrender.forEach(methodCallers__unbind);
  	}

  	// otherwise...
  	else {
  		if (length > section.length) {
  			// add any new ones
  			for (i = section.length; i < length; i += 1) {
  				// append list item to context stack
  				fragmentOptions.context = section.keypath.join(i);
  				fragmentOptions.index = i;

  				fragment = new virtualdom_Fragment(fragmentOptions);
  				section.fragmentsToRender.push(section.fragments[i] = fragment);
  			}
  		}
  	}

  	section.length = length;
  	return true;
  }

  function reevaluateListObjectSection(section, value, fragmentOptions) {
  	var id, i, hasKey, fragment, changed, deps;

  	hasKey = section.hasKey || (section.hasKey = {});

  	// remove any fragments that should no longer exist
  	i = section.fragments.length;
  	while (i--) {
  		fragment = section.fragments[i];

  		if (!(fragment.key in value)) {
  			changed = true;

  			fragment.unbind();
  			section.fragmentsToUnrender.push(fragment);
  			section.fragments.splice(i, 1);

  			hasKey[fragment.key] = false;
  		}
  	}

  	// notify any dependents about changed indices
  	i = section.fragments.length;
  	while (i--) {
  		fragment = section.fragments[i];

  		if (fragment.index !== i) {
  			fragment.index = i;
  			if (deps = fragment.registeredIndexRefs) {
  				deps.forEach(setValue__blindRebind);
  			}
  		}
  	}

  	// add any that haven't been created yet
  	i = section.fragments.length;
  	for (id in value) {
  		if (!hasKey[id]) {
  			changed = true;

  			fragmentOptions.context = section.keypath.join(id);
  			fragmentOptions.key = id;
  			fragmentOptions.index = i++;

  			fragment = new virtualdom_Fragment(fragmentOptions);

  			section.fragmentsToRender.push(fragment);
  			section.fragments.push(fragment);
  			hasKey[id] = true;
  		}
  	}

  	section.length = section.fragments.length;
  	return changed;
  }

  function reevaluateConditionalContextSection(section, value, fragmentOptions) {
  	if (value) {
  		return reevaluateContextSection(section, fragmentOptions);
  	} else {
  		return removeSectionFragments(section);
  	}
  }

  function reevaluateContextSection(section, fragmentOptions) {
  	var fragment;

  	// ...then if it isn't rendered, render it, adding section.keypath to the context stack
  	// (if it is already rendered, then any children dependent on the context stack
  	// will update themselves without any prompting)
  	if (!section.length) {
  		// append this section to the context stack
  		fragmentOptions.context = section.keypath;
  		fragmentOptions.index = 0;

  		fragment = new virtualdom_Fragment(fragmentOptions);

  		section.fragmentsToRender.push(section.fragments[0] = fragment);
  		section.length = 1;

  		return true;
  	}
  }

  function reevaluateConditionalSection(section, value, inverted, fragmentOptions) {
  	var doRender, emptyArray, emptyObject, fragment, name;

  	emptyArray = isArrayLike(value) && value.length === 0;
  	emptyObject = false;
  	if (!isArrayLike(value) && isObject(value)) {
  		emptyObject = true;
  		for (name in value) {
  			emptyObject = false;
  			break;
  		}
  	}

  	if (inverted) {
  		doRender = emptyArray || emptyObject || !value;
  	} else {
  		doRender = value && !emptyArray && !emptyObject;
  	}

  	if (doRender) {
  		if (!section.length) {
  			// no change to context stack
  			fragmentOptions.index = 0;

  			fragment = new virtualdom_Fragment(fragmentOptions);
  			section.fragmentsToRender.push(section.fragments[0] = fragment);
  			section.length = 1;

  			return true;
  		}

  		if (section.length > 1) {
  			section.fragmentsToUnrender = section.fragments.splice(1);
  			section.fragmentsToUnrender.forEach(methodCallers__unbind);

  			return true;
  		}
  	} else {
  		return removeSectionFragments(section);
  	}
  }

  function removeSectionFragments(section) {
  	if (section.length) {
  		section.fragmentsToUnrender = section.fragments.splice(0, section.fragments.length).filter(isRendered);
  		section.fragmentsToUnrender.forEach(methodCallers__unbind);
  		section.length = section.fragmentsToRender.length = 0;
  		return true;
  	}
  }

  function isRendered(fragment) {
  	return fragment.rendered;
  }

  function setValue__blindRebind(dep) {
  	// the keypath doesn't actually matter here as it won't have changed
  	dep.rebind("", "");
  }

  var prototype_toString = Section$toString;

  function Section$toString(escape) {
  	var str, i, len;

  	str = "";

  	i = 0;
  	len = this.length;

  	for (i = 0; i < len; i += 1) {
  		str += this.fragments[i].toString(escape);
  	}

  	return str;
  }

  var prototype_unbind = Section$unbind;
  function Section$unbind() {
  	var _this = this;

  	this.fragments.forEach(methodCallers__unbind);
  	this.fragmentsToRender.forEach(function (f) {
  		return removeFromArray(_this.fragments, f);
  	});
  	this.fragmentsToRender = [];
  	shared_unbind.call(this);

  	this.length = 0;
  	this.unbound = true;
  }

  var prototype_unrender = Section$unrender;

  function Section$unrender(shouldDestroy) {
  	this.fragments.forEach(shouldDestroy ? unrenderAndDestroy : prototype_unrender__unrender);
  	this.renderedFragments = [];
  	this.rendered = false;
  }

  function unrenderAndDestroy(fragment) {
  	fragment.unrender(true);
  }

  function prototype_unrender__unrender(fragment) {
  	fragment.unrender(false);
  }

  var prototype_update = Section$update;

  function Section$update() {
  	var fragment, renderIndex, renderedFragments, anchor, target, i, len;

  	// `this.renderedFragments` is in the order of the previous render.
  	// If fragments have shuffled about, this allows us to quickly
  	// reinsert them in the correct place
  	renderedFragments = this.renderedFragments;

  	// Remove fragments that have been marked for destruction
  	while (fragment = this.fragmentsToUnrender.pop()) {
  		fragment.unrender(true);
  		renderedFragments.splice(renderedFragments.indexOf(fragment), 1);
  	}

  	// Render new fragments (but don't insert them yet)
  	while (fragment = this.fragmentsToRender.shift()) {
  		fragment.render();
  	}

  	if (this.rendered) {
  		target = this.parentFragment.getNode();
  	}

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		fragment = this.fragments[i];
  		renderIndex = renderedFragments.indexOf(fragment, i); // search from current index - it's guaranteed to be the same or higher

  		if (renderIndex === i) {
  			// already in the right place. insert accumulated nodes (if any) and carry on
  			if (this.docFrag.childNodes.length) {
  				anchor = fragment.firstNode();
  				target.insertBefore(this.docFrag, anchor);
  			}

  			continue;
  		}

  		this.docFrag.appendChild(fragment.detach());

  		// update renderedFragments
  		if (renderIndex !== -1) {
  			renderedFragments.splice(renderIndex, 1);
  		}
  		renderedFragments.splice(i, 0, fragment);
  	}

  	if (this.rendered && this.docFrag.childNodes.length) {
  		anchor = this.parentFragment.findNextNode(this);
  		target.insertBefore(this.docFrag, anchor);
  	}

  	// Save the rendering order for next time
  	this.renderedFragments = this.fragments.slice();
  }

  var Section = function (options) {
  	this.type = SECTION;
  	this.subtype = this.currentSubtype = options.template.n;
  	this.inverted = this.subtype === SECTION_UNLESS;

  	this.pElement = options.pElement;

  	this.fragments = [];
  	this.fragmentsToCreate = [];
  	this.fragmentsToRender = [];
  	this.fragmentsToUnrender = [];

  	if (options.template.i) {
  		this.indexRefs = options.template.i.split(",").map(function (k, i) {
  			return { n: k, t: i === 0 ? "k" : "i" };
  		});
  	}

  	this.renderedFragments = [];

  	this.length = 0; // number of times this section is rendered

  	Mustache.init(this, options);
  };

  Section.prototype = {
  	bubble: Section_prototype_bubble,
  	detach: Section_prototype_detach,
  	find: find,
  	findAll: findAll,
  	findAllComponents: findAllComponents,
  	findComponent: findComponent,
  	findNextNode: findNextNode,
  	firstNode: firstNode,
  	getIndexRef: function (name) {
  		if (this.indexRefs) {
  			var i = this.indexRefs.length;
  			while (i--) {
  				var ref = this.indexRefs[i];
  				if (ref.n === name) {
  					return ref;
  				}
  			}
  		}
  	},
  	getValue: Mustache.getValue,
  	shuffle: shuffle,
  	rebind: prototype_rebind,
  	render: Section_prototype_render,
  	resolve: Mustache.resolve,
  	setValue: setValue,
  	toString: prototype_toString,
  	unbind: prototype_unbind,
  	unrender: prototype_unrender,
  	update: prototype_update
  };

  var _Section = Section;

  var Triple_prototype_detach = Triple$detach;

  function Triple$detach() {
  	var len, i;

  	if (this.docFrag) {
  		len = this.nodes.length;
  		for (i = 0; i < len; i += 1) {
  			this.docFrag.appendChild(this.nodes[i]);
  		}

  		return this.docFrag;
  	}
  }

  var Triple_prototype_find = Triple$find;
  function Triple$find(selector) {
  	var i, len, node, queryResult;

  	len = this.nodes.length;
  	for (i = 0; i < len; i += 1) {
  		node = this.nodes[i];

  		if (node.nodeType !== 1) {
  			continue;
  		}

  		if (matches(node, selector)) {
  			return node;
  		}

  		if (queryResult = node.querySelector(selector)) {
  			return queryResult;
  		}
  	}

  	return null;
  }

  var Triple_prototype_findAll = Triple$findAll;
  function Triple$findAll(selector, queryResult) {
  	var i, len, node, queryAllResult, numNodes, j;

  	len = this.nodes.length;
  	for (i = 0; i < len; i += 1) {
  		node = this.nodes[i];

  		if (node.nodeType !== 1) {
  			continue;
  		}

  		if (matches(node, selector)) {
  			queryResult.push(node);
  		}

  		if (queryAllResult = node.querySelectorAll(selector)) {
  			numNodes = queryAllResult.length;
  			for (j = 0; j < numNodes; j += 1) {
  				queryResult.push(queryAllResult[j]);
  			}
  		}
  	}
  }

  var Triple_prototype_firstNode = Triple$firstNode;

  function Triple$firstNode() {
  	if (this.rendered && this.nodes[0]) {
  		return this.nodes[0];
  	}

  	return this.parentFragment.findNextNode(this);
  }

  var elementCache = {},
      ieBug,
      ieBlacklist;

  try {
  	createElement("table").innerHTML = "foo";
  } catch (err) {
  	ieBug = true;

  	ieBlacklist = {
  		TABLE: ["<table class=\"x\">", "</table>"],
  		THEAD: ["<table><thead class=\"x\">", "</thead></table>"],
  		TBODY: ["<table><tbody class=\"x\">", "</tbody></table>"],
  		TR: ["<table><tr class=\"x\">", "</tr></table>"],
  		SELECT: ["<select class=\"x\">", "</select>"]
  	};
  }

  var insertHtml = function (html, node, docFrag) {
  	var container,
  	    nodes = [],
  	    wrapper,
  	    selectedOption,
  	    child,
  	    i;

  	// render 0 and false
  	if (html != null && html !== "") {
  		if (ieBug && (wrapper = ieBlacklist[node.tagName])) {
  			container = element("DIV");
  			container.innerHTML = wrapper[0] + html + wrapper[1];
  			container = container.querySelector(".x");

  			if (container.tagName === "SELECT") {
  				selectedOption = container.options[container.selectedIndex];
  			}
  		} else if (node.namespaceURI === namespaces.svg) {
  			container = element("DIV");
  			container.innerHTML = "<svg class=\"x\">" + html + "</svg>";
  			container = container.querySelector(".x");
  		} else {
  			container = element(node.tagName);
  			container.innerHTML = html;

  			if (container.tagName === "SELECT") {
  				selectedOption = container.options[container.selectedIndex];
  			}
  		}

  		while (child = container.firstChild) {
  			nodes.push(child);
  			docFrag.appendChild(child);
  		}

  		// This is really annoying. Extracting <option> nodes from the
  		// temporary container <select> causes the remaining ones to
  		// become selected. So now we have to deselect them. IE8, you
  		// amaze me. You really do
  		// ...and now Chrome too
  		if (node.tagName === "SELECT") {
  			i = nodes.length;
  			while (i--) {
  				if (nodes[i] !== selectedOption) {
  					nodes[i].selected = false;
  				}
  			}
  		}
  	}

  	return nodes;
  };

  function element(tagName) {
  	return elementCache[tagName] || (elementCache[tagName] = createElement(tagName));
  }

  var helpers_updateSelect = updateSelect;

  function updateSelect(parentElement) {
  	var selectedOptions, option, value;

  	if (!parentElement || parentElement.name !== "select" || !parentElement.binding) {
  		return;
  	}

  	selectedOptions = toArray(parentElement.node.options).filter(isSelected);

  	// If one of them had a `selected` attribute, we need to sync
  	// the model to the view
  	if (parentElement.getAttribute("multiple")) {
  		value = selectedOptions.map(function (o) {
  			return o.value;
  		});
  	} else if (option = selectedOptions[0]) {
  		value = option.value;
  	}

  	if (value !== undefined) {
  		parentElement.binding.setValue(value);
  	}

  	parentElement.bubble();
  }

  function isSelected(option) {
  	return option.selected;
  }

  var Triple_prototype_render = Triple$render;
  function Triple$render() {
  	if (this.rendered) {
  		throw new Error("Attempted to render an item that was already rendered");
  	}

  	this.docFrag = document.createDocumentFragment();
  	this.nodes = insertHtml(this.value, this.parentFragment.getNode(), this.docFrag);

  	// Special case - we're inserting the contents of a <select>
  	helpers_updateSelect(this.pElement);

  	this.rendered = true;
  	return this.docFrag;
  }

  var prototype_setValue = Triple$setValue;
  function Triple$setValue(value) {
  	var wrapper;

  	// TODO is there a better way to approach this?
  	if (wrapper = this.root.viewmodel.wrapped[this.keypath.str]) {
  		value = wrapper.get();
  	}

  	if (value !== this.value) {
  		this.value = value;
  		this.parentFragment.bubble();

  		if (this.rendered) {
  			global_runloop.addView(this);
  		}
  	}
  }

  var Triple_prototype_toString = Triple$toString;
  function Triple$toString() {
  	return this.value != undefined ? decodeCharacterReferences("" + this.value) : "";
  }

  var Triple_prototype_unrender = Triple$unrender;
  function Triple$unrender(shouldDestroy) {
  	if (this.rendered && shouldDestroy) {
  		this.nodes.forEach(detachNode);
  		this.rendered = false;
  	}

  	// TODO update live queries
  }

  var Triple_prototype_update = Triple$update;
  function Triple$update() {
  	var node, parentNode;

  	if (!this.rendered) {
  		return;
  	}

  	// Remove existing nodes
  	while (this.nodes && this.nodes.length) {
  		node = this.nodes.pop();
  		node.parentNode.removeChild(node);
  	}

  	// Insert new nodes
  	parentNode = this.parentFragment.getNode();

  	this.nodes = insertHtml(this.value, parentNode, this.docFrag);
  	parentNode.insertBefore(this.docFrag, this.parentFragment.findNextNode(this));

  	// Special case - we're inserting the contents of a <select>
  	helpers_updateSelect(this.pElement);
  }

  var Triple = function (options) {
  	this.type = TRIPLE;
  	Mustache.init(this, options);
  };

  Triple.prototype = {
  	detach: Triple_prototype_detach,
  	find: Triple_prototype_find,
  	findAll: Triple_prototype_findAll,
  	firstNode: Triple_prototype_firstNode,
  	getValue: Mustache.getValue,
  	rebind: Mustache.rebind,
  	render: Triple_prototype_render,
  	resolve: Mustache.resolve,
  	setValue: prototype_setValue,
  	toString: Triple_prototype_toString,
  	unbind: shared_unbind,
  	unrender: Triple_prototype_unrender,
  	update: Triple_prototype_update
  };

  var _Triple = Triple;

  var Element_prototype_bubble = function () {
  	this.parentFragment.bubble();
  };

  var Element_prototype_detach = Element$detach;

  function Element$detach() {
  	var node = this.node,
  	    parentNode;

  	if (node) {
  		// need to check for parent node - DOM may have been altered
  		// by something other than Ractive! e.g. jQuery UI...
  		if (parentNode = node.parentNode) {
  			parentNode.removeChild(node);
  		}

  		return node;
  	}
  }

  var Element_prototype_find = function (selector) {
  	if (!this.node) {
  		// this element hasn't been rendered yet
  		return null;
  	}

  	if (matches(this.node, selector)) {
  		return this.node;
  	}

  	if (this.fragment && this.fragment.find) {
  		return this.fragment.find(selector);
  	}
  };

  var Element_prototype_findAll = function (selector, query) {
  	// Add this node to the query, if applicable, and register the
  	// query on this element
  	if (query._test(this, true) && query.live) {
  		(this.liveQueries || (this.liveQueries = [])).push(query);
  	}

  	if (this.fragment) {
  		this.fragment.findAll(selector, query);
  	}
  };

  var Element_prototype_findAllComponents = function (selector, query) {
  	if (this.fragment) {
  		this.fragment.findAllComponents(selector, query);
  	}
  };

  var Element_prototype_findComponent = function (selector) {
  	if (this.fragment) {
  		return this.fragment.findComponent(selector);
  	}
  };

  var Element_prototype_findNextNode = Element$findNextNode;

  function Element$findNextNode() {
  	return null;
  }

  var Element_prototype_firstNode = Element$firstNode;

  function Element$firstNode() {
  	return this.node;
  }

  var getAttribute = Element$getAttribute;

  function Element$getAttribute(name) {
  	if (!this.attributes || !this.attributes[name]) {
  		return;
  	}

  	return this.attributes[name].value;
  }

  var truthy = /^true|on|yes|1$/i;
  var processBindingAttributes__isNumeric = /^[0-9]+$/;

  var processBindingAttributes = function (element, template) {
  	var val, attrs, attributes;

  	attributes = template.a || {};
  	attrs = {};

  	// attributes that are present but don't have a value (=)
  	// will be set to the number 0, which we condider to be true
  	// the string '0', however is false

  	val = attributes.twoway;
  	if (val !== undefined) {
  		attrs.twoway = val === 0 || truthy.test(val);
  	}

  	val = attributes.lazy;
  	if (val !== undefined) {
  		// check for timeout value
  		if (val !== 0 && processBindingAttributes__isNumeric.test(val)) {
  			attrs.lazy = parseInt(val);
  		} else {
  			attrs.lazy = val === 0 || truthy.test(val);
  		}
  	}

  	return attrs;
  };

  var Attribute_prototype_bubble = Attribute$bubble;
  function Attribute$bubble() {
  	var value = this.useProperty || !this.rendered ? this.fragment.getValue() : this.fragment.toString();

  	// TODO this can register the attribute multiple times (see render test
  	// 'Attribute with nested mustaches')
  	if (!isEqual(value, this.value)) {

  		// Need to clear old id from ractive.nodes
  		if (this.name === "id" && this.value) {
  			delete this.root.nodes[this.value];
  		}

  		this.value = value;

  		if (this.name === "value" && this.node) {
  			// We need to store the value on the DOM like this so we
  			// can retrieve it later without it being coerced to a string
  			this.node._ractive.value = value;
  		}

  		if (this.rendered) {
  			global_runloop.addView(this);
  		}
  	}
  }

  var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;
  svgCamelCaseElements = "altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern".split(" ");
  svgCamelCaseAttributes = "attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan".split(" ");

  createMap = function (items) {
  	var map = {},
  	    i = items.length;
  	while (i--) {
  		map[items[i].toLowerCase()] = items[i];
  	}
  	return map;
  };

  map = createMap(svgCamelCaseElements.concat(svgCamelCaseAttributes));

  var enforceCase = function (elementName) {
  	var lowerCaseElementName = elementName.toLowerCase();
  	return map[lowerCaseElementName] || lowerCaseElementName;
  };

  var determineNameAndNamespace = function (attribute, name) {
  	var colonIndex, namespacePrefix;

  	// are we dealing with a namespaced attribute, e.g. xlink:href?
  	colonIndex = name.indexOf(":");
  	if (colonIndex !== -1) {

  		// looks like we are, yes...
  		namespacePrefix = name.substr(0, colonIndex);

  		// ...unless it's a namespace *declaration*, which we ignore (on the assumption
  		// that only valid namespaces will be used)
  		if (namespacePrefix !== "xmlns") {
  			name = name.substring(colonIndex + 1);

  			attribute.name = enforceCase(name);
  			attribute.namespace = namespaces[namespacePrefix.toLowerCase()];
  			attribute.namespacePrefix = namespacePrefix;

  			if (!attribute.namespace) {
  				throw "Unknown namespace (\"" + namespacePrefix + "\")";
  			}

  			return;
  		}
  	}

  	// SVG attribute names are case sensitive
  	attribute.name = attribute.element.namespace !== namespaces.html ? enforceCase(name) : name;
  };

  var helpers_getInterpolator = getInterpolator;
  function getInterpolator(attribute) {
  	var items = attribute.fragment.items;

  	if (items.length !== 1) {
  		return;
  	}

  	if (items[0].type === INTERPOLATOR) {
  		return items[0];
  	}
  }

  var prototype_init = Attribute$init;
  function Attribute$init(options) {
  	this.type = ATTRIBUTE;
  	this.element = options.element;
  	this.root = options.root;

  	determineNameAndNamespace(this, options.name);
  	this.isBoolean = booleanAttributes.test(this.name);

  	// if it's an empty attribute, or just a straight key-value pair, with no
  	// mustache shenanigans, set the attribute accordingly and go home
  	if (!options.value || typeof options.value === "string") {
  		this.value = this.isBoolean ? true : options.value || "";
  		return;
  	}

  	// otherwise we need to do some work

  	// share parentFragment with parent element
  	this.parentFragment = this.element.parentFragment;

  	this.fragment = new virtualdom_Fragment({
  		template: options.value,
  		root: this.root,
  		owner: this
  	});

  	// TODO can we use this.fragment.toString() in some cases? It's quicker
  	this.value = this.fragment.getValue();

  	// Store a reference to this attribute's interpolator, if its fragment
  	// takes the form `{{foo}}`. This is necessary for two-way binding and
  	// for correctly rendering HTML later
  	this.interpolator = helpers_getInterpolator(this);
  	this.isBindable = !!this.interpolator && !this.interpolator.isStatic;

  	// mark as ready
  	this.ready = true;
  }

  var Attribute_prototype_rebind = Attribute$rebind;

  function Attribute$rebind(oldKeypath, newKeypath) {
  	if (this.fragment) {
  		this.fragment.rebind(oldKeypath, newKeypath);
  	}
  }

  var Attribute_prototype_render = Attribute$render;
  var propertyNames = {
  	"accept-charset": "acceptCharset",
  	accesskey: "accessKey",
  	bgcolor: "bgColor",
  	"class": "className",
  	codebase: "codeBase",
  	colspan: "colSpan",
  	contenteditable: "contentEditable",
  	datetime: "dateTime",
  	dirname: "dirName",
  	"for": "htmlFor",
  	"http-equiv": "httpEquiv",
  	ismap: "isMap",
  	maxlength: "maxLength",
  	novalidate: "noValidate",
  	pubdate: "pubDate",
  	readonly: "readOnly",
  	rowspan: "rowSpan",
  	tabindex: "tabIndex",
  	usemap: "useMap"
  };
  function Attribute$render(node) {
  	var propertyName;

  	this.node = node;

  	// should we use direct property access, or setAttribute?
  	if (!node.namespaceURI || node.namespaceURI === namespaces.html) {
  		propertyName = propertyNames[this.name] || this.name;

  		if (node[propertyName] !== undefined) {
  			this.propertyName = propertyName;
  		}

  		// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
  		// node.selected = true rather than node.setAttribute( 'selected', '' )
  		if (this.isBoolean || this.isTwoway) {
  			this.useProperty = true;
  		}

  		if (propertyName === "value") {
  			node._ractive.value = this.value;
  		}
  	}

  	this.rendered = true;
  	this.update();
  }

  var Attribute_prototype_toString = Attribute$toString;

  function Attribute$toString() {
  	var _ref = this;

  	var name = _ref.name;
  	var namespacePrefix = _ref.namespacePrefix;
  	var value = _ref.value;
  	var interpolator = _ref.interpolator;
  	var fragment = _ref.fragment;

  	// Special case - select and textarea values (should not be stringified)
  	if (name === "value" && (this.element.name === "select" || this.element.name === "textarea")) {
  		return;
  	}

  	// Special case - content editable
  	if (name === "value" && this.element.getAttribute("contenteditable") !== undefined) {
  		return;
  	}

  	// Special case - radio names
  	if (name === "name" && this.element.name === "input" && interpolator) {
  		return "name={{" + (interpolator.keypath.str || interpolator.ref) + "}}";
  	}

  	// Boolean attributes
  	if (this.isBoolean) {
  		return value ? name : "";
  	}

  	if (fragment) {
  		// special case - this catches undefined/null values (#1211)
  		if (fragment.items.length === 1 && fragment.items[0].value == null) {
  			return "";
  		}

  		value = fragment.toString();
  	}

  	if (namespacePrefix) {
  		name = namespacePrefix + ":" + name;
  	}

  	return value ? name + "=\"" + Attribute_prototype_toString__escape(value) + "\"" : name;
  }

  function Attribute_prototype_toString__escape(value) {
  	return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
  }

  var Attribute_prototype_unbind = Attribute$unbind;

  function Attribute$unbind() {
  	// ignore non-dynamic attributes
  	if (this.fragment) {
  		this.fragment.unbind();
  	}

  	if (this.name === "id") {
  		delete this.root.nodes[this.value];
  	}
  }

  var updateSelectValue = Attribute$updateSelect;

  function Attribute$updateSelect() {
  	var value = this.value,
  	    options,
  	    option,
  	    optionValue,
  	    i;

  	if (!this.locked) {
  		this.node._ractive.value = value;

  		options = this.node.options;
  		i = options.length;

  		while (i--) {
  			option = options[i];
  			optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive

  			if (optionValue == value) {
  				// double equals as we may be comparing numbers with strings
  				option.selected = true;
  				break;
  			}
  		}
  	}

  	// if we're still here, it means the new value didn't match any of the options...
  	// TODO figure out what to do in this situation
  }

  var updateMultipleSelectValue = Attribute$updateMultipleSelect;
  function Attribute$updateMultipleSelect() {
  	var value = this.value,
  	    options,
  	    i,
  	    option,
  	    optionValue;

  	if (!isArray(value)) {
  		value = [value];
  	}

  	options = this.node.options;
  	i = options.length;

  	while (i--) {
  		option = options[i];
  		optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive
  		option.selected = arrayContains(value, optionValue);
  	}
  }

  var updateRadioName = Attribute$updateRadioName;

  function Attribute$updateRadioName() {
  	var _ref = this;

  	var node = _ref.node;
  	var value = _ref.value;

  	node.checked = value == node._ractive.value;
  }

  var updateRadioValue = Attribute$updateRadioValue;
  function Attribute$updateRadioValue() {
  	var wasChecked,
  	    node = this.node,
  	    binding,
  	    bindings,
  	    i;

  	wasChecked = node.checked;

  	node.value = this.element.getAttribute("value");
  	node.checked = this.element.getAttribute("value") === this.element.getAttribute("name");

  	// This is a special case - if the input was checked, and the value
  	// changed so that it's no longer checked, the twoway binding is
  	// most likely out of date. To fix it we have to jump through some
  	// hoops... this is a little kludgy but it works
  	if (wasChecked && !node.checked && this.element.binding) {
  		bindings = this.element.binding.siblings;

  		if (i = bindings.length) {
  			while (i--) {
  				binding = bindings[i];

  				if (!binding.element.node) {
  					// this is the initial render, siblings are still rendering!
  					// we'll come back later...
  					return;
  				}

  				if (binding.element.node.checked) {
  					global_runloop.addRactive(binding.root);
  					return binding.handleChange();
  				}
  			}

  			this.root.viewmodel.set(binding.keypath, undefined);
  		}
  	}
  }

  var updateCheckboxName = Attribute$updateCheckboxName;
  function Attribute$updateCheckboxName() {
  	var _ref = this;

  	var element = _ref.element;
  	var node = _ref.node;
  	var value = _ref.value;var binding = element.binding;var valueAttribute;var i;

  	valueAttribute = element.getAttribute("value");

  	if (!isArray(value)) {
  		binding.isChecked = node.checked = value == valueAttribute;
  	} else {
  		i = value.length;
  		while (i--) {
  			if (valueAttribute == value[i]) {
  				binding.isChecked = node.checked = true;
  				return;
  			}
  		}
  		binding.isChecked = node.checked = false;
  	}
  }

  var updateClassName = Attribute$updateClassName;
  function Attribute$updateClassName() {
  	this.node.className = safeToStringValue(this.value);
  }

  var updateIdAttribute = Attribute$updateIdAttribute;

  function Attribute$updateIdAttribute() {
  	var _ref = this;

  	var node = _ref.node;
  	var value = _ref.value;

  	this.root.nodes[value] = node;
  	node.id = value;
  }

  var updateIEStyleAttribute = Attribute$updateIEStyleAttribute;

  function Attribute$updateIEStyleAttribute() {
  	var node, value;

  	node = this.node;
  	value = this.value;

  	if (value === undefined) {
  		value = "";
  	}

  	node.style.setAttribute("cssText", value);
  }

  var updateContentEditableValue = Attribute$updateContentEditableValue;

  function Attribute$updateContentEditableValue() {
  	var value = this.value;

  	if (value === undefined) {
  		value = "";
  	}

  	if (!this.locked) {
  		this.node.innerHTML = value;
  	}
  }

  var updateValue = Attribute$updateValue;

  function Attribute$updateValue() {
  	var _ref = this;

  	var node = _ref.node;
  	var value = _ref.value;

  	// store actual value, so it doesn't get coerced to a string
  	node._ractive.value = value;

  	// with two-way binding, only update if the change wasn't initiated by the user
  	// otherwise the cursor will often be sent to the wrong place
  	if (!this.locked) {
  		node.value = value == undefined ? "" : value;
  	}
  }

  var updateBoolean = Attribute$updateBooleanAttribute;

  function Attribute$updateBooleanAttribute() {
  	// with two-way binding, only update if the change wasn't initiated by the user
  	// otherwise the cursor will often be sent to the wrong place
  	if (!this.locked) {
  		this.node[this.propertyName] = this.value;
  	}
  }

  var updateEverythingElse = Attribute$updateEverythingElse;

  function Attribute$updateEverythingElse() {
  	var _ref = this;

  	var node = _ref.node;
  	var namespace = _ref.namespace;
  	var name = _ref.name;
  	var value = _ref.value;
  	var fragment = _ref.fragment;

  	if (namespace) {
  		node.setAttributeNS(namespace, name, (fragment || value).toString());
  	} else if (!this.isBoolean) {
  		if (value == null) {
  			node.removeAttribute(name);
  		} else {
  			node.setAttribute(name, (fragment || value).toString());
  		}
  	}

  	// Boolean attributes - truthy becomes '', falsy means 'remove attribute'
  	else {
  		if (value) {
  			node.setAttribute(name, "");
  		} else {
  			node.removeAttribute(name);
  		}
  	}
  }

  // There are a few special cases when it comes to updating attributes. For this reason,
  // the prototype .update() method points to this method, which waits until the
  // attribute has finished initialising, then replaces the prototype method with a more
  // suitable one. That way, we save ourselves doing a bunch of tests on each call
  var Attribute_prototype_update = Attribute$update;
  function Attribute$update() {
  	var _ref = this;

  	var name = _ref.name;
  	var element = _ref.element;
  	var node = _ref.node;var type;var updateMethod;

  	if (name === "id") {
  		updateMethod = updateIdAttribute;
  	} else if (name === "value") {
  		// special case - selects
  		if (element.name === "select" && name === "value") {
  			updateMethod = element.getAttribute("multiple") ? updateMultipleSelectValue : updateSelectValue;
  		} else if (element.name === "textarea") {
  			updateMethod = updateValue;
  		}

  		// special case - contenteditable
  		else if (element.getAttribute("contenteditable") != null) {
  			updateMethod = updateContentEditableValue;
  		}

  		// special case - <input>
  		else if (element.name === "input") {
  			type = element.getAttribute("type");

  			// type='file' value='{{fileList}}'>
  			if (type === "file") {
  				updateMethod = noop; // read-only
  			}

  			// type='radio' name='{{twoway}}'
  			else if (type === "radio" && element.binding && element.binding.name === "name") {
  				updateMethod = updateRadioValue;
  			} else {
  				updateMethod = updateValue;
  			}
  		}
  	}

  	// special case - <input type='radio' name='{{twoway}}' value='foo'>
  	else if (this.isTwoway && name === "name") {
  		if (node.type === "radio") {
  			updateMethod = updateRadioName;
  		} else if (node.type === "checkbox") {
  			updateMethod = updateCheckboxName;
  		}
  	}

  	// special case - style attributes in Internet Exploder
  	else if (name === "style" && node.style.setAttribute) {
  		updateMethod = updateIEStyleAttribute;
  	}

  	// special case - class names. IE fucks things up, again
  	else if (name === "class" && (!node.namespaceURI || node.namespaceURI === namespaces.html)) {
  		updateMethod = updateClassName;
  	} else if (this.useProperty) {
  		updateMethod = updateBoolean;
  	}

  	if (!updateMethod) {
  		updateMethod = updateEverythingElse;
  	}

  	this.update = updateMethod;
  	this.update();
  }

  var Attribute = function (options) {
  	this.init(options);
  };

  Attribute.prototype = {
  	bubble: Attribute_prototype_bubble,
  	init: prototype_init,
  	rebind: Attribute_prototype_rebind,
  	render: Attribute_prototype_render,
  	toString: Attribute_prototype_toString,
  	unbind: Attribute_prototype_unbind,
  	update: Attribute_prototype_update
  };

  var _Attribute = Attribute;

  var createAttributes = function (element, attributes) {
  	var name,
  	    attribute,
  	    result = [];

  	for (name in attributes) {
  		// skip binding attributes
  		if (name === "twoway" || name === "lazy") {
  			continue;
  		}

  		if (attributes.hasOwnProperty(name)) {
  			attribute = new _Attribute({
  				element: element,
  				name: name,
  				value: attributes[name],
  				root: element.root
  			});

  			result[name] = attribute;

  			if (name !== "value") {
  				result.push(attribute);
  			}
  		}
  	}

  	// value attribute goes last. This is because it
  	// may get clamped on render otherwise, e.g. in
  	// `<input type='range' value='999' min='0' max='1000'>`
  	// since default max is 100
  	if (attribute = result.value) {
  		result.push(attribute);
  	}

  	return result;
  };

  var _ConditionalAttribute__div;

  if (typeof document !== "undefined") {
  	_ConditionalAttribute__div = createElement("div");
  }

  var ConditionalAttribute = function (element, template) {
  	this.element = element;
  	this.root = element.root;
  	this.parentFragment = element.parentFragment;

  	this.attributes = [];

  	this.fragment = new virtualdom_Fragment({
  		root: element.root,
  		owner: this,
  		template: [template]
  	});
  };

  ConditionalAttribute.prototype = {
  	bubble: function () {
  		if (this.node) {
  			this.update();
  		}

  		this.element.bubble();
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		this.fragment.rebind(oldKeypath, newKeypath);
  	},

  	render: function (node) {
  		this.node = node;
  		this.isSvg = node.namespaceURI === namespaces.svg;

  		this.update();
  	},

  	unbind: function () {
  		this.fragment.unbind();
  	},

  	update: function () {
  		var _this = this;

  		var str, attrs;

  		str = this.fragment.toString();
  		attrs = parseAttributes(str, this.isSvg);

  		// any attributes that previously existed but no longer do
  		// must be removed
  		this.attributes.filter(function (a) {
  			return notIn(attrs, a);
  		}).forEach(function (a) {
  			_this.node.removeAttribute(a.name);
  		});

  		attrs.forEach(function (a) {
  			_this.node.setAttribute(a.name, a.value);
  		});

  		this.attributes = attrs;
  	},

  	toString: function () {
  		return this.fragment.toString();
  	}
  };

  var _ConditionalAttribute = ConditionalAttribute;

  function parseAttributes(str, isSvg) {
  	var tag = isSvg ? "svg" : "div";
  	_ConditionalAttribute__div.innerHTML = "<" + tag + " " + str + "></" + tag + ">";

  	return toArray(_ConditionalAttribute__div.childNodes[0].attributes);
  }

  function notIn(haystack, needle) {
  	var i = haystack.length;

  	while (i--) {
  		if (haystack[i].name === needle.name) {
  			return false;
  		}
  	}

  	return true;
  }

  var createConditionalAttributes = function (element, attributes) {
  	if (!attributes) {
  		return [];
  	}

  	return attributes.map(function (a) {
  		return new _ConditionalAttribute(element, a);
  	});
  };

  var Binding = function (element) {
  	var interpolator, keypath, value, parentForm;

  	this.element = element;
  	this.root = element.root;
  	this.attribute = element.attributes[this.name || "value"];

  	interpolator = this.attribute.interpolator;
  	interpolator.twowayBinding = this;

  	if (keypath = interpolator.keypath) {
  		if (keypath.str.slice(-1) === "}") {
  			warnOnceIfDebug("Two-way binding does not work with expressions (`%s` on <%s>)", interpolator.resolver.uniqueString, element.name, { ractive: this.root });
  			return false;
  		}

  		if (keypath.isSpecial) {
  			warnOnceIfDebug("Two-way binding does not work with %s", interpolator.resolver.ref, { ractive: this.root });
  			return false;
  		}
  	} else {
  		// A mustache may be *ambiguous*. Let's say we were given
  		// `value="{{bar}}"`. If the context was `foo`, and `foo.bar`
  		// *wasn't* `undefined`, the keypath would be `foo.bar`.
  		// Then, any user input would result in `foo.bar` being updated.
  		//
  		// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be
  		// left with an unresolved partial keypath - so we are forced to make an
  		// assumption. That assumption is that the input in question should
  		// be forced to resolve to `bar`, and any user input would affect `bar`
  		// and not `foo.bar`.
  		//
  		// Did that make any sense? No? Oh. Sorry. Well the moral of the story is
  		// be explicit when using two-way data-binding about what keypath you're
  		// updating. Using it in lists is probably a recipe for confusion...
  		var ref = interpolator.template.r ? "'" + interpolator.template.r + "' reference" : "expression";
  		warnIfDebug("The %s being used for two-way binding is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity", ref, { ractive: this.root });
  		interpolator.resolver.forceResolution();
  		keypath = interpolator.keypath;
  	}

  	this.attribute.isTwoway = true;
  	this.keypath = keypath;

  	// initialise value, if it's undefined
  	value = this.root.viewmodel.get(keypath);

  	if (value === undefined && this.getInitialValue) {
  		value = this.getInitialValue();

  		if (value !== undefined) {
  			this.root.viewmodel.set(keypath, value);
  		}
  	}

  	if (parentForm = findParentForm(element)) {
  		this.resetValue = value;
  		parentForm.formBindings.push(this);
  	}
  };

  Binding.prototype = {
  	handleChange: function () {
  		var _this = this;

  		global_runloop.start(this.root);
  		this.attribute.locked = true;
  		this.root.viewmodel.set(this.keypath, this.getValue());
  		global_runloop.scheduleTask(function () {
  			return _this.attribute.locked = false;
  		});
  		global_runloop.end();
  	},

  	rebound: function () {
  		var bindings, oldKeypath, newKeypath;

  		oldKeypath = this.keypath;
  		newKeypath = this.attribute.interpolator.keypath;

  		// The attribute this binding is linked to has already done the work
  		if (oldKeypath === newKeypath) {
  			return;
  		}

  		removeFromArray(this.root._twowayBindings[oldKeypath.str], this);

  		this.keypath = newKeypath;

  		bindings = this.root._twowayBindings[newKeypath.str] || (this.root._twowayBindings[newKeypath.str] = []);
  		bindings.push(this);
  	},

  	unbind: function () {}
  };

  Binding.extend = function (properties) {
  	var Parent = this,
  	    SpecialisedBinding;

  	SpecialisedBinding = function (element) {
  		Binding.call(this, element);

  		if (this.init) {
  			this.init();
  		}
  	};

  	SpecialisedBinding.prototype = create(Parent.prototype);
  	utils_object__extend(SpecialisedBinding.prototype, properties);

  	SpecialisedBinding.extend = Binding.extend;

  	return SpecialisedBinding;
  };

  var Binding_Binding = Binding;

  function findParentForm(element) {
  	while (element = element.parent) {
  		if (element.name === "form") {
  			return element;
  		}
  	}
  }

  // this is called when the element is unbound.
  // Specialised bindings can override it

  // This is the handler for DOM events that would lead to a change in the model
  // (i.e. change, sometimes, input, and occasionally click and keyup)
  var handleDomEvent = handleChange;

  function handleChange() {
  	this._ractive.binding.handleChange();
  }

  var GenericBinding;

  GenericBinding = Binding_Binding.extend({
  	getInitialValue: function () {
  		return "";
  	},

  	getValue: function () {
  		return this.element.node.value;
  	},

  	render: function () {
  		var node = this.element.node,
  		    lazy,
  		    timeout = false;
  		this.rendered = true;

  		// any lazy setting for this element overrides the root
  		// if the value is a number, it's a timeout
  		lazy = this.root.lazy;
  		if (this.element.lazy === true) {
  			lazy = true;
  		} else if (this.element.lazy === false) {
  			lazy = false;
  		} else if (is__isNumeric(this.element.lazy)) {
  			lazy = false;
  			timeout = +this.element.lazy;
  		} else if (is__isNumeric(lazy || "")) {
  			timeout = +lazy;
  			lazy = false;

  			// make sure the timeout is available to the handler
  			this.element.lazy = timeout;
  		}

  		this.handler = timeout ? handleDelay : handleDomEvent;

  		node.addEventListener("change", handleDomEvent, false);

  		if (!lazy) {
  			node.addEventListener("input", this.handler, false);

  			if (node.attachEvent) {
  				node.addEventListener("keyup", this.handler, false);
  			}
  		}

  		node.addEventListener("blur", handleBlur, false);
  	},

  	unrender: function () {
  		var node = this.element.node;
  		this.rendered = false;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("input", this.handler, false);
  		node.removeEventListener("keyup", this.handler, false);
  		node.removeEventListener("blur", handleBlur, false);
  	}
  });

  var Binding_GenericBinding = GenericBinding;

  function handleBlur() {
  	var value;

  	handleDomEvent.call(this);

  	value = this._ractive.root.viewmodel.get(this._ractive.binding.keypath);
  	this.value = value == undefined ? "" : value;
  }

  function handleDelay() {
  	var binding = this._ractive.binding,
  	    el = this;

  	if (!!binding._timeout) clearTimeout(binding._timeout);

  	binding._timeout = setTimeout(function () {
  		if (binding.rendered) handleDomEvent.call(el);
  		binding._timeout = undefined;
  	}, binding.element.lazy);
  }

  var ContentEditableBinding = Binding_GenericBinding.extend({
  	getInitialValue: function () {
  		return this.element.fragment ? this.element.fragment.toString() : "";
  	},

  	getValue: function () {
  		return this.element.node.innerHTML;
  	}
  });

  var Binding_ContentEditableBinding = ContentEditableBinding;

  var shared_getSiblings = getSiblings;
  var sets = {};
  function getSiblings(id, group, keypath) {
  	var hash = id + group + keypath;
  	return sets[hash] || (sets[hash] = []);
  }

  var RadioBinding = Binding_Binding.extend({
  	name: "checked",

  	init: function () {
  		this.siblings = shared_getSiblings(this.root._guid, "radio", this.element.getAttribute("name"));
  		this.siblings.push(this);
  	},

  	render: function () {
  		var node = this.element.node;

  		node.addEventListener("change", handleDomEvent, false);

  		if (node.attachEvent) {
  			node.addEventListener("click", handleDomEvent, false);
  		}
  	},

  	unrender: function () {
  		var node = this.element.node;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("click", handleDomEvent, false);
  	},

  	handleChange: function () {
  		global_runloop.start(this.root);

  		this.siblings.forEach(function (binding) {
  			binding.root.viewmodel.set(binding.keypath, binding.getValue());
  		});

  		global_runloop.end();
  	},

  	getValue: function () {
  		return this.element.node.checked;
  	},

  	unbind: function () {
  		removeFromArray(this.siblings, this);
  	}
  });

  var Binding_RadioBinding = RadioBinding;

  var RadioNameBinding = Binding_Binding.extend({
  	name: "name",

  	init: function () {
  		this.siblings = shared_getSiblings(this.root._guid, "radioname", this.keypath.str);
  		this.siblings.push(this);

  		this.radioName = true; // so that ractive.updateModel() knows what to do with this
  	},

  	getInitialValue: function () {
  		if (this.element.getAttribute("checked")) {
  			return this.element.getAttribute("value");
  		}
  	},

  	render: function () {
  		var node = this.element.node;

  		node.name = "{{" + this.keypath.str + "}}";
  		node.checked = this.root.viewmodel.get(this.keypath) == this.element.getAttribute("value");

  		node.addEventListener("change", handleDomEvent, false);

  		if (node.attachEvent) {
  			node.addEventListener("click", handleDomEvent, false);
  		}
  	},

  	unrender: function () {
  		var node = this.element.node;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("click", handleDomEvent, false);
  	},

  	getValue: function () {
  		var node = this.element.node;
  		return node._ractive ? node._ractive.value : node.value;
  	},

  	handleChange: function () {
  		// If this <input> is the one that's checked, then the value of its
  		// `name` keypath gets set to its value
  		if (this.element.node.checked) {
  			Binding_Binding.prototype.handleChange.call(this);
  		}
  	},

  	rebound: function (oldKeypath, newKeypath) {
  		var node;

  		Binding_Binding.prototype.rebound.call(this, oldKeypath, newKeypath);

  		if (node = this.element.node) {
  			node.name = "{{" + this.keypath.str + "}}";
  		}
  	},

  	unbind: function () {
  		removeFromArray(this.siblings, this);
  	}
  });

  var Binding_RadioNameBinding = RadioNameBinding;

  var CheckboxNameBinding = Binding_Binding.extend({
  	name: "name",

  	getInitialValue: function () {
  		// This only gets called once per group (of inputs that
  		// share a name), because it only gets called if there
  		// isn't an initial value. By the same token, we can make
  		// a note of that fact that there was no initial value,
  		// and populate it using any `checked` attributes that
  		// exist (which users should avoid, but which we should
  		// support anyway to avoid breaking expectations)
  		this.noInitialValue = true;
  		return [];
  	},

  	init: function () {
  		var existingValue, bindingValue;

  		this.checkboxName = true; // so that ractive.updateModel() knows what to do with this

  		// Each input has a reference to an array containing it and its
  		// siblings, as two-way binding depends on being able to ascertain
  		// the status of all inputs within the group
  		this.siblings = shared_getSiblings(this.root._guid, "checkboxes", this.keypath.str);
  		this.siblings.push(this);

  		if (this.noInitialValue) {
  			this.siblings.noInitialValue = true;
  		}

  		// If no initial value was set, and this input is checked, we
  		// update the model
  		if (this.siblings.noInitialValue && this.element.getAttribute("checked")) {
  			existingValue = this.root.viewmodel.get(this.keypath);
  			bindingValue = this.element.getAttribute("value");

  			existingValue.push(bindingValue);
  		}
  	},

  	unbind: function () {
  		removeFromArray(this.siblings, this);
  	},

  	render: function () {
  		var node = this.element.node,
  		    existingValue,
  		    bindingValue;

  		existingValue = this.root.viewmodel.get(this.keypath);
  		bindingValue = this.element.getAttribute("value");

  		if (isArray(existingValue)) {
  			this.isChecked = arrayContains(existingValue, bindingValue);
  		} else {
  			this.isChecked = existingValue == bindingValue;
  		}

  		node.name = "{{" + this.keypath.str + "}}";
  		node.checked = this.isChecked;

  		node.addEventListener("change", handleDomEvent, false);

  		// in case of IE emergency, bind to click event as well
  		if (node.attachEvent) {
  			node.addEventListener("click", handleDomEvent, false);
  		}
  	},

  	unrender: function () {
  		var node = this.element.node;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("click", handleDomEvent, false);
  	},

  	changed: function () {
  		var wasChecked = !!this.isChecked;
  		this.isChecked = this.element.node.checked;
  		return this.isChecked === wasChecked;
  	},

  	handleChange: function () {
  		this.isChecked = this.element.node.checked;
  		Binding_Binding.prototype.handleChange.call(this);
  	},

  	getValue: function () {
  		return this.siblings.filter(isChecked).map(Binding_CheckboxNameBinding__getValue);
  	}
  });

  function isChecked(binding) {
  	return binding.isChecked;
  }

  function Binding_CheckboxNameBinding__getValue(binding) {
  	return binding.element.getAttribute("value");
  }

  var Binding_CheckboxNameBinding = CheckboxNameBinding;

  var CheckboxBinding = Binding_Binding.extend({
  	name: "checked",

  	render: function () {
  		var node = this.element.node;

  		node.addEventListener("change", handleDomEvent, false);

  		if (node.attachEvent) {
  			node.addEventListener("click", handleDomEvent, false);
  		}
  	},

  	unrender: function () {
  		var node = this.element.node;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("click", handleDomEvent, false);
  	},

  	getValue: function () {
  		return this.element.node.checked;
  	}
  });

  var Binding_CheckboxBinding = CheckboxBinding;

  var SelectBinding = Binding_Binding.extend({
  	getInitialValue: function () {
  		var options = this.element.options,
  		    len,
  		    i,
  		    value,
  		    optionWasSelected;

  		if (this.element.getAttribute("value") !== undefined) {
  			return;
  		}

  		i = len = options.length;

  		if (!len) {
  			return;
  		}

  		// take the final selected option...
  		while (i--) {
  			if (options[i].getAttribute("selected")) {
  				value = options[i].getAttribute("value");
  				optionWasSelected = true;
  				break;
  			}
  		}

  		// or the first non-disabled option, if none are selected
  		if (!optionWasSelected) {
  			while (++i < len) {
  				if (!options[i].getAttribute("disabled")) {
  					value = options[i].getAttribute("value");
  					break;
  				}
  			}
  		}

  		// This is an optimisation (aka hack) that allows us to forgo some
  		// other more expensive work
  		if (value !== undefined) {
  			this.element.attributes.value.value = value;
  		}

  		return value;
  	},

  	render: function () {
  		this.element.node.addEventListener("change", handleDomEvent, false);
  	},

  	unrender: function () {
  		this.element.node.removeEventListener("change", handleDomEvent, false);
  	},

  	// TODO this method is an anomaly... is it necessary?
  	setValue: function (value) {
  		this.root.viewmodel.set(this.keypath, value);
  	},

  	getValue: function () {
  		var options, i, len, option, optionValue;

  		options = this.element.node.options;
  		len = options.length;

  		for (i = 0; i < len; i += 1) {
  			option = options[i];

  			if (options[i].selected) {
  				optionValue = option._ractive ? option._ractive.value : option.value;
  				return optionValue;
  			}
  		}
  	},

  	forceUpdate: function () {
  		var _this = this;

  		var value = this.getValue();

  		if (value !== undefined) {
  			this.attribute.locked = true;
  			global_runloop.scheduleTask(function () {
  				return _this.attribute.locked = false;
  			});
  			this.root.viewmodel.set(this.keypath, value);
  		}
  	}
  });

  var Binding_SelectBinding = SelectBinding;

  var MultipleSelectBinding = Binding_SelectBinding.extend({
  	getInitialValue: function () {
  		return this.element.options.filter(function (option) {
  			return option.getAttribute("selected");
  		}).map(function (option) {
  			return option.getAttribute("value");
  		});
  	},

  	render: function () {
  		var valueFromModel;

  		this.element.node.addEventListener("change", handleDomEvent, false);

  		valueFromModel = this.root.viewmodel.get(this.keypath);

  		if (valueFromModel === undefined) {
  			// get value from DOM, if possible
  			this.handleChange();
  		}
  	},

  	unrender: function () {
  		this.element.node.removeEventListener("change", handleDomEvent, false);
  	},

  	setValue: function () {
  		throw new Error("TODO not implemented yet");
  	},

  	getValue: function () {
  		var selectedValues, options, i, len, option, optionValue;

  		selectedValues = [];
  		options = this.element.node.options;
  		len = options.length;

  		for (i = 0; i < len; i += 1) {
  			option = options[i];

  			if (option.selected) {
  				optionValue = option._ractive ? option._ractive.value : option.value;
  				selectedValues.push(optionValue);
  			}
  		}

  		return selectedValues;
  	},

  	handleChange: function () {
  		var attribute, previousValue, value;

  		attribute = this.attribute;
  		previousValue = attribute.value;

  		value = this.getValue();

  		if (previousValue === undefined || !arrayContentsMatch(value, previousValue)) {
  			Binding_SelectBinding.prototype.handleChange.call(this);
  		}

  		return this;
  	},

  	forceUpdate: function () {
  		var _this = this;

  		var value = this.getValue();

  		if (value !== undefined) {
  			this.attribute.locked = true;
  			global_runloop.scheduleTask(function () {
  				return _this.attribute.locked = false;
  			});
  			this.root.viewmodel.set(this.keypath, value);
  		}
  	},

  	updateModel: function () {
  		if (this.attribute.value === undefined || !this.attribute.value.length) {
  			this.root.viewmodel.set(this.keypath, this.initialValue);
  		}
  	}
  });

  var Binding_MultipleSelectBinding = MultipleSelectBinding;

  var FileListBinding = Binding_Binding.extend({
  	render: function () {
  		this.element.node.addEventListener("change", handleDomEvent, false);
  	},

  	unrender: function () {
  		this.element.node.removeEventListener("change", handleDomEvent, false);
  	},

  	getValue: function () {
  		return this.element.node.files;
  	}
  });

  var Binding_FileListBinding = FileListBinding;

  var NumericBinding = Binding_GenericBinding.extend({
  	getInitialValue: function () {
  		return undefined;
  	},

  	getValue: function () {
  		var value = parseFloat(this.element.node.value);
  		return isNaN(value) ? undefined : value;
  	}
  });

  var init_createTwowayBinding = createTwowayBinding;

  function createTwowayBinding(element) {
  	var attributes = element.attributes,
  	    type,
  	    Binding,
  	    bindName,
  	    bindChecked,
  	    binding;

  	// if this is a late binding, and there's already one, it
  	// needs to be torn down
  	if (element.binding) {
  		element.binding.teardown();
  		element.binding = null;
  	}

  	// contenteditable
  	if (
  	// if the contenteditable attribute is true or is bindable and may thus become true
  	(element.getAttribute("contenteditable") || !!attributes.contenteditable && isBindable(attributes.contenteditable)) && isBindable(attributes.value)) {
  		Binding = Binding_ContentEditableBinding;
  	}

  	// <input>
  	else if (element.name === "input") {
  		type = element.getAttribute("type");

  		if (type === "radio" || type === "checkbox") {
  			bindName = isBindable(attributes.name);
  			bindChecked = isBindable(attributes.checked);

  			// we can either bind the name attribute, or the checked attribute - not both
  			if (bindName && bindChecked) {
  				warnIfDebug("A radio input can have two-way binding on its name attribute, or its checked attribute - not both", { ractive: element.root });
  			}

  			if (bindName) {
  				Binding = type === "radio" ? Binding_RadioNameBinding : Binding_CheckboxNameBinding;
  			} else if (bindChecked) {
  				Binding = type === "radio" ? Binding_RadioBinding : Binding_CheckboxBinding;
  			}
  		} else if (type === "file" && isBindable(attributes.value)) {
  			Binding = Binding_FileListBinding;
  		} else if (isBindable(attributes.value)) {
  			Binding = type === "number" || type === "range" ? NumericBinding : Binding_GenericBinding;
  		}
  	}

  	// <select>
  	else if (element.name === "select" && isBindable(attributes.value)) {
  		Binding = element.getAttribute("multiple") ? Binding_MultipleSelectBinding : Binding_SelectBinding;
  	}

  	// <textarea>
  	else if (element.name === "textarea" && isBindable(attributes.value)) {
  		Binding = Binding_GenericBinding;
  	}

  	if (Binding && (binding = new Binding(element)) && binding.keypath) {
  		return binding;
  	}
  }

  function isBindable(attribute) {
  	return attribute && attribute.isBindable;
  }

  // and this element also has a value attribute to bind

  var EventHandler_prototype_bubble = EventHandler$bubble;

  function EventHandler$bubble() {
  	var hasAction = this.getAction();

  	if (hasAction && !this.hasListener) {
  		this.listen();
  	} else if (!hasAction && this.hasListener) {
  		this.unrender();
  	}
  }

  // This function may be overwritten, if the event directive
  // includes parameters
  var EventHandler_prototype_fire = EventHandler$fire;
  function EventHandler$fire(event) {
  	shared_fireEvent(this.root, this.getAction(), { event: event });
  }

  var getAction = EventHandler$getAction;

  function EventHandler$getAction() {
  	return this.action.toString().trim();
  }

  var EventHandler_prototype_init = EventHandler$init;

  var eventPattern = /^event(?:\.(.+))?/;
  function EventHandler$init(element, name, template) {
  	var _this = this;

  	var action, refs, ractive;

  	this.element = element;
  	this.root = element.root;
  	this.parentFragment = element.parentFragment;
  	this.name = name;

  	if (name.indexOf("*") !== -1) {
  		fatal("Only component proxy-events may contain \"*\" wildcards, <%s on-%s=\"...\"/> is not valid", element.name, name);
  		this.invalid = true;
  	}

  	if (template.m) {
  		refs = template.a.r;

  		// This is a method call
  		this.method = template.m;
  		this.keypaths = [];
  		this.fn = shared_getFunctionFromString(template.a.s, refs.length);

  		this.parentFragment = element.parentFragment;
  		ractive = this.root;

  		// Create resolvers for each reference
  		this.refResolvers = [];
  		refs.forEach(function (ref, i) {
  			var match = undefined;

  			// special case - the `event` object
  			if (match = eventPattern.exec(ref)) {
  				_this.keypaths[i] = {
  					eventObject: true,
  					refinements: match[1] ? match[1].split(".") : []
  				};
  			} else {
  				_this.refResolvers.push(Resolvers_createReferenceResolver(_this, ref, function (keypath) {
  					return _this.resolve(i, keypath);
  				}));
  			}
  		});

  		this.fire = fireMethodCall;
  	} else {
  		// Get action ('foo' in 'on-click='foo')
  		action = template.n || template;
  		if (typeof action !== "string") {
  			action = new virtualdom_Fragment({
  				template: action,
  				root: this.root,
  				owner: this
  			});
  		}

  		this.action = action;

  		// Get parameters
  		if (template.d) {
  			this.dynamicParams = new virtualdom_Fragment({
  				template: template.d,
  				root: this.root,
  				owner: this.element
  			});

  			this.fire = fireEventWithDynamicParams;
  		} else if (template.a) {
  			this.params = template.a;
  			this.fire = fireEventWithParams;
  		}
  	}
  }

  function fireMethodCall(event) {
  	var ractive, values, args;

  	ractive = this.root;

  	if (typeof ractive[this.method] !== "function") {
  		throw new Error("Attempted to call a non-existent method (\"" + this.method + "\")");
  	}

  	values = this.keypaths.map(function (keypath) {
  		var value, len, i;

  		if (keypath === undefined) {
  			// not yet resolved
  			return undefined;
  		}

  		// TODO the refinements stuff would be better handled at parse time
  		if (keypath.eventObject) {
  			value = event;

  			if (len = keypath.refinements.length) {
  				for (i = 0; i < len; i += 1) {
  					value = value[keypath.refinements[i]];
  				}
  			}
  		} else {
  			value = ractive.viewmodel.get(keypath);
  		}

  		return value;
  	});

  	shared_eventStack.enqueue(ractive, event);

  	args = this.fn.apply(null, values);
  	ractive[this.method].apply(ractive, args);

  	shared_eventStack.dequeue(ractive);
  }

  function fireEventWithParams(event) {
  	shared_fireEvent(this.root, this.getAction(), { event: event, args: this.params });
  }

  function fireEventWithDynamicParams(event) {
  	var args = this.dynamicParams.getArgsList();

  	// need to strip [] from ends if a string!
  	if (typeof args === "string") {
  		args = args.substr(1, args.length - 2);
  	}

  	shared_fireEvent(this.root, this.getAction(), { event: event, args: args });
  }

  var shared_genericHandler = genericHandler;
  function genericHandler(event) {
  	var storage,
  	    handler,
  	    indices,
  	    index = {};

  	storage = this._ractive;
  	handler = storage.events[event.type];

  	if (indices = Resolvers_findIndexRefs(handler.element.parentFragment)) {
  		index = Resolvers_findIndexRefs.resolve(indices);
  	}

  	handler.fire({
  		node: this,
  		original: event,
  		index: index,
  		keypath: storage.keypath.str,
  		context: storage.root.viewmodel.get(storage.keypath)
  	});
  }

  var listen = EventHandler$listen;

  var customHandlers = {},
      touchEvents = {
  	touchstart: true,
  	touchmove: true,
  	touchend: true,
  	touchcancel: true,
  	//not w3c, but supported in some browsers
  	touchleave: true
  };
  function EventHandler$listen() {
  	var definition,
  	    name = this.name;

  	if (this.invalid) {
  		return;
  	}

  	if (definition = findInViewHierarchy("events", this.root, name)) {
  		this.custom = definition(this.node, getCustomHandler(name));
  	} else {
  		// Looks like we're dealing with a standard DOM event... but let's check
  		if (!("on" + name in this.node) && !(window && "on" + name in window) && !isJsdom) {

  			// okay to use touch events if this browser doesn't support them
  			if (!touchEvents[name]) {
  				warnOnceIfDebug(missingPlugin(name, "event"), { node: this.node });
  			}

  			return;
  		}

  		this.node.addEventListener(name, shared_genericHandler, false);
  	}

  	this.hasListener = true;
  }

  function getCustomHandler(name) {
  	if (!customHandlers[name]) {
  		customHandlers[name] = function (event) {
  			var storage = event.node._ractive;

  			event.index = storage.index;
  			event.keypath = storage.keypath.str;
  			event.context = storage.root.viewmodel.get(storage.keypath);

  			storage.events[name].fire(event);
  		};
  	}

  	return customHandlers[name];
  }

  var EventHandler_prototype_rebind = EventHandler$rebind;

  function EventHandler$rebind(oldKeypath, newKeypath) {
  	var fragment;
  	if (this.method) {
  		fragment = this.element.parentFragment;
  		this.refResolvers.forEach(rebind);

  		return;
  	}

  	if (typeof this.action !== "string") {
  		rebind(this.action);
  	}

  	if (this.dynamicParams) {
  		rebind(this.dynamicParams);
  	}

  	function rebind(thing) {
  		thing && thing.rebind(oldKeypath, newKeypath);
  	}
  }

  var EventHandler_prototype_render = EventHandler$render;

  function EventHandler$render() {
  	this.node = this.element.node;
  	// store this on the node itself, so it can be retrieved by a
  	// universal handler
  	this.node._ractive.events[this.name] = this;

  	if (this.method || this.getAction()) {
  		this.listen();
  	}
  }

  var prototype_resolve = EventHandler$resolve;

  function EventHandler$resolve(index, keypath) {
  	this.keypaths[index] = keypath;
  }

  var EventHandler_prototype_unbind = EventHandler$unbind;
  function EventHandler$unbind() {
  	if (this.method) {
  		this.refResolvers.forEach(methodCallers__unbind);
  		return;
  	}

  	// Tear down dynamic name
  	if (typeof this.action !== "string") {
  		this.action.unbind();
  	}

  	// Tear down dynamic parameters
  	if (this.dynamicParams) {
  		this.dynamicParams.unbind();
  	}
  }

  var EventHandler_prototype_unrender = EventHandler$unrender;
  function EventHandler$unrender() {

  	if (this.custom) {
  		this.custom.teardown();
  	} else {
  		this.node.removeEventListener(this.name, shared_genericHandler, false);
  	}

  	this.hasListener = false;
  }

  var EventHandler = function (element, name, template) {
  	this.init(element, name, template);
  };

  EventHandler.prototype = {
  	bubble: EventHandler_prototype_bubble,
  	fire: EventHandler_prototype_fire,
  	getAction: getAction,
  	init: EventHandler_prototype_init,
  	listen: listen,
  	rebind: EventHandler_prototype_rebind,
  	render: EventHandler_prototype_render,
  	resolve: prototype_resolve,
  	unbind: EventHandler_prototype_unbind,
  	unrender: EventHandler_prototype_unrender
  };

  var _EventHandler = EventHandler;

  var createEventHandlers = function (element, template) {
  	var i,
  	    name,
  	    names,
  	    handler,
  	    result = [];

  	for (name in template) {
  		if (template.hasOwnProperty(name)) {
  			names = name.split("-");
  			i = names.length;

  			while (i--) {
  				handler = new _EventHandler(element, names[i], template[name]);
  				result.push(handler);
  			}
  		}
  	}

  	return result;
  };

  var Decorator = function (element, template) {
  	var self = this,
  	    ractive,
  	    name,
  	    fragment;

  	this.element = element;
  	this.root = ractive = element.root;

  	name = template.n || template;

  	if (typeof name !== "string") {
  		fragment = new virtualdom_Fragment({
  			template: name,
  			root: ractive,
  			owner: element
  		});

  		name = fragment.toString();
  		fragment.unbind();

  		if (name === "") {
  			// empty string okay, just no decorator
  			return;
  		}
  	}

  	if (template.a) {
  		this.params = template.a;
  	} else if (template.d) {
  		this.fragment = new virtualdom_Fragment({
  			template: template.d,
  			root: ractive,
  			owner: element
  		});

  		this.params = this.fragment.getArgsList();

  		this.fragment.bubble = function () {
  			this.dirtyArgs = this.dirtyValue = true;
  			self.params = this.getArgsList();

  			if (self.ready) {
  				self.update();
  			}
  		};
  	}

  	this.fn = findInViewHierarchy("decorators", ractive, name);

  	if (!this.fn) {
  		fatal(missingPlugin(name, "decorator"));
  	}
  };

  Decorator.prototype = {
  	init: function () {
  		var node, result, args;

  		node = this.element.node;

  		if (this.params) {
  			args = [node].concat(this.params);
  			result = this.fn.apply(this.root, args);
  		} else {
  			result = this.fn.call(this.root, node);
  		}

  		if (!result || !result.teardown) {
  			throw new Error("Decorator definition must return an object with a teardown method");
  		}

  		// TODO does this make sense?
  		this.actual = result;
  		this.ready = true;
  	},

  	update: function () {
  		if (this.actual.update) {
  			this.actual.update.apply(this.root, this.params);
  		} else {
  			this.actual.teardown(true);
  			this.init();
  		}
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		if (this.fragment) {
  			this.fragment.rebind(oldKeypath, newKeypath);
  		}
  	},

  	teardown: function (updating) {
  		this.torndown = true;
  		if (this.ready) {
  			this.actual.teardown();
  		}

  		if (!updating && this.fragment) {
  			this.fragment.unbind();
  		}
  	}
  };

  var _Decorator = Decorator;

  function select__bubble() {
  	var _this = this;

  	if (!this.dirty) {
  		this.dirty = true;

  		global_runloop.scheduleTask(function () {
  			sync(_this);
  			_this.dirty = false;
  		});
  	}

  	this.parentFragment.bubble(); // default behaviour
  }

  function sync(selectElement) {
  	var selectNode, selectValue, isMultiple, options, optionWasSelected;

  	selectNode = selectElement.node;

  	if (!selectNode) {
  		return;
  	}

  	options = toArray(selectNode.options);

  	selectValue = selectElement.getAttribute("value");
  	isMultiple = selectElement.getAttribute("multiple");

  	// If the <select> has a specified value, that should override
  	// these options
  	if (selectValue !== undefined) {
  		options.forEach(function (o) {
  			var optionValue, shouldSelect;

  			optionValue = o._ractive ? o._ractive.value : o.value;
  			shouldSelect = isMultiple ? valueContains(selectValue, optionValue) : selectValue == optionValue;

  			if (shouldSelect) {
  				optionWasSelected = true;
  			}

  			o.selected = shouldSelect;
  		});

  		if (!optionWasSelected) {
  			if (options[0]) {
  				options[0].selected = true;
  			}

  			if (selectElement.binding) {
  				selectElement.binding.forceUpdate();
  			}
  		}
  	}

  	// Otherwise the value should be initialised according to which
  	// <option> element is selected, if twoway binding is in effect
  	else if (selectElement.binding) {
  		selectElement.binding.forceUpdate();
  	}
  }

  function valueContains(selectValue, optionValue) {
  	var i = selectValue.length;
  	while (i--) {
  		if (selectValue[i] == optionValue) {
  			return true;
  		}
  	}
  }

  function special_option__init(option, template) {
  	option.select = findParentSelect(option.parent);

  	// we might be inside a <datalist> element
  	if (!option.select) {
  		return;
  	}

  	option.select.options.push(option);

  	// If the value attribute is missing, use the element's content
  	if (!template.a) {
  		template.a = {};
  	}

  	// ...as long as it isn't disabled
  	if (template.a.value === undefined && !template.a.hasOwnProperty("disabled")) {
  		template.a.value = template.f;
  	}

  	// If there is a `selected` attribute, but the <select>
  	// already has a value, delete it
  	if ("selected" in template.a && option.select.getAttribute("value") !== undefined) {
  		delete template.a.selected;
  	}
  }

  function special_option__unbind(option) {
  	if (option.select) {
  		removeFromArray(option.select.options, option);
  	}
  }

  function findParentSelect(element) {
  	if (!element) {
  		return;
  	}

  	do {
  		if (element.name === "select") {
  			return element;
  		}
  	} while (element = element.parent);
  }

  var Element_prototype_init = Element$init;
  function Element$init(options) {
  	var parentFragment, template, ractive, binding, bindings, twoway, bindingAttrs;

  	this.type = ELEMENT;

  	// stuff we'll need later
  	parentFragment = this.parentFragment = options.parentFragment;
  	template = this.template = options.template;

  	this.parent = options.pElement || parentFragment.pElement;

  	this.root = ractive = parentFragment.root;
  	this.index = options.index;
  	this.key = options.key;

  	this.name = enforceCase(template.e);

  	// Special case - <option> elements
  	if (this.name === "option") {
  		special_option__init(this, template);
  	}

  	// Special case - <select> elements
  	if (this.name === "select") {
  		this.options = [];
  		this.bubble = select__bubble; // TODO this is a kludge
  	}

  	// Special case - <form> elements
  	if (this.name === "form") {
  		this.formBindings = [];
  	}

  	// handle binding attributes first (twoway, lazy)
  	bindingAttrs = processBindingAttributes(this, template);

  	// create attributes
  	this.attributes = createAttributes(this, template.a);
  	this.conditionalAttributes = createConditionalAttributes(this, template.m);

  	// append children, if there are any
  	if (template.f) {
  		this.fragment = new virtualdom_Fragment({
  			template: template.f,
  			root: ractive,
  			owner: this,
  			pElement: this,
  			cssIds: null
  		});
  	}

  	// the element setting should override the ractive setting
  	twoway = ractive.twoway;
  	if (bindingAttrs.twoway === false) twoway = false;else if (bindingAttrs.twoway === true) twoway = true;

  	this.twoway = twoway;
  	this.lazy = bindingAttrs.lazy;

  	// create twoway binding
  	if (twoway && (binding = init_createTwowayBinding(this, template.a))) {
  		this.binding = binding;

  		// register this with the root, so that we can do ractive.updateModel()
  		bindings = this.root._twowayBindings[binding.keypath.str] || (this.root._twowayBindings[binding.keypath.str] = []);
  		bindings.push(binding);
  	}

  	// create event proxies
  	if (template.v) {
  		this.eventHandlers = createEventHandlers(this, template.v);
  	}

  	// create decorator
  	if (template.o) {
  		this.decorator = new _Decorator(this, template.o);
  	}

  	// create transitions
  	this.intro = template.t0 || template.t1;
  	this.outro = template.t0 || template.t2;
  }

  var Element_prototype_rebind = Element$rebind;
  function Element$rebind(oldKeypath, newKeypath) {
  	var i, storage, liveQueries, ractive;

  	if (this.attributes) {
  		this.attributes.forEach(rebind);
  	}

  	if (this.conditionalAttributes) {
  		this.conditionalAttributes.forEach(rebind);
  	}

  	if (this.eventHandlers) {
  		this.eventHandlers.forEach(rebind);
  	}

  	if (this.decorator) {
  		rebind(this.decorator);
  	}

  	// rebind children
  	if (this.fragment) {
  		rebind(this.fragment);
  	}

  	// Update live queries, if necessary
  	if (liveQueries = this.liveQueries) {
  		ractive = this.root;

  		i = liveQueries.length;
  		while (i--) {
  			liveQueries[i]._makeDirty();
  		}
  	}

  	if (this.node && (storage = this.node._ractive)) {

  		// adjust keypath if needed
  		assignNewKeypath(storage, "keypath", oldKeypath, newKeypath);
  	}

  	function rebind(thing) {
  		thing.rebind(oldKeypath, newKeypath);
  	}
  }

  function special_img__render(img) {
  	var loadHandler;

  	// if this is an <img>, and we're in a crap browser, we may need to prevent it
  	// from overriding width and height when it loads the src
  	if (img.attributes.width || img.attributes.height) {
  		img.node.addEventListener("load", loadHandler = function () {
  			var width = img.getAttribute("width"),
  			    height = img.getAttribute("height");

  			if (width !== undefined) {
  				img.node.setAttribute("width", width);
  			}

  			if (height !== undefined) {
  				img.node.setAttribute("height", height);
  			}

  			img.node.removeEventListener("load", loadHandler, false);
  		}, false);
  	}
  }

  function form__render(element) {
  	element.node.addEventListener("reset", handleReset, false);
  }

  function form__unrender(element) {
  	element.node.removeEventListener("reset", handleReset, false);
  }

  function handleReset() {
  	var element = this._ractive.proxy;

  	global_runloop.start();
  	element.formBindings.forEach(updateModel);
  	global_runloop.end();
  }

  function updateModel(binding) {
  	binding.root.viewmodel.set(binding.keypath, binding.resetValue);
  }

  var Transition_prototype_init = Transition$init;
  function Transition$init(element, template, isIntro) {
  	var ractive, name, fragment;

  	this.element = element;
  	this.root = ractive = element.root;
  	this.isIntro = isIntro;

  	name = template.n || template;

  	if (typeof name !== "string") {
  		fragment = new virtualdom_Fragment({
  			template: name,
  			root: ractive,
  			owner: element
  		});

  		name = fragment.toString();
  		fragment.unbind();

  		if (name === "") {
  			// empty string okay, just no transition
  			return;
  		}
  	}

  	this.name = name;

  	if (template.a) {
  		this.params = template.a;
  	} else if (template.d) {
  		// TODO is there a way to interpret dynamic arguments without all the
  		// 'dependency thrashing'?
  		fragment = new virtualdom_Fragment({
  			template: template.d,
  			root: ractive,
  			owner: element
  		});

  		this.params = fragment.getArgsList();
  		fragment.unbind();
  	}

  	this._fn = findInViewHierarchy("transitions", ractive, name);

  	if (!this._fn) {
  		warnOnceIfDebug(missingPlugin(name, "transition"), { ractive: this.root });
  	}
  }

  var camelCase = function (hyphenatedStr) {
  	return hyphenatedStr.replace(/-([a-zA-Z])/g, function (match, $1) {
  		return $1.toUpperCase();
  	});
  };

  var helpers_prefix__prefix, prefixCache, helpers_prefix__testStyle;

  if (!isClient) {
  	helpers_prefix__prefix = null;
  } else {
  	prefixCache = {};
  	helpers_prefix__testStyle = createElement("div").style;

  	helpers_prefix__prefix = function (prop) {
  		var i, vendor, capped;

  		prop = camelCase(prop);

  		if (!prefixCache[prop]) {
  			if (helpers_prefix__testStyle[prop] !== undefined) {
  				prefixCache[prop] = prop;
  			} else {
  				// test vendors...
  				capped = prop.charAt(0).toUpperCase() + prop.substring(1);

  				i = vendors.length;
  				while (i--) {
  					vendor = vendors[i];
  					if (helpers_prefix__testStyle[vendor + capped] !== undefined) {
  						prefixCache[prop] = vendor + capped;
  						break;
  					}
  				}
  			}
  		}

  		return prefixCache[prop];
  	};
  }

  var helpers_prefix = helpers_prefix__prefix;

  var getStyle, prototype_getStyle__getComputedStyle;

  if (!isClient) {
  	getStyle = null;
  } else {
  	prototype_getStyle__getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;

  	getStyle = function (props) {
  		var computedStyle, styles, i, prop, value;

  		computedStyle = prototype_getStyle__getComputedStyle(this.node);

  		if (typeof props === "string") {
  			value = computedStyle[helpers_prefix(props)];
  			if (value === "0px") {
  				value = 0;
  			}
  			return value;
  		}

  		if (!isArray(props)) {
  			throw new Error("Transition$getStyle must be passed a string, or an array of strings representing CSS properties");
  		}

  		styles = {};

  		i = props.length;
  		while (i--) {
  			prop = props[i];
  			value = computedStyle[helpers_prefix(prop)];
  			if (value === "0px") {
  				value = 0;
  			}
  			styles[prop] = value;
  		}

  		return styles;
  	};
  }

  var prototype_getStyle = getStyle;

  var setStyle = function (style, value) {
  	var prop;

  	if (typeof style === "string") {
  		this.node.style[helpers_prefix(style)] = value;
  	} else {
  		for (prop in style) {
  			if (style.hasOwnProperty(prop)) {
  				this.node.style[helpers_prefix(prop)] = style[prop];
  			}
  		}
  	}

  	return this;
  };

  var Ticker = function (options) {
  	var easing;

  	this.duration = options.duration;
  	this.step = options.step;
  	this.complete = options.complete;

  	// easing
  	if (typeof options.easing === "string") {
  		easing = options.root.easing[options.easing];

  		if (!easing) {
  			warnOnceIfDebug(missingPlugin(options.easing, "easing"));
  			easing = linear;
  		}
  	} else if (typeof options.easing === "function") {
  		easing = options.easing;
  	} else {
  		easing = linear;
  	}

  	this.easing = easing;

  	this.start = utils_getTime();
  	this.end = this.start + this.duration;

  	this.running = true;
  	shared_animations.add(this);
  };

  Ticker.prototype = {
  	tick: function (now) {
  		var elapsed, eased;

  		if (!this.running) {
  			return false;
  		}

  		if (now > this.end) {
  			if (this.step) {
  				this.step(1);
  			}

  			if (this.complete) {
  				this.complete(1);
  			}

  			return false;
  		}

  		elapsed = now - this.start;
  		eased = this.easing(elapsed / this.duration);

  		if (this.step) {
  			this.step(eased);
  		}

  		return true;
  	},

  	stop: function () {
  		if (this.abort) {
  			this.abort();
  		}

  		this.running = false;
  	}
  };

  var shared_Ticker = Ticker;
  function linear(t) {
  	return t;
  }

  var unprefixPattern = new RegExp("^-(?:" + vendors.join("|") + ")-");

  var unprefix = function (prop) {
  	return prop.replace(unprefixPattern, "");
  };

  var vendorPattern = new RegExp("^(?:" + vendors.join("|") + ")([A-Z])");

  var hyphenate = function (str) {
  	var hyphenated;

  	if (!str) {
  		return ""; // edge case
  	}

  	if (vendorPattern.test(str)) {
  		str = "-" + str;
  	}

  	hyphenated = str.replace(/[A-Z]/g, function (match) {
  		return "-" + match.toLowerCase();
  	});

  	return hyphenated;
  };

  var createTransitions,
      animateStyle_createTransitions__testStyle,
      TRANSITION,
      TRANSITIONEND,
      CSS_TRANSITIONS_ENABLED,
      TRANSITION_DURATION,
      TRANSITION_PROPERTY,
      TRANSITION_TIMING_FUNCTION,
      canUseCssTransitions = {},
      cannotUseCssTransitions = {};

  if (!isClient) {
  	createTransitions = null;
  } else {
  	animateStyle_createTransitions__testStyle = createElement("div").style;

  	// determine some facts about our environment
  	(function () {
  		if (animateStyle_createTransitions__testStyle.transition !== undefined) {
  			TRANSITION = "transition";
  			TRANSITIONEND = "transitionend";
  			CSS_TRANSITIONS_ENABLED = true;
  		} else if (animateStyle_createTransitions__testStyle.webkitTransition !== undefined) {
  			TRANSITION = "webkitTransition";
  			TRANSITIONEND = "webkitTransitionEnd";
  			CSS_TRANSITIONS_ENABLED = true;
  		} else {
  			CSS_TRANSITIONS_ENABLED = false;
  		}
  	})();

  	if (TRANSITION) {
  		TRANSITION_DURATION = TRANSITION + "Duration";
  		TRANSITION_PROPERTY = TRANSITION + "Property";
  		TRANSITION_TIMING_FUNCTION = TRANSITION + "TimingFunction";
  	}

  	createTransitions = function (t, to, options, changedProperties, resolve) {

  		// Wait a beat (otherwise the target styles will be applied immediately)
  		// TODO use a fastdom-style mechanism?
  		setTimeout(function () {

  			var hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;

  			checkComplete = function () {
  				if (jsTransitionsComplete && cssTransitionsComplete) {
  					// will changes to events and fire have an unexpected consequence here?
  					t.root.fire(t.name + ":end", t.node, t.isIntro);
  					resolve();
  				}
  			};

  			// this is used to keep track of which elements can use CSS to animate
  			// which properties
  			hashPrefix = (t.node.namespaceURI || "") + t.node.tagName;

  			t.node.style[TRANSITION_PROPERTY] = changedProperties.map(helpers_prefix).map(hyphenate).join(",");
  			t.node.style[TRANSITION_TIMING_FUNCTION] = hyphenate(options.easing || "linear");
  			t.node.style[TRANSITION_DURATION] = options.duration / 1000 + "s";

  			transitionEndHandler = function (event) {
  				var index;

  				index = changedProperties.indexOf(camelCase(unprefix(event.propertyName)));
  				if (index !== -1) {
  					changedProperties.splice(index, 1);
  				}

  				if (changedProperties.length) {
  					// still transitioning...
  					return;
  				}

  				t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);

  				cssTransitionsComplete = true;
  				checkComplete();
  			};

  			t.node.addEventListener(TRANSITIONEND, transitionEndHandler, false);

  			setTimeout(function () {
  				var i = changedProperties.length,
  				    hash,
  				    originalValue,
  				    index,
  				    propertiesToTransitionInJs = [],
  				    prop,
  				    suffix;

  				while (i--) {
  					prop = changedProperties[i];
  					hash = hashPrefix + prop;

  					if (CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[hash]) {
  						t.node.style[helpers_prefix(prop)] = to[prop];

  						// If we're not sure if CSS transitions are supported for
  						// this tag/property combo, find out now
  						if (!canUseCssTransitions[hash]) {
  							originalValue = t.getStyle(prop);

  							// if this property is transitionable in this browser,
  							// the current style will be different from the target style
  							canUseCssTransitions[hash] = t.getStyle(prop) != to[prop];
  							cannotUseCssTransitions[hash] = !canUseCssTransitions[hash];

  							// Reset, if we're going to use timers after all
  							if (cannotUseCssTransitions[hash]) {
  								t.node.style[helpers_prefix(prop)] = originalValue;
  							}
  						}
  					}

  					if (!CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[hash]) {
  						// we need to fall back to timer-based stuff
  						if (originalValue === undefined) {
  							originalValue = t.getStyle(prop);
  						}

  						// need to remove this from changedProperties, otherwise transitionEndHandler
  						// will get confused
  						index = changedProperties.indexOf(prop);
  						if (index === -1) {
  							warnIfDebug("Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!", { node: t.node });
  						} else {
  							changedProperties.splice(index, 1);
  						}

  						// TODO Determine whether this property is animatable at all

  						suffix = /[^\d]*$/.exec(to[prop])[0];

  						// ...then kick off a timer-based transition
  						propertiesToTransitionInJs.push({
  							name: helpers_prefix(prop),
  							interpolator: shared_interpolate(parseFloat(originalValue), parseFloat(to[prop])),
  							suffix: suffix
  						});
  					}
  				}

  				// javascript transitions
  				if (propertiesToTransitionInJs.length) {
  					new shared_Ticker({
  						root: t.root,
  						duration: options.duration,
  						easing: camelCase(options.easing || ""),
  						step: function (pos) {
  							var prop, i;

  							i = propertiesToTransitionInJs.length;
  							while (i--) {
  								prop = propertiesToTransitionInJs[i];
  								t.node.style[prop.name] = prop.interpolator(pos) + prop.suffix;
  							}
  						},
  						complete: function () {
  							jsTransitionsComplete = true;
  							checkComplete();
  						}
  					});
  				} else {
  					jsTransitionsComplete = true;
  				}

  				if (!changedProperties.length) {
  					// We need to cancel the transitionEndHandler, and deal with
  					// the fact that it will never fire
  					t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);
  					cssTransitionsComplete = true;
  					checkComplete();
  				}
  			}, 0);
  		}, options.delay || 0);
  	};
  }

  var animateStyle_createTransitions = createTransitions;

  var hidden, vendor, animateStyle_visibility__prefix, animateStyle_visibility__i, visibility;

  if (typeof document !== "undefined") {
  	hidden = "hidden";

  	visibility = {};

  	if (hidden in document) {
  		animateStyle_visibility__prefix = "";
  	} else {
  		animateStyle_visibility__i = vendors.length;
  		while (animateStyle_visibility__i--) {
  			vendor = vendors[animateStyle_visibility__i];
  			hidden = vendor + "Hidden";

  			if (hidden in document) {
  				animateStyle_visibility__prefix = vendor;
  			}
  		}
  	}

  	if (animateStyle_visibility__prefix !== undefined) {
  		document.addEventListener(animateStyle_visibility__prefix + "visibilitychange", onChange);

  		// initialise
  		onChange();
  	} else {
  		// gah, we're in an old browser
  		if ("onfocusout" in document) {
  			document.addEventListener("focusout", onHide);
  			document.addEventListener("focusin", onShow);
  		} else {
  			window.addEventListener("pagehide", onHide);
  			window.addEventListener("blur", onHide);

  			window.addEventListener("pageshow", onShow);
  			window.addEventListener("focus", onShow);
  		}

  		visibility.hidden = false; // until proven otherwise. Not ideal but hey
  	}
  }

  function onChange() {
  	visibility.hidden = document[hidden];
  }

  function onHide() {
  	visibility.hidden = true;
  }

  function onShow() {
  	visibility.hidden = false;
  }

  var animateStyle_visibility = visibility;

  var animateStyle, _animateStyle__getComputedStyle, resolved;

  if (!isClient) {
  	animateStyle = null;
  } else {
  	_animateStyle__getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;

  	animateStyle = function (style, value, options) {
  		var _this = this;

  		var to;

  		if (arguments.length === 4) {
  			throw new Error("t.animateStyle() returns a promise - use .then() instead of passing a callback");
  		}

  		// Special case - page isn't visible. Don't animate anything, because
  		// that way you'll never get CSS transitionend events
  		if (animateStyle_visibility.hidden) {
  			this.setStyle(style, value);
  			return resolved || (resolved = utils_Promise.resolve());
  		}

  		if (typeof style === "string") {
  			to = {};
  			to[style] = value;
  		} else {
  			to = style;

  			// shuffle arguments
  			options = value;
  		}

  		// As of 0.3.9, transition authors should supply an `option` object with
  		// `duration` and `easing` properties (and optional `delay`), plus a
  		// callback function that gets called after the animation completes

  		// TODO remove this check in a future version
  		if (!options) {
  			warnOnceIfDebug("The \"%s\" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340", this.name);
  			options = this;
  		}

  		var promise = new utils_Promise(function (resolve) {
  			var propertyNames, changedProperties, computedStyle, current, from, i, prop;

  			// Edge case - if duration is zero, set style synchronously and complete
  			if (!options.duration) {
  				_this.setStyle(to);
  				resolve();
  				return;
  			}

  			// Get a list of the properties we're animating
  			propertyNames = Object.keys(to);
  			changedProperties = [];

  			// Store the current styles
  			computedStyle = _animateStyle__getComputedStyle(_this.node);

  			from = {};
  			i = propertyNames.length;
  			while (i--) {
  				prop = propertyNames[i];
  				current = computedStyle[helpers_prefix(prop)];

  				if (current === "0px") {
  					current = 0;
  				}

  				// we need to know if we're actually changing anything
  				if (current != to[prop]) {
  					// use != instead of !==, so we can compare strings with numbers
  					changedProperties.push(prop);

  					// make the computed style explicit, so we can animate where
  					// e.g. height='auto'
  					_this.node.style[helpers_prefix(prop)] = current;
  				}
  			}

  			// If we're not actually changing anything, the transitionend event
  			// will never fire! So we complete early
  			if (!changedProperties.length) {
  				resolve();
  				return;
  			}

  			animateStyle_createTransitions(_this, to, options, changedProperties, resolve);
  		});

  		return promise;
  	};
  }

  var _animateStyle = animateStyle;

  var processParams = function (params, defaults) {
  	if (typeof params === "number") {
  		params = { duration: params };
  	} else if (typeof params === "string") {
  		if (params === "slow") {
  			params = { duration: 600 };
  		} else if (params === "fast") {
  			params = { duration: 200 };
  		} else {
  			params = { duration: 400 };
  		}
  	} else if (!params) {
  		params = {};
  	}

  	return fillGaps({}, params, defaults);
  };

  var prototype_start = Transition$start;

  function Transition$start() {
  	var _this = this;

  	var node, originalStyle, completed;

  	node = this.node = this.element.node;
  	originalStyle = node.getAttribute("style");

  	// create t.complete() - we don't want this on the prototype,
  	// because we don't want `this` silliness when passing it as
  	// an argument
  	this.complete = function (noReset) {
  		if (completed) {
  			return;
  		}

  		if (!noReset && _this.isIntro) {
  			resetStyle(node, originalStyle);
  		}

  		node._ractive.transition = null;
  		_this._manager.remove(_this);

  		completed = true;
  	};

  	// If the transition function doesn't exist, abort
  	if (!this._fn) {
  		this.complete();
  		return;
  	}

  	this._fn.apply(this.root, [this].concat(this.params));
  }

  function resetStyle(node, style) {
  	if (style) {
  		node.setAttribute("style", style);
  	} else {

  		// Next line is necessary, to remove empty style attribute!
  		// See http://stackoverflow.com/a/7167553
  		node.getAttribute("style");
  		node.removeAttribute("style");
  	}
  }

  var Transition = function (owner, template, isIntro) {
  	this.init(owner, template, isIntro);
  };

  Transition.prototype = {
  	init: Transition_prototype_init,
  	start: prototype_start,
  	getStyle: prototype_getStyle,
  	setStyle: setStyle,
  	animateStyle: _animateStyle,
  	processParams: processParams
  };

  var _Transition = Transition;

  var Element_prototype_render = Element$render;

  var updateCss, updateScript;

  updateCss = function () {
  	var node = this.node,
  	    content = this.fragment.toString(false);

  	// IE8 has no styleSheet unless there's a type text/css
  	if (window && window.appearsToBeIELessEqual8) {
  		node.type = "text/css";
  	}

  	if (node.styleSheet) {
  		node.styleSheet.cssText = content;
  	} else {

  		while (node.hasChildNodes()) {
  			node.removeChild(node.firstChild);
  		}

  		node.appendChild(document.createTextNode(content));
  	}
  };

  updateScript = function () {
  	if (!this.node.type || this.node.type === "text/javascript") {
  		warnIfDebug("Script tag was updated. This does not cause the code to be re-evaluated!", { ractive: this.root });
  		// As it happens, we ARE in a position to re-evaluate the code if we wanted
  		// to - we could eval() it, or insert it into a fresh (temporary) script tag.
  		// But this would be a terrible idea with unpredictable results, so let's not.
  	}

  	this.node.text = this.fragment.toString(false);
  };
  function Element$render() {
  	var _this = this;

  	var root = this.root,
  	    namespace,
  	    node,
  	    transition;

  	namespace = getNamespace(this);
  	node = this.node = createElement(this.name, namespace);

  	// Is this a top-level node of a component? If so, we may need to add
  	// a data-ractive-css attribute, for CSS encapsulation
  	if (this.parentFragment.cssIds) {
  		this.node.setAttribute("data-ractive-css", this.parentFragment.cssIds.map(function (x) {
  			return "{" + x + "}";
  		}).join(" "));
  	}

  	// Add _ractive property to the node - we use this object to store stuff
  	// related to proxy events, two-way bindings etc
  	defineProperty(this.node, "_ractive", {
  		value: {
  			proxy: this,
  			keypath: getInnerContext(this.parentFragment),
  			events: create(null),
  			root: root
  		}
  	});

  	// Render attributes
  	this.attributes.forEach(function (a) {
  		return a.render(node);
  	});
  	this.conditionalAttributes.forEach(function (a) {
  		return a.render(node);
  	});

  	// Render children
  	if (this.fragment) {
  		// Special case - <script> element
  		if (this.name === "script") {
  			this.bubble = updateScript;
  			this.node.text = this.fragment.toString(false); // bypass warning initially
  			this.fragment.unrender = noop; // TODO this is a kludge
  		}

  		// Special case - <style> element
  		else if (this.name === "style") {
  			this.bubble = updateCss;
  			this.bubble();
  			this.fragment.unrender = noop;
  		}

  		// Special case - contenteditable
  		else if (this.binding && this.getAttribute("contenteditable")) {
  			this.fragment.unrender = noop;
  		} else {
  			this.node.appendChild(this.fragment.render());
  		}
  	}

  	// deal with two-way bindings
  	if (this.binding) {
  		this.binding.render();
  		this.node._ractive.binding = this.binding;
  	}

  	// Add proxy event handlers
  	if (this.eventHandlers) {
  		this.eventHandlers.forEach(function (h) {
  			return h.render();
  		});
  	}

  	if (this.name === "option") {
  		processOption(this);
  	}

  	// Special cases
  	if (this.name === "img") {
  		// if this is an <img>, and we're in a crap browser, we may
  		// need to prevent it from overriding width and height when
  		// it loads the src
  		special_img__render(this);
  	} else if (this.name === "form") {
  		// forms need to keep track of their bindings, in case of reset
  		form__render(this);
  	} else if (this.name === "input" || this.name === "textarea") {
  		// inputs and textareas should store their initial value as
  		// `defaultValue` in case of reset
  		this.node.defaultValue = this.node.value;
  	} else if (this.name === "option") {
  		// similarly for option nodes
  		this.node.defaultSelected = this.node.selected;
  	}

  	// apply decorator(s)
  	if (this.decorator && this.decorator.fn) {
  		global_runloop.scheduleTask(function () {
  			if (!_this.decorator.torndown) {
  				_this.decorator.init();
  			}
  		}, true);
  	}

  	// trigger intro transition
  	if (root.transitionsEnabled && this.intro) {
  		transition = new _Transition(this, this.intro, true);
  		global_runloop.registerTransition(transition);
  		global_runloop.scheduleTask(function () {
  			return transition.start();
  		}, true);

  		this.transition = transition;
  	}

  	if (this.node.autofocus) {
  		// Special case. Some browsers (*cough* Firefix *cough*) have a problem
  		// with dynamically-generated elements having autofocus, and they won't
  		// allow you to programmatically focus the element until it's in the DOM
  		global_runloop.scheduleTask(function () {
  			return _this.node.focus();
  		}, true);
  	}

  	updateLiveQueries(this);
  	return this.node;
  }

  function getNamespace(element) {
  	var namespace, xmlns, parent;

  	// Use specified namespace...
  	if (xmlns = element.getAttribute("xmlns")) {
  		namespace = xmlns;
  	}

  	// ...or SVG namespace, if this is an <svg> element
  	else if (element.name === "svg") {
  		namespace = namespaces.svg;
  	} else if (parent = element.parent) {
  		// ...or HTML, if the parent is a <foreignObject>
  		if (parent.name === "foreignObject") {
  			namespace = namespaces.html;
  		}

  		// ...or inherit from the parent node
  		else {
  			namespace = parent.node.namespaceURI;
  		}
  	} else {
  		namespace = element.root.el.namespaceURI;
  	}

  	return namespace;
  }

  function processOption(option) {
  	var optionValue, selectValue, i;

  	if (!option.select) {
  		return;
  	}

  	selectValue = option.select.getAttribute("value");
  	if (selectValue === undefined) {
  		return;
  	}

  	optionValue = option.getAttribute("value");

  	if (option.select.node.multiple && isArray(selectValue)) {
  		i = selectValue.length;
  		while (i--) {
  			if (optionValue == selectValue[i]) {
  				option.node.selected = true;
  				break;
  			}
  		}
  	} else {
  		option.node.selected = optionValue == selectValue;
  	}
  }

  function updateLiveQueries(element) {
  	var instance, liveQueries, i, selector, query;

  	// Does this need to be added to any live queries?
  	instance = element.root;

  	do {
  		liveQueries = instance._liveQueries;

  		i = liveQueries.length;
  		while (i--) {
  			selector = liveQueries[i];
  			query = liveQueries["_" + selector];

  			if (query._test(element)) {
  				// keep register of applicable selectors, for when we teardown
  				(element.liveQueries || (element.liveQueries = [])).push(query);
  			}
  		}
  	} while (instance = instance.parent);
  }

  var Element_prototype_toString = function () {
  	var str, escape;

  	if (this.template.y) {
  		// DOCTYPE declaration
  		return "<!DOCTYPE" + this.template.dd + ">";
  	}

  	str = "<" + this.template.e;

  	str += this.attributes.map(stringifyAttribute).join("") + this.conditionalAttributes.map(stringifyAttribute).join("");

  	// Special case - selected options
  	if (this.name === "option" && optionIsSelected(this)) {
  		str += " selected";
  	}

  	// Special case - two-way radio name bindings
  	if (this.name === "input" && inputIsCheckedRadio(this)) {
  		str += " checked";
  	}

  	str += ">";

  	// Special case - textarea
  	if (this.name === "textarea" && this.getAttribute("value") !== undefined) {
  		str += escapeHtml(this.getAttribute("value"));
  	}

  	// Special case - contenteditable
  	else if (this.getAttribute("contenteditable") !== undefined) {
  		str += this.getAttribute("value") || "";
  	}

  	if (this.fragment) {
  		escape = this.name !== "script" && this.name !== "style";
  		str += this.fragment.toString(escape);
  	}

  	// add a closing tag if this isn't a void element
  	if (!voidElementNames.test(this.template.e)) {
  		str += "</" + this.template.e + ">";
  	}

  	return str;
  };

  function optionIsSelected(element) {
  	var optionValue, selectValue, i;

  	optionValue = element.getAttribute("value");

  	if (optionValue === undefined || !element.select) {
  		return false;
  	}

  	selectValue = element.select.getAttribute("value");

  	if (selectValue == optionValue) {
  		return true;
  	}

  	if (element.select.getAttribute("multiple") && isArray(selectValue)) {
  		i = selectValue.length;
  		while (i--) {
  			if (selectValue[i] == optionValue) {
  				return true;
  			}
  		}
  	}
  }

  function inputIsCheckedRadio(element) {
  	var attributes, typeAttribute, valueAttribute, nameAttribute;

  	attributes = element.attributes;

  	typeAttribute = attributes.type;
  	valueAttribute = attributes.value;
  	nameAttribute = attributes.name;

  	if (!typeAttribute || typeAttribute.value !== "radio" || !valueAttribute || !nameAttribute.interpolator) {
  		return;
  	}

  	if (valueAttribute.value === nameAttribute.interpolator.value) {
  		return true;
  	}
  }

  function stringifyAttribute(attribute) {
  	var str = attribute.toString();
  	return str ? " " + str : "";
  }

  var Element_prototype_unbind = Element$unbind;
  function Element$unbind() {
  	if (this.fragment) {
  		this.fragment.unbind();
  	}

  	if (this.binding) {
  		this.binding.unbind();
  	}

  	if (this.eventHandlers) {
  		this.eventHandlers.forEach(methodCallers__unbind);
  	}

  	// Special case - <option>
  	if (this.name === "option") {
  		special_option__unbind(this);
  	}

  	this.attributes.forEach(methodCallers__unbind);
  	this.conditionalAttributes.forEach(methodCallers__unbind);
  }

  var Element_prototype_unrender = Element$unrender;

  function Element$unrender(shouldDestroy) {
  	var binding, bindings, transition;

  	if (transition = this.transition) {
  		transition.complete();
  	}

  	// Detach as soon as we can
  	if (this.name === "option") {
  		// <option> elements detach immediately, so that
  		// their parent <select> element syncs correctly, and
  		// since option elements can't have transitions anyway
  		this.detach();
  	} else if (shouldDestroy) {
  		global_runloop.detachWhenReady(this);
  	}

  	// Children first. that way, any transitions on child elements will be
  	// handled by the current transitionManager
  	if (this.fragment) {
  		this.fragment.unrender(false);
  	}

  	if (binding = this.binding) {
  		this.binding.unrender();

  		this.node._ractive.binding = null;
  		bindings = this.root._twowayBindings[binding.keypath.str];
  		bindings.splice(bindings.indexOf(binding), 1);
  	}

  	// Remove event handlers
  	if (this.eventHandlers) {
  		this.eventHandlers.forEach(methodCallers__unrender);
  	}

  	if (this.decorator) {
  		global_runloop.registerDecorator(this.decorator);
  	}

  	// trigger outro transition if necessary
  	if (this.root.transitionsEnabled && this.outro) {
  		transition = new _Transition(this, this.outro, false);
  		global_runloop.registerTransition(transition);
  		global_runloop.scheduleTask(function () {
  			return transition.start();
  		});
  	}

  	// Remove this node from any live queries
  	if (this.liveQueries) {
  		removeFromLiveQueries(this);
  	}

  	if (this.name === "form") {
  		form__unrender(this);
  	}
  }

  function removeFromLiveQueries(element) {
  	var query, selector, i;

  	i = element.liveQueries.length;
  	while (i--) {
  		query = element.liveQueries[i];
  		selector = query.selector;

  		query._remove(element.node);
  	}
  }

  var Element = function (options) {
  	this.init(options);
  };

  Element.prototype = {
  	bubble: Element_prototype_bubble,
  	detach: Element_prototype_detach,
  	find: Element_prototype_find,
  	findAll: Element_prototype_findAll,
  	findAllComponents: Element_prototype_findAllComponents,
  	findComponent: Element_prototype_findComponent,
  	findNextNode: Element_prototype_findNextNode,
  	firstNode: Element_prototype_firstNode,
  	getAttribute: getAttribute,
  	init: Element_prototype_init,
  	rebind: Element_prototype_rebind,
  	render: Element_prototype_render,
  	toString: Element_prototype_toString,
  	unbind: Element_prototype_unbind,
  	unrender: Element_prototype_unrender
  };

  var _Element = Element;

  var deIndent__empty = /^\s*$/,
      deIndent__leadingWhitespace = /^\s*/;

  var deIndent = function (str) {
  	var lines, firstLine, lastLine, minIndent;

  	lines = str.split("\n");

  	// remove first and last line, if they only contain whitespace
  	firstLine = lines[0];
  	if (firstLine !== undefined && deIndent__empty.test(firstLine)) {
  		lines.shift();
  	}

  	lastLine = lastItem(lines);
  	if (lastLine !== undefined && deIndent__empty.test(lastLine)) {
  		lines.pop();
  	}

  	minIndent = lines.reduce(reducer, null);

  	if (minIndent) {
  		str = lines.map(function (line) {
  			return line.replace(minIndent, "");
  		}).join("\n");
  	}

  	return str;
  };

  function reducer(previous, line) {
  	var lineIndent = deIndent__leadingWhitespace.exec(line)[0];

  	if (previous === null || lineIndent.length < previous.length) {
  		return lineIndent;
  	}

  	return previous;
  }

  var Partial_getPartialTemplate = getPartialTemplate;

  function getPartialTemplate(ractive, name, parentFragment) {
  	var partial;

  	// If the partial in instance or view heirarchy instances, great
  	if (partial = getPartialFromRegistry(ractive, name, parentFragment || {})) {
  		return partial;
  	}

  	// Does it exist on the page as a script tag?
  	partial = template_parser.fromId(name, { noThrow: true });

  	if (partial) {
  		// is this necessary?
  		partial = deIndent(partial);

  		// parse and register to this ractive instance
  		var parsed = template_parser.parse(partial, template_parser.getParseOptions(ractive));

  		// register (and return main partial if there are others in the template)
  		return ractive.partials[name] = parsed.t;
  	}
  }

  function getPartialFromRegistry(ractive, name, parentFragment) {
  	var fn = undefined,
  	    partial = findParentPartial(name, parentFragment.owner);

  	// if there was an instance up-hierarchy, cool
  	if (partial) return partial;

  	// find first instance in the ractive or view hierarchy that has this partial
  	var instance = findInstance("partials", ractive, name);

  	if (!instance) {
  		return;
  	}

  	partial = instance.partials[name];

  	// partial is a function?
  	if (typeof partial === "function") {
  		fn = partial.bind(instance);
  		fn.isOwner = instance.partials.hasOwnProperty(name);
  		partial = fn.call(ractive, template_parser);
  	}

  	if (!partial && partial !== "") {
  		warnIfDebug(noRegistryFunctionReturn, name, "partial", "partial", { ractive: ractive });
  		return;
  	}

  	// If this was added manually to the registry,
  	// but hasn't been parsed, parse it now
  	if (!template_parser.isParsed(partial)) {

  		// use the parseOptions of the ractive instance on which it was found
  		var parsed = template_parser.parse(partial, template_parser.getParseOptions(instance));

  		// Partials cannot contain nested partials!
  		// TODO add a test for this
  		if (parsed.p) {
  			warnIfDebug("Partials ({{>%s}}) cannot contain nested inline partials", name, { ractive: ractive });
  		}

  		// if fn, use instance to store result, otherwise needs to go
  		// in the correct point in prototype chain on instance or constructor
  		var target = fn ? instance : findOwner(instance, name);

  		// may be a template with partials, which need to be registered and main template extracted
  		target.partials[name] = partial = parsed.t;
  	}

  	// store for reset
  	if (fn) {
  		partial._fn = fn;
  	}

  	return partial.v ? partial.t : partial;
  }

  function findOwner(ractive, key) {
  	return ractive.partials.hasOwnProperty(key) ? ractive : findConstructor(ractive.constructor, key);
  }

  function findConstructor(constructor, key) {
  	if (!constructor) {
  		return;
  	}
  	return constructor.partials.hasOwnProperty(key) ? constructor : findConstructor(constructor._Parent, key);
  }

  function findParentPartial(name, parent) {
  	if (parent) {
  		if (parent.template && parent.template.p && parent.template.p[name]) {
  			return parent.template.p[name];
  		} else if (parent.parentFragment && parent.parentFragment.owner) {
  			return findParentPartial(name, parent.parentFragment.owner);
  		}
  	}
  }

  var applyIndent = function (string, indent) {
  	var indented;

  	if (!indent) {
  		return string;
  	}

  	indented = string.split("\n").map(function (line, notFirstLine) {
  		return notFirstLine ? indent + line : line;
  	}).join("\n");

  	return indented;
  };

  var missingPartialMessage = "Could not find template for partial \"%s\"";

  var Partial = function (options) {
  	var parentFragment, template;

  	parentFragment = this.parentFragment = options.parentFragment;

  	this.root = parentFragment.root;
  	this.type = PARTIAL;
  	this.index = options.index;
  	this.name = options.template.r;
  	this.rendered = false;

  	this.fragment = this.fragmentToRender = this.fragmentToUnrender = null;

  	Mustache.init(this, options);

  	// If this didn't resolve, it most likely means we have a named partial
  	// (i.e. `{{>foo}}` means 'use the foo partial', not 'use the partial
  	// whose name is the value of `foo`')
  	if (!this.keypath) {
  		if (template = Partial_getPartialTemplate(this.root, this.name, parentFragment)) {
  			shared_unbind.call(this); // prevent any further changes
  			this.isNamed = true;
  			this.setTemplate(template);
  		} else {
  			warnOnceIfDebug(missingPartialMessage, this.name);
  		}
  	}
  };

  Partial.prototype = {
  	bubble: function () {
  		this.parentFragment.bubble();
  	},

  	detach: function () {
  		return this.fragment.detach();
  	},

  	find: function (selector) {
  		return this.fragment.find(selector);
  	},

  	findAll: function (selector, query) {
  		return this.fragment.findAll(selector, query);
  	},

  	findComponent: function (selector) {
  		return this.fragment.findComponent(selector);
  	},

  	findAllComponents: function (selector, query) {
  		return this.fragment.findAllComponents(selector, query);
  	},

  	firstNode: function () {
  		return this.fragment.firstNode();
  	},

  	findNextNode: function () {
  		return this.parentFragment.findNextNode(this);
  	},

  	getPartialName: function () {
  		if (this.isNamed && this.name) return this.name;else if (this.value === undefined) return this.name;else return this.value;
  	},

  	getValue: function () {
  		return this.fragment.getValue();
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		// named partials aren't bound, so don't rebind
  		if (!this.isNamed) {
  			Mustache_rebind.call(this, oldKeypath, newKeypath);
  		}

  		if (this.fragment) {
  			this.fragment.rebind(oldKeypath, newKeypath);
  		}
  	},

  	render: function () {
  		this.docFrag = document.createDocumentFragment();
  		this.update();

  		this.rendered = true;
  		return this.docFrag;
  	},

  	resolve: Mustache.resolve,

  	setValue: function (value) {
  		var template;

  		if (value !== undefined && value === this.value) {
  			// nothing has changed, so no work to be done
  			return;
  		}

  		if (value !== undefined) {
  			template = Partial_getPartialTemplate(this.root, "" + value, this.parentFragment);
  		}

  		// we may be here if we have a partial like `{{>foo}}` and `foo` is the
  		// name of both a data property (whose value ISN'T the name of a partial)
  		// and a partial. In those cases, this becomes a named partial
  		if (!template && this.name && (template = Partial_getPartialTemplate(this.root, this.name, this.parentFragment))) {
  			shared_unbind.call(this);
  			this.isNamed = true;
  		}

  		if (!template) {
  			warnOnceIfDebug(missingPartialMessage, this.name, { ractive: this.root });
  		}

  		this.value = value;

  		this.setTemplate(template || []);

  		this.bubble();

  		if (this.rendered) {
  			global_runloop.addView(this);
  		}
  	},

  	setTemplate: function (template) {
  		if (this.fragment) {
  			this.fragment.unbind();
  			if (this.rendered) {
  				this.fragmentToUnrender = this.fragment;
  			}
  		}

  		this.fragment = new virtualdom_Fragment({
  			template: template,
  			root: this.root,
  			owner: this,
  			pElement: this.parentFragment.pElement
  		});

  		this.fragmentToRender = this.fragment;
  	},

  	toString: function (toString) {
  		var string, previousItem, lastLine, match;

  		string = this.fragment.toString(toString);

  		previousItem = this.parentFragment.items[this.index - 1];

  		if (!previousItem || previousItem.type !== TEXT) {
  			return string;
  		}

  		lastLine = previousItem.text.split("\n").pop();

  		if (match = /^\s+$/.exec(lastLine)) {
  			return applyIndent(string, match[0]);
  		}

  		return string;
  	},

  	unbind: function () {
  		if (!this.isNamed) {
  			// dynamic partial - need to unbind self
  			shared_unbind.call(this);
  		}

  		if (this.fragment) {
  			this.fragment.unbind();
  		}
  	},

  	unrender: function (shouldDestroy) {
  		if (this.rendered) {
  			if (this.fragment) {
  				this.fragment.unrender(shouldDestroy);
  			}
  			this.rendered = false;
  		}
  	},

  	update: function () {
  		var target, anchor;

  		if (this.fragmentToUnrender) {
  			this.fragmentToUnrender.unrender(true);
  			this.fragmentToUnrender = null;
  		}

  		if (this.fragmentToRender) {
  			this.docFrag.appendChild(this.fragmentToRender.render());
  			this.fragmentToRender = null;
  		}

  		if (this.rendered) {
  			target = this.parentFragment.getNode();
  			anchor = this.parentFragment.findNextNode(this);
  			target.insertBefore(this.docFrag, anchor);
  		}
  	}
  };

  var _Partial = Partial;

  // finds the component constructor in the registry or view hierarchy registries

  var Component_getComponent = getComponent;
  function getComponent(ractive, name) {

  	var Component,
  	    instance = findInstance("components", ractive, name);

  	if (instance) {
  		Component = instance.components[name];

  		// best test we have for not Ractive.extend
  		if (!Component._Parent) {
  			// function option, execute and store for reset
  			var fn = Component.bind(instance);
  			fn.isOwner = instance.components.hasOwnProperty(name);
  			Component = fn();

  			if (!Component) {
  				warnIfDebug(noRegistryFunctionReturn, name, "component", "component", { ractive: ractive });

  				return;
  			}

  			if (typeof Component === "string") {
  				// allow string lookup
  				Component = getComponent(ractive, Component);
  			}

  			Component._fn = fn;
  			instance.components[name] = Component;
  		}
  	}

  	return Component;
  }

  var Component_prototype_detach = Component$detach;
  var Component_prototype_detach__detachHook = new hooks_Hook("detach");
  function Component$detach() {
  	var detached = this.instance.fragment.detach();
  	Component_prototype_detach__detachHook.fire(this.instance);
  	return detached;
  }

  var Component_prototype_find = Component$find;

  function Component$find(selector) {
  	return this.instance.fragment.find(selector);
  }

  var Component_prototype_findAll = Component$findAll;

  function Component$findAll(selector, query) {
  	return this.instance.fragment.findAll(selector, query);
  }

  var Component_prototype_findAllComponents = Component$findAllComponents;

  function Component$findAllComponents(selector, query) {
  	query._test(this, true);

  	if (this.instance.fragment) {
  		this.instance.fragment.findAllComponents(selector, query);
  	}
  }

  var Component_prototype_findComponent = Component$findComponent;

  function Component$findComponent(selector) {
  	if (!selector || selector === this.name) {
  		return this.instance;
  	}

  	if (this.instance.fragment) {
  		return this.instance.fragment.findComponent(selector);
  	}

  	return null;
  }

  var Component_prototype_findNextNode = Component$findNextNode;

  function Component$findNextNode() {
  	return this.parentFragment.findNextNode(this);
  }

  var Component_prototype_firstNode = Component$firstNode;

  function Component$firstNode() {
  	if (this.rendered) {
  		return this.instance.fragment.firstNode();
  	}

  	return null;
  }

  var processWrapper = function (wrapper, array, methodName, newIndices) {
  	var root = wrapper.root;
  	var keypath = wrapper.keypath;

  	if (!!newIndices) {
  		root.viewmodel.smartUpdate(keypath, array, newIndices);
  	} else {
  		// If this is a sort or reverse, we just do root.set()...
  		// TODO use merge logic?
  		root.viewmodel.mark(keypath);
  	}
  };

  var patchedArrayProto = [],
      mutatorMethods = ["pop", "push", "reverse", "shift", "sort", "splice", "unshift"],
      testObj,
      patchArrayMethods,
      unpatchArrayMethods;

  mutatorMethods.forEach(function (methodName) {
  	var method = function () {
  		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
  			args[_key] = arguments[_key];
  		}

  		var newIndices, result, wrapper, i;

  		newIndices = shared_getNewIndices(this, methodName, args);

  		// apply the underlying method
  		result = Array.prototype[methodName].apply(this, arguments);

  		// trigger changes
  		global_runloop.start();

  		this._ractive.setting = true;
  		i = this._ractive.wrappers.length;
  		while (i--) {
  			wrapper = this._ractive.wrappers[i];

  			global_runloop.addRactive(wrapper.root);
  			processWrapper(wrapper, this, methodName, newIndices);
  		}

  		global_runloop.end();

  		this._ractive.setting = false;
  		return result;
  	};

  	defineProperty(patchedArrayProto, methodName, {
  		value: method
  	});
  });

  // can we use prototype chain injection?
  // http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection
  testObj = {};

  if (testObj.__proto__) {
  	// yes, we can
  	patchArrayMethods = function (array) {
  		array.__proto__ = patchedArrayProto;
  	};

  	unpatchArrayMethods = function (array) {
  		array.__proto__ = Array.prototype;
  	};
  } else {
  	// no, we can't
  	patchArrayMethods = function (array) {
  		var i, methodName;

  		i = mutatorMethods.length;
  		while (i--) {
  			methodName = mutatorMethods[i];
  			defineProperty(array, methodName, {
  				value: patchedArrayProto[methodName],
  				configurable: true
  			});
  		}
  	};

  	unpatchArrayMethods = function (array) {
  		var i;

  		i = mutatorMethods.length;
  		while (i--) {
  			delete array[mutatorMethods[i]];
  		}
  	};
  }

  patchArrayMethods.unpatch = unpatchArrayMethods;
  var patch = patchArrayMethods;

  var arrayAdaptor,

  // helpers
  ArrayWrapper, array_index__errorMessage;

  arrayAdaptor = {
  	filter: function (object) {
  		// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,
  		// or the array didn't trigger the get() itself
  		return isArray(object) && (!object._ractive || !object._ractive.setting);
  	},
  	wrap: function (ractive, array, keypath) {
  		return new ArrayWrapper(ractive, array, keypath);
  	}
  };

  ArrayWrapper = function (ractive, array, keypath) {
  	this.root = ractive;
  	this.value = array;
  	this.keypath = getKeypath(keypath);

  	// if this array hasn't already been ractified, ractify it
  	if (!array._ractive) {

  		// define a non-enumerable _ractive property to store the wrappers
  		defineProperty(array, "_ractive", {
  			value: {
  				wrappers: [],
  				instances: [],
  				setting: false
  			},
  			configurable: true
  		});

  		patch(array);
  	}

  	// store the ractive instance, so we can handle transitions later
  	if (!array._ractive.instances[ractive._guid]) {
  		array._ractive.instances[ractive._guid] = 0;
  		array._ractive.instances.push(ractive);
  	}

  	array._ractive.instances[ractive._guid] += 1;
  	array._ractive.wrappers.push(this);
  };

  ArrayWrapper.prototype = {
  	get: function () {
  		return this.value;
  	},
  	teardown: function () {
  		var array, storage, wrappers, instances, index;

  		array = this.value;
  		storage = array._ractive;
  		wrappers = storage.wrappers;
  		instances = storage.instances;

  		// if teardown() was invoked because we're clearing the cache as a result of
  		// a change that the array itself triggered, we can save ourselves the teardown
  		// and immediate setup
  		if (storage.setting) {
  			return false; // so that we don't remove it from this.root.viewmodel.wrapped
  		}

  		index = wrappers.indexOf(this);
  		if (index === -1) {
  			throw new Error(array_index__errorMessage);
  		}

  		wrappers.splice(index, 1);

  		// if nothing else depends on this array, we can revert it to its
  		// natural state
  		if (!wrappers.length) {
  			delete array._ractive;
  			patch.unpatch(this.value);
  		} else {
  			// remove ractive instance if possible
  			instances[this.root._guid] -= 1;
  			if (!instances[this.root._guid]) {
  				index = instances.indexOf(this.root);

  				if (index === -1) {
  					throw new Error(array_index__errorMessage);
  				}

  				instances.splice(index, 1);
  			}
  		}
  	}
  };

  array_index__errorMessage = "Something went wrong in a rather interesting way";
  var array_index = arrayAdaptor;

  var numeric = /^\s*[0-9]+\s*$/;

  var createBranch = function (key) {
  	return numeric.test(key) ? [] : {};
  };

  var magicAdaptor, MagicWrapper;

  try {
  	Object.defineProperty({}, "test", { value: 0 });

  	magicAdaptor = {
  		filter: function (object, keypath, ractive) {
  			var parentWrapper, parentValue;

  			if (!keypath) {
  				return false;
  			}

  			keypath = getKeypath(keypath);

  			// If the parent value is a wrapper, other than a magic wrapper,
  			// we shouldn't wrap this property
  			if ((parentWrapper = ractive.viewmodel.wrapped[keypath.parent.str]) && !parentWrapper.magic) {
  				return false;
  			}

  			parentValue = ractive.viewmodel.get(keypath.parent);

  			// if parentValue is an array that doesn't include this member,
  			// we should return false otherwise lengths will get messed up
  			if (isArray(parentValue) && /^[0-9]+$/.test(keypath.lastKey)) {
  				return false;
  			}

  			return parentValue && (typeof parentValue === "object" || typeof parentValue === "function");
  		},
  		wrap: function (ractive, property, keypath) {
  			return new MagicWrapper(ractive, property, keypath);
  		}
  	};

  	MagicWrapper = function (ractive, value, keypath) {
  		var objKeypath, template, siblings;

  		keypath = getKeypath(keypath);

  		this.magic = true;

  		this.ractive = ractive;
  		this.keypath = keypath;
  		this.value = value;

  		this.prop = keypath.lastKey;

  		objKeypath = keypath.parent;
  		this.obj = objKeypath.isRoot ? ractive.viewmodel.data : ractive.viewmodel.get(objKeypath);

  		template = this.originalDescriptor = Object.getOwnPropertyDescriptor(this.obj, this.prop);

  		// Has this property already been wrapped?
  		if (template && template.set && (siblings = template.set._ractiveWrappers)) {

  			// Yes. Register this wrapper to this property, if it hasn't been already
  			if (siblings.indexOf(this) === -1) {
  				siblings.push(this);
  			}

  			return; // already wrapped
  		}

  		// No, it hasn't been wrapped
  		createAccessors(this, value, template);
  	};

  	MagicWrapper.prototype = {
  		get: function () {
  			return this.value;
  		},
  		reset: function (value) {
  			if (this.updating) {
  				return;
  			}

  			this.updating = true;
  			this.obj[this.prop] = value; // trigger set() accessor
  			global_runloop.addRactive(this.ractive);
  			this.ractive.viewmodel.mark(this.keypath, { keepExistingWrapper: true });
  			this.updating = false;
  			return true;
  		},
  		set: function (key, value) {
  			if (this.updating) {
  				return;
  			}

  			if (!this.obj[this.prop]) {
  				this.updating = true;
  				this.obj[this.prop] = createBranch(key);
  				this.updating = false;
  			}

  			this.obj[this.prop][key] = value;
  		},
  		teardown: function () {
  			var template, set, value, wrappers, index;

  			// If this method was called because the cache was being cleared as a
  			// result of a set()/update() call made by this wrapper, we return false
  			// so that it doesn't get torn down
  			if (this.updating) {
  				return false;
  			}

  			template = Object.getOwnPropertyDescriptor(this.obj, this.prop);
  			set = template && template.set;

  			if (!set) {
  				// most likely, this was an array member that was spliced out
  				return;
  			}

  			wrappers = set._ractiveWrappers;

  			index = wrappers.indexOf(this);
  			if (index !== -1) {
  				wrappers.splice(index, 1);
  			}

  			// Last one out, turn off the lights
  			if (!wrappers.length) {
  				value = this.obj[this.prop];

  				Object.defineProperty(this.obj, this.prop, this.originalDescriptor || {
  					writable: true,
  					enumerable: true,
  					configurable: true
  				});

  				this.obj[this.prop] = value;
  			}
  		}
  	};
  } catch (err) {
  	magicAdaptor = false; // no magic in this browser
  }

  var adaptors_magic = magicAdaptor;

  function createAccessors(originalWrapper, value, template) {

  	var object, property, oldGet, oldSet, get, set;

  	object = originalWrapper.obj;
  	property = originalWrapper.prop;

  	// Is this template configurable?
  	if (template && !template.configurable) {
  		// Special case - array length
  		if (property === "length") {
  			return;
  		}

  		throw new Error("Cannot use magic mode with property \"" + property + "\" - object is not configurable");
  	}

  	// Time to wrap this property
  	if (template) {
  		oldGet = template.get;
  		oldSet = template.set;
  	}

  	get = oldGet || function () {
  		return value;
  	};

  	set = function (v) {
  		if (oldSet) {
  			oldSet(v);
  		}

  		value = oldGet ? oldGet() : v;
  		set._ractiveWrappers.forEach(updateWrapper);
  	};

  	function updateWrapper(wrapper) {
  		var keypath, ractive;

  		wrapper.value = value;

  		if (wrapper.updating) {
  			return;
  		}

  		ractive = wrapper.ractive;
  		keypath = wrapper.keypath;

  		wrapper.updating = true;
  		global_runloop.start(ractive);

  		ractive.viewmodel.mark(keypath);

  		global_runloop.end();
  		wrapper.updating = false;
  	}

  	// Create an array of wrappers, in case other keypaths/ractives depend on this property.
  	// Handily, we can store them as a property of the set function. Yay JavaScript.
  	set._ractiveWrappers = [originalWrapper];
  	Object.defineProperty(object, property, { get: get, set: set, enumerable: true, configurable: true });
  }

  var magicArrayAdaptor, MagicArrayWrapper;

  if (adaptors_magic) {
  	magicArrayAdaptor = {
  		filter: function (object, keypath, ractive) {
  			return adaptors_magic.filter(object, keypath, ractive) && array_index.filter(object);
  		},

  		wrap: function (ractive, array, keypath) {
  			return new MagicArrayWrapper(ractive, array, keypath);
  		}
  	};

  	MagicArrayWrapper = function (ractive, array, keypath) {
  		this.value = array;

  		this.magic = true;

  		this.magicWrapper = adaptors_magic.wrap(ractive, array, keypath);
  		this.arrayWrapper = array_index.wrap(ractive, array, keypath);
  	};

  	MagicArrayWrapper.prototype = {
  		get: function () {
  			return this.value;
  		},
  		teardown: function () {
  			this.arrayWrapper.teardown();
  			this.magicWrapper.teardown();
  		},
  		reset: function (value) {
  			return this.magicWrapper.reset(value);
  		}
  	};
  }

  var magicArray = magicArrayAdaptor;

  var prototype_adapt = Viewmodel$adapt;

  var prefixers = {};
  function Viewmodel$adapt(keypath, value) {
  	var len, i, adaptor, wrapped;

  	if (!this.adaptors) return;

  	// Do we have an adaptor for this value?
  	len = this.adaptors.length;
  	for (i = 0; i < len; i += 1) {
  		adaptor = this.adaptors[i];

  		if (adaptor.filter(value, keypath, this.ractive)) {
  			wrapped = this.wrapped[keypath] = adaptor.wrap(this.ractive, value, keypath, getPrefixer(keypath));
  			wrapped.value = value;
  			return;
  		}
  	}
  }

  function prefixKeypath(obj, prefix) {
  	var prefixed = {},
  	    key;

  	if (!prefix) {
  		return obj;
  	}

  	prefix += ".";

  	for (key in obj) {
  		if (obj.hasOwnProperty(key)) {
  			prefixed[prefix + key] = obj[key];
  		}
  	}

  	return prefixed;
  }

  function getPrefixer(rootKeypath) {
  	var rootDot;

  	if (!prefixers[rootKeypath]) {
  		rootDot = rootKeypath ? rootKeypath + "." : "";

  		prefixers[rootKeypath] = function (relativeKeypath, value) {
  			var obj;

  			if (typeof relativeKeypath === "string") {
  				obj = {};
  				obj[rootDot + relativeKeypath] = value;
  				return obj;
  			}

  			if (typeof relativeKeypath === "object") {
  				// 'relativeKeypath' is in fact a hash, not a keypath
  				return rootDot ? prefixKeypath(relativeKeypath, rootKeypath) : relativeKeypath;
  			}
  		};
  	}

  	return prefixers[rootKeypath];
  }

  // TEMP

  var helpers_getUpstreamChanges = getUpstreamChanges;
  function getUpstreamChanges(changes) {
  	var upstreamChanges = [rootKeypath],
  	    i,
  	    keypath;

  	i = changes.length;
  	while (i--) {
  		keypath = changes[i].parent;

  		while (keypath && !keypath.isRoot) {
  			if (changes.indexOf(keypath) === -1) {
  				addToArray(upstreamChanges, keypath);
  			}
  			keypath = keypath.parent;
  		}
  	}

  	return upstreamChanges;
  }

  var applyChanges_notifyPatternObservers = notifyPatternObservers;

  function notifyPatternObservers(viewmodel, keypath, onlyDirect) {
  	var potentialWildcardMatches;

  	updateMatchingPatternObservers(viewmodel, keypath);

  	if (onlyDirect) {
  		return;
  	}

  	potentialWildcardMatches = keypath.wildcardMatches();
  	potentialWildcardMatches.forEach(function (upstreamPattern) {
  		cascade(viewmodel, upstreamPattern, keypath);
  	});
  }

  function cascade(viewmodel, upstreamPattern, keypath) {
  	var group, map, actualChildKeypath;

  	// TODO should be one or the other
  	upstreamPattern = upstreamPattern.str || upstreamPattern;

  	group = viewmodel.depsMap.patternObservers;
  	map = group && group[upstreamPattern];

  	if (!map) {
  		return;
  	}

  	map.forEach(function (childKeypath) {
  		actualChildKeypath = keypath.join(childKeypath.lastKey); // 'foo.bar.baz'

  		updateMatchingPatternObservers(viewmodel, actualChildKeypath);
  		cascade(viewmodel, childKeypath, actualChildKeypath);
  	});
  }

  function updateMatchingPatternObservers(viewmodel, keypath) {
  	viewmodel.patternObservers.forEach(function (observer) {
  		if (observer.regex.test(keypath.str)) {
  			observer.update(keypath);
  		}
  	});
  }

  var applyChanges = Viewmodel$applyChanges;

  function Viewmodel$applyChanges() {
  	var _this = this;

  	var self = this,
  	    changes,
  	    upstreamChanges,
  	    hash = {},
  	    bindings;

  	changes = this.changes;

  	if (!changes.length) {
  		// TODO we end up here on initial render. Perhaps we shouldn't?
  		return;
  	}

  	function invalidateComputation(computation) {
  		var key = computation.key;

  		if (computation.viewmodel === self) {
  			self.clearCache(key.str);
  			computation.invalidate();

  			changes.push(key);
  			cascade(key);
  		} else {
  			computation.viewmodel.mark(key);
  		}
  	}

  	function cascade(keypath) {
  		var map, computations;

  		if (self.noCascade.hasOwnProperty(keypath.str)) {
  			return;
  		}

  		if (computations = self.deps.computed[keypath.str]) {
  			computations.forEach(invalidateComputation);
  		}

  		if (map = self.depsMap.computed[keypath.str]) {
  			map.forEach(cascade);
  		}
  	}

  	changes.slice().forEach(cascade);

  	upstreamChanges = helpers_getUpstreamChanges(changes);
  	upstreamChanges.forEach(function (keypath) {
  		var computations;

  		// make sure we haven't already been down this particular keypath in this turn
  		if (changes.indexOf(keypath) === -1 && (computations = self.deps.computed[keypath.str])) {
  			computations.forEach(invalidateComputation);
  		}
  	});

  	this.changes = [];

  	// Pattern observers are a weird special case
  	if (this.patternObservers.length) {
  		upstreamChanges.forEach(function (keypath) {
  			return applyChanges_notifyPatternObservers(_this, keypath, true);
  		});
  		changes.forEach(function (keypath) {
  			return applyChanges_notifyPatternObservers(_this, keypath);
  		});
  	}

  	if (this.deps.observers) {
  		upstreamChanges.forEach(function (keypath) {
  			return notifyUpstreamDependants(_this, null, keypath, "observers");
  		});
  		notifyAllDependants(this, changes, "observers");
  	}

  	if (this.deps["default"]) {
  		bindings = [];
  		upstreamChanges.forEach(function (keypath) {
  			return notifyUpstreamDependants(_this, bindings, keypath, "default");
  		});

  		if (bindings.length) {
  			notifyBindings(this, bindings, changes);
  		}

  		notifyAllDependants(this, changes, "default");
  	}

  	// Return a hash of keypaths to updated values
  	changes.forEach(function (keypath) {
  		hash[keypath.str] = _this.get(keypath);
  	});

  	this.implicitChanges = {};
  	this.noCascade = {};

  	return hash;
  }

  function notifyUpstreamDependants(viewmodel, bindings, keypath, groupName) {
  	var dependants, value;

  	if (dependants = findDependants(viewmodel, keypath, groupName)) {
  		value = viewmodel.get(keypath);

  		dependants.forEach(function (d) {
  			// don't "set" the parent value, refine it
  			// i.e. not data = value, but data[foo] = fooValue
  			if (bindings && d.refineValue) {
  				bindings.push(d);
  			} else {
  				d.setValue(value);
  			}
  		});
  	}
  }

  function notifyBindings(viewmodel, bindings, changes) {

  	bindings.forEach(function (binding) {
  		var useSet = false,
  		    i = 0,
  		    length = changes.length,
  		    refinements = [];

  		while (i < length) {
  			var keypath = changes[i];

  			if (keypath === binding.keypath) {
  				useSet = true;
  				break;
  			}

  			if (keypath.slice(0, binding.keypath.length) === binding.keypath) {
  				refinements.push(keypath);
  			}

  			i++;
  		}

  		if (useSet) {
  			binding.setValue(viewmodel.get(binding.keypath));
  		}

  		if (refinements.length) {
  			binding.refineValue(refinements);
  		}
  	});
  }

  function notifyAllDependants(viewmodel, keypaths, groupName) {
  	var queue = [];

  	addKeypaths(keypaths);
  	queue.forEach(dispatch);

  	function addKeypaths(keypaths) {
  		keypaths.forEach(addKeypath);
  		keypaths.forEach(cascade);
  	}

  	function addKeypath(keypath) {
  		var deps = findDependants(viewmodel, keypath, groupName);

  		if (deps) {
  			queue.push({
  				keypath: keypath,
  				deps: deps
  			});
  		}
  	}

  	function cascade(keypath) {
  		var childDeps;

  		if (childDeps = viewmodel.depsMap[groupName][keypath.str]) {
  			addKeypaths(childDeps);
  		}
  	}

  	function dispatch(set) {
  		var value = viewmodel.get(set.keypath);
  		set.deps.forEach(function (d) {
  			return d.setValue(value);
  		});
  	}
  }

  function findDependants(viewmodel, keypath, groupName) {
  	var group = viewmodel.deps[groupName];
  	return group ? group[keypath.str] : null;
  }

  var capture = Viewmodel$capture;

  function Viewmodel$capture() {
  	this.captureGroups.push([]);
  }

  var clearCache = Viewmodel$clearCache;

  function Viewmodel$clearCache(keypath, keepExistingWrapper) {
  	var cacheMap, wrapper;

  	if (!keepExistingWrapper) {
  		// Is there a wrapped property at this keypath?
  		if (wrapper = this.wrapped[keypath]) {
  			// Did we unwrap it?
  			if (wrapper.teardown() !== false) {
  				// Is this right?
  				// What's the meaning of returning false from teardown?
  				// Could there be a GC ramification if this is a "real" ractive.teardown()?
  				this.wrapped[keypath] = null;
  			}
  		}
  	}

  	this.cache[keypath] = undefined;

  	if (cacheMap = this.cacheMap[keypath]) {
  		while (cacheMap.length) {
  			this.clearCache(cacheMap.pop());
  		}
  	}
  }

  var UnresolvedDependency = function (computation, ref) {
  	this.computation = computation;
  	this.viewmodel = computation.viewmodel;
  	this.ref = ref;

  	// TODO this seems like a red flag!
  	this.root = this.viewmodel.ractive;
  	this.parentFragment = this.root.component && this.root.component.parentFragment;
  };

  UnresolvedDependency.prototype = {
  	resolve: function (keypath) {
  		this.computation.softDeps.push(keypath);
  		this.computation.unresolvedDeps[keypath.str] = null;
  		this.viewmodel.register(keypath, this.computation, "computed");
  	}
  };

  var Computation_UnresolvedDependency = UnresolvedDependency;

  var Computation = function (key, signature) {
  	this.key = key;

  	this.getter = signature.getter;
  	this.setter = signature.setter;

  	this.hardDeps = signature.deps || [];
  	this.softDeps = [];
  	this.unresolvedDeps = {};

  	this.depValues = {};

  	this._dirty = this._firstRun = true;
  };

  Computation.prototype = {
  	constructor: Computation,

  	init: function (viewmodel) {
  		var _this = this;

  		var initial;

  		this.viewmodel = viewmodel;
  		this.bypass = true;

  		initial = viewmodel.get(this.key);
  		viewmodel.clearCache(this.key.str);

  		this.bypass = false;

  		if (this.setter && initial !== undefined) {
  			this.set(initial);
  		}

  		if (this.hardDeps) {
  			this.hardDeps.forEach(function (d) {
  				return viewmodel.register(d, _this, "computed");
  			});
  		}
  	},

  	invalidate: function () {
  		this._dirty = true;
  	},

  	get: function () {
  		var _this = this;

  		var newDeps,
  		    dependenciesChanged,
  		    dependencyValuesChanged = false;

  		if (this.getting) {
  			// prevent double-computation (e.g. caused by array mutation inside computation)
  			var msg = "The " + this.key.str + " computation indirectly called itself. This probably indicates a bug in the computation. It is commonly caused by `array.sort(...)` - if that's the case, clone the array first with `array.slice().sort(...)`";
  			warnOnce(msg);
  			return this.value;
  		}

  		this.getting = true;

  		if (this._dirty) {
  			// determine whether the inputs have changed, in case this depends on
  			// other computed values
  			if (this._firstRun || !this.hardDeps.length && !this.softDeps.length) {
  				dependencyValuesChanged = true;
  			} else {
  				[this.hardDeps, this.softDeps].forEach(function (deps) {
  					var keypath, value, i;

  					if (dependencyValuesChanged) {
  						return;
  					}

  					i = deps.length;
  					while (i--) {
  						keypath = deps[i];
  						value = _this.viewmodel.get(keypath);

  						if (!isEqual(value, _this.depValues[keypath.str])) {
  							_this.depValues[keypath.str] = value;
  							dependencyValuesChanged = true;

  							return;
  						}
  					}
  				});
  			}

  			if (dependencyValuesChanged) {
  				this.viewmodel.capture();

  				try {
  					this.value = this.getter();
  				} catch (err) {
  					warnIfDebug("Failed to compute \"%s\"", this.key.str);
  					logIfDebug(err.stack || err);

  					this.value = void 0;
  				}

  				newDeps = this.viewmodel.release();
  				dependenciesChanged = this.updateDependencies(newDeps);

  				if (dependenciesChanged) {
  					[this.hardDeps, this.softDeps].forEach(function (deps) {
  						deps.forEach(function (keypath) {
  							_this.depValues[keypath.str] = _this.viewmodel.get(keypath);
  						});
  					});
  				}
  			}

  			this._dirty = false;
  		}

  		this.getting = this._firstRun = false;
  		return this.value;
  	},

  	set: function (value) {
  		if (this.setting) {
  			this.value = value;
  			return;
  		}

  		if (!this.setter) {
  			throw new Error("Computed properties without setters are read-only. (This may change in a future version of Ractive!)");
  		}

  		this.setter(value);
  	},

  	updateDependencies: function (newDeps) {
  		var i, oldDeps, keypath, dependenciesChanged, unresolved;

  		oldDeps = this.softDeps;

  		// remove dependencies that are no longer used
  		i = oldDeps.length;
  		while (i--) {
  			keypath = oldDeps[i];

  			if (newDeps.indexOf(keypath) === -1) {
  				dependenciesChanged = true;
  				this.viewmodel.unregister(keypath, this, "computed");
  			}
  		}

  		// create references for any new dependencies
  		i = newDeps.length;
  		while (i--) {
  			keypath = newDeps[i];

  			if (oldDeps.indexOf(keypath) === -1 && (!this.hardDeps || this.hardDeps.indexOf(keypath) === -1)) {
  				dependenciesChanged = true;

  				// if this keypath is currently unresolved, we need to mark
  				// it as such. TODO this is a bit muddy...
  				if (isUnresolved(this.viewmodel, keypath) && !this.unresolvedDeps[keypath.str]) {
  					unresolved = new Computation_UnresolvedDependency(this, keypath.str);
  					newDeps.splice(i, 1);

  					this.unresolvedDeps[keypath.str] = unresolved;
  					global_runloop.addUnresolved(unresolved);
  				} else {
  					this.viewmodel.register(keypath, this, "computed");
  				}
  			}
  		}

  		if (dependenciesChanged) {
  			this.softDeps = newDeps.slice();
  		}

  		return dependenciesChanged;
  	}
  };

  function isUnresolved(viewmodel, keypath) {
  	var key = keypath.firstKey;

  	return !(key in viewmodel.data) && !(key in viewmodel.computations) && !(key in viewmodel.mappings);
  }

  var Computation_Computation = Computation;

  var compute = Viewmodel$compute;
  function Viewmodel$compute(key, signature) {
  	var computation = new Computation_Computation(key, signature);

  	if (this.ready) {
  		computation.init(this);
  	}

  	return this.computations[key.str] = computation;
  }

  var FAILED_LOOKUP = { FAILED_LOOKUP: true };

  var viewmodel_prototype_get = Viewmodel$get;

  var viewmodel_prototype_get__empty = {};
  function Viewmodel$get(keypath, options) {
  	var cache = this.cache,
  	    value,
  	    computation,
  	    wrapped,
  	    captureGroup,
  	    keypathStr = keypath.str,
  	    key;

  	options = options || viewmodel_prototype_get__empty;

  	// capture the keypath, if we're inside a computation
  	if (options.capture && (captureGroup = lastItem(this.captureGroups))) {
  		if (! ~captureGroup.indexOf(keypath)) {
  			captureGroup.push(keypath);
  		}
  	}

  	if (hasOwn.call(this.mappings, keypath.firstKey)) {
  		return this.mappings[keypath.firstKey].get(keypath, options);
  	}

  	if (keypath.isSpecial) {
  		return keypath.value;
  	}

  	if (cache[keypathStr] === undefined) {

  		// Is this a computed property?
  		if ((computation = this.computations[keypathStr]) && !computation.bypass) {
  			value = computation.get();
  			this.adapt(keypathStr, value);
  		}

  		// Is this a wrapped property?
  		else if (wrapped = this.wrapped[keypathStr]) {
  			value = wrapped.value;
  		}

  		// Is it the root?
  		else if (keypath.isRoot) {
  			this.adapt("", this.data);
  			value = this.data;
  		}

  		// No? Then we need to retrieve the value one key at a time
  		else {
  			value = retrieve(this, keypath);
  		}

  		cache[keypathStr] = value;
  	} else {
  		value = cache[keypathStr];
  	}

  	if (!options.noUnwrap && (wrapped = this.wrapped[keypathStr])) {
  		value = wrapped.get();
  	}

  	if (keypath.isRoot && options.fullRootGet) {
  		for (key in this.mappings) {
  			value[key] = this.mappings[key].getValue();
  		}
  	}

  	return value === FAILED_LOOKUP ? void 0 : value;
  }

  function retrieve(viewmodel, keypath) {

  	var parentValue, cacheMap, value, wrapped;

  	parentValue = viewmodel.get(keypath.parent);

  	if (wrapped = viewmodel.wrapped[keypath.parent.str]) {
  		parentValue = wrapped.get();
  	}

  	if (parentValue === null || parentValue === undefined) {
  		return;
  	}

  	// update cache map
  	if (!(cacheMap = viewmodel.cacheMap[keypath.parent.str])) {
  		viewmodel.cacheMap[keypath.parent.str] = [keypath.str];
  	} else {
  		if (cacheMap.indexOf(keypath.str) === -1) {
  			cacheMap.push(keypath.str);
  		}
  	}

  	// If this property doesn't exist, we return a sentinel value
  	// so that we know to query parent scope (if such there be)
  	if (typeof parentValue === "object" && !(keypath.lastKey in parentValue)) {
  		return viewmodel.cache[keypath.str] = FAILED_LOOKUP;
  	}

  	value = parentValue[keypath.lastKey];

  	// Do we have an adaptor for this value?
  	viewmodel.adapt(keypath.str, value, false);

  	// Update cache
  	viewmodel.cache[keypath.str] = value;
  	return value;
  }

  var viewmodel_prototype_init = Viewmodel$init;

  function Viewmodel$init() {
  	var key;

  	for (key in this.computations) {
  		this.computations[key].init(this);
  	}
  }

  var prototype_map = Viewmodel$map;

  function Viewmodel$map(key, options) {
  	var mapping = this.mappings[key.str] = new Mapping(key, options);
  	mapping.initViewmodel(this);
  	return mapping;
  }

  var Mapping = function (localKey, options) {
  	this.localKey = localKey;
  	this.keypath = options.keypath;
  	this.origin = options.origin;

  	this.deps = [];
  	this.unresolved = [];

  	this.resolved = false;
  };

  Mapping.prototype = {
  	forceResolution: function () {
  		// TODO warn, as per #1692?
  		this.keypath = this.localKey;
  		this.setup();
  	},

  	get: function (keypath, options) {
  		if (!this.resolved) {
  			return undefined;
  		}
  		return this.origin.get(this.map(keypath), options);
  	},

  	getValue: function () {
  		if (!this.keypath) {
  			return undefined;
  		}
  		return this.origin.get(this.keypath);
  	},

  	initViewmodel: function (viewmodel) {
  		this.local = viewmodel;
  		this.setup();
  	},

  	map: function (keypath) {
  		if (typeof this.keypath === undefined) {
  			return this.localKey;
  		}
  		return keypath.replace(this.localKey, this.keypath);
  	},

  	register: function (keypath, dependant, group) {
  		this.deps.push({ keypath: keypath, dep: dependant, group: group });

  		if (this.resolved) {
  			this.origin.register(this.map(keypath), dependant, group);
  		}
  	},

  	resolve: function (keypath) {
  		if (this.keypath !== undefined) {
  			this.unbind(true);
  		}

  		this.keypath = keypath;
  		this.setup();
  	},

  	set: function (keypath, value) {
  		if (!this.resolved) {
  			this.forceResolution();
  		}

  		this.origin.set(this.map(keypath), value);
  	},

  	setup: function () {
  		var _this = this;

  		if (this.keypath === undefined) {
  			return;
  		}

  		this.resolved = true;

  		// accumulated dependants can now be registered
  		if (this.deps.length) {
  			this.deps.forEach(function (d) {
  				var keypath = _this.map(d.keypath);
  				_this.origin.register(keypath, d.dep, d.group);

  				// TODO this is a bit of a red flag... all deps should be the same?
  				if (d.dep.setValue) {
  					d.dep.setValue(_this.origin.get(keypath));
  				} else if (d.dep.invalidate) {
  					d.dep.invalidate();
  				} else {
  					throw new Error("An unexpected error occurred. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!");
  				}
  			});

  			this.origin.mark(this.keypath);
  		}
  	},

  	setValue: function (value) {
  		if (!this.keypath) {
  			throw new Error("Mapping does not have keypath, cannot set value. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!");
  		}

  		this.origin.set(this.keypath, value);
  	},

  	unbind: function (keepLocal) {
  		var _this = this;

  		if (!keepLocal) {
  			delete this.local.mappings[this.localKey];
  		}

  		if (!this.resolved) {
  			return;
  		}

  		this.deps.forEach(function (d) {
  			_this.origin.unregister(_this.map(d.keypath), d.dep, d.group);
  		});

  		if (this.tracker) {
  			this.origin.unregister(this.keypath, this.tracker);
  		}
  	},

  	unregister: function (keypath, dependant, group) {
  		var deps, i;

  		if (!this.resolved) {
  			return;
  		}

  		deps = this.deps;
  		i = deps.length;

  		while (i--) {
  			if (deps[i].dep === dependant) {
  				deps.splice(i, 1);
  				break;
  			}
  		}
  		this.origin.unregister(this.map(keypath), dependant, group);
  	}
  };

  var mark = Viewmodel$mark;

  function Viewmodel$mark(keypath, options) {
  	var computation,
  	    keypathStr = keypath.str;

  	// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)
  	// should not be picked up by pattern observers
  	if (options) {
  		if (options.implicit) {
  			this.implicitChanges[keypathStr] = true;
  		}
  		if (options.noCascade) {
  			this.noCascade[keypathStr] = true;
  		}
  	}

  	if (computation = this.computations[keypathStr]) {
  		computation.invalidate();
  	}

  	if (this.changes.indexOf(keypath) === -1) {
  		this.changes.push(keypath);
  	}

  	// pass on keepExistingWrapper, if we can
  	var keepExistingWrapper = options ? options.keepExistingWrapper : false;

  	this.clearCache(keypathStr, keepExistingWrapper);

  	if (this.ready) {
  		this.onchange();
  	}
  }

  var mapOldToNewIndex = function (oldArray, newArray) {
  	var usedIndices, firstUnusedIndex, newIndices, changed;

  	usedIndices = {};
  	firstUnusedIndex = 0;

  	newIndices = oldArray.map(function (item, i) {
  		var index, start, len;

  		start = firstUnusedIndex;
  		len = newArray.length;

  		do {
  			index = newArray.indexOf(item, start);

  			if (index === -1) {
  				changed = true;
  				return -1;
  			}

  			start = index + 1;
  		} while (usedIndices[index] && start < len);

  		// keep track of the first unused index, so we don't search
  		// the whole of newArray for each item in oldArray unnecessarily
  		if (index === firstUnusedIndex) {
  			firstUnusedIndex += 1;
  		}

  		if (index !== i) {
  			changed = true;
  		}

  		usedIndices[index] = true;
  		return index;
  	});

  	return newIndices;
  };

  var merge = Viewmodel$merge;

  var comparators = {};
  function Viewmodel$merge(keypath, currentArray, array, options) {
  	var oldArray, newArray, comparator, newIndices;

  	this.mark(keypath);

  	if (options && options.compare) {

  		comparator = getComparatorFunction(options.compare);

  		try {
  			oldArray = currentArray.map(comparator);
  			newArray = array.map(comparator);
  		} catch (err) {
  			// fallback to an identity check - worst case scenario we have
  			// to do more DOM manipulation than we thought...
  			warnIfDebug("merge(): \"%s\" comparison failed. Falling back to identity checking", keypath);

  			oldArray = currentArray;
  			newArray = array;
  		}
  	} else {
  		oldArray = currentArray;
  		newArray = array;
  	}

  	// find new indices for members of oldArray
  	newIndices = mapOldToNewIndex(oldArray, newArray);

  	this.smartUpdate(keypath, array, newIndices, currentArray.length !== array.length);
  }

  function stringify(item) {
  	return JSON.stringify(item);
  }

  function getComparatorFunction(comparator) {
  	// If `compare` is `true`, we use JSON.stringify to compare
  	// objects that are the same shape, but non-identical - i.e.
  	// { foo: 'bar' } !== { foo: 'bar' }
  	if (comparator === true) {
  		return stringify;
  	}

  	if (typeof comparator === "string") {
  		if (!comparators[comparator]) {
  			comparators[comparator] = function (item) {
  				return item[comparator];
  			};
  		}

  		return comparators[comparator];
  	}

  	if (typeof comparator === "function") {
  		return comparator;
  	}

  	throw new Error("The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)");
  }

  var register = Viewmodel$register;

  function Viewmodel$register(keypath, dependant) {
  	var group = arguments[2] === undefined ? "default" : arguments[2];

  	var mapping, depsByKeypath, deps;

  	if (dependant.isStatic) {
  		return; // TODO we should never get here if a dependant is static...
  	}

  	if (mapping = this.mappings[keypath.firstKey]) {
  		mapping.register(keypath, dependant, group);
  	} else {
  		depsByKeypath = this.deps[group] || (this.deps[group] = {});
  		deps = depsByKeypath[keypath.str] || (depsByKeypath[keypath.str] = []);

  		deps.push(dependant);

  		if (!this.depsMap[group]) {
  			this.depsMap[group] = {};
  		}

  		if (!keypath.isRoot) {
  			register__updateDependantsMap(this, keypath, group);
  		}
  	}
  }

  function register__updateDependantsMap(viewmodel, keypath, group) {
  	var map, parent, keypathStr;

  	// update dependants map
  	while (!keypath.isRoot) {
  		map = viewmodel.depsMap[group];
  		parent = map[keypath.parent.str] || (map[keypath.parent.str] = []);

  		keypathStr = keypath.str;

  		// TODO find an alternative to this nasty approach
  		if (parent["_" + keypathStr] === undefined) {
  			parent["_" + keypathStr] = 0;
  			parent.push(keypath);
  		}

  		parent["_" + keypathStr] += 1;
  		keypath = keypath.parent;
  	}
  }

  var release = Viewmodel$release;

  function Viewmodel$release() {
  	return this.captureGroups.pop();
  }

  var reset = Viewmodel$reset;

  function Viewmodel$reset(data) {
  	this.data = data;
  	this.clearCache("");
  }

  var prototype_set = Viewmodel$set;

  function Viewmodel$set(keypath, value) {
  	var options = arguments[2] === undefined ? {} : arguments[2];

  	var mapping, computation, wrapper, keepExistingWrapper;

  	// unless data is being set for data tracking purposes
  	if (!options.noMapping) {
  		// If this data belongs to a different viewmodel,
  		// pass the change along
  		if (mapping = this.mappings[keypath.firstKey]) {
  			return mapping.set(keypath, value);
  		}
  	}

  	computation = this.computations[keypath.str];
  	if (computation) {
  		if (computation.setting) {
  			// let the other computation set() handle things...
  			return;
  		}
  		computation.set(value);
  		value = computation.get();
  	}

  	if (isEqual(this.cache[keypath.str], value)) {
  		return;
  	}

  	wrapper = this.wrapped[keypath.str];

  	// If we have a wrapper with a `reset()` method, we try and use it. If the
  	// `reset()` method returns false, the wrapper should be torn down, and
  	// (most likely) a new one should be created later
  	if (wrapper && wrapper.reset) {
  		keepExistingWrapper = wrapper.reset(value) !== false;

  		if (keepExistingWrapper) {
  			value = wrapper.get();
  		}
  	}

  	if (!computation && !keepExistingWrapper) {
  		resolveSet(this, keypath, value);
  	}

  	if (!options.silent) {
  		this.mark(keypath);
  	} else {
  		// We're setting a parent of the original target keypath (i.e.
  		// creating a fresh branch) - we need to clear the cache, but
  		// not mark it as a change
  		this.clearCache(keypath.str);
  	}
  }

  function resolveSet(viewmodel, keypath, value) {
  	var wrapper, parentValue, wrapperSet, valueSet;

  	wrapperSet = function () {
  		if (wrapper.set) {
  			wrapper.set(keypath.lastKey, value);
  		} else {
  			parentValue = wrapper.get();
  			valueSet();
  		}
  	};

  	valueSet = function () {
  		if (!parentValue) {
  			parentValue = createBranch(keypath.lastKey);
  			viewmodel.set(keypath.parent, parentValue, { silent: true });
  		}
  		parentValue[keypath.lastKey] = value;
  	};

  	wrapper = viewmodel.wrapped[keypath.parent.str];

  	if (wrapper) {
  		wrapperSet();
  	} else {
  		parentValue = viewmodel.get(keypath.parent);

  		// may have been wrapped via the above .get()
  		// call on viewmodel if this is first access via .set()!
  		if (wrapper = viewmodel.wrapped[keypath.parent.str]) {
  			wrapperSet();
  		} else {
  			valueSet();
  		}
  	}
  }

  var smartUpdate = Viewmodel$smartUpdate;

  var implicitOption = { implicit: true },
      noCascadeOption = { noCascade: true };
  function Viewmodel$smartUpdate(keypath, array, newIndices) {
  	var _this = this;

  	var dependants, oldLength, i;

  	oldLength = newIndices.length;

  	// Indices that are being removed should be marked as dirty
  	newIndices.forEach(function (newIndex, oldIndex) {
  		if (newIndex === -1) {
  			_this.mark(keypath.join(oldIndex), noCascadeOption);
  		}
  	});

  	// Update the model
  	// TODO allow existing array to be updated in place, rather than replaced?
  	this.set(keypath, array, { silent: true });

  	if (dependants = this.deps["default"][keypath.str]) {
  		dependants.filter(canShuffle).forEach(function (d) {
  			return d.shuffle(newIndices, array);
  		});
  	}

  	if (oldLength !== array.length) {
  		this.mark(keypath.join("length"), implicitOption);

  		for (i = newIndices.touchedFrom; i < array.length; i += 1) {
  			this.mark(keypath.join(i));
  		}

  		// don't allow removed indexes beyond end of new array to trigger recomputations
  		// TODO is this still necessary, now that computations are lazy?
  		for (i = array.length; i < oldLength; i += 1) {
  			this.mark(keypath.join(i), noCascadeOption);
  		}
  	}
  }

  function canShuffle(dependant) {
  	return typeof dependant.shuffle === "function";
  }

  var prototype_teardown = Viewmodel$teardown;

  function Viewmodel$teardown() {
  	var _this = this;

  	var unresolvedImplicitDependency;

  	// Clear entire cache - this has the desired side-effect
  	// of unwrapping adapted values (e.g. arrays)
  	Object.keys(this.cache).forEach(function (keypath) {
  		return _this.clearCache(keypath);
  	});

  	// Teardown any failed lookups - we don't need them to resolve any more
  	while (unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop()) {
  		unresolvedImplicitDependency.teardown();
  	}
  }

  var unregister = Viewmodel$unregister;

  function Viewmodel$unregister(keypath, dependant) {
  	var group = arguments[2] === undefined ? "default" : arguments[2];

  	var mapping, deps, index;

  	if (dependant.isStatic) {
  		return;
  	}

  	if (mapping = this.mappings[keypath.firstKey]) {
  		return mapping.unregister(keypath, dependant, group);
  	}

  	deps = this.deps[group][keypath.str];
  	index = deps.indexOf(dependant);

  	if (index === -1) {
  		throw new Error("Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks");
  	}

  	deps.splice(index, 1);

  	if (keypath.isRoot) {
  		return;
  	}

  	unregister__updateDependantsMap(this, keypath, group);
  }

  function unregister__updateDependantsMap(viewmodel, keypath, group) {
  	var map, parent;

  	// update dependants map
  	while (!keypath.isRoot) {
  		map = viewmodel.depsMap[group];
  		parent = map[keypath.parent.str];

  		parent["_" + keypath.str] -= 1;

  		if (!parent["_" + keypath.str]) {
  			// remove from parent deps map
  			removeFromArray(parent, keypath);
  			parent["_" + keypath.str] = undefined;
  		}

  		keypath = keypath.parent;
  	}
  }

  var Viewmodel = function (options) {
  	var adapt = options.adapt;
  	var data = options.data;
  	var ractive = options.ractive;
  	var computed = options.computed;
  	var mappings = options.mappings;
  	var key;
  	var mapping;

  	// TODO is it possible to remove this reference?
  	this.ractive = ractive;

  	this.adaptors = adapt;
  	this.onchange = options.onchange;

  	this.cache = {}; // we need to be able to use hasOwnProperty, so can't inherit from null
  	this.cacheMap = create(null);

  	this.deps = {
  		computed: create(null),
  		"default": create(null)
  	};
  	this.depsMap = {
  		computed: create(null),
  		"default": create(null)
  	};

  	this.patternObservers = [];

  	this.specials = create(null);

  	this.wrapped = create(null);
  	this.computations = create(null);

  	this.captureGroups = [];
  	this.unresolvedImplicitDependencies = [];

  	this.changes = [];
  	this.implicitChanges = {};
  	this.noCascade = {};

  	this.data = data;

  	// set up explicit mappings
  	this.mappings = create(null);
  	for (key in mappings) {
  		this.map(getKeypath(key), mappings[key]);
  	}

  	if (data) {
  		// if data exists locally, but is missing on the parent,
  		// we transfer ownership to the parent
  		for (key in data) {
  			if ((mapping = this.mappings[key]) && mapping.getValue() === undefined) {
  				mapping.setValue(data[key]);
  			}
  		}
  	}

  	for (key in computed) {
  		if (mappings && key in mappings) {
  			fatal("Cannot map to a computed property ('%s')", key);
  		}

  		this.compute(getKeypath(key), computed[key]);
  	}

  	this.ready = true;
  };

  Viewmodel.prototype = {
  	adapt: prototype_adapt,
  	applyChanges: applyChanges,
  	capture: capture,
  	clearCache: clearCache,
  	compute: compute,
  	get: viewmodel_prototype_get,
  	init: viewmodel_prototype_init,
  	map: prototype_map,
  	mark: mark,
  	merge: merge,
  	register: register,
  	release: release,
  	reset: reset,
  	set: prototype_set,
  	smartUpdate: smartUpdate,
  	teardown: prototype_teardown,
  	unregister: unregister
  };

  var viewmodel_Viewmodel = Viewmodel;

  function HookQueue(event) {
  	this.hook = new hooks_Hook(event);
  	this.inProcess = {};
  	this.queue = {};
  }

  HookQueue.prototype = {

  	constructor: HookQueue,

  	begin: function (ractive) {
  		this.inProcess[ractive._guid] = true;
  	},

  	end: function (ractive) {

  		var parent = ractive.parent;

  		// If this is *isn't* a child of a component that's in process,
  		// it should call methods or fire at this point
  		if (!parent || !this.inProcess[parent._guid]) {
  			fire(this, ractive);
  		}
  		// elsewise, handoff to parent to fire when ready
  		else {
  			getChildQueue(this.queue, parent).push(ractive);
  		}

  		delete this.inProcess[ractive._guid];
  	}
  };

  function getChildQueue(queue, ractive) {
  	return queue[ractive._guid] || (queue[ractive._guid] = []);
  }

  function fire(hookQueue, ractive) {

  	var childQueue = getChildQueue(hookQueue.queue, ractive);

  	hookQueue.hook.fire(ractive);

  	// queue is "live" because components can end up being
  	// added while hooks fire on parents that modify data values.
  	while (childQueue.length) {
  		fire(hookQueue, childQueue.shift());
  	}

  	delete hookQueue.queue[ractive._guid];
  }

  var hooks_HookQueue = HookQueue;

  var helpers_getComputationSignatures = getComputationSignatures;

  var helpers_getComputationSignatures__pattern = /\$\{([^\}]+)\}/g;
  function getComputationSignatures(ractive, computed) {
  	var signatures = {},
  	    key;

  	for (key in computed) {
  		signatures[key] = getComputationSignature(ractive, key, computed[key]);
  	}

  	return signatures;
  }

  function getComputationSignature(ractive, key, signature) {
  	var getter, setter;

  	if (typeof signature === "function") {
  		getter = helpers_getComputationSignatures__bind(signature, ractive);
  	}

  	if (typeof signature === "string") {
  		getter = createFunctionFromString(ractive, signature);
  	}

  	if (typeof signature === "object") {
  		if (typeof signature.get === "string") {
  			getter = createFunctionFromString(ractive, signature.get);
  		} else if (typeof signature.get === "function") {
  			getter = helpers_getComputationSignatures__bind(signature.get, ractive);
  		} else {
  			fatal("`%s` computation must have a `get()` method", key);
  		}

  		if (typeof signature.set === "function") {
  			setter = helpers_getComputationSignatures__bind(signature.set, ractive);
  		}
  	}

  	return { getter: getter, setter: setter };
  }

  function createFunctionFromString(ractive, str) {
  	var functionBody, hasThis, fn;

  	functionBody = "return (" + str.replace(helpers_getComputationSignatures__pattern, function (match, keypath) {
  		hasThis = true;
  		return "__ractive.get(\"" + keypath + "\")";
  	}) + ");";

  	if (hasThis) {
  		functionBody = "var __ractive = this; " + functionBody;
  	}

  	fn = new Function(functionBody);
  	return hasThis ? fn.bind(ractive) : fn;
  }

  function helpers_getComputationSignatures__bind(fn, context) {
  	return /this/.test(fn.toString()) ? fn.bind(context) : fn;
  }

  var constructHook = new hooks_Hook("construct");
  var configHook = new hooks_Hook("config");
  var initHook = new hooks_HookQueue("init");
  var initialise__uid = 0;

  var initialise__registryNames = ["adaptors", "components", "decorators", "easing", "events", "interpolators", "partials", "transitions"];

  var initialise = initialiseRactiveInstance;

  function initialiseRactiveInstance(ractive) {
  	var userOptions = arguments[1] === undefined ? {} : arguments[1];
  	var options = arguments[2] === undefined ? {} : arguments[2];

  	var el, viewmodel;

  	if (_Ractive.DEBUG) {
  		welcome();
  	}

  	initialiseProperties(ractive, options);

  	// TODO remove this, eventually
  	defineProperty(ractive, "data", { get: deprecateRactiveData });

  	// TODO don't allow `onconstruct` with `new Ractive()`, there's no need for it
  	constructHook.fire(ractive, userOptions);

  	// Add registries
  	initialise__registryNames.forEach(function (name) {
  		ractive[name] = utils_object__extend(create(ractive.constructor[name] || null), userOptions[name]);
  	});

  	// Create a viewmodel
  	viewmodel = new viewmodel_Viewmodel({
  		adapt: getAdaptors(ractive, ractive.adapt, userOptions),
  		data: custom_data.init(ractive.constructor, ractive, userOptions),
  		computed: helpers_getComputationSignatures(ractive, utils_object__extend(create(ractive.constructor.prototype.computed), userOptions.computed)),
  		mappings: options.mappings,
  		ractive: ractive,
  		onchange: function () {
  			return global_runloop.addRactive(ractive);
  		}
  	});

  	ractive.viewmodel = viewmodel;

  	// This can't happen earlier, because computed properties may call `ractive.get()`, etc
  	viewmodel.init();

  	// init config from Parent and options
  	config_config.init(ractive.constructor, ractive, userOptions);

  	configHook.fire(ractive);
  	initHook.begin(ractive);

  	// // If this is a component with a function `data` property, call the function
  	// // with `ractive` as context (unless the child was also a function)
  	// if ( typeof ractive.constructor.prototype.data === 'function' && typeof userOptions.data !== 'function' ) {
  	// 	viewmodel.reset( ractive.constructor.prototype.data.call( ractive ) || fatal( '`data` functions must return a data object' ) );
  	// }

  	// Render virtual DOM
  	if (ractive.template) {
  		var cssIds = undefined;

  		if (options.cssIds || ractive.cssId) {
  			cssIds = options.cssIds ? options.cssIds.slice() : [];

  			if (ractive.cssId) {
  				cssIds.push(ractive.cssId);
  			}
  		}

  		ractive.fragment = new virtualdom_Fragment({
  			template: ractive.template,
  			root: ractive,
  			owner: ractive, // saves doing `if ( this.parent ) { /*...*/ }` later on
  			cssIds: cssIds
  		});
  	}

  	initHook.end(ractive);

  	// render automatically ( if `el` is specified )
  	if (el = getElement(ractive.el)) {
  		var promise = ractive.render(el, ractive.append);

  		if (_Ractive.DEBUG_PROMISES) {
  			promise["catch"](function (err) {
  				warnOnceIfDebug("Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\n  Ractive.DEBUG_PROMISES = false;");
  				warnIfDebug("An error happened during rendering", { ractive: ractive });
  				err.stack && logIfDebug(err.stack);

  				throw err;
  			});
  		}
  	}
  }

  function getAdaptors(ractive, protoAdapt, userOptions) {
  	var adapt, magic, modifyArrays;

  	protoAdapt = protoAdapt.map(lookup);
  	adapt = ensureArray(userOptions.adapt).map(lookup);

  	adapt = initialise__combine(protoAdapt, adapt);

  	magic = "magic" in userOptions ? userOptions.magic : ractive.magic;
  	modifyArrays = "modifyArrays" in userOptions ? userOptions.modifyArrays : ractive.modifyArrays;

  	if (magic) {
  		if (!environment__magic) {
  			throw new Error("Getters and setters (magic mode) are not supported in this browser");
  		}

  		if (modifyArrays) {
  			adapt.push(magicArray);
  		}

  		adapt.push(adaptors_magic);
  	}

  	if (modifyArrays) {
  		adapt.push(array_index);
  	}

  	return adapt;

  	function lookup(adaptor) {
  		if (typeof adaptor === "string") {
  			adaptor = findInViewHierarchy("adaptors", ractive, adaptor);

  			if (!adaptor) {
  				fatal(missingPlugin(adaptor, "adaptor"));
  			}
  		}

  		return adaptor;
  	}
  }

  function initialise__combine(a, b) {
  	var c = a.slice(),
  	    i = b.length;

  	while (i--) {
  		if (! ~c.indexOf(b[i])) {
  			c.push(b[i]);
  		}
  	}

  	return c;
  }

  function initialiseProperties(ractive, options) {
  	// Generate a unique identifier, for places where you'd use a weak map if it
  	// existed
  	ractive._guid = "r-" + initialise__uid++;

  	// events
  	ractive._subs = create(null);

  	// storage for item configuration from instantiation to reset,
  	// like dynamic functions or original values
  	ractive._config = {};

  	// two-way bindings
  	ractive._twowayBindings = create(null);

  	// animations (so we can stop any in progress at teardown)
  	ractive._animations = [];

  	// nodes registry
  	ractive.nodes = {};

  	// live queries
  	ractive._liveQueries = [];
  	ractive._liveComponentQueries = [];

  	// bound data functions
  	ractive._boundFunctions = [];

  	// observers
  	ractive._observers = [];

  	// properties specific to inline components
  	if (options.component) {
  		ractive.parent = options.parent;
  		ractive.container = options.container || null;
  		ractive.root = ractive.parent.root;

  		ractive.component = options.component;
  		options.component.instance = ractive;

  		// for hackability, this could be an open option
  		// for any ractive instance, but for now, just
  		// for components and just for ractive...
  		ractive._inlinePartials = options.inlinePartials;
  	} else {
  		ractive.root = ractive;
  		ractive.parent = ractive.container = null;
  	}
  }

  function deprecateRactiveData() {
  	throw new Error("Using `ractive.data` is no longer supported - you must use the `ractive.get()` API instead");
  }

  function ComplexParameter(component, template, callback) {
  	this.parentFragment = component.parentFragment;
  	this.callback = callback;

  	this.fragment = new virtualdom_Fragment({
  		template: template,
  		root: component.root,
  		owner: this
  	});

  	this.update();
  }

  var initialise_ComplexParameter = ComplexParameter;

  ComplexParameter.prototype = {
  	bubble: function () {
  		if (!this.dirty) {
  			this.dirty = true;
  			global_runloop.addView(this);
  		}
  	},

  	update: function () {
  		this.callback(this.fragment.getValue());
  		this.dirty = false;
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		this.fragment.rebind(oldKeypath, newKeypath);
  	},

  	unbind: function () {
  		this.fragment.unbind();
  	}
  };

  var createInstance = function (component, Component, attributes, yieldTemplate, partials) {
  	var instance,
  	    parentFragment,
  	    ractive,
  	    fragment,
  	    container,
  	    inlinePartials = {},
  	    data = {},
  	    mappings = {},
  	    ready,
  	    resolvers = [];

  	parentFragment = component.parentFragment;
  	ractive = component.root;

  	partials = partials || {};
  	utils_object__extend(inlinePartials, partials);

  	// Make contents available as a {{>content}} partial
  	partials.content = yieldTemplate || [];

  	// set a default partial for yields with no name
  	inlinePartials[""] = partials.content;

  	if (Component.defaults.el) {
  		warnIfDebug("The <%s/> component has a default `el` property; it has been disregarded", component.name);
  	}

  	// find container
  	fragment = parentFragment;
  	while (fragment) {
  		if (fragment.owner.type === YIELDER) {
  			container = fragment.owner.container;
  			break;
  		}

  		fragment = fragment.parent;
  	}

  	// each attribute represents either a) data or b) a mapping
  	if (attributes) {
  		Object.keys(attributes).forEach(function (key) {
  			var attribute = attributes[key],
  			    parsed,
  			    resolver;

  			if (typeof attribute === "string") {
  				// it's static data
  				parsed = parseJSON(attribute);
  				data[key] = parsed ? parsed.value : attribute;
  			} else if (attribute === 0) {
  				// it had no '=', so we'll call it true
  				data[key] = true;
  			} else if (isArray(attribute)) {
  				// this represents dynamic data
  				if (isSingleInterpolator(attribute)) {
  					mappings[key] = {
  						origin: component.root.viewmodel,
  						keypath: undefined
  					};

  					resolver = createResolver(component, attribute[0], function (keypath) {
  						if (keypath.isSpecial) {
  							if (ready) {
  								instance.set(key, keypath.value); // TODO use viewmodel?
  							} else {
  								data[key] = keypath.value;

  								// TODO errr.... would be better if we didn't have to do this
  								delete mappings[key];
  							}
  						} else {
  							if (ready) {
  								instance.viewmodel.mappings[key].resolve(keypath);
  							} else {
  								// resolved immediately
  								mappings[key].keypath = keypath;
  							}
  						}
  					});
  				} else {
  					resolver = new initialise_ComplexParameter(component, attribute, function (value) {
  						if (ready) {
  							instance.set(key, value); // TODO use viewmodel?
  						} else {
  							data[key] = value;
  						}
  					});
  				}

  				resolvers.push(resolver);
  			} else {
  				throw new Error("erm wut");
  			}
  		});
  	}

  	instance = create(Component.prototype);

  	initialise(instance, {
  		el: null,
  		append: true,
  		data: data,
  		partials: partials,
  		magic: ractive.magic || Component.defaults.magic,
  		modifyArrays: ractive.modifyArrays,
  		// need to inherit runtime parent adaptors
  		adapt: ractive.adapt
  	}, {
  		parent: ractive,
  		component: component,
  		container: container,
  		mappings: mappings,
  		inlinePartials: inlinePartials,
  		cssIds: parentFragment.cssIds
  	});

  	ready = true;
  	component.resolvers = resolvers;

  	return instance;
  };

  function createResolver(component, template, callback) {
  	var resolver;

  	if (template.r) {
  		resolver = Resolvers_createReferenceResolver(component, template.r, callback);
  	} else if (template.x) {
  		resolver = new Resolvers_ExpressionResolver(component, component.parentFragment, template.x, callback);
  	} else if (template.rx) {
  		resolver = new ReferenceExpressionResolver_ReferenceExpressionResolver(component, template.rx, callback);
  	}

  	return resolver;
  }

  function isSingleInterpolator(template) {
  	return template.length === 1 && template[0].t === INTERPOLATOR;
  }

  // TODO how should event arguments be handled? e.g.
  // <widget on-foo='bar:1,2,3'/>
  // The event 'bar' will be fired on the parent instance
  // when 'foo' fires on the child, but the 1,2,3 arguments
  // will be lost

  var initialise_propagateEvents = propagateEvents;

  function propagateEvents(component, eventsDescriptor) {
  	var eventName;

  	for (eventName in eventsDescriptor) {
  		if (eventsDescriptor.hasOwnProperty(eventName)) {
  			propagateEvent(component.instance, component.root, eventName, eventsDescriptor[eventName]);
  		}
  	}
  }

  function propagateEvent(childInstance, parentInstance, eventName, proxyEventName) {
  	if (typeof proxyEventName !== "string") {
  		fatal("Components currently only support simple events - you cannot include arguments. Sorry!");
  	}

  	childInstance.on(eventName, function () {
  		var event, args;

  		// semi-weak test, but what else? tag the event obj ._isEvent ?
  		if (arguments.length && arguments[0] && arguments[0].node) {
  			event = Array.prototype.shift.call(arguments);
  		}

  		args = Array.prototype.slice.call(arguments);

  		shared_fireEvent(parentInstance, proxyEventName, { event: event, args: args });

  		// cancel bubbling
  		return false;
  	});
  }

  var initialise_updateLiveQueries = function (component) {
  	var ancestor, query;

  	// If there's a live query for this component type, add it
  	ancestor = component.root;
  	while (ancestor) {
  		if (query = ancestor._liveComponentQueries["_" + component.name]) {
  			query.push(component.instance);
  		}

  		ancestor = ancestor.parent;
  	}
  };

  var Component_prototype_init = Component$init;
  function Component$init(options, Component) {
  	var parentFragment, root;

  	if (!Component) {
  		throw new Error("Component \"" + this.name + "\" not found");
  	}

  	parentFragment = this.parentFragment = options.parentFragment;
  	root = parentFragment.root;

  	this.root = root;
  	this.type = COMPONENT;
  	this.name = options.template.e;
  	this.index = options.index;
  	this.indexRefBindings = {};
  	this.yielders = {};
  	this.resolvers = [];

  	createInstance(this, Component, options.template.a, options.template.f, options.template.p);
  	initialise_propagateEvents(this, options.template.v);

  	// intro, outro and decorator directives have no effect
  	if (options.template.t0 || options.template.t1 || options.template.t2 || options.template.o) {
  		warnIfDebug("The \"intro\", \"outro\" and \"decorator\" directives have no effect on components", { ractive: this.instance });
  	}

  	initialise_updateLiveQueries(this);
  }

  var Component_prototype_rebind = Component$rebind;

  function Component$rebind(oldKeypath, newKeypath) {
  	var query;

  	this.resolvers.forEach(rebind);

  	for (var k in this.yielders) {
  		if (this.yielders[k][0]) {
  			rebind(this.yielders[k][0]);
  		}
  	}

  	if (query = this.root._liveComponentQueries["_" + this.name]) {
  		query._makeDirty();
  	}

  	function rebind(x) {
  		x.rebind(oldKeypath, newKeypath);
  	}
  }

  var Component_prototype_render = Component$render;

  function Component$render() {
  	var instance = this.instance;

  	instance.render(this.parentFragment.getNode());

  	this.rendered = true;
  	return instance.fragment.detach();
  }

  var Component_prototype_toString = Component$toString;

  function Component$toString() {
  	return this.instance.fragment.toString();
  }

  var Component_prototype_unbind = Component$unbind;

  var Component_prototype_unbind__teardownHook = new hooks_Hook("teardown");
  function Component$unbind() {
  	var instance = this.instance;

  	this.resolvers.forEach(methodCallers__unbind);

  	removeFromLiveComponentQueries(this);

  	instance._observers.forEach(cancel);

  	// teardown the instance
  	instance.fragment.unbind();
  	instance.viewmodel.teardown();

  	if (instance.fragment.rendered && instance.el.__ractive_instances__) {
  		removeFromArray(instance.el.__ractive_instances__, instance);
  	}

  	Component_prototype_unbind__teardownHook.fire(instance);
  }

  function removeFromLiveComponentQueries(component) {
  	var instance, query;

  	instance = component.root;

  	do {
  		if (query = instance._liveComponentQueries["_" + component.name]) {
  			query._remove(component);
  		}
  	} while (instance = instance.parent);
  }

  var Component_prototype_unrender = Component$unrender;

  function Component$unrender(shouldDestroy) {
  	this.shouldDestroy = shouldDestroy;
  	this.instance.unrender();
  }

  var Component = function (options, Constructor) {
  	this.init(options, Constructor);
  };

  Component.prototype = {
  	detach: Component_prototype_detach,
  	find: Component_prototype_find,
  	findAll: Component_prototype_findAll,
  	findAllComponents: Component_prototype_findAllComponents,
  	findComponent: Component_prototype_findComponent,
  	findNextNode: Component_prototype_findNextNode,
  	firstNode: Component_prototype_firstNode,
  	init: Component_prototype_init,
  	rebind: Component_prototype_rebind,
  	render: Component_prototype_render,
  	toString: Component_prototype_toString,
  	unbind: Component_prototype_unbind,
  	unrender: Component_prototype_unrender
  };

  var _Component = Component;

  var Comment = function (options) {
  	this.type = COMMENT;
  	this.value = options.template.c;
  };

  Comment.prototype = {
  	detach: shared_detach,

  	firstNode: function () {
  		return this.node;
  	},

  	render: function () {
  		if (!this.node) {
  			this.node = document.createComment(this.value);
  		}

  		return this.node;
  	},

  	toString: function () {
  		return "<!--" + this.value + "-->";
  	},

  	unrender: function (shouldDestroy) {
  		if (shouldDestroy) {
  			this.node.parentNode.removeChild(this.node);
  		}
  	}
  };

  var items_Comment = Comment;

  var Yielder = function (options) {
  	var container, component;

  	this.type = YIELDER;

  	this.container = container = options.parentFragment.root;
  	this.component = component = container.component;

  	this.container = container;
  	this.containerFragment = options.parentFragment;
  	this.parentFragment = component.parentFragment;

  	var name = this.name = options.template.n || "";

  	var template = container._inlinePartials[name];

  	if (!template) {
  		warnIfDebug("Could not find template for partial \"" + name + "\"", { ractive: options.root });
  		template = [];
  	}

  	this.fragment = new virtualdom_Fragment({
  		owner: this,
  		root: container.parent,
  		template: template,
  		pElement: this.containerFragment.pElement
  	});

  	// even though only one yielder is allowed, we need to have an array of them
  	// as it's possible to cause a yielder to be created before the last one
  	// was destroyed in the same turn of the runloop
  	if (!isArray(component.yielders[name])) {
  		component.yielders[name] = [this];
  	} else {
  		component.yielders[name].push(this);
  	}

  	global_runloop.scheduleTask(function () {
  		if (component.yielders[name].length > 1) {
  			throw new Error("A component template can only have one {{yield" + (name ? " " + name : "") + "}} declaration at a time");
  		}
  	});
  };

  Yielder.prototype = {
  	detach: function () {
  		return this.fragment.detach();
  	},

  	find: function (selector) {
  		return this.fragment.find(selector);
  	},

  	findAll: function (selector, query) {
  		return this.fragment.findAll(selector, query);
  	},

  	findComponent: function (selector) {
  		return this.fragment.findComponent(selector);
  	},

  	findAllComponents: function (selector, query) {
  		return this.fragment.findAllComponents(selector, query);
  	},

  	findNextNode: function () {
  		return this.containerFragment.findNextNode(this);
  	},

  	firstNode: function () {
  		return this.fragment.firstNode();
  	},

  	getValue: function (options) {
  		return this.fragment.getValue(options);
  	},

  	render: function () {
  		return this.fragment.render();
  	},

  	unbind: function () {
  		this.fragment.unbind();
  	},

  	unrender: function (shouldDestroy) {
  		this.fragment.unrender(shouldDestroy);
  		removeFromArray(this.component.yielders[this.name], this);
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		this.fragment.rebind(oldKeypath, newKeypath);
  	},

  	toString: function () {
  		return this.fragment.toString();
  	}
  };

  var items_Yielder = Yielder;

  var Doctype = function (options) {
  	this.declaration = options.template.a;
  };

  Doctype.prototype = {
  	init: noop,
  	render: noop,
  	unrender: noop,
  	teardown: noop,
  	toString: function () {
  		return "<!DOCTYPE" + this.declaration + ">";
  	}
  };

  var items_Doctype = Doctype;

  var Fragment_prototype_init = Fragment$init;

  function Fragment$init(options) {
  	var _this = this;

  	this.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute
  	this.parent = this.owner.parentFragment;

  	// inherited properties
  	this.root = options.root;
  	this.pElement = options.pElement;
  	this.context = options.context;
  	this.index = options.index;
  	this.key = options.key;
  	this.registeredIndexRefs = [];

  	// encapsulated styles should be inherited until they get applied by an element
  	this.cssIds = "cssIds" in options ? options.cssIds : this.parent ? this.parent.cssIds : null;

  	this.items = options.template.map(function (template, i) {
  		return createItem({
  			parentFragment: _this,
  			pElement: options.pElement,
  			template: template,
  			index: i
  		});
  	});

  	this.value = this.argsList = null;
  	this.dirtyArgs = this.dirtyValue = true;

  	this.bound = true;
  }

  function createItem(options) {
  	if (typeof options.template === "string") {
  		return new items_Text(options);
  	}

  	switch (options.template.t) {
  		case YIELDER:
  			return new items_Yielder(options);
  		case INTERPOLATOR:
  			return new items_Interpolator(options);
  		case SECTION:
  			return new _Section(options);
  		case TRIPLE:
  			return new _Triple(options);
  		case ELEMENT:
  			var constructor = undefined;
  			if (constructor = Component_getComponent(options.parentFragment.root, options.template.e)) {
  				return new _Component(options, constructor);
  			}
  			return new _Element(options);
  		case PARTIAL:
  			return new _Partial(options);
  		case COMMENT:
  			return new items_Comment(options);
  		case DOCTYPE:
  			return new items_Doctype(options);

  		default:
  			throw new Error("Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!");
  	}
  }

  var Fragment_prototype_rebind = Fragment$rebind;
  function Fragment$rebind(oldKeypath, newKeypath) {

  	// assign new context keypath if needed
  	if (!this.owner || this.owner.hasContext) {
  		assignNewKeypath(this, "context", oldKeypath, newKeypath);
  	}

  	this.items.forEach(function (item) {
  		if (item.rebind) {
  			item.rebind(oldKeypath, newKeypath);
  		}
  	});
  }

  var Fragment_prototype_render = Fragment$render;

  function Fragment$render() {
  	var result;

  	if (this.items.length === 1) {
  		result = this.items[0].render();
  	} else {
  		result = document.createDocumentFragment();

  		this.items.forEach(function (item) {
  			result.appendChild(item.render());
  		});
  	}

  	this.rendered = true;
  	return result;
  }

  var Fragment_prototype_toString = Fragment$toString;

  function Fragment$toString(escape) {
  	if (!this.items) {
  		return "";
  	}

  	return this.items.map(escape ? toEscapedString : Fragment_prototype_toString__toString).join("");
  }

  function Fragment_prototype_toString__toString(item) {
  	return item.toString();
  }

  function toEscapedString(item) {
  	return item.toString(true);
  }

  var Fragment_prototype_unbind = Fragment$unbind;

  function Fragment$unbind() {
  	if (!this.bound) {
  		return;
  	}

  	this.items.forEach(unbindItem);
  	this.bound = false;
  }

  function unbindItem(item) {
  	if (item.unbind) {
  		item.unbind();
  	}
  }

  var Fragment_prototype_unrender = Fragment$unrender;

  function Fragment$unrender(shouldDestroy) {
  	if (!this.rendered) {
  		throw new Error("Attempted to unrender a fragment that was not rendered");
  	}

  	this.items.forEach(function (i) {
  		return i.unrender(shouldDestroy);
  	});
  	this.rendered = false;
  }

  var Fragment = function (options) {
  	this.init(options);
  };

  Fragment.prototype = {
  	bubble: prototype_bubble,
  	detach: Fragment_prototype_detach,
  	find: Fragment_prototype_find,
  	findAll: Fragment_prototype_findAll,
  	findAllComponents: Fragment_prototype_findAllComponents,
  	findComponent: Fragment_prototype_findComponent,
  	findNextNode: prototype_findNextNode,
  	firstNode: prototype_firstNode,
  	getArgsList: getArgsList,
  	getNode: getNode,
  	getValue: prototype_getValue,
  	init: Fragment_prototype_init,
  	rebind: Fragment_prototype_rebind,
  	registerIndexRef: function (idx) {
  		var idxs = this.registeredIndexRefs;
  		if (idxs.indexOf(idx) === -1) {
  			idxs.push(idx);
  		}
  	},
  	render: Fragment_prototype_render,
  	toString: Fragment_prototype_toString,
  	unbind: Fragment_prototype_unbind,
  	unregisterIndexRef: function (idx) {
  		var idxs = this.registeredIndexRefs;
  		idxs.splice(idxs.indexOf(idx), 1);
  	},
  	unrender: Fragment_prototype_unrender
  };

  var virtualdom_Fragment = Fragment;

  var prototype_reset = Ractive$reset;
  var shouldRerender = ["template", "partials", "components", "decorators", "events"],
      resetHook = new hooks_Hook("reset");
  function Ractive$reset(data) {
  	var promise, wrapper, changes, i, rerender;

  	data = data || {};

  	if (typeof data !== "object") {
  		throw new Error("The reset method takes either no arguments, or an object containing new data");
  	}

  	// If the root object is wrapped, try and use the wrapper's reset value
  	if ((wrapper = this.viewmodel.wrapped[""]) && wrapper.reset) {
  		if (wrapper.reset(data) === false) {
  			// reset was rejected, we need to replace the object
  			this.viewmodel.reset(data);
  		}
  	} else {
  		this.viewmodel.reset(data);
  	}

  	// reset config items and track if need to rerender
  	changes = config_config.reset(this);

  	i = changes.length;
  	while (i--) {
  		if (shouldRerender.indexOf(changes[i]) > -1) {
  			rerender = true;
  			break;
  		}
  	}

  	if (rerender) {
  		var component = undefined;

  		this.viewmodel.mark(rootKeypath);

  		// Is this is a component, we need to set the `shouldDestroy`
  		// flag, otherwise it will assume by default that a parent node
  		// will be detached, and therefore it doesn't need to bother
  		// detaching its own nodes
  		if (component = this.component) {
  			component.shouldDestroy = true;
  		}

  		this.unrender();

  		if (component) {
  			component.shouldDestroy = false;
  		}

  		// If the template changed, we need to destroy the parallel DOM
  		// TODO if we're here, presumably it did?
  		if (this.fragment.template !== this.template) {
  			this.fragment.unbind();

  			this.fragment = new virtualdom_Fragment({
  				template: this.template,
  				root: this,
  				owner: this
  			});
  		}

  		promise = this.render(this.el, this.anchor);
  	} else {
  		promise = global_runloop.start(this, true);
  		this.viewmodel.mark(rootKeypath);
  		global_runloop.end();
  	}

  	resetHook.fire(this, data);

  	return promise;
  }

  var resetPartial = function (name, partial) {
  	var promise,
  	    collection = [];

  	function collect(source, dest, ractive) {
  		// if this is a component and it has its own partial, bail
  		if (ractive && ractive.partials[name]) return;

  		source.forEach(function (item) {
  			// queue to rerender if the item is a partial and the current name matches
  			if (item.type === PARTIAL && item.getPartialName() === name) {
  				dest.push(item);
  			}

  			// if it has a fragment, process its items
  			if (item.fragment) {
  				collect(item.fragment.items, dest, ractive);
  			}

  			// or if it has fragments
  			if (isArray(item.fragments)) {
  				collect(item.fragments, dest, ractive);
  			}

  			// or if it is itself a fragment, process its items
  			else if (isArray(item.items)) {
  				collect(item.items, dest, ractive);
  			}

  			// or if it is a component, step in and process its items
  			else if (item.type === COMPONENT && item.instance) {
  				collect(item.instance.fragment.items, dest, item.instance);
  			}

  			// if the item is an element, process its attributes too
  			if (item.type === ELEMENT) {
  				if (isArray(item.attributes)) {
  					collect(item.attributes, dest, ractive);
  				}

  				if (isArray(item.conditionalAttributes)) {
  					collect(item.conditionalAttributes, dest, ractive);
  				}
  			}
  		});
  	}

  	collect(this.fragment.items, collection);
  	this.partials[name] = partial;

  	promise = global_runloop.start(this, true);

  	collection.forEach(function (item) {
  		item.value = undefined;
  		item.setValue(name);
  	});

  	global_runloop.end();

  	return promise;
  };

  // TODO should resetTemplate be asynchronous? i.e. should it be a case
  // of outro, update template, intro? I reckon probably not, since that
  // could be achieved with unrender-resetTemplate-render. Also, it should
  // conceptually be similar to resetPartial, which couldn't be async

  var resetTemplate = Ractive$resetTemplate;
  function Ractive$resetTemplate(template) {
  	var transitionsEnabled, component;

  	template_template.init(null, this, { template: template });

  	transitionsEnabled = this.transitionsEnabled;
  	this.transitionsEnabled = false;

  	// Is this is a component, we need to set the `shouldDestroy`
  	// flag, otherwise it will assume by default that a parent node
  	// will be detached, and therefore it doesn't need to bother
  	// detaching its own nodes
  	if (component = this.component) {
  		component.shouldDestroy = true;
  	}

  	this.unrender();

  	if (component) {
  		component.shouldDestroy = false;
  	}

  	// remove existing fragment and create new one
  	this.fragment.unbind();
  	this.fragment = new virtualdom_Fragment({
  		template: this.template,
  		root: this,
  		owner: this
  	});

  	this.render(this.el, this.anchor);

  	this.transitionsEnabled = transitionsEnabled;
  }

  var reverse = makeArrayMethod("reverse");

  var Ractive_prototype_set = Ractive$set;

  function Ractive$set(keypath, value) {
  	var map, promise;

  	promise = global_runloop.start(this, true);

  	// Set multiple keypaths in one go
  	if (isObject(keypath)) {
  		map = keypath;

  		for (keypath in map) {
  			if (map.hasOwnProperty(keypath)) {
  				value = map[keypath];
  				set(this, keypath, value);
  			}
  		}
  	}

  	// Set a single keypath
  	else {
  		set(this, keypath, value);
  	}

  	global_runloop.end();

  	return promise;
  }

  function set(ractive, keypath, value) {
  	keypath = getKeypath(normalise(keypath));

  	if (keypath.isPattern) {
  		getMatchingKeypaths(ractive, keypath).forEach(function (keypath) {
  			ractive.viewmodel.set(keypath, value);
  		});
  	} else {
  		ractive.viewmodel.set(keypath, value);
  	}
  }

  var shift = makeArrayMethod("shift");

  var prototype_sort = makeArrayMethod("sort");

  var splice = makeArrayMethod("splice");

  var subtract = Ractive$subtract;
  function Ractive$subtract(keypath, d) {
  	return shared_add(this, keypath, d === undefined ? -1 : -d);
  }

  // Teardown. This goes through the root fragment and all its children, removing observers
  // and generally cleaning up after itself

  var Ractive_prototype_teardown = Ractive$teardown;

  var Ractive_prototype_teardown__teardownHook = new hooks_Hook("teardown");
  function Ractive$teardown() {
  	var promise;

  	this.fragment.unbind();
  	this.viewmodel.teardown();

  	this._observers.forEach(cancel);

  	if (this.fragment.rendered && this.el.__ractive_instances__) {
  		removeFromArray(this.el.__ractive_instances__, this);
  	}

  	this.shouldDestroy = true;
  	promise = this.fragment.rendered ? this.unrender() : utils_Promise.resolve();

  	Ractive_prototype_teardown__teardownHook.fire(this);

  	this._boundFunctions.forEach(deleteFunctionCopy);

  	return promise;
  }

  function deleteFunctionCopy(bound) {
  	delete bound.fn[bound.prop];
  }

  var toggle = Ractive$toggle;
  function Ractive$toggle(keypath) {
  	var _this = this;

  	if (typeof keypath !== "string") {
  		throw new TypeError(badArguments);
  	}

  	var changes = undefined;

  	if (/\*/.test(keypath)) {
  		changes = {};

  		getMatchingKeypaths(this, getKeypath(normalise(keypath))).forEach(function (keypath) {
  			changes[keypath.str] = !_this.viewmodel.get(keypath);
  		});

  		return this.set(changes);
  	}

  	return this.set(keypath, !this.get(keypath));
  }

  var toHTML = Ractive$toHTML;

  function Ractive$toHTML() {
  	return this.fragment.toString(true);
  }

  var Ractive_prototype_unrender = Ractive$unrender;
  var unrenderHook = new hooks_Hook("unrender");
  function Ractive$unrender() {
  	var promise, shouldDestroy;

  	if (!this.fragment.rendered) {
  		warnIfDebug("ractive.unrender() was called on a Ractive instance that was not rendered");
  		return utils_Promise.resolve();
  	}

  	promise = global_runloop.start(this, true);

  	// If this is a component, and the component isn't marked for destruction,
  	// don't detach nodes from the DOM unnecessarily
  	shouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;

  	// Cancel any animations in progress
  	while (this._animations[0]) {
  		this._animations[0].stop(); // it will remove itself from the index
  	}

  	this.fragment.unrender(shouldDestroy);

  	removeFromArray(this.el.__ractive_instances__, this);

  	unrenderHook.fire(this);

  	global_runloop.end();
  	return promise;
  }

  var unshift = makeArrayMethod("unshift");

  var Ractive_prototype_update = Ractive$update;
  var updateHook = new hooks_Hook("update");
  function Ractive$update(keypath) {
  	var promise;

  	keypath = getKeypath(keypath) || rootKeypath;

  	promise = global_runloop.start(this, true);
  	this.viewmodel.mark(keypath);
  	global_runloop.end();

  	updateHook.fire(this, keypath);

  	return promise;
  }

  var prototype_updateModel = Ractive$updateModel;

  function Ractive$updateModel(keypath, cascade) {
  	var values, key, bindings;

  	if (typeof keypath === "string" && !cascade) {
  		bindings = this._twowayBindings[keypath];
  	} else {
  		bindings = [];

  		for (key in this._twowayBindings) {
  			if (!keypath || getKeypath(key).equalsOrStartsWith(keypath)) {
  				// TODO is this right?
  				bindings.push.apply(bindings, this._twowayBindings[key]);
  			}
  		}
  	}

  	values = consolidate(this, bindings);
  	return this.set(values);
  }

  function consolidate(ractive, bindings) {
  	var values = {},
  	    checkboxGroups = [];

  	bindings.forEach(function (b) {
  		var oldValue, newValue;

  		// special case - radio name bindings
  		if (b.radioName && !b.element.node.checked) {
  			return;
  		}

  		// special case - checkbox name bindings come in groups, so
  		// we want to get the value once at most
  		if (b.checkboxName) {
  			if (!checkboxGroups[b.keypath.str] && !b.changed()) {
  				checkboxGroups.push(b.keypath);
  				checkboxGroups[b.keypath.str] = b;
  			}

  			return;
  		}

  		oldValue = b.attribute.value;
  		newValue = b.getValue();

  		if (arrayContentsMatch(oldValue, newValue)) {
  			return;
  		}

  		if (!isEqual(oldValue, newValue)) {
  			values[b.keypath.str] = newValue;
  		}
  	});

  	// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`
  	if (checkboxGroups.length) {
  		checkboxGroups.forEach(function (keypath) {
  			var binding, oldValue, newValue;

  			binding = checkboxGroups[keypath.str]; // one to represent the entire group
  			oldValue = binding.attribute.value;
  			newValue = binding.getValue();

  			if (!arrayContentsMatch(oldValue, newValue)) {
  				values[keypath.str] = newValue;
  			}
  		});
  	}

  	return values;
  }

  var prototype = {
  	add: prototype_add,
  	animate: prototype_animate,
  	detach: prototype_detach,
  	find: prototype_find,
  	findAll: prototype_findAll,
  	findAllComponents: prototype_findAllComponents,
  	findComponent: prototype_findComponent,
  	findContainer: findContainer,
  	findParent: findParent,
  	fire: prototype_fire,
  	get: prototype_get,
  	insert: insert,
  	merge: prototype_merge,
  	observe: observe,
  	observeOnce: observeOnce,
  	off: off,
  	on: on,
  	once: once,
  	pop: pop,
  	push: push,
  	render: prototype_render,
  	reset: prototype_reset,
  	resetPartial: resetPartial,
  	resetTemplate: resetTemplate,
  	reverse: reverse,
  	set: Ractive_prototype_set,
  	shift: shift,
  	sort: prototype_sort,
  	splice: splice,
  	subtract: subtract,
  	teardown: Ractive_prototype_teardown,
  	toggle: toggle,
  	toHTML: toHTML,
  	toHtml: toHTML,
  	unrender: Ractive_prototype_unrender,
  	unshift: unshift,
  	update: Ractive_prototype_update,
  	updateModel: prototype_updateModel
  };

  var wrapMethod = function (method, superMethod, force) {

  	if (force || needsSuper(method, superMethod)) {

  		return function () {

  			var hasSuper = ("_super" in this),
  			    _super = this._super,
  			    result;

  			this._super = superMethod;

  			result = method.apply(this, arguments);

  			if (hasSuper) {
  				this._super = _super;
  			}

  			return result;
  		};
  	} else {
  		return method;
  	}
  };

  function needsSuper(method, superMethod) {
  	return typeof superMethod === "function" && /_super/.test(method);
  }

  var unwrapExtended = unwrap;

  function unwrap(Child) {
  	var options = {};

  	while (Child) {
  		addRegistries(Child, options);
  		addOtherOptions(Child, options);

  		if (Child._Parent !== _Ractive) {
  			Child = Child._Parent;
  		} else {
  			Child = false;
  		}
  	}

  	return options;
  }

  function addRegistries(Child, options) {
  	config_registries.forEach(function (r) {
  		addRegistry(r.useDefaults ? Child.prototype : Child, options, r.name);
  	});
  }

  function addRegistry(target, options, name) {
  	var registry,
  	    keys = Object.keys(target[name]);

  	if (!keys.length) {
  		return;
  	}

  	if (!(registry = options[name])) {
  		registry = options[name] = {};
  	}

  	keys.filter(function (key) {
  		return !(key in registry);
  	}).forEach(function (key) {
  		return registry[key] = target[name][key];
  	});
  }

  function addOtherOptions(Child, options) {
  	Object.keys(Child.prototype).forEach(function (key) {
  		if (key === "computed") {
  			return;
  		}

  		var value = Child.prototype[key];

  		if (!(key in options)) {
  			options[key] = value._method ? value._method : value;
  		}

  		// is it a wrapped function?
  		else if (typeof options[key] === "function" && typeof value === "function" && options[key]._method) {

  			var result = undefined,
  			    needsSuper = value._method;

  			if (needsSuper) {
  				value = value._method;
  			}

  			// rewrap bound directly to parent fn
  			result = wrapMethod(options[key]._method, value);

  			if (needsSuper) {
  				result._method = result;
  			}

  			options[key] = result;
  		}
  	});
  }

  var _extend = _extend__extend;

  function _extend__extend() {
  	for (var _len = arguments.length, options = Array(_len), _key = 0; _key < _len; _key++) {
  		options[_key] = arguments[_key];
  	}

  	if (!options.length) {
  		return extendOne(this);
  	} else {
  		return options.reduce(extendOne, this);
  	}
  }

  function extendOne(Parent) {
  	var options = arguments[1] === undefined ? {} : arguments[1];

  	var Child, proto;

  	// if we're extending with another Ractive instance...
  	//
  	//   var Human = Ractive.extend(...), Spider = Ractive.extend(...);
  	//   var Spiderman = Human.extend( Spider );
  	//
  	// ...inherit prototype methods and default options as well
  	if (options.prototype instanceof _Ractive) {
  		options = unwrapExtended(options);
  	}

  	Child = function (options) {
  		if (!(this instanceof Child)) return new Child(options);
  		initialise(this, options);
  	};

  	proto = create(Parent.prototype);
  	proto.constructor = Child;

  	// Static properties
  	defineProperties(Child, {
  		// alias prototype as defaults
  		defaults: { value: proto },

  		// extendable
  		extend: { value: _extend__extend, writable: true, configurable: true },

  		// Parent - for IE8, can't use Object.getPrototypeOf
  		_Parent: { value: Parent }
  	});

  	// extend configuration
  	config_config.extend(Parent, proto, options);

  	custom_data.extend(Parent, proto, options);

  	if (options.computed) {
  		proto.computed = utils_object__extend(create(Parent.prototype.computed), options.computed);
  	}

  	Child.prototype = proto;

  	return Child;
  }

  var getNodeInfo = function (node) {
  	var info = {},
  	    priv,
  	    indices;

  	if (!node || !(priv = node._ractive)) {
  		return info;
  	}

  	info.ractive = priv.root;
  	info.keypath = priv.keypath.str;
  	info.index = {};

  	// find all index references and resolve them
  	if (indices = Resolvers_findIndexRefs(priv.proxy.parentFragment)) {
  		info.index = Resolvers_findIndexRefs.resolve(indices);
  	}

  	return info;
  };

  var Ractive, properties;

  // Main Ractive required object
  Ractive = function (options) {
  	if (!(this instanceof Ractive)) return new Ractive(options);
  	initialise(this, options);
  };

  // Ractive properties
  properties = {

  	// debug flag
  	DEBUG: { writable: true, value: true },
  	DEBUG_PROMISES: { writable: true, value: true },

  	// static methods:
  	extend: { value: _extend },
  	getNodeInfo: { value: getNodeInfo },
  	parse: { value: _parse },

  	// Namespaced constructors
  	Promise: { value: utils_Promise },

  	// support
  	svg: { value: svg },
  	magic: { value: environment__magic },

  	// version
  	VERSION: { value: "0.7.3" },

  	// Plugins
  	adaptors: { writable: true, value: {} },
  	components: { writable: true, value: {} },
  	decorators: { writable: true, value: {} },
  	easing: { writable: true, value: static_easing },
  	events: { writable: true, value: {} },
  	interpolators: { writable: true, value: static_interpolators },
  	partials: { writable: true, value: {} },
  	transitions: { writable: true, value: {} }
  };

  // Ractive properties
  defineProperties(Ractive, properties);

  Ractive.prototype = utils_object__extend(prototype, config_defaults);

  Ractive.prototype.constructor = Ractive;

  // alias prototype as defaults
  Ractive.defaults = Ractive.prototype;

  // Ractive.js makes liberal use of things like Array.prototype.indexOf. In
  // older browsers, these are made available via a shim - here, we do a quick
  // pre-flight check to make sure that either a) we're not in a shit browser,
  // or b) we're using a Ractive-legacy.js build
  var FUNCTION = "function";

  if (typeof Date.now !== FUNCTION || typeof String.prototype.trim !== FUNCTION || typeof Object.keys !== FUNCTION || typeof Array.prototype.indexOf !== FUNCTION || typeof Array.prototype.forEach !== FUNCTION || typeof Array.prototype.map !== FUNCTION || typeof Array.prototype.filter !== FUNCTION || typeof window !== "undefined" && typeof window.addEventListener !== FUNCTION) {
  	throw new Error("It looks like you're attempting to use Ractive.js in an older browser. You'll need to use one of the 'legacy builds' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.");
  }

  var _Ractive = Ractive;

  return _Ractive;

}));


},{}],28:[function(require,module,exports){
module.exports = function denodeify(fn) {
	return function() {
		var self = this
		var args = Array.prototype.slice.call(arguments)
		return new Promise(function(resolve, reject) {
			args.push(function(err, res) {
				if (err) {
					reject(err)
				} else {
					resolve(res)
				}
			})

			var res = fn.apply(self, args)

			var isPromise = res
				&& (typeof res === 'object' || typeof res === 'function')
				&& typeof res.then === 'function'

			if (isPromise) {
				resolve(res)
			}
		})
	}
}

},{}],29:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],30:[function(require,module,exports){
'use strict';

function time(action, seconds) {
	return { action: action, seconds: seconds };
}
function walk(seconds) {
	return time('walk', seconds);
}
function jog(seconds) {
	return time('jog', seconds);
}
function warmup(seconds) {
	return time('warmup', seconds);
}
function cooldown(seconds) {
	return time('cooldown', seconds);
}

var firstWeek = [warmup(.05 * 60), jog(60), walk(60), jog(60), walk(60), jog(60), walk(60), jog(60), walk(60), jog(60), walk(60), jog(60), walk(60), jog(60), walk(60), jog(60), walk(60), cooldown(5 * 60)];
var secondWeek = [warmup(5 * 60), jog(90), walk(120), jog(90), walk(120), jog(90), walk(120), jog(90), walk(120), jog(90), walk(120), jog(90), walk(120), cooldown(4 * 60)];
var thirdWeek = [warmup(5 * 60), jog(90), walk(120), jog(90), walk(120), jog(3 * 60), walk(3 * 60), jog(3 * 60), walk(3 * 60), jog(90), walk(120), jog(90), walk(120), jog(3 * 60), walk(3 * 60), jog(3 * 60), walk(3 * 60), cooldown(5 * 60)];
var fourthWeek = [warmup(5 * 60), jog(5 * 60), walk(90), jog(5 * 60), walk(150), jog(3 * 60), walk(90), jog(5 * 60), cooldown(3 * 60 + 30)];
var fifthWeekDayOne = [warmup(5 * 60), jog(5 * 60), walk(3 * 60), jog(5 * 60), walk(3 * 60), jog(5 * 60), cooldown(4 * 60)];
var fifthWeekDayTwo = [warmup(5 * 60), jog(8 * 60), walk(5 * 60), jog(8 * 60), cooldown(4 * 60)];
var fifthWeekDayThree = [warmup(5 * 60), jog(20 * 60), cooldown(5 * 60)];

var sixthWeekDayOne = [warmup(5 * 60), jog(5 * 60), walk(3 * 60), jog(8 * 60), walk(3 * 60), jog(5 * 60), cooldown(4 * 60)];
var sixthWeekDayTwo = [warmup(5 * 60), jog(10 * 60), walk(3 * 60), jog(10 * 60), cooldown(4 * 60)];
var sixthWeekDayThree = [warmup(5 * 60), jog(22 * 60), cooldown(5 * 60)];

var seventhWeek = [warmup(5 * 60), jog(25)];

var eightWeek = [warmup(5 * 60), jog(28)];

var ninthWeek = [warmup(5 * 60), jog(30)];

module.exports = [[firstWeek, firstWeek, firstWeek], [secondWeek, secondWeek, secondWeek], [thirdWeek, thirdWeek, thirdWeek], [fourthWeek, fourthWeek, fourthWeek], [fifthWeekDayOne, fifthWeekDayTwo, fifthWeekDayThree], [sixthWeekDayOne, sixthWeekDayTwo, sixthWeekDayThree], [seventhWeek, seventhWeek, seventhWeek], [eightWeek, eightWeek, eightWeek], [ninthWeek, ninthWeek, ninthWeek]];

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyIsIm1vZGVsLmpzIiwibm9kZV9tb2R1bGVzL2Fic3RyYWN0LXN0YXRlLXJvdXRlci9kZWZhdWx0LXJvdXRlci1vcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzL2Fic3RyYWN0LXN0YXRlLXJvdXRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hYnN0cmFjdC1zdGF0ZS1yb3V0ZXIvbGliL2N1cnJlbnQtc3RhdGUuanMiLCJub2RlX21vZHVsZXMvYWJzdHJhY3Qtc3RhdGUtcm91dGVyL2xpYi9wcm9taXNlLW1hcC1zZXJpZXMuanMiLCJub2RlX21vZHVsZXMvYWJzdHJhY3Qtc3RhdGUtcm91dGVyL2xpYi9zdGF0ZS1jaGFuZ2UtbG9naWMuanMiLCJub2RlX21vZHVsZXMvYWJzdHJhY3Qtc3RhdGUtcm91dGVyL2xpYi9zdGF0ZS1jb21wYXJpc29uLmpzIiwibm9kZV9tb2R1bGVzL2Fic3RyYWN0LXN0YXRlLXJvdXRlci9saWIvc3RhdGUtc3RhdGUuanMiLCJub2RlX21vZHVsZXMvYWJzdHJhY3Qtc3RhdGUtcm91dGVyL2xpYi9zdGF0ZS1zdHJpbmctcGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL2Fic3RyYWN0LXN0YXRlLXJvdXRlci9saWIvc3RhdGUtdHJhbnNpdGlvbi1tYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2FycmF5LnByb3RvdHlwZS5maW5kL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbWJpbmUtYXJyYXlzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvaGFzaC1icm93bi1yb3V0ZXIvaGFzaC1sb2NhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9oYXNoLWJyb3duLXJvdXRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9uYXRpdmUtcHJvbWlzZS1vbmx5L25wby5qcyIsIm5vZGVfbW9kdWxlcy9wYWdlLXBhdGgtYnVpbGRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYWdlLXBhdGgtYnVpbGRlci9wYXRoLXBhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC13aXRoLXJldmVyc2libGUta2V5cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC13aXRoLXJldmVyc2libGUta2V5cy9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yYWN0aXZlLXN0YXRlLXJvdXRlci9yZW5kZXIuanMiLCJub2RlX21vZHVsZXMvcmFjdGl2ZS9yYWN0aXZlLmpzIiwibm9kZV9tb2R1bGVzL3RoZW4tZGVub2RlaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3h0ZW5kL2ltbXV0YWJsZS5qcyIsInNjaGVkdWxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUNBQSxJQUFNLFFBQVEsUUFBUSxZQUFSLENBQWQ7QUFDQSxJQUFNLHFCQUFxQixRQUFRLHNCQUFSLENBQTNCO0FBQ0EsSUFBTSxzQkFBc0IsUUFBUSx1QkFBUixDQUE1QjtBQUNBLElBQU0sdUJBQXVCLG1CQUFtQixRQUFRLFNBQVIsQ0FBbkIsQ0FBN0I7QUFDQSxJQUFNLGNBQWMsb0JBQW9CLG9CQUFwQixFQUEwQyxjQUExQyxDQUFwQjtBQUNBLElBQU0sUUFBUSxRQUFRLFNBQVIsQ0FBZDs7QUFFQSxTQUFTLE9BQVQsQ0FBaUIsSUFBakIsRUFBdUI7QUFDdEIsS0FBTSxNQUFNLEtBQUssTUFBTCxFQUFaO0FBQ0EsUUFBTyxDQUFDLFFBQUQsRUFBVyxRQUFYLEVBQXFCLFNBQXJCLEVBQWdDLFdBQWhDLEVBQTZDLFVBQTdDLEVBQXlELFFBQXpELEVBQW1FLFVBQW5FLEVBQStFLEdBQS9FLENBQVA7QUFDQTs7QUFFRCxTQUFTLFNBQVQsQ0FBbUIsSUFBbkIsRUFBeUI7QUFDeEIsS0FBTSxRQUFRLEtBQUssUUFBTCxFQUFkO0FBQ0EsUUFBTyxDQUFDLFNBQUQsRUFBWSxVQUFaLEVBQXdCLE9BQXhCLEVBQWlDLE9BQWpDLEVBQTBDLEtBQTFDLEVBQWlELE1BQWpELEVBQXlELE1BQXpELEVBQ04sUUFETSxFQUNJLFdBREosRUFDaUIsU0FEakIsRUFDNEIsVUFENUIsRUFDd0MsVUFEeEMsRUFDb0QsS0FEcEQsQ0FBUDtBQUVBOztBQUVELElBQU0sU0FBUztBQUNkLE9BQU0sTUFEUTtBQUVkLFdBQVUsTUFGSTtBQUdkLFNBQVEsT0FITTtBQUlkLE1BQUs7QUFKUyxDQUFmOztBQU9BLFlBQVksUUFBWixDQUFxQjtBQUNwQixPQUFNLGVBRGM7QUFFcEIsV0FBVSxnQkFGVTtBQUdwQixRQUFPLFNBSGE7QUFJcEIsVUFBUyxpQkFBUyxJQUFULEVBQWUsTUFBZixFQUF1QixFQUF2QixFQUEyQjtBQUNuQyxLQUFHLElBQUgsRUFBUztBQUNSLGFBQVUsS0FERjtBQUVSLFVBQU8sTUFBTSxJQUFOLEVBRkM7QUFHUix1QkFIUTtBQUlSO0FBSlEsR0FBVDtBQU1BO0FBWG1CLENBQXJCOztBQWNBLFlBQVksUUFBWixDQUFxQjtBQUNwQixPQUFNLE9BRGM7QUFFcEIsV0FBVTtBQUNULFlBQVUsUUFERDtBQUVULFlBQVU7QUFDVCxnQkFBYSxTQUFTLFdBQVQsR0FBdUI7QUFDbkMsV0FBTyxLQUFLLEdBQUwsQ0FBUyxNQUFULEVBQWlCLEtBQUssR0FBTCxDQUFTLGFBQVQsQ0FBakIsQ0FBUDtBQUNBLElBSFE7QUFJVCxlQUFZLFNBQVMsVUFBVCxHQUFzQjtBQUNqQyxXQUFPLEtBQUssR0FBTCxDQUFTLEtBQUssR0FBTCxDQUFTLGlCQUFULElBQThCLEtBQUssR0FBTCxDQUFTLGFBQVQsRUFBd0IsT0FBdEQsR0FBZ0UsR0FBekUsRUFBOEUsR0FBOUUsQ0FBUDtBQUNBLElBTlE7QUFPVCxVQUFPLFNBQVMsS0FBVCxHQUFpQjtBQUN2QixXQUFPLE9BQU8sS0FBSyxHQUFMLENBQVMsYUFBVCxFQUF3QixNQUEvQixDQUFQO0FBQ0E7QUFUUTtBQUZELEVBRlU7QUFnQnBCLFFBQU8sK0JBaEJhO0FBaUJwQixVQUFTLGlCQUFTLElBQVQsRUFBZSxNQUFmLEVBQXVCLEVBQXZCLEVBQTJCO0FBQ25DLEtBQUcsSUFBSCxFQUFTO0FBQ1IsU0FBTSxNQUFNLE9BQU8sSUFBYixFQUFtQixPQUFPLEdBQTFCLENBREU7QUFFUixlQUFZLE1BRko7QUFHUixnQkFBYSxDQUhMO0FBSVIsb0JBQWlCO0FBSlQsR0FBVDtBQU1BLEVBeEJtQjtBQXlCcEIsV0FBVSxrQkFBUyxPQUFULEVBQWtCO0FBQUEsTUFDWCxPQURXLEdBQ2EsT0FEYixDQUNuQixNQURtQjtBQUFBLE1BQ0YsVUFERSxHQUNhLE9BRGIsQ0FDRixVQURFOztBQUczQjs7QUFDQSxNQUFNLFVBQVUsSUFBSSxJQUFKLEVBQWhCOztBQUVBLFdBQVMsYUFBVCxHQUF5QjtBQUN4QixPQUFNLFdBQVcsUUFBUSxHQUFSLENBQVksYUFBWixJQUE2QixDQUE5QztBQUNBLE9BQU0saUJBQWlCLFFBQVEsR0FBUixDQUFZLE1BQVosRUFBb0IsTUFBM0M7O0FBRUEsT0FBSSxZQUFZLGNBQWhCLEVBQWdDO0FBQy9CLFlBQVEsSUFBUixDQUFhLE1BQWI7QUFDQSxJQUZELE1BRU87QUFDTixZQUFRLEdBQVIsQ0FBWTtBQUNYLGtCQUFhLFFBREY7QUFFWCxzQkFBaUI7QUFGTixLQUFaO0FBSUE7QUFDRDs7QUFFRCxNQUFNLFFBQVEsVUFBVSxHQUFWLEVBQWUsb0JBQW9CLFVBQUMsT0FBRCxFQUFVLFVBQVYsRUFBeUI7QUFDekUsT0FBTSxtQkFBbUIsUUFBUSxHQUFSLENBQVksaUJBQVosS0FBa0MsUUFBUSxHQUFSLENBQVksYUFBWixFQUEyQixPQUF0RjtBQUNBLE9BQUksZ0JBQUosRUFBc0I7QUFDckI7QUFDQTtBQUNBLElBSEQsTUFHTztBQUNOLFlBQVEsR0FBUixDQUFZO0FBQ1gsc0JBQWlCO0FBRE4sS0FBWjtBQUdBO0FBQ0QsR0FWNEIsQ0FBZixDQUFkOztBQVlBLFVBQVEsRUFBUixDQUFXLFFBQVgsRUFBcUI7QUFBQSxVQUFNLFlBQVksRUFBWixDQUFlLGVBQWYsQ0FBTjtBQUFBLEdBQXJCOztBQUVBLFVBQVEsRUFBUixDQUFXLE1BQVgsRUFBbUIsWUFBTTtBQUN4QixTQUFNLFFBQU4sQ0FBZTtBQUNkLFVBQU0sV0FBVyxJQURIO0FBRWQsU0FBSyxXQUFXLEdBRkY7QUFHZCxVQUFNO0FBSFEsSUFBZjtBQUtBLGVBQVksRUFBWixDQUFlLFVBQWY7QUFDQSxHQVBEOztBQVNBLFVBQVEsRUFBUixDQUFXLFNBQVgsRUFBc0IsS0FBdEI7QUFDQTtBQXJFbUIsQ0FBckI7O0FBd0VBLFlBQVksUUFBWixDQUFxQjtBQUNwQixPQUFNLFVBRGM7QUFFcEIsV0FBVSxXQUZVO0FBR3BCLFFBQU8sV0FIYTtBQUlwQixXQUFVLGtCQUFTLE9BQVQsRUFBa0I7QUFDM0IsTUFBTSxVQUFVLFdBQVcsWUFBTTtBQUNoQyxlQUFZLEVBQVosQ0FBZSxlQUFmO0FBQ0EsR0FGZSxFQUViLElBRmEsQ0FBaEI7O0FBSUEsVUFBUSxFQUFSLENBQVcsU0FBWCxFQUFzQjtBQUFBLFVBQU0sYUFBYSxPQUFiLENBQU47QUFBQSxHQUF0QjtBQUNBO0FBVm1CLENBQXJCOztBQWNBLFNBQVMsU0FBVCxDQUFtQixTQUFuQixFQUE4QixNQUE5QixFQUFzQztBQUNyQyxLQUFJLGdCQUFKOztBQUVBLFVBQVMsVUFBVCxHQUFzQjtBQUNyQixZQUFVLFlBQVksR0FBWixFQUFWO0FBQ0E7O0FBRUQsS0FBTSxXQUFXLFlBQVk7QUFBQSxTQUFNLE9BQU8sQ0FBQyxZQUFZLEdBQVosS0FBb0IsT0FBckIsSUFBZ0MsSUFBdkMsRUFBNkMsVUFBN0MsQ0FBTjtBQUFBLEVBQVosRUFBNEUsU0FBNUUsQ0FBakI7O0FBRUE7O0FBRUEsUUFBTztBQUFBLFNBQU0sY0FBYyxRQUFkLENBQU47QUFBQSxFQUFQO0FBQ0E7O0FBRUQsU0FBUyxtQkFBVCxDQUE2QixFQUE3QixFQUFpQztBQUNoQyxLQUFJLFlBQVksS0FBaEI7QUFDQSxRQUFPLFlBQWtCO0FBQUEsb0NBQU4sSUFBTTtBQUFOLE9BQU07QUFBQTs7QUFDeEIsTUFBSSxDQUFDLFNBQUwsRUFBZ0I7QUFDZixlQUFZLElBQVo7QUFDQSxVQUFPLHFCQUFQLENBQTZCLFlBQU07QUFDbEMsZ0JBQVksS0FBWjtBQUNBLE9BQUcsS0FBSCxDQUFTLElBQVQsRUFBZSxJQUFmO0FBQ0EsSUFIRDtBQUlBO0FBQ0QsRUFSRDtBQVNBOztBQUVELFlBQVksb0JBQVosQ0FBaUMsZUFBakM7Ozs7Ozs7QUN4SkEsSUFBTSxTQUFTLFFBQVEsT0FBUixDQUFmOztBQUVBLElBQU0sTUFBTSxNQUFaOztBQUVBLE9BQU8sT0FBUCxHQUFpQjtBQUNoQixPQUFNLFNBQVMsSUFBVCxHQUFnQjtBQUNyQixTQUFPLFdBQVcsc0JBQVgsQ0FBUDtBQUNBLEVBSGU7QUFJaEIsV0FBVSx3QkFBNEI7QUFBQSxNQUFsQixJQUFrQixRQUFsQixJQUFrQjtBQUFBLE1BQVosR0FBWSxRQUFaLEdBQVk7QUFBQSxNQUFQLElBQU8sUUFBUCxJQUFPOztBQUNyQyxTQUFPLE9BQU8sRUFBRSxPQUFPLHNCQUFULEVBQWlDLFVBQWpDLEVBQXVDLFFBQXZDLEVBQTRDLFVBQTVDLEVBQVAsQ0FBUDtBQUNBO0FBTmUsQ0FBakI7O0FBU0EsU0FBUyxvQkFBVCxHQUFnQztBQUMvQixLQUFNLGNBQWMsYUFBYSxPQUFiLENBQXFCLEdBQXJCLENBQXBCOztBQUVBLFFBQU8sY0FBYyxLQUFLLEtBQUwsQ0FBVyxXQUFYLENBQWQsR0FBd0MsRUFBL0M7QUFDQTs7QUFFRCxTQUFTLEtBQVQsQ0FBZSxLQUFmLEVBQXNCO0FBQ3JCLGNBQWEsT0FBYixDQUFxQixHQUFyQixFQUEwQixLQUFLLFNBQUwsQ0FBZSxLQUFmLENBQTFCO0FBQ0E7O0FBRUQsU0FBUyxVQUFULENBQW9CLEtBQXBCLEVBQTJCO0FBQzFCLE9BQU0sT0FBTixHQUFnQixRQUFRLElBQVIsQ0FBYSxJQUFiLEVBQW1CLEtBQW5CLENBQWhCO0FBQ0EsT0FBTSxNQUFOLEdBQWUsT0FBTyxJQUFQLENBQVksSUFBWixFQUFrQixLQUFsQixDQUFmO0FBQ0EsUUFBTyxLQUFQO0FBQ0E7O0FBRUQsU0FBUyxPQUFULENBQWlCLEtBQWpCLEVBQXdCLElBQXhCLEVBQThCO0FBQzdCLFFBQU8sTUFBTSxJQUFOLEtBQWUsRUFBdEI7QUFDQTs7QUFFRCxTQUFTLE1BQVQsQ0FBZ0IsS0FBaEIsRUFBdUIsSUFBdkIsRUFBNkIsR0FBN0IsRUFBa0M7QUFDakMsS0FBTSxZQUFZLFFBQVEsS0FBUixFQUFlLElBQWYsRUFBcUIsR0FBckIsQ0FBbEI7QUFDQSxRQUFPLFlBQVksSUFBSSxJQUFKLENBQVMsU0FBVCxDQUFaLEdBQWtDLElBQXpDO0FBQ0E7O0FBRUQsU0FBUyxNQUFULFFBQTBDO0FBQUEsS0FBekIsS0FBeUIsU0FBekIsS0FBeUI7QUFBQSxLQUFsQixJQUFrQixTQUFsQixJQUFrQjtBQUFBLEtBQVosR0FBWSxTQUFaLEdBQVk7QUFBQSxLQUFQLElBQU8sU0FBUCxJQUFPOztBQUN6QyxLQUFNLFdBQVcsT0FBTyxLQUFQLHNCQUNmLElBRGUsRUFDUixPQUFPLE1BQU0sSUFBTixDQUFQLHNCQUNOLEdBRE0sRUFDQSxLQUFLLE9BQUwsRUFEQSxFQURRLEVBQWpCOztBQU1BLE9BQU0sUUFBTjs7QUFFQSxRQUFPLFdBQVcsUUFBWCxDQUFQO0FBQ0E7OztBQ2hERDs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzN1Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuQkEsU0FBUyxJQUFULENBQWMsTUFBZCxFQUFzQixPQUF0QixFQUErQjtBQUM5QixRQUFPLEVBQUUsY0FBRixFQUFVLGdCQUFWLEVBQVA7QUFDQTtBQUNELFNBQVMsSUFBVCxDQUFjLE9BQWQsRUFBdUI7QUFDdEIsUUFBTyxLQUFLLE1BQUwsRUFBYSxPQUFiLENBQVA7QUFDQTtBQUNELFNBQVMsR0FBVCxDQUFhLE9BQWIsRUFBc0I7QUFDckIsUUFBTyxLQUFLLEtBQUwsRUFBWSxPQUFaLENBQVA7QUFDQTtBQUNELFNBQVMsTUFBVCxDQUFnQixPQUFoQixFQUF5QjtBQUN4QixRQUFPLEtBQUssUUFBTCxFQUFlLE9BQWYsQ0FBUDtBQUNBO0FBQ0QsU0FBUyxRQUFULENBQWtCLE9BQWxCLEVBQTJCO0FBQzFCLFFBQU8sS0FBSyxVQUFMLEVBQWlCLE9BQWpCLENBQVA7QUFDQTs7QUFFRCxJQUFNLFlBQVksQ0FDakIsT0FBTyxNQUFNLEVBQWIsQ0FEaUIsRUFFakIsSUFBSSxFQUFKLENBRmlCLEVBRVIsS0FBSyxFQUFMLENBRlEsRUFHakIsSUFBSSxFQUFKLENBSGlCLEVBR1IsS0FBSyxFQUFMLENBSFEsRUFJakIsSUFBSSxFQUFKLENBSmlCLEVBSVIsS0FBSyxFQUFMLENBSlEsRUFLakIsSUFBSSxFQUFKLENBTGlCLEVBS1IsS0FBSyxFQUFMLENBTFEsRUFNakIsSUFBSSxFQUFKLENBTmlCLEVBTVIsS0FBSyxFQUFMLENBTlEsRUFPakIsSUFBSSxFQUFKLENBUGlCLEVBT1IsS0FBSyxFQUFMLENBUFEsRUFRakIsSUFBSSxFQUFKLENBUmlCLEVBUVIsS0FBSyxFQUFMLENBUlEsRUFTakIsSUFBSSxFQUFKLENBVGlCLEVBU1IsS0FBSyxFQUFMLENBVFEsRUFVakIsU0FBUyxJQUFJLEVBQWIsQ0FWaUIsQ0FBbEI7QUFZQSxJQUFNLGFBQWEsQ0FDbEIsT0FBTyxJQUFJLEVBQVgsQ0FEa0IsRUFFbEIsSUFBSSxFQUFKLENBRmtCLEVBRVQsS0FBSyxHQUFMLENBRlMsRUFHbEIsSUFBSSxFQUFKLENBSGtCLEVBR1QsS0FBSyxHQUFMLENBSFMsRUFJbEIsSUFBSSxFQUFKLENBSmtCLEVBSVQsS0FBSyxHQUFMLENBSlMsRUFLbEIsSUFBSSxFQUFKLENBTGtCLEVBS1QsS0FBSyxHQUFMLENBTFMsRUFNbEIsSUFBSSxFQUFKLENBTmtCLEVBTVQsS0FBSyxHQUFMLENBTlMsRUFPbEIsSUFBSSxFQUFKLENBUGtCLEVBT1QsS0FBSyxHQUFMLENBUFMsRUFRbEIsU0FBUyxJQUFJLEVBQWIsQ0FSa0IsQ0FBbkI7QUFVQSxJQUFNLFlBQVksQ0FDakIsT0FBTyxJQUFJLEVBQVgsQ0FEaUIsRUFFakIsSUFBSSxFQUFKLENBRmlCLEVBRVIsS0FBSyxHQUFMLENBRlEsRUFHakIsSUFBSSxFQUFKLENBSGlCLEVBR1IsS0FBSyxHQUFMLENBSFEsRUFJakIsSUFBSSxJQUFJLEVBQVIsQ0FKaUIsRUFJSixLQUFLLElBQUksRUFBVCxDQUpJLEVBS2pCLElBQUksSUFBSSxFQUFSLENBTGlCLEVBS0osS0FBSyxJQUFJLEVBQVQsQ0FMSSxFQU1qQixJQUFJLEVBQUosQ0FOaUIsRUFNUixLQUFLLEdBQUwsQ0FOUSxFQU9qQixJQUFJLEVBQUosQ0FQaUIsRUFPUixLQUFLLEdBQUwsQ0FQUSxFQVFqQixJQUFJLElBQUksRUFBUixDQVJpQixFQVFKLEtBQUssSUFBSSxFQUFULENBUkksRUFTakIsSUFBSSxJQUFJLEVBQVIsQ0FUaUIsRUFTSixLQUFLLElBQUksRUFBVCxDQVRJLEVBVWpCLFNBQVMsSUFBSSxFQUFiLENBVmlCLENBQWxCO0FBWUEsSUFBTSxhQUFhLENBQ2xCLE9BQU8sSUFBSSxFQUFYLENBRGtCLEVBRWxCLElBQUksSUFBSSxFQUFSLENBRmtCLEVBRUwsS0FBSyxFQUFMLENBRkssRUFHbEIsSUFBSSxJQUFJLEVBQVIsQ0FIa0IsRUFHTCxLQUFLLEdBQUwsQ0FISyxFQUlsQixJQUFJLElBQUksRUFBUixDQUprQixFQUlMLEtBQUssRUFBTCxDQUpLLEVBS2xCLElBQUksSUFBSSxFQUFSLENBTGtCLEVBTWxCLFNBQVMsSUFBSSxFQUFKLEdBQVMsRUFBbEIsQ0FOa0IsQ0FBbkI7QUFRQSxJQUFNLGtCQUFrQixDQUN2QixPQUFPLElBQUksRUFBWCxDQUR1QixFQUV2QixJQUFJLElBQUksRUFBUixDQUZ1QixFQUVWLEtBQUssSUFBSSxFQUFULENBRlUsRUFHdkIsSUFBSSxJQUFJLEVBQVIsQ0FIdUIsRUFHVixLQUFLLElBQUksRUFBVCxDQUhVLEVBSXZCLElBQUksSUFBSSxFQUFSLENBSnVCLEVBS3ZCLFNBQVMsSUFBSSxFQUFiLENBTHVCLENBQXhCO0FBT0EsSUFBTSxrQkFBa0IsQ0FDdkIsT0FBTyxJQUFJLEVBQVgsQ0FEdUIsRUFFdkIsSUFBSSxJQUFJLEVBQVIsQ0FGdUIsRUFFVixLQUFLLElBQUksRUFBVCxDQUZVLEVBR3ZCLElBQUksSUFBSSxFQUFSLENBSHVCLEVBSXZCLFNBQVMsSUFBSSxFQUFiLENBSnVCLENBQXhCO0FBTUEsSUFBTSxvQkFBb0IsQ0FDekIsT0FBTyxJQUFJLEVBQVgsQ0FEeUIsRUFFekIsSUFBSSxLQUFLLEVBQVQsQ0FGeUIsRUFHekIsU0FBUyxJQUFJLEVBQWIsQ0FIeUIsQ0FBMUI7O0FBTUEsSUFBTSxrQkFBa0IsQ0FDdkIsT0FBTyxJQUFJLEVBQVgsQ0FEdUIsRUFFdkIsSUFBSSxJQUFJLEVBQVIsQ0FGdUIsRUFFVixLQUFLLElBQUksRUFBVCxDQUZVLEVBR3ZCLElBQUksSUFBSSxFQUFSLENBSHVCLEVBR1YsS0FBSyxJQUFJLEVBQVQsQ0FIVSxFQUl2QixJQUFJLElBQUksRUFBUixDQUp1QixFQUt2QixTQUFTLElBQUksRUFBYixDQUx1QixDQUF4QjtBQU9BLElBQU0sa0JBQWtCLENBQ3ZCLE9BQU8sSUFBSSxFQUFYLENBRHVCLEVBRXZCLElBQUksS0FBSyxFQUFULENBRnVCLEVBRVQsS0FBSyxJQUFJLEVBQVQsQ0FGUyxFQUd2QixJQUFJLEtBQUssRUFBVCxDQUh1QixFQUl2QixTQUFTLElBQUksRUFBYixDQUp1QixDQUF4QjtBQU1BLElBQU0sb0JBQW9CLENBQ3pCLE9BQU8sSUFBSSxFQUFYLENBRHlCLEVBRXpCLElBQUksS0FBSyxFQUFULENBRnlCLEVBR3pCLFNBQVMsSUFBSSxFQUFiLENBSHlCLENBQTFCOztBQU1BLElBQU0sY0FBYyxDQUNuQixPQUFPLElBQUksRUFBWCxDQURtQixFQUVuQixJQUFJLEVBQUosQ0FGbUIsQ0FBcEI7O0FBS0EsSUFBTSxZQUFZLENBQ2pCLE9BQU8sSUFBSSxFQUFYLENBRGlCLEVBRWpCLElBQUksRUFBSixDQUZpQixDQUFsQjs7QUFLQSxJQUFNLFlBQVksQ0FDakIsT0FBTyxJQUFJLEVBQVgsQ0FEaUIsRUFFakIsSUFBSSxFQUFKLENBRmlCLENBQWxCOztBQUtBLE9BQU8sT0FBUCxHQUFpQixDQUNoQixDQUFDLFNBQUQsRUFBWSxTQUFaLEVBQXVCLFNBQXZCLENBRGdCLEVBRWhCLENBQUMsVUFBRCxFQUFhLFVBQWIsRUFBeUIsVUFBekIsQ0FGZ0IsRUFHaEIsQ0FBQyxTQUFELEVBQVksU0FBWixFQUF1QixTQUF2QixDQUhnQixFQUloQixDQUFDLFVBQUQsRUFBYSxVQUFiLEVBQXlCLFVBQXpCLENBSmdCLEVBS2hCLENBQUMsZUFBRCxFQUFrQixlQUFsQixFQUFtQyxpQkFBbkMsQ0FMZ0IsRUFNaEIsQ0FBQyxlQUFELEVBQWtCLGVBQWxCLEVBQW1DLGlCQUFuQyxDQU5nQixFQU9oQixDQUFDLFdBQUQsRUFBYyxXQUFkLEVBQTJCLFdBQTNCLENBUGdCLEVBUWhCLENBQUMsU0FBRCxFQUFZLFNBQVosRUFBdUIsU0FBdkIsQ0FSZ0IsRUFTaEIsQ0FBQyxTQUFELEVBQVksU0FBWixFQUF1QixTQUF2QixDQVRnQixDQUFqQiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJjb25zdCB3ZWVrcyA9IHJlcXVpcmUoJy4vc2NoZWR1bGUnKVxuY29uc3QgcmFjdGl2ZVN0YXRlUm91dGVyID0gcmVxdWlyZSgncmFjdGl2ZS1zdGF0ZS1yb3V0ZXInKVxuY29uc3QgYWJzdHJhY3RTdGF0ZVJvdXRlciA9IHJlcXVpcmUoJ2Fic3RyYWN0LXN0YXRlLXJvdXRlcicpXG5jb25zdCByYWN0aXZlU3RhdGVSZW5kZXJlciA9IHJhY3RpdmVTdGF0ZVJvdXRlcihyZXF1aXJlKCdyYWN0aXZlJykpXG5jb25zdCBzdGF0ZVJvdXRlciA9IGFic3RyYWN0U3RhdGVSb3V0ZXIocmFjdGl2ZVN0YXRlUmVuZGVyZXIsICcjYXBwLWNvbnRlbnQnKVxuY29uc3QgbW9kZWwgPSByZXF1aXJlKCcuL21vZGVsJylcblxuZnVuY3Rpb24gZGF5TmFtZShkYXRlKSB7XG5cdGNvbnN0IGRheSA9IGRhdGUuZ2V0RGF5KClcblx0cmV0dXJuIFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXVtkYXldXG59XG5cbmZ1bmN0aW9uIG1vbnRoTmFtZShkYXRlKSB7XG5cdGNvbnN0IG1vbnRoID0gZGF0ZS5nZXRNb250aCgpXG5cdHJldHVybiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsXG5cdFx0J0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddW21vbnRoXVxufVxuXG5jb25zdCBjb2xvcnMgPSB7XG5cdHdhbGs6ICdibHVlJyxcblx0Y29vbGRvd246ICdhcXVhJyxcblx0d2FybXVwOiAnb2xpdmUnLFxuXHRqb2c6ICdvcmFuZ2UnXG59XG5cbnN0YXRlUm91dGVyLmFkZFN0YXRlKHtcblx0bmFtZTogJ2RheS1zZWxlY3Rpb24nLFxuXHR0ZW1wbGF0ZTogJyNkYXktc2VsZWN0aW9uJyxcblx0cm91dGU6ICcvc2VsZWN0Jyxcblx0cmVzb2x2ZTogZnVuY3Rpb24oZGF0YSwgcGFyYW1zLCBjYikge1xuXHRcdGNiKG51bGwsIHtcblx0XHRcdGFsbFBsYW5zOiB3ZWVrcyxcblx0XHRcdG1vZGVsOiBtb2RlbC5sb2FkKCksXG5cdFx0XHRtb250aE5hbWUsXG5cdFx0XHRkYXlOYW1lXG5cdFx0fSlcblx0fVxufSlcblxuc3RhdGVSb3V0ZXIuYWRkU3RhdGUoe1xuXHRuYW1lOiAndGltZXInLFxuXHR0ZW1wbGF0ZToge1xuXHRcdHRlbXBsYXRlOiAnI3RpbWVyJyxcblx0XHRjb21wdXRlZDoge1xuXHRcdFx0Y3VycmVudFBsYW46IGZ1bmN0aW9uIGN1cnJlbnRQbGFuKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXQoJ3BsYW4nKVt0aGlzLmdldCgnY3VycmVudFN0ZXAnKV1cblx0XHRcdH0sXG5cdFx0XHRwZXJjZW50YWdlOiBmdW5jdGlvbiBwZXJjZW50YWdlKCkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5taW4odGhpcy5nZXQoJ3NlY29uZHNUaGlzU3RlcCcpIC8gdGhpcy5nZXQoJ2N1cnJlbnRQbGFuJykuc2Vjb25kcyAqIDEwMCwgMTAwKVxuXHRcdFx0fSxcblx0XHRcdGNvbG9yOiBmdW5jdGlvbiBjb2xvcigpIHtcblx0XHRcdFx0cmV0dXJuIGNvbG9yc1t0aGlzLmdldCgnY3VycmVudFBsYW4nKS5hY3Rpb25dXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRyb3V0ZTogJy90aW1lci86d2VlayhcXFxcZCspLzpkYXkoXFxcXGQrKScsXG5cdHJlc29sdmU6IGZ1bmN0aW9uKGRhdGEsIHBhcmFtcywgY2IpIHtcblx0XHRjYihudWxsLCB7XG5cdFx0XHRwbGFuOiB3ZWVrc1twYXJhbXMud2Vla11bcGFyYW1zLmRheV0sXG5cdFx0XHRwYXJhbWV0ZXJzOiBwYXJhbXMsXG5cdFx0XHRjdXJyZW50U3RlcDogMCxcblx0XHRcdHNlY29uZHNUaGlzU3RlcDogMFxuXHRcdH0pXG5cdH0sXG5cdGFjdGl2YXRlOiBmdW5jdGlvbihjb250ZXh0KSB7XG5cdFx0Y29uc3QgeyBkb21BcGk6IHJhY3RpdmUsIHBhcmFtZXRlcnMgfSA9IGNvbnRleHRcblxuXHRcdC8vIGlmIEkgc3RhcnQgYXQgMjM6NDUgYW5kIGZpbmlzaCBhdCAwMDoxNSwgaXQgY291bnRzIGFzIGJlaW5nIHRoZSBkYXkgYmVmb3JlXG5cdFx0Y29uc3QgcnVuRGF0ZSA9IG5ldyBEYXRlKClcblxuXHRcdGZ1bmN0aW9uIGluY3JlbWVudFN0ZXAoKSB7XG5cdFx0XHRjb25zdCBuZXh0U3RlcCA9IHJhY3RpdmUuZ2V0KCdjdXJyZW50U3RlcCcpICsgMVxuXHRcdFx0Y29uc3QgbGFzdFN0ZXBOdW1iZXIgPSByYWN0aXZlLmdldCgncGxhbicpLmxlbmd0aFxuXG5cdFx0XHRpZiAobmV4dFN0ZXAgPj0gbGFzdFN0ZXBOdW1iZXIpIHtcblx0XHRcdFx0cmFjdGl2ZS5maXJlKCdkb25lJylcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJhY3RpdmUuc2V0KHtcblx0XHRcdFx0XHRjdXJyZW50U3RlcDogbmV4dFN0ZXAsXG5cdFx0XHRcdFx0c2Vjb25kc1RoaXNTdGVwOiAwXG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc3QgY2xlYXIgPSB0aW1lclRpY2soMTAwLCBkZWJvdW5jZVRvTmV4dEZyYW1lKChzZWNvbmRzLCByZXNldENsb2NrKSA9PiB7XG5cdFx0XHRjb25zdCBkb25lV2l0aFRoaXNTdGVwID0gcmFjdGl2ZS5nZXQoJ3NlY29uZHNUaGlzU3RlcCcpID49IHJhY3RpdmUuZ2V0KCdjdXJyZW50UGxhbicpLnNlY29uZHNcblx0XHRcdGlmIChkb25lV2l0aFRoaXNTdGVwKSB7XG5cdFx0XHRcdGluY3JlbWVudFN0ZXAoKVxuXHRcdFx0XHRyZXNldENsb2NrKClcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJhY3RpdmUuc2V0KHtcblx0XHRcdFx0XHRzZWNvbmRzVGhpc1N0ZXA6IHNlY29uZHNcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHR9KSlcblxuXHRcdHJhY3RpdmUub24oJ2NhbmNlbCcsICgpID0+IHN0YXRlUm91dGVyLmdvKCdkYXktc2VsZWN0aW9uJykpXG5cblx0XHRyYWN0aXZlLm9uKCdkb25lJywgKCkgPT4ge1xuXHRcdFx0bW9kZWwuc3RvcmVEYXkoe1xuXHRcdFx0XHR3ZWVrOiBwYXJhbWV0ZXJzLndlZWssXG5cdFx0XHRcdGRheTogcGFyYW1ldGVycy5kYXksXG5cdFx0XHRcdGRhdGU6IHJ1bkRhdGVcblx0XHRcdH0pXG5cdFx0XHRzdGF0ZVJvdXRlci5nbygnY29uZ3JhdHMnKVxuXHRcdH0pXG5cblx0XHRjb250ZXh0Lm9uKCdkZXN0cm95JywgY2xlYXIpXG5cdH1cbn0pXG5cbnN0YXRlUm91dGVyLmFkZFN0YXRlKHtcblx0bmFtZTogJ2NvbmdyYXRzJyxcblx0dGVtcGxhdGU6ICcjY29uZ3JhdHMnLFxuXHRyb3V0ZTogJy9jb21wbGV0ZScsXG5cdGFjdGl2YXRlOiBmdW5jdGlvbihjb250ZXh0KSB7XG5cdFx0Y29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0c3RhdGVSb3V0ZXIuZ28oJ2RheS1zZWxlY3Rpb24nKVxuXHRcdH0sIDMwMDApXG5cblx0XHRjb250ZXh0Lm9uKCdkZXN0cm95JywgKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpKVxuXHR9XG59KVxuXG5cbmZ1bmN0aW9uIHRpbWVyVGljayhmcmVxdWVuY3ksIHRpY2tDYikge1xuXHRsZXQgc3RhcnRlZFxuXG5cdGZ1bmN0aW9uIHJlc2V0Q2xvY2soKSB7XG5cdFx0c3RhcnRlZCA9IHBlcmZvcm1hbmNlLm5vdygpXG5cdH1cblxuXHRjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHRpY2tDYigocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydGVkKSAvIDEwMDAsIHJlc2V0Q2xvY2spLCBmcmVxdWVuY3kpXG5cblx0cmVzZXRDbG9jaygpXG5cblx0cmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpXG59XG5cbmZ1bmN0aW9uIGRlYm91bmNlVG9OZXh0RnJhbWUoZm4pIHtcblx0bGV0IGhhcHBlbmluZyA9IGZhbHNlXG5cdHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG5cdFx0aWYgKCFoYXBwZW5pbmcpIHtcblx0XHRcdGhhcHBlbmluZyA9IHRydWVcblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuXHRcdFx0XHRoYXBwZW5pbmcgPSBmYWxzZVxuXHRcdFx0XHRmbi5hcHBseShudWxsLCBhcmdzKVxuXHRcdFx0fSlcblx0XHR9XG5cdH1cbn1cblxuc3RhdGVSb3V0ZXIuZXZhbHVhdGVDdXJyZW50Um91dGUoJ2RheS1zZWxlY3Rpb24nKVxuIiwiY29uc3QgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxuXG5jb25zdCBLRVkgPSAnQzI1SydcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGxvYWQ6IGZ1bmN0aW9uIGxvYWQoKSB7XG5cdFx0cmV0dXJuIGFkZE1ldGhvZHMobG9hZEZyb21Mb2NhbHN0b3JhZ2UoKSlcblx0fSxcblx0c3RvcmVEYXk6IGZ1bmN0aW9uKHt3ZWVrLCBkYXksIGRhdGV9KSB7XG5cdFx0cmV0dXJuIHNldERheSh7IG1vZGVsOiBsb2FkRnJvbUxvY2Fsc3RvcmFnZSgpLCB3ZWVrLCBkYXksIGRhdGUgfSlcblx0fVxufVxuXG5mdW5jdGlvbiBsb2FkRnJvbUxvY2Fsc3RvcmFnZSgpIHtcblx0Y29uc3QgZnJvbVN0b3JhZ2UgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShLRVkpXG5cblx0cmV0dXJuIGZyb21TdG9yYWdlID8gSlNPTi5wYXJzZShmcm9tU3RvcmFnZSkgOiB7fVxufVxuXG5mdW5jdGlvbiBzdG9yZShtb2RlbCkge1xuXHRsb2NhbFN0b3JhZ2Uuc2V0SXRlbShLRVksIEpTT04uc3RyaW5naWZ5KG1vZGVsKSlcbn1cblxuZnVuY3Rpb24gYWRkTWV0aG9kcyhtb2RlbCkge1xuXHRtb2RlbC5nZXRXZWVrID0gZ2V0V2Vlay5iaW5kKG51bGwsIG1vZGVsKVxuXHRtb2RlbC5nZXREYXkgPSBnZXREYXkuYmluZChudWxsLCBtb2RlbClcblx0cmV0dXJuIG1vZGVsXG59XG5cbmZ1bmN0aW9uIGdldFdlZWsobW9kZWwsIHdlZWspIHtcblx0cmV0dXJuIG1vZGVsW3dlZWtdIHx8IHt9XG59XG5cbmZ1bmN0aW9uIGdldERheShtb2RlbCwgd2VlaywgZGF5KSB7XG5cdGNvbnN0IHRpbWVzdGFtcCA9IGdldFdlZWsobW9kZWwsIHdlZWspW2RheV1cblx0cmV0dXJuIHRpbWVzdGFtcCA/IG5ldyBEYXRlKHRpbWVzdGFtcCkgOiBudWxsXG59XG5cbmZ1bmN0aW9uIHNldERheSh7bW9kZWwsIHdlZWssIGRheSwgZGF0ZX0pIHtcblx0Y29uc3QgbmV3TW9kZWwgPSBleHRlbmQobW9kZWwsIHtcblx0XHRbd2Vla106IGV4dGVuZChtb2RlbFt3ZWVrXSwge1xuXHRcdFx0W2RheV06IGRhdGUudmFsdWVPZigpXG5cdFx0fSlcblx0fSlcblxuXHRzdG9yZShuZXdNb2RlbClcblxuXHRyZXR1cm4gYWRkTWV0aG9kcyhuZXdNb2RlbClcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0geyByZXZlcnNlOiBmYWxzZSB9IiwidmFyIFN0YXRlU3RhdGUgPSByZXF1aXJlKCcuL2xpYi9zdGF0ZS1zdGF0ZScpXG52YXIgU3RhdGVDb21wYXJpc29uID0gcmVxdWlyZSgnLi9saWIvc3RhdGUtY29tcGFyaXNvbicpXG52YXIgQ3VycmVudFN0YXRlID0gcmVxdWlyZSgnLi9saWIvY3VycmVudC1zdGF0ZScpXG52YXIgc3RhdGVDaGFuZ2VMb2dpYyA9IHJlcXVpcmUoJy4vbGliL3N0YXRlLWNoYW5nZS1sb2dpYycpXG52YXIgcGFyc2UgPSByZXF1aXJlKCcuL2xpYi9zdGF0ZS1zdHJpbmctcGFyc2VyJylcbnZhciBTdGF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9saWIvc3RhdGUtdHJhbnNpdGlvbi1tYW5hZ2VyJylcbnZhciBkZWZhdWx0Um91dGVyT3B0aW9ucyA9IHJlcXVpcmUoJy4vZGVmYXVsdC1yb3V0ZXItb3B0aW9ucy5qcycpXG5cbnZhciBzZXJpZXMgPSByZXF1aXJlKCcuL2xpYi9wcm9taXNlLW1hcC1zZXJpZXMnKVxudmFyIGRlbm9kZWlmeSA9IHJlcXVpcmUoJ3RoZW4tZGVub2RlaWZ5JylcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBuZXdIYXNoQnJvd25Sb3V0ZXIgPSByZXF1aXJlKCdoYXNoLWJyb3duLXJvdXRlcicpXG52YXIgY29tYmluZSA9IHJlcXVpcmUoJ2NvbWJpbmUtYXJyYXlzJylcbnZhciBidWlsZFBhdGggPSByZXF1aXJlKCdwYWdlLXBhdGgtYnVpbGRlcicpXG5cbnJlcXVpcmUoJ25hdGl2ZS1wcm9taXNlLW9ubHkvbnBvJylcblxudmFyIGV4cGVjdGVkUHJvcGVydGllc09mQWRkU3RhdGUgPSBbJ25hbWUnLCAncm91dGUnLCAnZGVmYXVsdENoaWxkJywgJ2RhdGEnLCAndGVtcGxhdGUnLCAncmVzb2x2ZScsICdhY3RpdmF0ZScsICdxdWVyeXN0cmluZ1BhcmFtZXRlcnMnLCAnZGVmYXVsdFF1ZXJ5c3RyaW5nUGFyYW1ldGVycyddXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gU3RhdGVQcm92aWRlcihtYWtlUmVuZGVyZXIsIHJvb3RFbGVtZW50LCBzdGF0ZVJvdXRlck9wdGlvbnMpIHtcblx0dmFyIHByb3RvdHlwYWxTdGF0ZUhvbGRlciA9IFN0YXRlU3RhdGUoKVxuXHR2YXIgbGFzdENvbXBsZXRlbHlMb2FkZWRTdGF0ZSA9IEN1cnJlbnRTdGF0ZSgpXG5cdHZhciBsYXN0U3RhdGVTdGFydGVkQWN0aXZhdGluZyA9IEN1cnJlbnRTdGF0ZSgpXG5cdHZhciBzdGF0ZVByb3ZpZGVyRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKVxuXHRTdGF0ZVRyYW5zaXRpb25NYW5hZ2VyKHN0YXRlUHJvdmlkZXJFbWl0dGVyKVxuXHRzdGF0ZVJvdXRlck9wdGlvbnMgPSBleHRlbmQoe1xuXHRcdHRocm93T25FcnJvcjogdHJ1ZSxcblx0XHRwYXRoUHJlZml4OiAnIydcblx0fSwgc3RhdGVSb3V0ZXJPcHRpb25zKVxuXG5cdGlmICghc3RhdGVSb3V0ZXJPcHRpb25zLnJvdXRlcikge1xuXHRcdHN0YXRlUm91dGVyT3B0aW9ucy5yb3V0ZXIgPSBuZXdIYXNoQnJvd25Sb3V0ZXIoZGVmYXVsdFJvdXRlck9wdGlvbnMpXG5cdH1cblxuXHRzdGF0ZVJvdXRlck9wdGlvbnMucm91dGVyLnNldERlZmF1bHQoZnVuY3Rpb24ocm91dGUsIHBhcmFtZXRlcnMpIHtcblx0XHRzdGF0ZVByb3ZpZGVyRW1pdHRlci5lbWl0KCdyb3V0ZU5vdEZvdW5kJywgcm91dGUsIHBhcmFtZXRlcnMpXG5cdH0pXG5cblx0dmFyIGRlc3Ryb3lEb20gPSBudWxsXG5cdHZhciBnZXREb21DaGlsZCA9IG51bGxcblx0dmFyIHJlbmRlckRvbSA9IG51bGxcblx0dmFyIHJlc2V0RG9tID0gbnVsbFxuXG5cdHZhciBhY3RpdmVEb21BcGlzID0ge31cblx0dmFyIGFjdGl2ZVN0YXRlUmVzb2x2ZUNvbnRlbnQgPSB7fVxuXHR2YXIgYWN0aXZlRW1pdHRlcnMgPSB7fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZUVycm9yKGV2ZW50LCBlcnIpIHtcblx0XHRwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0c3RhdGVQcm92aWRlckVtaXR0ZXIuZW1pdChldmVudCwgZXJyKVxuXHRcdFx0Y29uc29sZS5lcnJvcihldmVudCArICcgLSAnICsgZXJyLm1lc3NhZ2UpXG5cdFx0XHRpZiAoc3RhdGVSb3V0ZXJPcHRpb25zLnRocm93T25FcnJvcikge1xuXHRcdFx0XHR0aHJvdyBlcnJcblx0XHRcdH1cblx0XHR9KVxuXHR9XG5cblx0ZnVuY3Rpb24gZGVzdHJveVN0YXRlTmFtZShzdGF0ZU5hbWUpIHtcblx0XHR2YXIgc3RhdGUgPSBwcm90b3R5cGFsU3RhdGVIb2xkZXIuZ2V0KHN0YXRlTmFtZSlcblx0XHRzdGF0ZVByb3ZpZGVyRW1pdHRlci5lbWl0KCdiZWZvcmVEZXN0cm95U3RhdGUnLCB7XG5cdFx0XHRzdGF0ZTogc3RhdGUsXG5cdFx0XHRkb21BcGk6IGFjdGl2ZURvbUFwaXNbc3RhdGVOYW1lXVxuXHRcdH0pXG5cblx0XHRhY3RpdmVFbWl0dGVyc1tzdGF0ZU5hbWVdLmVtaXQoJ2Rlc3Ryb3knKVxuXHRcdGFjdGl2ZUVtaXR0ZXJzW3N0YXRlTmFtZV0ucmVtb3ZlQWxsTGlzdGVuZXJzKClcblx0XHRkZWxldGUgYWN0aXZlRW1pdHRlcnNbc3RhdGVOYW1lXVxuXHRcdGRlbGV0ZSBhY3RpdmVTdGF0ZVJlc29sdmVDb250ZW50W3N0YXRlTmFtZV1cblxuXHRcdHJldHVybiBkZXN0cm95RG9tKGFjdGl2ZURvbUFwaXNbc3RhdGVOYW1lXSkudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSBhY3RpdmVEb21BcGlzW3N0YXRlTmFtZV1cblx0XHRcdHN0YXRlUHJvdmlkZXJFbWl0dGVyLmVtaXQoJ2FmdGVyRGVzdHJveVN0YXRlJywge1xuXHRcdFx0XHRzdGF0ZTogc3RhdGVcblx0XHRcdH0pXG5cdFx0fSlcblx0fVxuXG5cdGZ1bmN0aW9uIHJlc2V0U3RhdGVOYW1lKHBhcmFtZXRlcnMsIHN0YXRlTmFtZSkge1xuXHRcdHZhciBkb21BcGkgPSBhY3RpdmVEb21BcGlzW3N0YXRlTmFtZV1cblx0XHR2YXIgY29udGVudCA9IGdldENvbnRlbnRPYmplY3QoYWN0aXZlU3RhdGVSZXNvbHZlQ29udGVudCwgc3RhdGVOYW1lKVxuXHRcdHZhciBzdGF0ZSA9IHByb3RvdHlwYWxTdGF0ZUhvbGRlci5nZXQoc3RhdGVOYW1lKVxuXG5cdFx0c3RhdGVQcm92aWRlckVtaXR0ZXIuZW1pdCgnYmVmb3JlUmVzZXRTdGF0ZScsIHtcblx0XHRcdGRvbUFwaTogZG9tQXBpLFxuXHRcdFx0Y29udGVudDogY29udGVudCxcblx0XHRcdHN0YXRlOiBzdGF0ZSxcblx0XHRcdHBhcmFtZXRlcnM6IHBhcmFtZXRlcnNcblx0XHR9KVxuXG5cdFx0YWN0aXZlRW1pdHRlcnNbc3RhdGVOYW1lXS5lbWl0KCdkZXN0cm95Jylcblx0XHRkZWxldGUgYWN0aXZlRW1pdHRlcnNbc3RhdGVOYW1lXVxuXG5cdFx0cmV0dXJuIHJlc2V0RG9tKHtcblx0XHRcdGRvbUFwaTogZG9tQXBpLFxuXHRcdFx0Y29udGVudDogY29udGVudCxcblx0XHRcdHRlbXBsYXRlOiBzdGF0ZS50ZW1wbGF0ZSxcblx0XHRcdHBhcmFtZXRlcnM6IHBhcmFtZXRlcnNcblx0XHR9KS50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdFx0c3RhdGVQcm92aWRlckVtaXR0ZXIuZW1pdCgnYWZ0ZXJSZXNldFN0YXRlJywge1xuXHRcdFx0XHRkb21BcGk6IGRvbUFwaSxcblx0XHRcdFx0Y29udGVudDogY29udGVudCxcblx0XHRcdFx0c3RhdGU6IHN0YXRlLFxuXHRcdFx0XHRwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzXG5cdFx0XHR9KVxuXHRcdH0pXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRDaGlsZEVsZW1lbnRGb3JTdGF0ZU5hbWUoc3RhdGVOYW1lKSB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcblx0XHRcdHZhciBwYXJlbnQgPSBwcm90b3R5cGFsU3RhdGVIb2xkZXIuZ2V0UGFyZW50KHN0YXRlTmFtZSlcblx0XHRcdGlmIChwYXJlbnQpIHtcblx0XHRcdFx0dmFyIHBhcmVudERvbUFwaSA9IGFjdGl2ZURvbUFwaXNbcGFyZW50Lm5hbWVdXG5cdFx0XHRcdHJlc29sdmUoZ2V0RG9tQ2hpbGQocGFyZW50RG9tQXBpKSlcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc29sdmUocm9vdEVsZW1lbnQpXG5cdFx0XHR9XG5cdFx0fSlcblx0fVxuXG5cdGZ1bmN0aW9uIHJlbmRlclN0YXRlTmFtZShwYXJhbWV0ZXJzLCBzdGF0ZU5hbWUpIHtcblx0XHRyZXR1cm4gZ2V0Q2hpbGRFbGVtZW50Rm9yU3RhdGVOYW1lKHN0YXRlTmFtZSkudGhlbihmdW5jdGlvbihjaGlsZEVsZW1lbnQpIHtcblx0XHRcdHZhciBzdGF0ZSA9IHByb3RvdHlwYWxTdGF0ZUhvbGRlci5nZXQoc3RhdGVOYW1lKVxuXHRcdFx0dmFyIGNvbnRlbnQgPSBnZXRDb250ZW50T2JqZWN0KGFjdGl2ZVN0YXRlUmVzb2x2ZUNvbnRlbnQsIHN0YXRlTmFtZSlcblxuXHRcdFx0c3RhdGVQcm92aWRlckVtaXR0ZXIuZW1pdCgnYmVmb3JlQ3JlYXRlU3RhdGUnLCB7XG5cdFx0XHRcdHN0YXRlOiBzdGF0ZSxcblx0XHRcdFx0Y29udGVudDogY29udGVudCxcblx0XHRcdFx0cGFyYW1ldGVyczogcGFyYW1ldGVyc1xuXHRcdFx0fSlcblxuXHRcdFx0cmV0dXJuIHJlbmRlckRvbSh7XG5cdFx0XHRcdGVsZW1lbnQ6IGNoaWxkRWxlbWVudCxcblx0XHRcdFx0dGVtcGxhdGU6IHN0YXRlLnRlbXBsYXRlLFxuXHRcdFx0XHRjb250ZW50OiBjb250ZW50LFxuXHRcdFx0XHRwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzXG5cdFx0XHR9KS50aGVuKGZ1bmN0aW9uKGRvbUFwaSkge1xuXHRcdFx0XHRhY3RpdmVEb21BcGlzW3N0YXRlTmFtZV0gPSBkb21BcGlcblx0XHRcdFx0c3RhdGVQcm92aWRlckVtaXR0ZXIuZW1pdCgnYWZ0ZXJDcmVhdGVTdGF0ZScsIHtcblx0XHRcdFx0XHRzdGF0ZTogc3RhdGUsXG5cdFx0XHRcdFx0ZG9tQXBpOiBkb21BcGksXG5cdFx0XHRcdFx0Y29udGVudDogY29udGVudCxcblx0XHRcdFx0XHRwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVybiBkb21BcGlcblx0XHRcdH0pXG5cdFx0fSlcblx0fVxuXG5cdGZ1bmN0aW9uIHJlbmRlckFsbChzdGF0ZU5hbWVzLCBwYXJhbWV0ZXJzKSB7XG5cdFx0cmV0dXJuIHNlcmllcyhzdGF0ZU5hbWVzLCByZW5kZXJTdGF0ZU5hbWUuYmluZChudWxsLCBwYXJhbWV0ZXJzKSlcblx0fVxuXG5cdGZ1bmN0aW9uIG9uUm91dGVDaGFuZ2Uoc3RhdGUsIHBhcmFtZXRlcnMpIHtcblx0XHR0cnkge1xuXHRcdFx0dmFyIGZpbmFsRGVzdGluYXRpb25TdGF0ZU5hbWUgPSBwcm90b3R5cGFsU3RhdGVIb2xkZXIuYXBwbHlEZWZhdWx0Q2hpbGRTdGF0ZXMoc3RhdGUubmFtZSlcblxuXHRcdFx0aWYgKGZpbmFsRGVzdGluYXRpb25TdGF0ZU5hbWUgPT09IHN0YXRlLm5hbWUpIHtcblx0XHRcdFx0ZW1pdEV2ZW50QW5kQXR0ZW1wdFN0YXRlQ2hhbmdlKGZpbmFsRGVzdGluYXRpb25TdGF0ZU5hbWUsIHBhcmFtZXRlcnMpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBUaGVyZSBhcmUgZGVmYXVsdCBjaGlsZCBzdGF0ZXMgdGhhdCBuZWVkIHRvIGJlIGFwcGxpZWRcblxuXHRcdFx0XHR2YXIgdGhlUm91dGVXZU5lZWRUb0VuZFVwQXQgPSBtYWtlUGF0aChmaW5hbERlc3RpbmF0aW9uU3RhdGVOYW1lLCBwYXJhbWV0ZXJzKVxuXHRcdFx0XHR2YXIgY3VycmVudFJvdXRlID0gc3RhdGVSb3V0ZXJPcHRpb25zLnJvdXRlci5sb2NhdGlvbi5nZXQoKVxuXG5cdFx0XHRcdGlmICh0aGVSb3V0ZVdlTmVlZFRvRW5kVXBBdCA9PT0gY3VycmVudFJvdXRlKSB7XG5cdFx0XHRcdFx0Ly8gdGhlIGNoaWxkIHN0YXRlIGhhcyB0aGUgc2FtZSByb3V0ZSBhcyB0aGUgY3VycmVudCBvbmUsIGp1c3Qgc3RhcnQgbmF2aWdhdGluZyB0aGVyZVxuXHRcdFx0XHRcdGVtaXRFdmVudEFuZEF0dGVtcHRTdGF0ZUNoYW5nZShmaW5hbERlc3RpbmF0aW9uU3RhdGVOYW1lLCBwYXJhbWV0ZXJzKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGNoYW5nZSB0aGUgdXJsIHRvIG1hdGNoIHRoZSBmdWxsIGRlZmF1bHQgY2hpbGQgc3RhdGUgcm91dGVcblx0XHRcdFx0XHRzdGF0ZVByb3ZpZGVyRW1pdHRlci5nbyhmaW5hbERlc3RpbmF0aW9uU3RhdGVOYW1lLCBwYXJhbWV0ZXJzLCB7IHJlcGxhY2U6IHRydWUgfSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0aGFuZGxlRXJyb3IoJ3N0YXRlRXJyb3InLCBlcnIpXG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gYWRkU3RhdGUoc3RhdGUpIHtcblx0XHRpZiAodHlwZW9mIHN0YXRlID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBcXCdzdGF0ZVxcJyB0byBiZSBwYXNzZWQgaW4uJylcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBzdGF0ZS5uYW1lID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgXFwnbmFtZVxcJyBvcHRpb24gdG8gYmUgcGFzc2VkIGluLicpXG5cdFx0fSBlbHNlIGlmICh0eXBlb2Ygc3RhdGUudGVtcGxhdGUgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBcXCd0ZW1wbGF0ZVxcJyBvcHRpb24gdG8gYmUgcGFzc2VkIGluLicpXG5cdFx0fVxuXHRcdE9iamVjdC5rZXlzKHN0YXRlKS5maWx0ZXIoZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRyZXR1cm4gZXhwZWN0ZWRQcm9wZXJ0aWVzT2ZBZGRTdGF0ZS5pbmRleE9mKGtleSkgPT09IC0xXG5cdFx0fSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdGNvbnNvbGUud2FybignVW5leHBlY3RlZCBwcm9wZXJ0eSBwYXNzZWQgdG8gYWRkU3RhdGU6Jywga2V5KVxuXHRcdH0pXG5cblx0XHRwcm90b3R5cGFsU3RhdGVIb2xkZXIuYWRkKHN0YXRlLm5hbWUsIHN0YXRlKVxuXG5cdFx0dmFyIHJvdXRlID0gcHJvdG90eXBhbFN0YXRlSG9sZGVyLmJ1aWxkRnVsbFN0YXRlUm91dGUoc3RhdGUubmFtZSlcblxuXHRcdHN0YXRlUm91dGVyT3B0aW9ucy5yb3V0ZXIuYWRkKHJvdXRlLCBvblJvdXRlQ2hhbmdlLmJpbmQobnVsbCwgc3RhdGUpKVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0U3RhdGVzVG9SZXNvbHZlKHN0YXRlQ2hhbmdlcykge1xuXHRcdHJldHVybiBzdGF0ZUNoYW5nZXMuY2hhbmdlLmNvbmNhdChzdGF0ZUNoYW5nZXMuY3JlYXRlKS5tYXAocHJvdG90eXBhbFN0YXRlSG9sZGVyLmdldClcblx0fVxuXG5cdGZ1bmN0aW9uIGVtaXRFdmVudEFuZEF0dGVtcHRTdGF0ZUNoYW5nZShuZXdTdGF0ZU5hbWUsIHBhcmFtZXRlcnMpIHtcblx0XHRzdGF0ZVByb3ZpZGVyRW1pdHRlci5lbWl0KCdzdGF0ZUNoYW5nZUF0dGVtcHQnLCBmdW5jdGlvbiBzdGF0ZUdvKHRyYW5zaXRpb24pIHtcblx0XHRcdGF0dGVtcHRTdGF0ZUNoYW5nZShuZXdTdGF0ZU5hbWUsIHBhcmFtZXRlcnMsIHRyYW5zaXRpb24pXG5cdFx0fSlcblx0fVxuXG5cdGZ1bmN0aW9uIGF0dGVtcHRTdGF0ZUNoYW5nZShuZXdTdGF0ZU5hbWUsIHBhcmFtZXRlcnMsIHRyYW5zaXRpb24pIHtcblx0XHRmdW5jdGlvbiBpZk5vdENhbmNlbGxlZChmbikge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAodHJhbnNpdGlvbi5jYW5jZWxsZWQpIHtcblx0XHRcdFx0XHR2YXIgZXJyID0gbmV3IEVycm9yKCdUaGUgdHJhbnNpdGlvbiB0byAnICsgbmV3U3RhdGVOYW1lICsgJ3dhcyBjYW5jZWxsZWQnKVxuXHRcdFx0XHRcdGVyci53YXNDYW5jZWxsZWRCeVNvbWVvbmVFbHNlID0gdHJ1ZVxuXHRcdFx0XHRcdHRocm93IGVyclxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcHJvbWlzZU1lKHByb3RvdHlwYWxTdGF0ZUhvbGRlci5ndWFyYW50ZWVBbGxTdGF0ZXNFeGlzdCwgbmV3U3RhdGVOYW1lKVxuXHRcdC50aGVuKGZ1bmN0aW9uIGFwcGx5RGVmYXVsdFBhcmFtZXRlcnMoKSB7XG5cdFx0XHR2YXIgc3RhdGUgPSBwcm90b3R5cGFsU3RhdGVIb2xkZXIuZ2V0KG5ld1N0YXRlTmFtZSlcblx0XHRcdHZhciBkZWZhdWx0UGFyYW1zID0gc3RhdGUuZGVmYXVsdFF1ZXJ5c3RyaW5nUGFyYW1ldGVycyB8fCB7fVxuXHRcdFx0dmFyIG5lZWRUb0FwcGx5RGVmYXVsdHMgPSBPYmplY3Qua2V5cyhkZWZhdWx0UGFyYW1zKS5zb21lKGZ1bmN0aW9uIG1pc3NpbmdQYXJhbWV0ZXJWYWx1ZShwYXJhbSkge1xuXHRcdFx0XHRyZXR1cm4gIXBhcmFtZXRlcnNbcGFyYW1dXG5cdFx0XHR9KVxuXG5cdFx0XHRpZiAobmVlZFRvQXBwbHlEZWZhdWx0cykge1xuXHRcdFx0XHR0aHJvdyByZWRpcmVjdG9yKG5ld1N0YXRlTmFtZSwgZXh0ZW5kKGRlZmF1bHRQYXJhbXMsIHBhcmFtZXRlcnMpKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0YXRlXG5cdFx0fSkudGhlbihpZk5vdENhbmNlbGxlZChmdW5jdGlvbihzdGF0ZSkge1xuXHRcdFx0c3RhdGVQcm92aWRlckVtaXR0ZXIuZW1pdCgnc3RhdGVDaGFuZ2VTdGFydCcsIHN0YXRlLCBwYXJhbWV0ZXJzKVxuXHRcdFx0bGFzdFN0YXRlU3RhcnRlZEFjdGl2YXRpbmcuc2V0KHN0YXRlLm5hbWUsIHBhcmFtZXRlcnMpXG5cdFx0fSkpLnRoZW4oZnVuY3Rpb24gZ2V0U3RhdGVDaGFuZ2VzKCkge1xuXHRcdFx0dmFyIHN0YXRlQ29tcGFyaXNvblJlc3VsdHMgPSBTdGF0ZUNvbXBhcmlzb24ocHJvdG90eXBhbFN0YXRlSG9sZGVyKShsYXN0Q29tcGxldGVseUxvYWRlZFN0YXRlLmdldCgpLm5hbWUsIGxhc3RDb21wbGV0ZWx5TG9hZGVkU3RhdGUuZ2V0KCkucGFyYW1ldGVycywgbmV3U3RhdGVOYW1lLCBwYXJhbWV0ZXJzKVxuXHRcdFx0cmV0dXJuIHN0YXRlQ2hhbmdlTG9naWMoc3RhdGVDb21wYXJpc29uUmVzdWx0cykgLy8geyBkZXN0cm95LCBjaGFuZ2UsIGNyZWF0ZSB9XG5cdFx0fSkudGhlbihpZk5vdENhbmNlbGxlZChmdW5jdGlvbiByZXNvbHZlRGVzdHJveUFuZEFjdGl2YXRlU3RhdGVzKHN0YXRlQ2hhbmdlcykge1xuXHRcdFx0cmV0dXJuIHJlc29sdmVTdGF0ZXMoZ2V0U3RhdGVzVG9SZXNvbHZlKHN0YXRlQ2hhbmdlcyksIGV4dGVuZChwYXJhbWV0ZXJzKSkuY2F0Y2goZnVuY3Rpb24gb25SZXNvbHZlRXJyb3IoZSkge1xuXHRcdFx0XHRlLnN0YXRlQ2hhbmdlRXJyb3IgPSB0cnVlXG5cdFx0XHRcdHRocm93IGVcblx0XHRcdH0pLnRoZW4oaWZOb3RDYW5jZWxsZWQoZnVuY3Rpb24gZGVzdHJveUFuZEFjdGl2YXRlKHN0YXRlUmVzb2x2ZVJlc3VsdHNPYmplY3QpIHtcblx0XHRcdFx0dHJhbnNpdGlvbi5jYW5jZWxsYWJsZSA9IGZhbHNlXG5cblx0XHRcdFx0ZnVuY3Rpb24gYWN0aXZhdGVBbGwoKSB7XG5cdFx0XHRcdFx0dmFyIHN0YXRlc1RvQWN0aXZhdGUgPSBzdGF0ZUNoYW5nZXMuY2hhbmdlLmNvbmNhdChzdGF0ZUNoYW5nZXMuY3JlYXRlKVxuXG5cdFx0XHRcdFx0cmV0dXJuIGFjdGl2YXRlU3RhdGVzKHN0YXRlc1RvQWN0aXZhdGUpXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhY3RpdmVTdGF0ZVJlc29sdmVDb250ZW50ID0gZXh0ZW5kKGFjdGl2ZVN0YXRlUmVzb2x2ZUNvbnRlbnQsIHN0YXRlUmVzb2x2ZVJlc3VsdHNPYmplY3QpXG5cblx0XHRcdFx0cmV0dXJuIHNlcmllcyhyZXZlcnNlKHN0YXRlQ2hhbmdlcy5kZXN0cm95KSwgZGVzdHJveVN0YXRlTmFtZSkudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc2VyaWVzKHJldmVyc2Uoc3RhdGVDaGFuZ2VzLmNoYW5nZSksIHJlc2V0U3RhdGVOYW1lLmJpbmQobnVsbCwgZXh0ZW5kKHBhcmFtZXRlcnMpKSlcblx0XHRcdFx0fSkudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVuZGVyQWxsKHN0YXRlQ2hhbmdlcy5jcmVhdGUsIGV4dGVuZChwYXJhbWV0ZXJzKSkudGhlbihhY3RpdmF0ZUFsbClcblx0XHRcdFx0fSlcblx0XHRcdH0pKVxuXG5cdFx0XHRmdW5jdGlvbiBhY3RpdmF0ZVN0YXRlcyhzdGF0ZU5hbWVzKSB7XG5cdFx0XHRcdHJldHVybiBzdGF0ZU5hbWVzLm1hcChwcm90b3R5cGFsU3RhdGVIb2xkZXIuZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uKHN0YXRlKSB7XG5cdFx0XHRcdFx0dmFyIGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKClcblx0XHRcdFx0XHR2YXIgY29udGV4dCA9IE9iamVjdC5jcmVhdGUoZW1pdHRlcilcblx0XHRcdFx0XHRjb250ZXh0LmRvbUFwaSA9IGFjdGl2ZURvbUFwaXNbc3RhdGUubmFtZV1cblx0XHRcdFx0XHRjb250ZXh0LmRhdGEgPSBzdGF0ZS5kYXRhXG5cdFx0XHRcdFx0Y29udGV4dC5wYXJhbWV0ZXJzID0gcGFyYW1ldGVyc1xuXHRcdFx0XHRcdGNvbnRleHQuY29udGVudCA9IGdldENvbnRlbnRPYmplY3QoYWN0aXZlU3RhdGVSZXNvbHZlQ29udGVudCwgc3RhdGUubmFtZSlcblx0XHRcdFx0XHRhY3RpdmVFbWl0dGVyc1tzdGF0ZS5uYW1lXSA9IGVtaXR0ZXJcblxuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRzdGF0ZS5hY3RpdmF0ZSAmJiBzdGF0ZS5hY3RpdmF0ZShjb250ZXh0KVxuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IGVcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdH0pKS50aGVuKGZ1bmN0aW9uIHN0YXRlQ2hhbmdlQ29tcGxldGUoKSB7XG5cdFx0XHRsYXN0Q29tcGxldGVseUxvYWRlZFN0YXRlLnNldChuZXdTdGF0ZU5hbWUsIHBhcmFtZXRlcnMpXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRzdGF0ZVByb3ZpZGVyRW1pdHRlci5lbWl0KCdzdGF0ZUNoYW5nZUVuZCcsIHByb3RvdHlwYWxTdGF0ZUhvbGRlci5nZXQobmV3U3RhdGVOYW1lKSwgcGFyYW1ldGVycylcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0aGFuZGxlRXJyb3IoJ3N0YXRlRXJyb3InLCBlKVxuXHRcdFx0fVxuXHRcdH0pLmNhdGNoKGlmTm90Q2FuY2VsbGVkKGZ1bmN0aW9uIGhhbmRsZVN0YXRlQ2hhbmdlRXJyb3IoZXJyKSB7XG5cdFx0XHRpZiAoZXJyICYmIGVyci5yZWRpcmVjdFRvKSB7XG5cdFx0XHRcdHN0YXRlUHJvdmlkZXJFbWl0dGVyLmVtaXQoJ3N0YXRlQ2hhbmdlQ2FuY2VsbGVkJywgZXJyKVxuXHRcdFx0XHRyZXR1cm4gc3RhdGVQcm92aWRlckVtaXR0ZXIuZ28oZXJyLnJlZGlyZWN0VG8ubmFtZSwgZXJyLnJlZGlyZWN0VG8ucGFyYW1zLCB7IHJlcGxhY2U6IHRydWUgfSlcblx0XHRcdH0gZWxzZSBpZiAoZXJyKSB7XG5cdFx0XHRcdGhhbmRsZUVycm9yKCdzdGF0ZUNoYW5nZUVycm9yJywgZXJyKVxuXHRcdFx0fVxuXHRcdH0pKS5jYXRjaChmdW5jdGlvbiBoYW5kbGVDYW5jZWxsYXRpb24oZXJyKSB7XG5cdFx0XHRpZiAoZXJyICYmIGVyci53YXNDYW5jZWxsZWRCeVNvbWVvbmVFbHNlKSB7XG5cdFx0XHRcdC8vIHdlIGRvbid0IGNhcmUsIHRoZSBzdGF0ZSB0cmFuc2l0aW9uIG1hbmFnZXIgaGFzIGFscmVhZHkgZW1pdHRlZCB0aGUgc3RhdGVDaGFuZ2VDYW5jZWxsZWQgZm9yIHVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHByb2JhYmx5IHNob3VsZG4ndCBoYXBwZW4sIG1heWJlIGZpbGUgYW4gaXNzdWUgb3Igc29tZXRoaW5nIFwiICsgZXJyKVxuXHRcdFx0fVxuXHRcdH0pXG5cdH1cblxuXHRmdW5jdGlvbiBtYWtlUGF0aChzdGF0ZU5hbWUsIHBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcblx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLmluaGVyaXQpIHtcblx0XHRcdHBhcmFtZXRlcnMgPSBleHRlbmQobGFzdFN0YXRlU3RhcnRlZEFjdGl2YXRpbmcuZ2V0KCkucGFyYW1ldGVycywgcGFyYW1ldGVycylcblx0XHR9XG5cblx0XHRwcm90b3R5cGFsU3RhdGVIb2xkZXIuZ3VhcmFudGVlQWxsU3RhdGVzRXhpc3Qoc3RhdGVOYW1lKVxuXHRcdHZhciByb3V0ZSA9IHByb3RvdHlwYWxTdGF0ZUhvbGRlci5idWlsZEZ1bGxTdGF0ZVJvdXRlKHN0YXRlTmFtZSlcblx0XHRyZXR1cm4gYnVpbGRQYXRoKHJvdXRlLCBwYXJhbWV0ZXJzIHx8IHt9KVxuXHR9XG5cblx0dmFyIGRlZmF1bHRPcHRpb25zID0ge1xuXHRcdHJlcGxhY2U6IGZhbHNlXG5cdH1cblxuXHRzdGF0ZVByb3ZpZGVyRW1pdHRlci5hZGRTdGF0ZSA9IGFkZFN0YXRlXG5cdHN0YXRlUHJvdmlkZXJFbWl0dGVyLmdvID0gZnVuY3Rpb24gZ28obmV3U3RhdGVOYW1lLCBwYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG5cdFx0b3B0aW9ucyA9IGV4dGVuZChkZWZhdWx0T3B0aW9ucywgb3B0aW9ucylcblx0XHR2YXIgZ29GdW5jdGlvbiA9IG9wdGlvbnMucmVwbGFjZSA/IHN0YXRlUm91dGVyT3B0aW9ucy5yb3V0ZXIucmVwbGFjZSA6IHN0YXRlUm91dGVyT3B0aW9ucy5yb3V0ZXIuZ29cblxuXHRcdHJldHVybiBwcm9taXNlTWUobWFrZVBhdGgsIG5ld1N0YXRlTmFtZSwgcGFyYW1ldGVycywgb3B0aW9ucykudGhlbihnb0Z1bmN0aW9uLCBoYW5kbGVFcnJvci5iaW5kKG51bGwsICdzdGF0ZUNoYW5nZUVycm9yJykpXG5cdH1cblx0c3RhdGVQcm92aWRlckVtaXR0ZXIuZXZhbHVhdGVDdXJyZW50Um91dGUgPSBmdW5jdGlvbiBldmFsdWF0ZUN1cnJlbnRSb3V0ZShkZWZhdWx0U3RhdGUsIGRlZmF1bHRQYXJhbXMpIHtcblx0XHRyZXR1cm4gcHJvbWlzZU1lKG1ha2VQYXRoLCBkZWZhdWx0U3RhdGUsIGRlZmF1bHRQYXJhbXMpLnRoZW4oZnVuY3Rpb24oZGVmYXVsdFBhdGgpIHtcblx0XHRcdHN0YXRlUm91dGVyT3B0aW9ucy5yb3V0ZXIuZXZhbHVhdGVDdXJyZW50KGRlZmF1bHRQYXRoKVxuXHRcdH0pLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuXHRcdFx0aGFuZGxlRXJyb3IoJ3N0YXRlRXJyb3InLCBlcnIpXG5cdFx0fSlcblx0fVxuXHRzdGF0ZVByb3ZpZGVyRW1pdHRlci5tYWtlUGF0aCA9IGZ1bmN0aW9uIG1ha2VQYXRoQW5kUHJlcGVuZEhhc2goc3RhdGVOYW1lLCBwYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIHN0YXRlUm91dGVyT3B0aW9ucy5wYXRoUHJlZml4ICsgbWFrZVBhdGgoc3RhdGVOYW1lLCBwYXJhbWV0ZXJzLCBvcHRpb25zKVxuXHR9XG5cdHN0YXRlUHJvdmlkZXJFbWl0dGVyLnN0YXRlSXNBY3RpdmUgPSBmdW5jdGlvbiBzdGF0ZUlzQWN0aXZlKHN0YXRlTmFtZSwgb3B0cykge1xuXHRcdHZhciBjdXJyZW50U3RhdGUgPSBsYXN0Q29tcGxldGVseUxvYWRlZFN0YXRlLmdldCgpXG5cdFx0cmV0dXJuIChjdXJyZW50U3RhdGUubmFtZSA9PT0gc3RhdGVOYW1lIHx8IGN1cnJlbnRTdGF0ZS5uYW1lLmluZGV4T2Yoc3RhdGVOYW1lICsgJy4nKSA9PT0gMCkgJiYgKHR5cGVvZiBvcHRzID09PSAndW5kZWZpbmVkJyB8fCBPYmplY3Qua2V5cyhvcHRzKS5ldmVyeShmdW5jdGlvbiBtYXRjaGVzKGtleSkge1xuXHRcdFx0cmV0dXJuIG9wdHNba2V5XSA9PT0gY3VycmVudFN0YXRlLnBhcmFtZXRlcnNba2V5XVxuXHRcdH0pKVxuXHR9XG5cblx0dmFyIHJlbmRlcmVyID0gbWFrZVJlbmRlcmVyKHN0YXRlUHJvdmlkZXJFbWl0dGVyKVxuXG5cdGRlc3Ryb3lEb20gPSBkZW5vZGVpZnkocmVuZGVyZXIuZGVzdHJveSlcblx0Z2V0RG9tQ2hpbGQgPSBkZW5vZGVpZnkocmVuZGVyZXIuZ2V0Q2hpbGRFbGVtZW50KVxuXHRyZW5kZXJEb20gPSBkZW5vZGVpZnkocmVuZGVyZXIucmVuZGVyKVxuXHRyZXNldERvbSA9IGRlbm9kZWlmeShyZW5kZXJlci5yZXNldClcblxuXHRyZXR1cm4gc3RhdGVQcm92aWRlckVtaXR0ZXJcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGVudE9iamVjdChzdGF0ZVJlc29sdmVSZXN1bHRzT2JqZWN0LCBzdGF0ZU5hbWUpIHtcblx0dmFyIGFsbFBvc3NpYmxlUmVzb2x2ZWRTdGF0ZU5hbWVzID0gcGFyc2Uoc3RhdGVOYW1lKVxuXG5cdHJldHVybiBhbGxQb3NzaWJsZVJlc29sdmVkU3RhdGVOYW1lcy5maWx0ZXIoZnVuY3Rpb24oc3RhdGVOYW1lKSB7XG5cdFx0cmV0dXJuIHN0YXRlUmVzb2x2ZVJlc3VsdHNPYmplY3Rbc3RhdGVOYW1lXVxuXHR9KS5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBzdGF0ZU5hbWUpIHtcblx0XHRyZXR1cm4gZXh0ZW5kKG9iaiwgc3RhdGVSZXNvbHZlUmVzdWx0c09iamVjdFtzdGF0ZU5hbWVdKVxuXHR9LCB7fSlcbn1cblxuZnVuY3Rpb24gcmVkaXJlY3RvcihuZXdTdGF0ZU5hbWUsIHBhcmFtZXRlcnMpIHtcblx0cmV0dXJuIHtcblx0XHRyZWRpcmVjdFRvOiB7XG5cdFx0XHRuYW1lOiBuZXdTdGF0ZU5hbWUsXG5cdFx0XHRwYXJhbXM6IHBhcmFtZXRlcnNcblx0XHR9XG5cdH1cbn1cblxuLy8geyBbc3RhdGVOYW1lXTogcmVzb2x2ZVJlc3VsdCB9XG5mdW5jdGlvbiByZXNvbHZlU3RhdGVzKHN0YXRlcywgcGFyYW1ldGVycykge1xuXHR2YXIgc3RhdGVzV2l0aFJlc29sdmVGdW5jdGlvbnMgPSBzdGF0ZXMuZmlsdGVyKGlzRnVuY3Rpb24oJ3Jlc29sdmUnKSlcblx0dmFyIHN0YXRlTmFtZXNXaXRoUmVzb2x2ZUZ1bmN0aW9ucyA9IHN0YXRlc1dpdGhSZXNvbHZlRnVuY3Rpb25zLm1hcChwcm9wZXJ0eSgnbmFtZScpKVxuXHR2YXIgcmVzb2x2ZXMgPSBQcm9taXNlLmFsbChzdGF0ZXNXaXRoUmVzb2x2ZUZ1bmN0aW9ucy5tYXAoZnVuY3Rpb24oc3RhdGUpIHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZUNiKGVyciwgY29udGVudCkge1xuXHRcdFx0XHRlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoY29udGVudClcblx0XHRcdH1cblxuXHRcdFx0cmVzb2x2ZUNiLnJlZGlyZWN0ID0gZnVuY3Rpb24gcmVkaXJlY3QobmV3U3RhdGVOYW1lLCBwYXJhbWV0ZXJzKSB7XG5cdFx0XHRcdHJlamVjdChyZWRpcmVjdG9yKG5ld1N0YXRlTmFtZSwgcGFyYW1ldGVycykpXG5cdFx0XHR9XG5cblx0XHRcdHZhciByZXMgPSBzdGF0ZS5yZXNvbHZlKHN0YXRlLmRhdGEsIHBhcmFtZXRlcnMsIHJlc29sdmVDYilcblx0XHRcdGlmIChyZXMgJiYgKHR5cGVvZiByZXMgPT09ICdvYmplY3QnIHx8IHR5cGVvZiByZXMgPT09ICdmdW5jdGlvbicpICYmIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRyZXNvbHZlKHJlcylcblx0XHRcdH1cblx0XHR9KVxuXHR9KSlcblxuXHRyZXR1cm4gcmVzb2x2ZXMudGhlbihmdW5jdGlvbihyZXNvbHZlUmVzdWx0cykge1xuXHRcdHJldHVybiBjb21iaW5lKHtcblx0XHRcdHN0YXRlTmFtZTogc3RhdGVOYW1lc1dpdGhSZXNvbHZlRnVuY3Rpb25zLFxuXHRcdFx0cmVzb2x2ZVJlc3VsdDogcmVzb2x2ZVJlc3VsdHNcblx0XHR9KS5yZWR1Y2UoZnVuY3Rpb24ob2JqLCByZXN1bHQpIHtcblx0XHRcdG9ialtyZXN1bHQuc3RhdGVOYW1lXSA9IHJlc3VsdC5yZXNvbHZlUmVzdWx0XG5cdFx0XHRyZXR1cm4gb2JqXG5cdFx0fSwge30pXG5cdH0pXG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5KG5hbWUpIHtcblx0cmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuXHRcdHJldHVybiBvYmpbbmFtZV1cblx0fVxufVxuXG5mdW5jdGlvbiByZXZlcnNlKGFyeSkge1xuXHRyZXR1cm4gYXJ5LnNsaWNlKCkucmV2ZXJzZSgpXG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24ocHJvcGVydHkpIHtcblx0cmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuXHRcdHJldHVybiB0eXBlb2Ygb2JqW3Byb3BlcnR5XSA9PT0gJ2Z1bmN0aW9uJ1xuXHR9XG59XG5cbmZ1bmN0aW9uIHByb21pc2VNZSgpIHtcblx0dmFyIGZuID0gQXJyYXkucHJvdG90eXBlLnNoaWZ0LmFwcGx5KGFyZ3VtZW50cylcblx0dmFyIGFyZ3MgPSBhcmd1bWVudHNcblx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcblx0XHRyZXNvbHZlKGZuLmFwcGx5KG51bGwsIGFyZ3MpKVxuXHR9KVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBDdXJyZW50U3RhdGUoKSB7XG5cdHZhciBjdXJyZW50ID0ge1xuXHRcdG5hbWU6ICcnLFxuXHRcdHBhcmFtZXRlcnM6IHt9XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gY3VycmVudFxuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbihuYW1lLCBwYXJhbWV0ZXJzKSB7XG5cdFx0XHRjdXJyZW50ID0ge1xuXHRcdFx0XHRuYW1lOiBuYW1lLFxuXHRcdFx0XHRwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG4iLCIvLyBQdWxsZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vam9saXNzL3Byb21pc2UtbWFwLXNlcmllcyBhbmQgcHJldHRpZWQgdXAgYSBiaXRcblxudmFyIFByb21pc2UgPSByZXF1aXJlKCduYXRpdmUtcHJvbWlzZS1vbmx5L25wbycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2VxdWVuY2UoYXJyYXksIGl0ZXJhdG9yLCB0aGlzQXJnKSB7XG5cdHZhciBjdXJyZW50ID0gUHJvbWlzZS5yZXNvbHZlKClcblx0dmFyIGNiID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBpdGVyYXRvci5iaW5kKHRoaXNBcmcpIDogaXRlcmF0b3JcblxuXHR2YXIgcmVzdWx0cyA9IGFycmF5Lm1hcChmdW5jdGlvbih2YWx1ZSwgaSkge1xuXHRcdHJldHVybiBjdXJyZW50ID0gY3VycmVudC50aGVuKGZ1bmN0aW9uKGopIHtcblx0XHRcdHJldHVybiBjYih2YWx1ZSwgaiwgYXJyYXkpXG5cdFx0fS5iaW5kKG51bGwsIGkpKVxuXHR9KVxuXG5cdHJldHVybiBQcm9taXNlLmFsbChyZXN1bHRzKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdGF0ZUNoYW5nZUxvZ2ljKHN0YXRlQ29tcGFyaXNvblJlc3VsdHMpIHtcblx0dmFyIGhpdENoYW5naW5nU3RhdGUgPSBmYWxzZVxuXHR2YXIgaGl0RGVzdHJveWVkU3RhdGUgPSBmYWxzZVxuXG5cdHZhciBvdXRwdXQgPSB7XG5cdFx0ZGVzdHJveTogW10sXG5cdFx0Y2hhbmdlOiBbXSxcblx0XHRjcmVhdGU6IFtdXG5cdH1cblxuXHRzdGF0ZUNvbXBhcmlzb25SZXN1bHRzLmZvckVhY2goZnVuY3Rpb24oc3RhdGUpIHtcblx0XHRoaXRDaGFuZ2luZ1N0YXRlID0gaGl0Q2hhbmdpbmdTdGF0ZSB8fCBzdGF0ZS5zdGF0ZVBhcmFtZXRlcnNDaGFuZ2VkXG5cdFx0aGl0RGVzdHJveWVkU3RhdGUgPSBoaXREZXN0cm95ZWRTdGF0ZSB8fCBzdGF0ZS5zdGF0ZU5hbWVDaGFuZ2VkXG5cblx0XHRpZiAoc3RhdGUubmFtZUJlZm9yZSkge1xuXHRcdFx0aWYgKGhpdERlc3Ryb3llZFN0YXRlKSB7XG5cdFx0XHRcdG91dHB1dC5kZXN0cm95LnB1c2goc3RhdGUubmFtZUJlZm9yZSlcblx0XHRcdH0gZWxzZSBpZiAoaGl0Q2hhbmdpbmdTdGF0ZSkge1xuXHRcdFx0XHRvdXRwdXQuY2hhbmdlLnB1c2goc3RhdGUubmFtZUJlZm9yZSlcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoc3RhdGUubmFtZUFmdGVyICYmIGhpdERlc3Ryb3llZFN0YXRlKSB7XG5cdFx0XHRvdXRwdXQuY3JlYXRlLnB1c2goc3RhdGUubmFtZUFmdGVyKVxuXHRcdH1cblx0fSlcblxuXHRyZXR1cm4gb3V0cHV0XG59XG4iLCJ2YXIgc3RhdGVTdHJpbmdQYXJzZXIgPSByZXF1aXJlKCcuL3N0YXRlLXN0cmluZy1wYXJzZXInKVxudmFyIGNvbWJpbmUgPSByZXF1aXJlKCdjb21iaW5lLWFycmF5cycpXG52YXIgcGF0aFRvUmVnZXhwID0gcmVxdWlyZSgncGF0aC10by1yZWdleHAtd2l0aC1yZXZlcnNpYmxlLWtleXMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFN0YXRlQ29tcGFyaXNvbihzdGF0ZVN0YXRlKSB7XG5cdHZhciBnZXRQYXRoUGFyYW1ldGVycyA9IHBhdGhQYXJhbWV0ZXJzKClcblxuXHR2YXIgcGFyYW1ldGVyc0NoYW5nZWQgPSBwYXJhbWV0ZXJzVGhhdE1hdHRlcldlcmVDaGFuZ2VkLmJpbmQobnVsbCwgc3RhdGVTdGF0ZSwgZ2V0UGF0aFBhcmFtZXRlcnMpXG5cblx0cmV0dXJuIHN0YXRlQ29tcGFyaXNvbi5iaW5kKG51bGwsIHBhcmFtZXRlcnNDaGFuZ2VkKVxufVxuXG5mdW5jdGlvbiBwYXRoUGFyYW1ldGVycygpIHtcblx0dmFyIHBhcmFtZXRlcnMgPSB7fVxuXG5cdHJldHVybiBmdW5jdGlvbiBnZXRQYXRoUGFyYW1ldGVycyhwYXRoKSB7XG5cdFx0aWYgKCFwYXRoKSB7XG5cdFx0XHRyZXR1cm4gW11cblx0XHR9XG5cblx0XHRpZiAoIXBhcmFtZXRlcnNbcGF0aF0pIHtcblx0XHRcdHBhcmFtZXRlcnNbcGF0aF0gPSBwYXRoVG9SZWdleHAocGF0aCkua2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRcdHJldHVybiBrZXkubmFtZVxuXHRcdFx0fSlcblx0XHR9XG5cblx0XHRyZXR1cm4gcGFyYW1ldGVyc1twYXRoXVxuXHR9XG59XG5cbmZ1bmN0aW9uIHBhcmFtZXRlcnNUaGF0TWF0dGVyV2VyZUNoYW5nZWQoc3RhdGVTdGF0ZSwgZ2V0UGF0aFBhcmFtZXRlcnMsIHN0YXRlTmFtZSwgZnJvbVBhcmFtZXRlcnMsIHRvUGFyYW1ldGVycykge1xuXHR2YXIgc3RhdGUgPSBzdGF0ZVN0YXRlLmdldChzdGF0ZU5hbWUpXG5cdHZhciBxdWVyeXN0cmluZ1BhcmFtZXRlcnMgPSBzdGF0ZS5xdWVyeXN0cmluZ1BhcmFtZXRlcnMgfHwgW11cblx0dmFyIHBhcmFtZXRlcnMgPSBnZXRQYXRoUGFyYW1ldGVycyhzdGF0ZS5yb3V0ZSkuY29uY2F0KHF1ZXJ5c3RyaW5nUGFyYW1ldGVycylcblxuXHRyZXR1cm4gQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzKSAmJiBwYXJhbWV0ZXJzLnNvbWUoZnVuY3Rpb24oa2V5KSB7XG5cdFx0cmV0dXJuIGZyb21QYXJhbWV0ZXJzW2tleV0gIT09IHRvUGFyYW1ldGVyc1trZXldXG5cdH0pXG59XG5cbmZ1bmN0aW9uIHN0YXRlQ29tcGFyaXNvbihwYXJhbWV0ZXJzQ2hhbmdlZCwgb3JpZ2luYWxTdGF0ZSwgb3JpZ2luYWxQYXJhbWV0ZXJzLCBuZXdTdGF0ZSwgbmV3UGFyYW1ldGVycykge1xuXHR2YXIgc3RhdGVzID0gY29tYmluZSh7XG5cdFx0c3RhcnQ6IHN0YXRlU3RyaW5nUGFyc2VyKG9yaWdpbmFsU3RhdGUpLFxuXHRcdGVuZDogc3RhdGVTdHJpbmdQYXJzZXIobmV3U3RhdGUpXG5cdH0pXG5cblx0cmV0dXJuIHN0YXRlcy5tYXAoZnVuY3Rpb24oc3RhdGVzKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG5hbWVCZWZvcmU6IHN0YXRlcy5zdGFydCxcblx0XHRcdG5hbWVBZnRlcjogc3RhdGVzLmVuZCxcblx0XHRcdHN0YXRlTmFtZUNoYW5nZWQ6IHN0YXRlcy5zdGFydCAhPT0gc3RhdGVzLmVuZCxcblx0XHRcdHN0YXRlUGFyYW1ldGVyc0NoYW5nZWQ6IHN0YXRlcy5zdGFydCA9PT0gc3RhdGVzLmVuZCAmJiBwYXJhbWV0ZXJzQ2hhbmdlZChzdGF0ZXMuc3RhcnQsIG9yaWdpbmFsUGFyYW1ldGVycywgbmV3UGFyYW1ldGVycylcblx0XHR9XG5cdH0pXG59XG4iLCJ2YXIgc3RhdGVTdHJpbmdQYXJzZXIgPSByZXF1aXJlKCcuL3N0YXRlLXN0cmluZy1wYXJzZXInKVxudmFyIHBhcnNlID0gcmVxdWlyZSgnLi9zdGF0ZS1zdHJpbmctcGFyc2VyJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBTdGF0ZVN0YXRlKCkge1xuXHR2YXIgc3RhdGVzID0ge31cblxuXHRmdW5jdGlvbiBnZXRIaWVyYXJjaHkobmFtZSkge1xuXHRcdHZhciBuYW1lcyA9IHN0YXRlU3RyaW5nUGFyc2VyKG5hbWUpXG5cblx0XHRyZXR1cm4gbmFtZXMubWFwKGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdGlmICghc3RhdGVzW25hbWVdKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignU3RhdGUgJyArIG5hbWUgKyAnIG5vdCBmb3VuZCcpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RhdGVzW25hbWVdXG5cdFx0fSlcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFBhcmVudChuYW1lKSB7XG5cdFx0dmFyIHBhcmVudE5hbWUgPSBnZXRQYXJlbnROYW1lKG5hbWUpXG5cblx0XHRyZXR1cm4gcGFyZW50TmFtZSAmJiBzdGF0ZXNbcGFyZW50TmFtZV1cblx0fVxuXG5cdGZ1bmN0aW9uIGdldFBhcmVudE5hbWUobmFtZSkge1xuXHRcdHZhciBuYW1lcyA9IHN0YXRlU3RyaW5nUGFyc2VyKG5hbWUpXG5cblx0XHRpZiAobmFtZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0dmFyIHNlY29uZFRvTGFzdCA9IG5hbWVzLmxlbmd0aCAtIDJcblxuXHRcdFx0cmV0dXJuIG5hbWVzW3NlY29uZFRvTGFzdF1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGxcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBndWFyYW50ZWVBbGxTdGF0ZXNFeGlzdChuZXdTdGF0ZU5hbWUpIHtcblx0XHR2YXIgc3RhdGVOYW1lcyA9IHBhcnNlKG5ld1N0YXRlTmFtZSlcblx0XHR2YXIgc3RhdGVzVGhhdERvbnRFeGlzdCA9IHN0YXRlTmFtZXMuZmlsdGVyKGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHJldHVybiAhc3RhdGVzW25hbWVdXG5cdFx0fSlcblxuXHRcdGlmIChzdGF0ZXNUaGF0RG9udEV4aXN0Lmxlbmd0aCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignU3RhdGUgJyArIHN0YXRlc1RoYXREb250RXhpc3Rbc3RhdGVzVGhhdERvbnRFeGlzdC5sZW5ndGggLSAxXSArICcgZG9lcyBub3QgZXhpc3QnKVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGJ1aWxkRnVsbFN0YXRlUm91dGUoc3RhdGVOYW1lKSB7XG5cdFx0cmV0dXJuIGdldEhpZXJhcmNoeShzdGF0ZU5hbWUpLm1hcChmdW5jdGlvbihzdGF0ZSkge1xuXHRcdFx0cmV0dXJuICcvJyArIChzdGF0ZS5yb3V0ZSB8fCAnJylcblx0XHR9KS5qb2luKCcnKS5yZXBsYWNlKC9cXC97Mix9L2csICcvJylcblx0fVxuXG5cdGZ1bmN0aW9uIGFwcGx5RGVmYXVsdENoaWxkU3RhdGVzKHN0YXRlTmFtZSkge1xuXHRcdHZhciBzdGF0ZSA9IHN0YXRlc1tzdGF0ZU5hbWVdXG5cblx0XHRmdW5jdGlvbiBnZXREZWZhdWx0Q2hpbGRTdGF0ZU5hbWUoKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgJiYgKHR5cGVvZiBzdGF0ZS5kZWZhdWx0Q2hpbGQgPT09ICdmdW5jdGlvbidcblx0XHRcdFx0PyBzdGF0ZS5kZWZhdWx0Q2hpbGQoKVxuXHRcdFx0XHQ6IHN0YXRlLmRlZmF1bHRDaGlsZClcblx0XHR9XG5cblx0XHR2YXIgZGVmYXVsdENoaWxkU3RhdGVOYW1lID0gZ2V0RGVmYXVsdENoaWxkU3RhdGVOYW1lKClcblxuXHRcdGlmICghZGVmYXVsdENoaWxkU3RhdGVOYW1lKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVOYW1lXG5cdFx0fVxuXG5cdFx0dmFyIGZ1bGxTdGF0ZU5hbWUgPSBzdGF0ZU5hbWUgKyAnLicgKyBkZWZhdWx0Q2hpbGRTdGF0ZU5hbWVcblxuXHRcdHJldHVybiBhcHBseURlZmF1bHRDaGlsZFN0YXRlcyhmdWxsU3RhdGVOYW1lKVxuXHR9XG5cblxuXHRyZXR1cm4ge1xuXHRcdGFkZDogZnVuY3Rpb24obmFtZSwgc3RhdGUpIHtcblx0XHRcdHN0YXRlc1tuYW1lXSA9IHN0YXRlXG5cdFx0fSxcblx0XHRnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHJldHVybiBuYW1lICYmIHN0YXRlc1tuYW1lXVxuXHRcdH0sXG5cdFx0Z2V0SGllcmFyY2h5OiBnZXRIaWVyYXJjaHksXG5cdFx0Z2V0UGFyZW50OiBnZXRQYXJlbnQsXG5cdFx0Z2V0UGFyZW50TmFtZTogZ2V0UGFyZW50TmFtZSxcblx0XHRndWFyYW50ZWVBbGxTdGF0ZXNFeGlzdDogZ3VhcmFudGVlQWxsU3RhdGVzRXhpc3QsXG5cdFx0YnVpbGRGdWxsU3RhdGVSb3V0ZTogYnVpbGRGdWxsU3RhdGVSb3V0ZSxcblx0XHRhcHBseURlZmF1bHRDaGlsZFN0YXRlczogYXBwbHlEZWZhdWx0Q2hpbGRTdGF0ZXNcblx0fVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdGF0ZVN0cmluZykge1xuXHRyZXR1cm4gc3RhdGVTdHJpbmcuc3BsaXQoJy4nKS5yZWR1Y2UoZnVuY3Rpb24oc3RhdGVOYW1lcywgbGF0ZXN0TmFtZUNodW5rKSB7XG5cdFx0aWYgKHN0YXRlTmFtZXMubGVuZ3RoKSB7XG5cdFx0XHRsYXRlc3ROYW1lQ2h1bmsgPSBzdGF0ZU5hbWVzW3N0YXRlTmFtZXMubGVuZ3RoIC0gMV0gKyAnLicgKyBsYXRlc3ROYW1lQ2h1bmtcblx0XHR9XG5cdFx0c3RhdGVOYW1lcy5wdXNoKGxhdGVzdE5hbWVDaHVuaylcblx0XHRyZXR1cm4gc3RhdGVOYW1lc1xuXHR9LCBbXSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVtaXR0ZXIpIHtcclxuXHR2YXIgY3VycmVudFRyYW5zaXRpb25BdHRlbXB0ID0gbnVsbFxyXG5cdHZhciBuZXh0VHJhbnNpdGlvbiA9IG51bGxcclxuXHJcblx0ZnVuY3Rpb24gZG9uZVRyYW5zaXRpb25pbmcoKSB7XHJcblx0XHRjdXJyZW50VHJhbnNpdGlvbkF0dGVtcHQgPSBudWxsXHJcblx0XHRpZiAobmV4dFRyYW5zaXRpb24pIHtcclxuXHRcdFx0YmVnaW5OZXh0VHJhbnNpdGlvbkF0dGVtcHQoKVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaXNUcmFuc2l0aW9uaW5nKCkge1xyXG5cdFx0cmV0dXJuICEhY3VycmVudFRyYW5zaXRpb25BdHRlbXB0XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBiZWdpbk5leHRUcmFuc2l0aW9uQXR0ZW1wdCgpIHtcclxuXHRcdGN1cnJlbnRUcmFuc2l0aW9uQXR0ZW1wdCA9IG5leHRUcmFuc2l0aW9uXHJcblx0XHRuZXh0VHJhbnNpdGlvbiA9IG51bGxcclxuXHRcdGN1cnJlbnRUcmFuc2l0aW9uQXR0ZW1wdC5iZWdpblN0YXRlQ2hhbmdlKClcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNhbmNlbEN1cnJlbnRUcmFuc2l0aW9uKCkge1xyXG5cdFx0Y3VycmVudFRyYW5zaXRpb25BdHRlbXB0LnRyYW5zaXRpb24uY2FuY2VsbGVkID0gdHJ1ZVxyXG5cdFx0dmFyIGVyciA9IG5ldyBFcnJvcignU3RhdGUgdHJhbnNpdGlvbiBjYW5jZWxsZWQgYnkgdGhlIHN0YXRlIHRyYW5zaXRpb24gbWFuYWdlcicpXHJcblx0XHRlcnIud2FzQ2FuY2VsbGVkQnlTb21lb25lRWxzZSA9IHRydWVcclxuXHRcdGVtaXR0ZXIuZW1pdCgnc3RhdGVDaGFuZ2VDYW5jZWxsZWQnLCBlcnIpXHJcblx0fVxyXG5cclxuXHRlbWl0dGVyLm9uKCdzdGF0ZUNoYW5nZUF0dGVtcHQnLCBmdW5jdGlvbihiZWdpblN0YXRlQ2hhbmdlKSB7XHJcblx0XHRuZXh0VHJhbnNpdGlvbiA9IGNyZWF0ZVN0YXRlVHJhbnNpdGlvbkF0dGVtcHQoYmVnaW5TdGF0ZUNoYW5nZSlcclxuXHJcblx0XHRpZiAoaXNUcmFuc2l0aW9uaW5nKCkgJiYgY3VycmVudFRyYW5zaXRpb25BdHRlbXB0LnRyYW5zaXRpb24uY2FuY2VsbGFibGUpIHtcclxuXHRcdFx0Y2FuY2VsQ3VycmVudFRyYW5zaXRpb24oKVxyXG5cdFx0fSBlbHNlIGlmICghaXNUcmFuc2l0aW9uaW5nKCkpIHtcclxuXHRcdFx0YmVnaW5OZXh0VHJhbnNpdGlvbkF0dGVtcHQoKVxyXG5cdFx0fVxyXG5cdH0pXHJcblxyXG5cdGVtaXR0ZXIub24oJ3N0YXRlQ2hhbmdlRXJyb3InLCBkb25lVHJhbnNpdGlvbmluZylcclxuXHRlbWl0dGVyLm9uKCdzdGF0ZUNoYW5nZUNhbmNlbGxlZCcsIGRvbmVUcmFuc2l0aW9uaW5nKVxyXG5cdGVtaXR0ZXIub24oJ3N0YXRlQ2hhbmdlRW5kJywgZG9uZVRyYW5zaXRpb25pbmcpXHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZVN0YXRlVHJhbnNpdGlvbkF0dGVtcHQoYmVnaW5TdGF0ZUNoYW5nZSkge1xyXG5cdFx0dmFyIHRyYW5zaXRpb24gPSB7XHJcblx0XHRcdGNhbmNlbGxlZDogZmFsc2UsXHJcblx0XHRcdGNhbmNlbGxhYmxlOiB0cnVlXHJcblx0XHR9XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR0cmFuc2l0aW9uOiB0cmFuc2l0aW9uLFxyXG5cdFx0XHRiZWdpblN0YXRlQ2hhbmdlOiBiZWdpblN0YXRlQ2hhbmdlLmJpbmQobnVsbCwgdHJhbnNpdGlvbilcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwiLy8gQXJyYXkucHJvdG90eXBlLmZpbmQgLSBNSVQgTGljZW5zZSAoYykgMjAxMyBQYXVsIE1pbGxlciA8aHR0cDovL3BhdWxtaWxsci5jb20+XG4vLyBGb3IgYWxsIGRldGFpbHMgYW5kIGRvY3M6IGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvYXJyYXkucHJvdG90eXBlLmZpbmRcbi8vIEZpeGVzIGFuZCB0ZXN0cyBzdXBwbGllZCBieSBEdW5jYW4gSGFsbCA8aHR0cDovL2R1bmNhbmhhbGwubmV0PiBcbihmdW5jdGlvbihnbG9iYWxzKXtcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kKSByZXR1cm47XG5cbiAgdmFyIGZpbmQgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICB2YXIgbGlzdCA9IE9iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGggPCAwID8gMCA6IGxpc3QubGVuZ3RoID4+PiAwOyAvLyBFUy5Ub1VpbnQzMjtcbiAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9PSAnZnVuY3Rpb24nIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwcmVkaWNhdGUpICE9PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheSNmaW5kOiBwcmVkaWNhdGUgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdO1xuICAgIGZvciAodmFyIGkgPSAwLCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZSA9IGxpc3RbaV07XG4gICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpc0FyZywgdmFsdWUsIGksIGxpc3QpKSByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgIHRyeSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXkucHJvdG90eXBlLCAnZmluZCcsIHtcbiAgICAgICAgdmFsdWU6IGZpbmQsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGNhdGNoKGUpIHt9XG4gIH1cblxuICBpZiAoIUFycmF5LnByb3RvdHlwZS5maW5kKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmZpbmQgPSBmaW5kO1xuICB9XG59KSh0aGlzKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKSB7XG5cdHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKVxuXG5cdGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRpZiAoIUFycmF5LmlzQXJyYXkob2JqW2tleV0pKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3Ioa2V5ICsgJyBpcyBub3QgYW4gYXJyYXknKVxuXHRcdH1cblx0fSlcblxuXHR2YXIgbWF4SW5kZXggPSBrZXlzLnJlZHVjZShmdW5jdGlvbihtYXhTb0Zhciwga2V5KSB7XG5cdFx0dmFyIGxlbiA9IG9ialtrZXldLmxlbmd0aFxuXHRcdHJldHVybiBtYXhTb0ZhciA+IGxlbiA/IG1heFNvRmFyIDogbGVuXG5cdH0sIDApXG5cblx0dmFyIG91dHB1dCA9IFtdXG5cblx0ZnVuY3Rpb24gZ2V0T2JqZWN0KGluZGV4KSB7XG5cdFx0dmFyIG8gPSB7fVxuXHRcdGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdG9ba2V5XSA9IG9ialtrZXldW2luZGV4XVxuXHRcdH0pXG5cdFx0cmV0dXJuIG9cblx0fVxuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbWF4SW5kZXg7ICsraSkge1xuXHRcdG91dHB1dC5wdXNoKGdldE9iamVjdChpKSlcblx0fVxuXG5cdHJldHVybiBvdXRwdXRcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBIYXNoTG9jYXRpb24od2luZG93KSB7XG5cdHZhciBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpXG5cdHZhciBsYXN0ID0gJydcblx0dmFyIG5lZWRUb0RlY29kZSA9IGdldE5lZWRUb0RlY29kZSgpXG5cblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCBmdW5jdGlvbigpIHtcblx0XHRpZiAobGFzdCAhPT0gZW1pdHRlci5nZXQoKSkge1xuXHRcdFx0bGFzdCA9IGVtaXR0ZXIuZ2V0KClcblx0XHRcdGVtaXR0ZXIuZW1pdCgnaGFzaGNoYW5nZScpXG5cdFx0fVxuXHR9KVxuXG5cdGVtaXR0ZXIuZ28gPSBnby5iaW5kKG51bGwsIHdpbmRvdylcblx0ZW1pdHRlci5yZXBsYWNlID0gcmVwbGFjZS5iaW5kKG51bGwsIHdpbmRvdylcblx0ZW1pdHRlci5nZXQgPSBnZXQuYmluZChudWxsLCB3aW5kb3csIG5lZWRUb0RlY29kZSlcblxuXHRyZXR1cm4gZW1pdHRlclxufVxuXG5mdW5jdGlvbiByZXBsYWNlKHdpbmRvdywgbmV3UGF0aCkge1xuXHR3aW5kb3cubG9jYXRpb24ucmVwbGFjZShldmVyeXRoaW5nQmVmb3JlVGhlU2xhc2god2luZG93LmxvY2F0aW9uLmhyZWYpICsgJyMnICsgbmV3UGF0aClcbn1cblxuZnVuY3Rpb24gZXZlcnl0aGluZ0JlZm9yZVRoZVNsYXNoKHVybCkge1xuXHR2YXIgaGFzaEluZGV4ID0gdXJsLmluZGV4T2YoJyMnKVxuXHRyZXR1cm4gaGFzaEluZGV4ID09PSAtMSA/IHVybCA6IHVybC5zdWJzdHJpbmcoMCwgaGFzaEluZGV4KVxufVxuXG5mdW5jdGlvbiBnbyh3aW5kb3csIG5ld1BhdGgpIHtcblx0d2luZG93LmxvY2F0aW9uLmhhc2ggPSBuZXdQYXRoXG59XG5cbmZ1bmN0aW9uIGdldCh3aW5kb3csIG5lZWRUb0RlY29kZSkge1xuXHR2YXIgaGFzaCA9IHJlbW92ZUhhc2hGcm9tUGF0aCh3aW5kb3cubG9jYXRpb24uaGFzaClcblx0cmV0dXJuIG5lZWRUb0RlY29kZSA/IGRlY29kZVVSSShoYXNoKSA6IGhhc2hcbn1cblxuZnVuY3Rpb24gcmVtb3ZlSGFzaEZyb21QYXRoKHBhdGgpIHtcblx0cmV0dXJuIChwYXRoICYmIHBhdGhbMF0gPT09ICcjJykgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGhcbn1cblxuZnVuY3Rpb24gZ2V0TmVlZFRvRGVjb2RlKCkge1xuXHR2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuXHRhLmhyZWYgPSAnI3ggeCdcblx0cmV0dXJuICEveCB4Ly50ZXN0KGEuaGFzaClcbn1cbiIsInZhciBwYXRoVG9SZWdleHAgPSByZXF1aXJlKCdwYXRoLXRvLXJlZ2V4cC13aXRoLXJldmVyc2libGUta2V5cycpXG52YXIgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpXG52YXIgeHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG52YXIgYnJvd3Nlckhhc2hMb2NhdGlvbiA9IHJlcXVpcmUoJy4vaGFzaC1sb2NhdGlvbi5qcycpXG5yZXF1aXJlKCdhcnJheS5wcm90b3R5cGUuZmluZCcpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gUm91dGVyKG9wdHMsIGhhc2hMb2NhdGlvbikge1xuXHRpZiAoaXNIYXNoTG9jYXRpb24ob3B0cykpIHtcblx0XHRoYXNoTG9jYXRpb24gPSBvcHRzXG5cdFx0b3B0cyA9IG51bGxcblx0fVxuXG5cdG9wdHMgPSBvcHRzIHx8IHt9XG5cblx0aWYgKCFoYXNoTG9jYXRpb24pIHtcblx0XHRoYXNoTG9jYXRpb24gPSBicm93c2VySGFzaExvY2F0aW9uKHdpbmRvdylcblx0fVxuXG5cdHZhciByb3V0ZXMgPSBbXVxuXG5cdHZhciBvbkhhc2hDaGFuZ2UgPSBldmFsdWF0ZUN1cnJlbnRQYXRoLmJpbmQobnVsbCwgcm91dGVzLCBoYXNoTG9jYXRpb24sICEhb3B0cy5yZXZlcnNlKVxuXG5cdGhhc2hMb2NhdGlvbi5vbignaGFzaGNoYW5nZScsIG9uSGFzaENoYW5nZSlcblxuXHRmdW5jdGlvbiBzdG9wKCkge1xuXHRcdGhhc2hMb2NhdGlvbi5yZW1vdmVMaXN0ZW5lcignaGFzaGNoYW5nZScsIG9uSGFzaENoYW5nZSlcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0YWRkOiBhZGQuYmluZChudWxsLCByb3V0ZXMpLFxuXHRcdHN0b3A6IHN0b3AsXG5cdFx0ZXZhbHVhdGVDdXJyZW50OiBldmFsdWF0ZUN1cnJlbnRQYXRoT3JHb1RvRGVmYXVsdC5iaW5kKG51bGwsIHJvdXRlcywgaGFzaExvY2F0aW9uLCAhIW9wdHMucmV2ZXJzZSksXG5cdFx0c2V0RGVmYXVsdDogc2V0RGVmYXVsdC5iaW5kKG51bGwsIHJvdXRlcyksXG5cdFx0cmVwbGFjZTogaGFzaExvY2F0aW9uLnJlcGxhY2UsXG5cdFx0Z286IGhhc2hMb2NhdGlvbi5nbyxcblx0XHRsb2NhdGlvbjogaGFzaExvY2F0aW9uXG5cdH1cbn1cblxuZnVuY3Rpb24gZXZhbHVhdGVDdXJyZW50UGF0aChyb3V0ZXMsIGhhc2hMb2NhdGlvbiwgcmV2ZXJzZSkge1xuXHRldmFsdWF0ZVBhdGgocm91dGVzLCBoYXNoTG9jYXRpb24uZ2V0KCksIHJldmVyc2UpXG59XG5cbmZ1bmN0aW9uIGdldFBhdGhQYXJ0cyhwYXRoKSB7XG5cdHZhciBjaHVua3MgPSBwYXRoLnNwbGl0KCc/Jylcblx0cmV0dXJuIHtcblx0XHRwYXRoOiBjaHVua3Muc2hpZnQoKSxcblx0XHRxdWVyeVN0cmluZzogcXMucGFyc2UoY2h1bmtzLmpvaW4oJycpKVxuXHR9XG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRlUGF0aChyb3V0ZXMsIHBhdGgsIHJldmVyc2UpIHtcblx0dmFyIHBhdGhQYXJ0cyA9IGdldFBhdGhQYXJ0cyhwYXRoKVxuXHRwYXRoID0gcGF0aFBhcnRzLnBhdGhcblx0dmFyIHF1ZXJ5U3RyaW5nUGFyYW1ldGVycyA9IHBhdGhQYXJ0cy5xdWVyeVN0cmluZ1xuXG5cdHZhciBtYXRjaGluZ1JvdXRlID0gKHJldmVyc2UgPyByZXZlcnNlQXJyYXkocm91dGVzKSA6IHJvdXRlcykuZmluZChcIlwiLm1hdGNoLCBwYXRoKVxuXG5cdGlmIChtYXRjaGluZ1JvdXRlKSB7XG5cdFx0dmFyIHJlZ2V4UmVzdWx0ID0gbWF0Y2hpbmdSb3V0ZS5leGVjKHBhdGgpXG5cdFx0dmFyIHJvdXRlUGFyYW1ldGVycyA9IG1ha2VQYXJhbWV0ZXJzT2JqZWN0RnJvbVJlZ2V4UmVzdWx0KG1hdGNoaW5nUm91dGUua2V5cywgcmVnZXhSZXN1bHQpXG5cdFx0dmFyIHBhcmFtcyA9IHh0ZW5kKHF1ZXJ5U3RyaW5nUGFyYW1ldGVycywgcm91dGVQYXJhbWV0ZXJzKVxuXHRcdG1hdGNoaW5nUm91dGUuZm4ocGFyYW1zKVxuXHR9IGVsc2UgaWYgKHJvdXRlcy5kZWZhdWx0Rm4pIHtcblx0XHRyb3V0ZXMuZGVmYXVsdEZuKHBhdGgsIHF1ZXJ5U3RyaW5nUGFyYW1ldGVycylcblx0fVxufVxuXG5mdW5jdGlvbiByZXZlcnNlQXJyYXkoYXJ5KSB7XG5cdHJldHVybiBhcnkuc2xpY2UoKS5yZXZlcnNlKClcbn1cblxuZnVuY3Rpb24gbWFrZVBhcmFtZXRlcnNPYmplY3RGcm9tUmVnZXhSZXN1bHQoa2V5cywgcmVnZXhSZXN1bHQpIHtcblx0cmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uKG1lbW8sIHVybEtleSwgaW5kZXgpIHtcblx0XHRtZW1vW3VybEtleS5uYW1lXSA9IHJlZ2V4UmVzdWx0W2luZGV4ICsgMV1cblx0XHRyZXR1cm4gbWVtb1xuXHR9LCB7fSlcbn1cblxuZnVuY3Rpb24gYWRkKHJvdXRlcywgcm91dGVTdHJpbmcsIHJvdXRlRnVuY3Rpb24pIHtcblx0aWYgKHR5cGVvZiByb3V0ZUZ1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgcm91dGVyIGFkZCBmdW5jdGlvbiBtdXN0IGJlIHBhc3NlZCBhIGNhbGxiYWNrIGZ1bmN0aW9uJylcblx0fVxuXHR2YXIgbmV3Um91dGUgPSBwYXRoVG9SZWdleHAocm91dGVTdHJpbmcpXG5cdG5ld1JvdXRlLmZuID0gcm91dGVGdW5jdGlvblxuXHRyb3V0ZXMucHVzaChuZXdSb3V0ZSlcbn1cblxuZnVuY3Rpb24gZXZhbHVhdGVDdXJyZW50UGF0aE9yR29Ub0RlZmF1bHQocm91dGVzLCBoYXNoTG9jYXRpb24sIHJldmVyc2UsIGRlZmF1bHRQYXRoKSB7XG5cdGlmIChoYXNoTG9jYXRpb24uZ2V0KCkpIHtcblx0XHR2YXIgcm91dGVzQ29weSA9IHJvdXRlcy5zbGljZSgpXG5cdFx0cm91dGVzQ29weS5kZWZhdWx0Rm4gPSBmdW5jdGlvbigpIHtcblx0XHRcdGhhc2hMb2NhdGlvbi5nbyhkZWZhdWx0UGF0aClcblx0XHR9XG5cdFx0ZXZhbHVhdGVDdXJyZW50UGF0aChyb3V0ZXNDb3B5LCBoYXNoTG9jYXRpb24sIHJldmVyc2UpXG5cdH0gZWxzZSB7XG5cdFx0aGFzaExvY2F0aW9uLmdvKGRlZmF1bHRQYXRoKVxuXHR9XG59XG5cbmZ1bmN0aW9uIHNldERlZmF1bHQocm91dGVzLCBkZWZhdWx0Rm4pIHtcblx0cm91dGVzLmRlZmF1bHRGbiA9IGRlZmF1bHRGblxufVxuXG5mdW5jdGlvbiBpc0hhc2hMb2NhdGlvbihoYXNoTG9jYXRpb24pIHtcblx0cmV0dXJuIGhhc2hMb2NhdGlvbiAmJiBoYXNoTG9jYXRpb24uZ28gJiYgaGFzaExvY2F0aW9uLnJlcGxhY2UgJiYgaGFzaExvY2F0aW9uLm9uXG59IiwiLyohIE5hdGl2ZSBQcm9taXNlIE9ubHlcbiAgICB2MC44LjEgKGMpIEt5bGUgU2ltcHNvblxuICAgIE1JVCBMaWNlbnNlOiBodHRwOi8vZ2V0aWZ5Lm1pdC1saWNlbnNlLm9yZ1xuKi9cbiFmdW5jdGlvbih0LG4sZSl7blt0XT1uW3RdfHxlKCksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9blt0XTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQmJmRlZmluZShmdW5jdGlvbigpe3JldHVybiBuW3RdfSl9KFwiUHJvbWlzZVwiLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOnRoaXMsZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KHQsbil7bC5hZGQodCxuKSxofHwoaD15KGwuZHJhaW4pKX1mdW5jdGlvbiBuKHQpe3ZhciBuLGU9dHlwZW9mIHQ7cmV0dXJuIG51bGw9PXR8fFwib2JqZWN0XCIhPWUmJlwiZnVuY3Rpb25cIiE9ZXx8KG49dC50aGVuKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBuP246ITF9ZnVuY3Rpb24gZSgpe2Zvcih2YXIgdD0wO3Q8dGhpcy5jaGFpbi5sZW5ndGg7dCsrKW8odGhpcywxPT09dGhpcy5zdGF0ZT90aGlzLmNoYWluW3RdLnN1Y2Nlc3M6dGhpcy5jaGFpblt0XS5mYWlsdXJlLHRoaXMuY2hhaW5bdF0pO3RoaXMuY2hhaW4ubGVuZ3RoPTB9ZnVuY3Rpb24gbyh0LGUsbyl7dmFyIHIsaTt0cnl7ZT09PSExP28ucmVqZWN0KHQubXNnKToocj1lPT09ITA/dC5tc2c6ZS5jYWxsKHZvaWQgMCx0Lm1zZykscj09PW8ucHJvbWlzZT9vLnJlamVjdChUeXBlRXJyb3IoXCJQcm9taXNlLWNoYWluIGN5Y2xlXCIpKTooaT1uKHIpKT9pLmNhbGwocixvLnJlc29sdmUsby5yZWplY3QpOm8ucmVzb2x2ZShyKSl9Y2F0Y2goYyl7by5yZWplY3QoYyl9fWZ1bmN0aW9uIHIobyl7dmFyIGMsdT10aGlzO2lmKCF1LnRyaWdnZXJlZCl7dS50cmlnZ2VyZWQ9ITAsdS5kZWYmJih1PXUuZGVmKTt0cnl7KGM9bihvKSk/dChmdW5jdGlvbigpe3ZhciB0PW5ldyBmKHUpO3RyeXtjLmNhbGwobyxmdW5jdGlvbigpe3IuYXBwbHkodCxhcmd1bWVudHMpfSxmdW5jdGlvbigpe2kuYXBwbHkodCxhcmd1bWVudHMpfSl9Y2F0Y2gobil7aS5jYWxsKHQsbil9fSk6KHUubXNnPW8sdS5zdGF0ZT0xLHUuY2hhaW4ubGVuZ3RoPjAmJnQoZSx1KSl9Y2F0Y2goYSl7aS5jYWxsKG5ldyBmKHUpLGEpfX19ZnVuY3Rpb24gaShuKXt2YXIgbz10aGlzO28udHJpZ2dlcmVkfHwoby50cmlnZ2VyZWQ9ITAsby5kZWYmJihvPW8uZGVmKSxvLm1zZz1uLG8uc3RhdGU9MixvLmNoYWluLmxlbmd0aD4wJiZ0KGUsbykpfWZ1bmN0aW9uIGModCxuLGUsbyl7Zm9yKHZhciByPTA7cjxuLmxlbmd0aDtyKyspIWZ1bmN0aW9uKHIpe3QucmVzb2x2ZShuW3JdKS50aGVuKGZ1bmN0aW9uKHQpe2Uocix0KX0sbyl9KHIpfWZ1bmN0aW9uIGYodCl7dGhpcy5kZWY9dCx0aGlzLnRyaWdnZXJlZD0hMX1mdW5jdGlvbiB1KHQpe3RoaXMucHJvbWlzZT10LHRoaXMuc3RhdGU9MCx0aGlzLnRyaWdnZXJlZD0hMSx0aGlzLmNoYWluPVtdLHRoaXMubXNnPXZvaWQgMH1mdW5jdGlvbiBhKG4pe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIG4pdGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7aWYoMCE9PXRoaXMuX19OUE9fXyl0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBwcm9taXNlXCIpO3RoaXMuX19OUE9fXz0xO3ZhciBvPW5ldyB1KHRoaXMpO3RoaXMudGhlbj1mdW5jdGlvbihuLHIpe3ZhciBpPXtzdWNjZXNzOlwiZnVuY3Rpb25cIj09dHlwZW9mIG4/bjohMCxmYWlsdXJlOlwiZnVuY3Rpb25cIj09dHlwZW9mIHI/cjohMX07cmV0dXJuIGkucHJvbWlzZT1uZXcgdGhpcy5jb25zdHJ1Y3RvcihmdW5jdGlvbih0LG4pe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHR8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIG4pdGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7aS5yZXNvbHZlPXQsaS5yZWplY3Q9bn0pLG8uY2hhaW4ucHVzaChpKSwwIT09by5zdGF0ZSYmdChlLG8pLGkucHJvbWlzZX0sdGhpc1tcImNhdGNoXCJdPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRoZW4odm9pZCAwLHQpfTt0cnl7bi5jYWxsKHZvaWQgMCxmdW5jdGlvbih0KXtyLmNhbGwobyx0KX0sZnVuY3Rpb24odCl7aS5jYWxsKG8sdCl9KX1jYXRjaChjKXtpLmNhbGwobyxjKX19dmFyIHMsaCxsLHA9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyx5PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZXRJbW1lZGlhdGU/ZnVuY3Rpb24odCl7cmV0dXJuIHNldEltbWVkaWF0ZSh0KX06c2V0VGltZW91dDt0cnl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LFwieFwiLHt9KSxzPWZ1bmN0aW9uKHQsbixlLG8pe3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLHt2YWx1ZTplLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTpvIT09ITF9KX19Y2F0Y2goZCl7cz1mdW5jdGlvbih0LG4sZSl7cmV0dXJuIHRbbl09ZSx0fX1sPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LG4pe3RoaXMuZm49dCx0aGlzLnNlbGY9bix0aGlzLm5leHQ9dm9pZCAwfXZhciBuLGUsbztyZXR1cm57YWRkOmZ1bmN0aW9uKHIsaSl7bz1uZXcgdChyLGkpLGU/ZS5uZXh0PW86bj1vLGU9byxvPXZvaWQgMH0sZHJhaW46ZnVuY3Rpb24oKXt2YXIgdD1uO2ZvcihuPWU9aD12b2lkIDA7dDspdC5mbi5jYWxsKHQuc2VsZiksdD10Lm5leHR9fX0oKTt2YXIgZz1zKHt9LFwiY29uc3RydWN0b3JcIixhLCExKTtyZXR1cm4gYS5wcm90b3R5cGU9ZyxzKGcsXCJfX05QT19fXCIsMCwhMSkscyhhLFwicmVzb2x2ZVwiLGZ1bmN0aW9uKHQpe3ZhciBuPXRoaXM7cmV0dXJuIHQmJlwib2JqZWN0XCI9PXR5cGVvZiB0JiYxPT09dC5fX05QT19fP3Q6bmV3IG4oZnVuY3Rpb24obixlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBufHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO24odCl9KX0pLHMoYSxcInJlamVjdFwiLGZ1bmN0aW9uKHQpe3JldHVybiBuZXcgdGhpcyhmdW5jdGlvbihuLGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIG58fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpdGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7ZSh0KX0pfSkscyhhLFwiYWxsXCIsZnVuY3Rpb24odCl7dmFyIG49dGhpcztyZXR1cm5cIltvYmplY3QgQXJyYXldXCIhPXAuY2FsbCh0KT9uLnJlamVjdChUeXBlRXJyb3IoXCJOb3QgYW4gYXJyYXlcIikpOjA9PT10Lmxlbmd0aD9uLnJlc29sdmUoW10pOm5ldyBuKGZ1bmN0aW9uKGUsbyl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZXx8XCJmdW5jdGlvblwiIT10eXBlb2Ygbyl0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBmdW5jdGlvblwiKTt2YXIgcj10Lmxlbmd0aCxpPUFycmF5KHIpLGY9MDtjKG4sdCxmdW5jdGlvbih0LG4pe2lbdF09biwrK2Y9PT1yJiZlKGkpfSxvKX0pfSkscyhhLFwicmFjZVwiLGZ1bmN0aW9uKHQpe3ZhciBuPXRoaXM7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiIT1wLmNhbGwodCk/bi5yZWplY3QoVHlwZUVycm9yKFwiTm90IGFuIGFycmF5XCIpKTpuZXcgbihmdW5jdGlvbihlLG8pe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGV8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIG8pdGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7YyhuLHQsZnVuY3Rpb24odCxuKXtlKG4pfSxvKX0pfSksYX0pO1xuIiwidmFyIHBhcnNlciA9IHJlcXVpcmUoJy4vcGF0aC1wYXJzZXInKVxudmFyIHN0cmluZ2lmeVF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKS5zdHJpbmdpZnlcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwYXRoU3RyLCBwYXJhbWV0ZXJzKSB7XG5cblx0dmFyIHBhcnNlZCA9IHR5cGVvZiBwYXRoU3RyID09PSAnc3RyaW5nJyA/IHBhcnNlcihwYXRoU3RyKSA6IHBhdGhTdHJcblx0dmFyIGFsbFRva2VucyA9IHBhcnNlZC5hbGxUb2tlbnNcblx0dmFyIHJlZ2V4ID0gcGFyc2VkLnJlZ2V4XG5cblx0aWYgKHBhcmFtZXRlcnMpIHtcblx0XHR2YXIgcGF0aCA9IGFsbFRva2Vucy5tYXAoZnVuY3Rpb24oYml0KSB7XG5cdFx0XHRpZiAoYml0LnN0cmluZykge1xuXHRcdFx0XHRyZXR1cm4gYml0LnN0cmluZ1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZGVmaW5lZCA9IHR5cGVvZiBwYXJhbWV0ZXJzW2JpdC5uYW1lXSAhPT0gJ3VuZGVmaW5lZCdcblx0XHRcdGlmICghYml0Lm9wdGlvbmFsICYmICFkZWZpbmVkKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignTXVzdCBzdXBwbHkgYXJndW1lbnQgJyArIGJpdC5uYW1lICsgJyBmb3IgcGF0aCAnICsgcGF0aFN0cilcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRlZmluZWQgPyAoYml0LmRlbGltaXRlciArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbWV0ZXJzW2JpdC5uYW1lXSkpIDogJydcblx0XHR9KS5qb2luKCcnKVxuXG5cdFx0aWYgKCFyZWdleC50ZXN0KHBhdGgpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVkIGFyZ3VtZW50cyBkbyBub3QgbWF0Y2ggdGhlIG9yaWdpbmFsIGFyZ3VtZW50cycpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJ1aWxkUGF0aFdpdGhRdWVyeXN0cmluZyhwYXRoLCBwYXJhbWV0ZXJzLCBhbGxUb2tlbnMpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHBhcnNlZFxuXHR9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUGF0aFdpdGhRdWVyeXN0cmluZyhwYXRoLCBwYXJhbWV0ZXJzLCB0b2tlbkFycmF5KSB7XG5cdHZhciBwYXJhbWV0ZXJzSW5RdWVyeXN0cmluZyA9IGdldFBhcmFtZXRlcnNXaXRob3V0TWF0Y2hpbmdUb2tlbihwYXJhbWV0ZXJzLCB0b2tlbkFycmF5KVxuXG5cdGlmIChPYmplY3Qua2V5cyhwYXJhbWV0ZXJzSW5RdWVyeXN0cmluZykubGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuIHBhdGhcblx0fVxuXG5cdHJldHVybiBwYXRoICsgJz8nICsgc3RyaW5naWZ5UXVlcnlzdHJpbmcocGFyYW1ldGVyc0luUXVlcnlzdHJpbmcpXG59XG5cbmZ1bmN0aW9uIGdldFBhcmFtZXRlcnNXaXRob3V0TWF0Y2hpbmdUb2tlbihwYXJhbWV0ZXJzLCB0b2tlbkFycmF5KSB7XG5cdHZhciB0b2tlbkhhc2ggPSB0b2tlbkFycmF5LnJlZHVjZShmdW5jdGlvbihtZW1vLCBiaXQpIHtcblx0XHRpZiAoIWJpdC5zdHJpbmcpIHtcblx0XHRcdG1lbW9bYml0Lm5hbWVdID0gYml0XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vXG5cdH0sIHt9KVxuXG5cdHJldHVybiBPYmplY3Qua2V5cyhwYXJhbWV0ZXJzKS5maWx0ZXIoZnVuY3Rpb24ocGFyYW0pIHtcblx0XHRyZXR1cm4gIXRva2VuSGFzaFtwYXJhbV1cblx0fSkucmVkdWNlKGZ1bmN0aW9uKG5ld1BhcmFtZXRlcnMsIHBhcmFtKSB7XG5cdFx0bmV3UGFyYW1ldGVyc1twYXJhbV0gPSBwYXJhbWV0ZXJzW3BhcmFtXVxuXHRcdHJldHVybiBuZXdQYXJhbWV0ZXJzXG5cdH0sIHt9KVxufVxuIiwiLy8gVGhpcyBmaWxlIHRvIGJlIHJlcGxhY2VkIHdpdGggYW4gb2ZmaWNpYWwgaW1wbGVtZW50YXRpb24gbWFpbnRhaW5lZCBieVxuLy8gdGhlIHBhZ2UuanMgY3JldyBpZiBhbmQgd2hlbiB0aGF0IGJlY29tZXMgYW4gb3B0aW9uXG5cbnZhciBwYXRoVG9SZWdleHAgPSByZXF1aXJlKCdwYXRoLXRvLXJlZ2V4cC13aXRoLXJldmVyc2libGUta2V5cycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocGF0aFN0cmluZykge1xuXHR2YXIgcGFyc2VSZXN1bHRzID0gcGF0aFRvUmVnZXhwKHBhdGhTdHJpbmcpXG5cblx0Ly8gVGhlIG9ubHkgcmVhc29uIEknbSByZXR1cm5pbmcgYSBuZXcgb2JqZWN0IGluc3RlYWQgb2YgdGhlIHJlc3VsdHMgb2YgdGhlIHBhdGhUb1JlZ2V4cFxuXHQvLyBmdW5jdGlvbiBpcyBzbyB0aGF0IGlmIHRoZSBvZmZpY2lhbCBpbXBsZW1lbnRhdGlvbiBlbmRzIHVwIHJldHVybmluZyBhblxuXHQvLyBhbGxUb2tlbnMtc3R5bGUgYXJyYXkgdmlhIHNvbWUgb3RoZXIgbWVjaGFuaXNtLCBJIG1heSBiZSBhYmxlIHRvIGNoYW5nZSB0aGlzIGZpbGVcblx0Ly8gd2l0aG91dCBoYXZpbmcgdG8gY2hhbmdlIHRoZSByZXN0IG9mIHRoZSBtb2R1bGUgaW4gaW5kZXguanNcblx0cmV0dXJuIHtcblx0XHRyZWdleDogcGFyc2VSZXN1bHRzLFxuXHRcdGFsbFRva2VuczogcGFyc2VSZXN1bHRzLmFsbFRva2Vuc1xuXHR9XG59XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcblxuLyoqXG4gKiBFeHBvc2UgYHBhdGhUb1JlZ2V4cGAuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gcGF0aFRvUmVnZXhwO1xuXG4vKipcbiAqIFRoZSBtYWluIHBhdGggbWF0Y2hpbmcgcmVnZXhwIHV0aWxpdHkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXG4gIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCB3b24ndCB0cmFuc2Zvcm0uXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCJdXG4gIC8vIFwiL3JvdXRlKFxcXFxkKylcIiA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZF1cbiAgJyhbXFxcXC8uXSk/KD86XFxcXDooXFxcXHcrKSg/OlxcXFwoKCg/OlxcXFxcXFxcLnxbXildKSopXFxcXCkpP3xcXFxcKCgoPzpcXFxcXFxcXC58W14pXSkqKVxcXFwpKShbKyo/XSk/JyxcbiAgLy8gTWF0Y2ggcmVnZXhwIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IGFyZSBhbHdheXMgZXNjYXBlZC5cbiAgJyhbLisqPz1eIToke30oKVtcXFxcXXxcXFxcL10pJ1xuXS5qb2luKCd8JyksICdnJyk7XG5cbi8qKlxuICogRXNjYXBlIHRoZSBjYXB0dXJpbmcgZ3JvdXAgYnkgZXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gZ3JvdXBcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlR3JvdXAgKGdyb3VwKSB7XG4gIHJldHVybiBncm91cC5yZXBsYWNlKC8oWz0hOiRcXC8oKV0pL2csICdcXFxcJDEnKTtcbn1cblxuLyoqXG4gKiBBdHRhY2ggdGhlIGtleXMgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAge1JlZ0V4cH0gcmVcbiAqIEBwYXJhbSAge0FycmF5fSAga2V5c1xuICogQHJldHVybiB7UmVnRXhwfVxuICovXG5mdW5jdGlvbiBhdHRhY2hLZXlzIChyZSwga2V5cywgYWxsVG9rZW5zKSB7XG4gIHJlLmtleXMgPSBrZXlzO1xuICByZS5hbGxUb2tlbnMgPSBhbGxUb2tlbnM7XG4gIHJldHVybiByZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBmbGFncyAob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5zZW5zaXRpdmUgPyAnJyA6ICdpJztcbn1cblxuLyoqXG4gKiBQdWxsIG91dCBrZXlzIGZyb20gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7UmVnRXhwfSBwYXRoXG4gKiBAcGFyYW0gIHtBcnJheX0gIGtleXNcbiAqIEByZXR1cm4ge1JlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9SZWdleHAgKHBhdGgsIGtleXMsIGFsbFRva2Vucykge1xuICAvLyBVc2UgYSBuZWdhdGl2ZSBsb29rYWhlYWQgdG8gbWF0Y2ggb25seSBjYXB0dXJpbmcgZ3JvdXBzLlxuICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZyk7XG5cbiAgaWYgKGdyb3Vwcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBuYW1lOiAgICAgIGksXG4gICAgICAgIGRlbGltaXRlcjogbnVsbCxcbiAgICAgICAgb3B0aW9uYWw6ICBmYWxzZSxcbiAgICAgICAgcmVwZWF0OiAgICBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocGF0aCwga2V5cywgYWxsVG9rZW5zKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMsIGFsbFRva2Vucykge1xuICB2YXIgcGFydHMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKHBhdGhUb1JlZ2V4cChwYXRoW2ldLCBrZXlzLCBvcHRpb25zLCBhbGxUb2tlbnMpLnNvdXJjZSk7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnKD86JyArIHBhcnRzLmpvaW4oJ3wnKSArICcpJywgZmxhZ3Mob3B0aW9ucykpO1xuICByZXR1cm4gYXR0YWNoS2V5cyhyZWdleHAsIGtleXMsIGFsbFRva2Vucyk7XG59XG5cbi8qKlxuICogUmVwbGFjZSB0aGUgc3BlY2lmaWMgdGFncyB3aXRoIHJlZ2V4cCBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlcGxhY2VQYXRoIChwYXRoLCBrZXlzLCBhbGxUb2tlbnMpIHtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RFbmRJbmRleCA9IDBcblxuICBmdW5jdGlvbiBhZGRMYXN0VG9rZW4obGFzdFRva2VuKSB7XG4gICAgaWYgKGxhc3RFbmRJbmRleCA9PT0gMCAmJiBsYXN0VG9rZW5bMF0gIT09ICcvJykge1xuICAgICAgbGFzdFRva2VuID0gJy8nICsgbGFzdFRva2VuXG4gICAgfVxuICAgIGFsbFRva2Vucy5wdXNoKHtcbiAgICAgIHN0cmluZzogbGFzdFRva2VuXG4gICAgfSk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHJlcGxhY2UgKG1hdGNoLCBlc2NhcGVkLCBwcmVmaXgsIGtleSwgY2FwdHVyZSwgZ3JvdXAsIHN1ZmZpeCwgZXNjYXBlLCBvZmZzZXQpIHtcbiAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgcmV0dXJuIGVzY2FwZWQ7XG4gICAgfVxuXG4gICAgaWYgKGVzY2FwZSkge1xuICAgICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZTtcbiAgICB9XG5cbiAgICB2YXIgcmVwZWF0ICAgPSBzdWZmaXggPT09ICcrJyB8fCBzdWZmaXggPT09ICcqJztcbiAgICB2YXIgb3B0aW9uYWwgPSBzdWZmaXggPT09ICc/JyB8fCBzdWZmaXggPT09ICcqJztcblxuICAgIGlmIChvZmZzZXQgPiBsYXN0RW5kSW5kZXgpIHtcbiAgICAgIGFkZExhc3RUb2tlbihwYXRoLnN1YnN0cmluZyhsYXN0RW5kSW5kZXgsIG9mZnNldCkpO1xuICAgIH1cblxuICAgIGxhc3RFbmRJbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgIHZhciBuZXdLZXkgPSB7XG4gICAgICBuYW1lOiAgICAgIGtleSB8fCBpbmRleCsrLFxuICAgICAgZGVsaW1pdGVyOiBwcmVmaXggfHwgJy8nLFxuICAgICAgb3B0aW9uYWw6ICBvcHRpb25hbCxcbiAgICAgIHJlcGVhdDogICAgcmVwZWF0XG4gICAgfVxuXG4gICAga2V5cy5wdXNoKG5ld0tleSk7XG4gICAgYWxsVG9rZW5zLnB1c2gobmV3S2V5KTtcblxuICAgIHByZWZpeCA9IHByZWZpeCA/ICgnXFxcXCcgKyBwcmVmaXgpIDogJyc7XG4gICAgY2FwdHVyZSA9IGVzY2FwZUdyb3VwKGNhcHR1cmUgfHwgZ3JvdXAgfHwgJ1teJyArIChwcmVmaXggfHwgJ1xcXFwvJykgKyAnXSs/Jyk7XG5cbiAgICBpZiAocmVwZWF0KSB7XG4gICAgICBjYXB0dXJlID0gY2FwdHVyZSArICcoPzonICsgcHJlZml4ICsgY2FwdHVyZSArICcpKic7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICByZXR1cm4gJyg/OicgKyBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJykpPyc7XG4gICAgfVxuXG4gICAgLy8gQmFzaWMgcGFyYW1ldGVyIHN1cHBvcnQuXG4gICAgcmV0dXJuIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSc7XG4gIH1cblxuICB2YXIgbmV3UGF0aCA9IHBhdGgucmVwbGFjZShQQVRIX1JFR0VYUCwgcmVwbGFjZSk7XG5cbiAgaWYgKGxhc3RFbmRJbmRleCA8IHBhdGgubGVuZ3RoKSB7XG4gICAgYWRkTGFzdFRva2VuKHBhdGguc3Vic3RyaW5nKGxhc3RFbmRJbmRleCkpXG4gIH1cblxuICByZXR1cm4gbmV3UGF0aDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICpcbiAqIEBwYXJhbSAgeyhTdHJpbmd8UmVnRXhwfEFycmF5KX0gcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgICAgICAgICAgICBba2V5c11cbiAqIEBwYXJhbSAge09iamVjdH0gICAgICAgICAgICAgICAgW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucywgYWxsVG9rZW5zKSB7XG4gIGtleXMgPSBrZXlzIHx8IFtdO1xuICBhbGxUb2tlbnMgPSBhbGxUb2tlbnMgfHwgW107XG5cbiAgaWYgKCFpc0FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IGtleXM7XG4gICAga2V5cyA9IFtdO1xuICB9IGVsc2UgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucywgYWxsVG9rZW5zKTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIGFycmF5VG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucywgYWxsVG9rZW5zKTtcbiAgfVxuXG4gIHZhciBzdHJpY3QgPSBvcHRpb25zLnN0cmljdDtcbiAgdmFyIGVuZCA9IG9wdGlvbnMuZW5kICE9PSBmYWxzZTtcbiAgdmFyIHJvdXRlID0gcmVwbGFjZVBhdGgocGF0aCwga2V5cywgYWxsVG9rZW5zKTtcbiAgdmFyIGVuZHNXaXRoU2xhc2ggPSBwYXRoLmNoYXJBdChwYXRoLmxlbmd0aCAtIDEpID09PSAnLyc7XG5cbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cbiAgLy8gbWF0Y2ggYWxyZWFkeSBlbmRzIHdpdGggYSBzbGFzaCwgd2UgcmVtb3ZlIGl0IGZvciBjb25zaXN0ZW5jeS4gVGhlIHNsYXNoXG4gIC8vIGlzIHZhbGlkIGF0IHRoZSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3QgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHJvdXRlID0gKGVuZHNXaXRoU2xhc2ggPyByb3V0ZS5zbGljZSgwLCAtMikgOiByb3V0ZSkgKyAnKD86XFxcXC8oPz0kKSk/JztcbiAgfVxuXG4gIGlmIChlbmQpIHtcbiAgICByb3V0ZSArPSAnJCc7XG4gIH0gZWxzZSB7XG4gICAgLy8gSW4gbm9uLWVuZGluZyBtb2RlLCB3ZSBuZWVkIHRoZSBjYXB0dXJpbmcgZ3JvdXBzIHRvIG1hdGNoIGFzIG11Y2ggYXNcbiAgICAvLyBwb3NzaWJsZSBieSB1c2luZyBhIHBvc2l0aXZlIGxvb2thaGVhZCB0byB0aGUgZW5kIG9yIG5leHQgcGF0aCBzZWdtZW50LlxuICAgIHJvdXRlICs9IHN0cmljdCAmJiBlbmRzV2l0aFNsYXNoID8gJycgOiAnKD89XFxcXC98JCknO1xuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMobmV3IFJlZ0V4cCgnXicgKyByb3V0ZSwgZmxhZ3Mob3B0aW9ucykpLCBrZXlzLCBhbGxUb2tlbnMpO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxufSAoKSlcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IGNhY2hlZFNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNhY2hlZENsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsInZhciBleHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG5cbmZ1bmN0aW9uIHdyYXBXYWNreVByb21pc2UocHJvbWlzZSwgY2IpIHtcblx0cHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdGNiKClcblx0fSwgZnVuY3Rpb24oZXJyKSB7XG5cdFx0Y2IoZXJyKVxuXHR9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFJhY3RpdmVTdGF0ZVJvdXRlcihSYWN0aXZlLCByYWN0aXZlT3B0aW9ucywgb3B0aW9ucykge1xuXHRmdW5jdGlvbiBjb3B5SWZBcHByb3ByaWF0ZSh2YWx1ZSkge1xuXHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMuZGVlcENvcHlEYXRhT25TZXQpIHtcblx0XHRcdHJldHVybiBjb3B5KHZhbHVlKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdmFsdWVcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZ1bmN0aW9uIG1ha2VSZW5kZXJlcihzdGF0ZVJvdXRlcikge1xuXHRcdHZhciBFeHRlbmRlZFJhY3RpdmUgPSBSYWN0aXZlLmV4dGVuZChyYWN0aXZlT3B0aW9ucyB8fCB7fSlcblx0XHR2YXIgZXh0ZW5kZWREYXRhID0gRXh0ZW5kZWRSYWN0aXZlLmRlZmF1bHRzLmRhdGFcblx0XHR2YXIgcmFjdGl2ZURhdGEgPSBSYWN0aXZlLmRlZmF1bHRzLmRhdGFcblxuXHRcdGV4dGVuZGVkRGF0YS5tYWtlUGF0aCA9IHJhY3RpdmVEYXRhLm1ha2VQYXRoID0gc3RhdGVSb3V0ZXIubWFrZVBhdGhcblxuXHRcdGV4dGVuZGVkRGF0YS5hY3RpdmUgPSByYWN0aXZlRGF0YS5hY3RpdmUgPSBmdW5jdGlvbiBhY3RpdmUoc3RhdGVOYW1lKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVSb3V0ZXIuc3RhdGVJc0FjdGl2ZShzdGF0ZU5hbWUpID8gJ2FjdGl2ZScgOiAnJ1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihjb250ZXh0LCBjYikge1xuXHRcdFx0XHR2YXIgZWxlbWVudCA9IGNvbnRleHQuZWxlbWVudFxuXHRcdFx0XHR2YXIgaW5wdXRUZW1wbGF0ZSA9IGNvbnRleHQudGVtcGxhdGVcblxuXHRcdFx0XHR2YXIgZGVmYXVsdERlY29yYXRvcnMgPSB7XG5cdFx0XHRcdFx0YWN0aXZlOiBhY3RpdmVTdGF0ZURlY2FyYXRvci5iaW5kKG51bGwsIHN0YXRlUm91dGVyKVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZnVuY3Rpb24gZ2V0RGF0YSgpIHtcblx0XHRcdFx0XHR2YXIgY29weU9mQ29udGVudCA9IGNvcHlJZkFwcHJvcHJpYXRlKGNvbnRleHQuY29udGVudClcblx0XHRcdFx0XHRyZXR1cm4gaXNUZW1wbGF0ZShpbnB1dFRlbXBsYXRlKSA/IGNvcHlPZkNvbnRlbnQgOiBleHRlbmQoaW5wdXRUZW1wbGF0ZS5kYXRhLCBjb3B5T2ZDb250ZW50KVxuXHRcdFx0XHR9XG5cdFx0XHRcdGZ1bmN0aW9uIGdldERlY29yYXRvcnMoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGlzVGVtcGxhdGUoaW5wdXRUZW1wbGF0ZSkgPyBkZWZhdWx0RGVjb3JhdG9ycyA6IGV4dGVuZChkZWZhdWx0RGVjb3JhdG9ycywgaW5wdXRUZW1wbGF0ZS5kZWNvcmF0b3JzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XG5cdFx0XHRcdFx0dmFyIGJhcmVPcHRpb25zID0gaXNUZW1wbGF0ZShpbnB1dFRlbXBsYXRlKSA/IHsgdGVtcGxhdGU6IGlucHV0VGVtcGxhdGUgfSA6IGlucHV0VGVtcGxhdGVcblxuXHRcdFx0XHRcdHJldHVybiBleHRlbmQoYmFyZU9wdGlvbnMsIHtcblx0XHRcdFx0XHRcdGRlY29yYXRvcnM6IGdldERlY29yYXRvcnMoKSxcblx0XHRcdFx0XHRcdGRhdGE6IGdldERhdGEoKSxcblx0XHRcdFx0XHRcdGVsOiBlbGVtZW50XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dmFyIHJhY3RpdmUgPSBuZXcgRXh0ZW5kZWRSYWN0aXZlKGdldE9wdGlvbnMoKSlcblx0XHRcdFx0XHRjYihudWxsLCByYWN0aXZlKVxuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0Y2IoZSlcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlc2V0OiBmdW5jdGlvbiByZXNldChjb250ZXh0LCBjYikge1xuXHRcdFx0XHR2YXIgcmFjdGl2ZSA9IGNvbnRleHQuZG9tQXBpXG5cdFx0XHRcdHJhY3RpdmUub2ZmKClcblx0XHRcdFx0d3JhcFdhY2t5UHJvbWlzZShyYWN0aXZlLnJlc2V0KGNvcHlJZkFwcHJvcHJpYXRlKGNvbnRleHQuY29udGVudCkpLCBjYilcblx0XHRcdH0sXG5cdFx0XHRkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KHJhY3RpdmUsIGNiKSB7XG5cdFx0XHRcdHdyYXBXYWNreVByb21pc2UocmFjdGl2ZS50ZWFyZG93bigpLCBjYilcblx0XHRcdH0sXG5cdFx0XHRnZXRDaGlsZEVsZW1lbnQ6IGZ1bmN0aW9uIGdldENoaWxkRWxlbWVudChyYWN0aXZlLCBjYikge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhciBjaGlsZCA9IHJhY3RpdmUuZmluZCgndWktdmlldycpXG5cdFx0XHRcdFx0Y2IobnVsbCwgY2hpbGQpXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRjYihlKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGNvcHkodmFsdWUpIHtcblx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0cmV0dXJuIHZhbHVlLm1hcChjb3B5KVxuXHR9IGVsc2UgaWYgKG9iamVjdCh2YWx1ZSkpIHtcblx0XHR2YXIgdGFyZ2V0ID0ge31cblx0XHRPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdHRhcmdldFtrZXldID0gY29weSh2YWx1ZVtrZXldKVxuXHRcdH0pXG5cdFx0cmV0dXJuIHRhcmdldFxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiB2YWx1ZVxuXHR9XG59XG5cbmZ1bmN0aW9uIG9iamVjdChvKSB7XG5cdHJldHVybiBvICYmIHR5cGVvZiBvID09PSAnb2JqZWN0J1xufVxuXG5mdW5jdGlvbiBhY3RpdmVTdGF0ZURlY2FyYXRvcihzdGF0ZVJvdXRlciwgZWxlbWVudCwgc3RhdGVOYW1lKSB7XG5cdHZhciBwYXJhbWV0ZXJzVG9NYXRjaCA9IHBhcnNlUGFyYW1ldGVycyhhcmd1bWVudHMpXG5cdGZ1bmN0aW9uIG9uU3RhdGVDaGFuZ2UoKSB7XG5cdFx0dmFyIGFjdGl2ZSA9IHN0YXRlUm91dGVyLnN0YXRlSXNBY3RpdmUoc3RhdGVOYW1lLCBwYXJhbWV0ZXJzVG9NYXRjaClcblxuXHRcdGlmIChhY3RpdmUpIHtcblx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJylcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKVxuXHRcdH1cblxuXHR9XG5cblx0c3RhdGVSb3V0ZXIub24oJ3N0YXRlQ2hhbmdlRW5kJywgb25TdGF0ZUNoYW5nZSlcblxuXHRmdW5jdGlvbiB0ZWFyZG93bigpIHtcblx0XHRzdGF0ZVJvdXRlci5yZW1vdmVMaXN0ZW5lcignc3RhdGVDaGFuZ2VFbmQnLCBvblN0YXRlQ2hhbmdlKVxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHR0ZWFyZG93bjogdGVhcmRvd25cblx0fVxufVxuXG5mdW5jdGlvbiBwYXJzZVBhcmFtZXRlcnMoYXJncykge1xuXHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMilcblx0cmV0dXJuIGFyZ3MucmVkdWNlKGZ1bmN0aW9uKGFsbFBhcmFtZXRlcnMsIHBhcmFtZXRlclBhaXIpIHtcblx0XHR2YXIga2V5QW5kVmFsdWUgPSBwYXJhbWV0ZXJQYWlyLnNwbGl0KCc6Jylcblx0XHRpZiAoa2V5QW5kVmFsdWUubGVuZ3RoID4gMSkge1xuXHRcdFx0YWxsUGFyYW1ldGVyc1trZXlBbmRWYWx1ZVswXV0gPSBrZXlBbmRWYWx1ZVsxXVxuXHRcdH1cblx0XHRyZXR1cm4gYWxsUGFyYW1ldGVyc1xuXHR9LCB7fSlcbn1cblxuZnVuY3Rpb24gYWxsUGFyYW1ldGVyc01hdGNoKHRvTWF0Y2gsIHBhcmFtZXRlcnMpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKHRvTWF0Y2gpLmV2ZXJ5KGZ1bmN0aW9uKGtleSkge1xuXHRcdHJldHVybiB0b01hdGNoW2tleV0gPT0gcGFyYW1ldGVyc1trZXldXG5cdH0pXG59XG5cbmZ1bmN0aW9uIGlzVGVtcGxhdGUoaW5wdXRUZW1wbGF0ZSkge1xuXHRyZXR1cm4gdHlwZW9mIGlucHV0VGVtcGxhdGUgPT09ICdzdHJpbmcnIHx8IGlzUmFjdGl2ZVRlbXBsYXRlT2JqZWN0KGlucHV0VGVtcGxhdGUpXG59XG5cbmZ1bmN0aW9uIGlzUmFjdGl2ZVRlbXBsYXRlT2JqZWN0KHRlbXBsYXRlKSB7XG5cdC8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9ibG9iL2IxYzllMWU1YzIyZGFhYzMyMTBlZTdkYjBmNTExMDY1YjMxYWFjM2Mvc3JjL1JhY3RpdmUvY29uZmlnL2N1c3RvbS90ZW1wbGF0ZS90ZW1wbGF0ZS5qcyNMMTEzLUwxMTZcblx0cmV0dXJuIHRlbXBsYXRlICYmIHR5cGVvZiB0ZW1wbGF0ZS52ID09PSAnbnVtYmVyJ1xufVxuIiwiLypcblx0UmFjdGl2ZS5qcyB2MC43LjNcblx0U2F0IEFwciAyNSAyMDE1IDEzOjUyOjM4IEdNVC0wNDAwIChFRFQpIC0gY29tbWl0IGRhNDBmODFjNjYwYmEyZjA5YzQ1YTA5YTljMjBmZGQzNGVlMzZkODBcblxuXHRodHRwOi8vcmFjdGl2ZWpzLm9yZ1xuXHRodHRwOi8vdHdpdHRlci5jb20vUmFjdGl2ZUpTXG5cblx0UmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICBnbG9iYWwuUmFjdGl2ZSA9IGZhY3RvcnkoKVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgVEVNUExBVEVfVkVSU0lPTiA9IDM7XG5cbiAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuXG4gIFx0Ly8gcmVuZGVyIHBsYWNlbWVudDpcbiAgXHRlbDogdm9pZCAwLFxuICBcdGFwcGVuZDogZmFsc2UsXG5cbiAgXHQvLyB0ZW1wbGF0ZTpcbiAgXHR0ZW1wbGF0ZTogeyB2OiBURU1QTEFURV9WRVJTSU9OLCB0OiBbXSB9LFxuXG4gIFx0Ly8gcGFyc2U6ICAgICAvLyBUT0RPIHN0YXRpYyBkZWxpbWl0ZXJzP1xuICBcdHByZXNlcnZlV2hpdGVzcGFjZTogZmFsc2UsXG4gIFx0c2FuaXRpemU6IGZhbHNlLFxuICBcdHN0cmlwQ29tbWVudHM6IHRydWUsXG4gIFx0ZGVsaW1pdGVyczogW1wie3tcIiwgXCJ9fVwiXSxcbiAgXHR0cmlwbGVEZWxpbWl0ZXJzOiBbXCJ7e3tcIiwgXCJ9fX1cIl0sXG4gIFx0aW50ZXJwb2xhdGU6IGZhbHNlLFxuXG4gIFx0Ly8gZGF0YSAmIGJpbmRpbmc6XG4gIFx0ZGF0YToge30sXG4gIFx0Y29tcHV0ZWQ6IHt9LFxuICBcdG1hZ2ljOiBmYWxzZSxcbiAgXHRtb2RpZnlBcnJheXM6IHRydWUsXG4gIFx0YWRhcHQ6IFtdLFxuICBcdGlzb2xhdGVkOiBmYWxzZSxcbiAgXHR0d293YXk6IHRydWUsXG4gIFx0bGF6eTogZmFsc2UsXG5cbiAgXHQvLyB0cmFuc2l0aW9uczpcbiAgXHRub0ludHJvOiBmYWxzZSxcbiAgXHR0cmFuc2l0aW9uc0VuYWJsZWQ6IHRydWUsXG4gIFx0Y29tcGxldGU6IHZvaWQgMCxcblxuICBcdC8vIGNzczpcbiAgXHRjc3M6IG51bGwsXG4gIFx0bm9Dc3NUcmFuc2Zvcm06IGZhbHNlXG4gIH07XG5cbiAgdmFyIGNvbmZpZ19kZWZhdWx0cyA9IGRlZmF1bHRPcHRpb25zO1xuXG4gIC8vIFRoZXNlIGFyZSBhIHN1YnNldCBvZiB0aGUgZWFzaW5nIGVxdWF0aW9ucyBmb3VuZCBhdFxuICAvLyBodHRwczovL3Jhdy5naXRodWIuY29tL2RhbnJvL2Vhc2luZy1qcyAtIGxpY2Vuc2UgaW5mb1xuICAvLyBmb2xsb3dzOlxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIGVhc2luZy5qcyB2MC41LjRcbiAgLy8gR2VuZXJpYyBzZXQgb2YgZWFzaW5nIGZ1bmN0aW9ucyB3aXRoIEFNRCBzdXBwb3J0XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYW5yby9lYXNpbmctanNcbiAgLy8gVGhpcyBjb2RlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gIC8vIGh0dHA6Ly9kYW5yby5taXQtbGljZW5zZS5vcmcvXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEFsbCBmdW5jdGlvbnMgYWRhcHRlZCBmcm9tIFRob21hcyBGdWNocyAmIEplcmVteSBLYWhuXG4gIC8vIEVhc2luZyBFcXVhdGlvbnMgKGMpIDIwMDMgUm9iZXJ0IFBlbm5lciwgQlNEIGxpY2Vuc2VcbiAgLy8gaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9kYW5yby9lYXNpbmctanMvbWFzdGVyL0xJQ0VOU0VcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBJbiB0aGF0IGxpYnJhcnksIHRoZSBmdW5jdGlvbnMgbmFtZWQgZWFzZUluLCBlYXNlT3V0LCBhbmRcbiAgLy8gZWFzZUluT3V0IGJlbG93IGFyZSBuYW1lZCBlYXNlSW5DdWJpYywgZWFzZU91dEN1YmljLCBhbmRcbiAgLy8gKHlvdSBndWVzc2VkIGl0KSBlYXNlSW5PdXRDdWJpYy5cbiAgLy9cbiAgLy8gWW91IGNhbiBhZGQgYWRkaXRpb25hbCBlYXNpbmcgZnVuY3Rpb25zIHRvIHRoaXMgbGlzdCwgYW5kIHRoZXlcbiAgLy8gd2lsbCBiZSBnbG9iYWxseSBhdmFpbGFibGUuXG5cbiAgdmFyIHN0YXRpY19lYXNpbmcgPSB7XG4gIFx0bGluZWFyOiBmdW5jdGlvbiAocG9zKSB7XG4gIFx0XHRyZXR1cm4gcG9zO1xuICBcdH0sXG4gIFx0ZWFzZUluOiBmdW5jdGlvbiAocG9zKSB7XG4gIFx0XHRyZXR1cm4gTWF0aC5wb3cocG9zLCAzKTtcbiAgXHR9LFxuICBcdGVhc2VPdXQ6IGZ1bmN0aW9uIChwb3MpIHtcbiAgXHRcdHJldHVybiBNYXRoLnBvdyhwb3MgLSAxLCAzKSArIDE7XG4gIFx0fSxcbiAgXHRlYXNlSW5PdXQ6IGZ1bmN0aW9uIChwb3MpIHtcbiAgXHRcdGlmICgocG9zIC89IDAuNSkgPCAxKSB7XG4gIFx0XHRcdHJldHVybiAwLjUgKiBNYXRoLnBvdyhwb3MsIDMpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIDAuNSAqIChNYXRoLnBvdyhwb3MgLSAyLCAzKSArIDIpO1xuICBcdH1cbiAgfTtcblxuICAvKmdsb2JhbCBjb25zb2xlLCBuYXZpZ2F0b3IgKi9cbiAgdmFyIGlzQ2xpZW50LCBpc0pzZG9tLCBoYXNDb25zb2xlLCBlbnZpcm9ubWVudF9fbWFnaWMsIG5hbWVzcGFjZXMsIHN2ZywgdmVuZG9ycztcblxuICBpc0NsaWVudCA9IHR5cGVvZiBkb2N1bWVudCA9PT0gXCJvYmplY3RcIjtcblxuICBpc0pzZG9tID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvanNEb20vLnRlc3QobmF2aWdhdG9yLmFwcE5hbWUpO1xuXG4gIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS53YXJuID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGNvbnNvbGUud2Fybi5hcHBseSA9PT0gXCJmdW5jdGlvblwiO1xuXG4gIHRyeSB7XG4gIFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInRlc3RcIiwgeyB2YWx1ZTogMCB9KTtcbiAgXHRlbnZpcm9ubWVudF9fbWFnaWMgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gIFx0ZW52aXJvbm1lbnRfX21hZ2ljID0gZmFsc2U7XG4gIH1cblxuICBuYW1lc3BhY2VzID0ge1xuICBcdGh0bWw6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLFxuICBcdG1hdGhtbDogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCIsXG4gIFx0c3ZnOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIFx0eGxpbms6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICBcdHhtbDogXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIixcbiAgXHR4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wiXG4gIH07XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICBcdHN2ZyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICBcdHN2ZyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0Jhc2ljU3RydWN0dXJlXCIsIFwiMS4xXCIpO1xuICB9XG5cbiAgdmVuZG9ycyA9IFtcIm9cIiwgXCJtc1wiLCBcIm1velwiLCBcIndlYmtpdFwiXTtcblxuICB2YXIgY3JlYXRlRWxlbWVudCwgbWF0Y2hlcywgZG9tX19kaXYsIG1ldGhvZE5hbWVzLCB1bnByZWZpeGVkLCBwcmVmaXhlZCwgZG9tX19pLCBqLCBtYWtlRnVuY3Rpb247XG5cbiAgLy8gVGVzdCBmb3IgU1ZHIHN1cHBvcnRcbiAgaWYgKCFzdmcpIHtcbiAgXHRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIG5zKSB7XG4gIFx0XHRpZiAobnMgJiYgbnMgIT09IG5hbWVzcGFjZXMuaHRtbCkge1xuICBcdFx0XHR0aHJvdyBcIlRoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IG5hbWVzcGFjZXMgb3RoZXIgdGhhbiBodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sLiBUaGUgbW9zdCBsaWtlbHkgY2F1c2Ugb2YgdGhpcyBlcnJvciBpcyB0aGF0IHlvdSdyZSB0cnlpbmcgdG8gcmVuZGVyIFNWRyBpbiBhbiBvbGRlciBicm93c2VyLiBTZWUgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3Qvc3ZnLWFuZC1vbGRlci1icm93c2VycyBmb3IgbW9yZSBpbmZvcm1hdGlvblwiO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgXHR9O1xuICB9IGVsc2Uge1xuICBcdGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwgbnMpIHtcbiAgXHRcdGlmICghbnMgfHwgbnMgPT09IG5hbWVzcGFjZXMuaHRtbCkge1xuICBcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgdHlwZSk7XG4gIFx0fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEVsZW1lbnQoaW5wdXQpIHtcbiAgXHR2YXIgb3V0cHV0O1xuXG4gIFx0aWYgKCFpbnB1dCB8fCB0eXBlb2YgaW5wdXQgPT09IFwiYm9vbGVhblwiKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgIWRvY3VtZW50IHx8ICFpbnB1dCkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gV2UgYWxyZWFkeSBoYXZlIGEgRE9NIG5vZGUgLSBubyB3b3JrIHRvIGRvLiAoRHVjayB0eXBpbmcgYWxlcnQhKVxuICBcdGlmIChpbnB1dC5ub2RlVHlwZSkge1xuICBcdFx0cmV0dXJuIGlucHV0O1xuICBcdH1cblxuICBcdC8vIEdldCBub2RlIGZyb20gc3RyaW5nXG4gIFx0aWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0Ly8gdHJ5IElEIGZpcnN0XG4gIFx0XHRvdXRwdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpbnB1dCk7XG5cbiAgXHRcdC8vIHRoZW4gYXMgc2VsZWN0b3IsIGlmIHBvc3NpYmxlXG4gIFx0XHRpZiAoIW91dHB1dCAmJiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKSB7XG4gIFx0XHRcdG91dHB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoaW5wdXQpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBkaWQgaXQgd29yaz9cbiAgXHRcdGlmIChvdXRwdXQgJiYgb3V0cHV0Lm5vZGVUeXBlKSB7XG4gIFx0XHRcdHJldHVybiBvdXRwdXQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gSWYgd2UndmUgYmVlbiBnaXZlbiBhIGNvbGxlY3Rpb24gKGpRdWVyeSwgWmVwdG8gZXRjKSwgZXh0cmFjdCB0aGUgZmlyc3QgaXRlbVxuICBcdGlmIChpbnB1dFswXSAmJiBpbnB1dFswXS5ub2RlVHlwZSkge1xuICBcdFx0cmV0dXJuIGlucHV0WzBdO1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKCFpc0NsaWVudCkge1xuICBcdG1hdGNoZXMgPSBudWxsO1xuICB9IGVsc2Uge1xuICBcdGRvbV9fZGl2ID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgXHRtZXRob2ROYW1lcyA9IFtcIm1hdGNoZXNcIiwgXCJtYXRjaGVzU2VsZWN0b3JcIl07XG5cbiAgXHRtYWtlRnVuY3Rpb24gPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICBcdFx0cmV0dXJuIGZ1bmN0aW9uIChub2RlLCBzZWxlY3Rvcikge1xuICBcdFx0XHRyZXR1cm4gbm9kZVttZXRob2ROYW1lXShzZWxlY3Rvcik7XG4gIFx0XHR9O1xuICBcdH07XG5cbiAgXHRkb21fX2kgPSBtZXRob2ROYW1lcy5sZW5ndGg7XG5cbiAgXHR3aGlsZSAoZG9tX19pLS0gJiYgIW1hdGNoZXMpIHtcbiAgXHRcdHVucHJlZml4ZWQgPSBtZXRob2ROYW1lc1tkb21fX2ldO1xuXG4gIFx0XHRpZiAoZG9tX19kaXZbdW5wcmVmaXhlZF0pIHtcbiAgXHRcdFx0bWF0Y2hlcyA9IG1ha2VGdW5jdGlvbih1bnByZWZpeGVkKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGogPSB2ZW5kb3JzLmxlbmd0aDtcbiAgXHRcdFx0d2hpbGUgKGotLSkge1xuICBcdFx0XHRcdHByZWZpeGVkID0gdmVuZG9yc1tkb21fX2ldICsgdW5wcmVmaXhlZC5zdWJzdHIoMCwgMSkudG9VcHBlckNhc2UoKSArIHVucHJlZml4ZWQuc3Vic3RyaW5nKDEpO1xuXG4gIFx0XHRcdFx0aWYgKGRvbV9fZGl2W3ByZWZpeGVkXSkge1xuICBcdFx0XHRcdFx0bWF0Y2hlcyA9IG1ha2VGdW5jdGlvbihwcmVmaXhlZCk7XG4gIFx0XHRcdFx0XHRicmVhaztcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBJRTguLi5cbiAgXHRpZiAoIW1hdGNoZXMpIHtcbiAgXHRcdG1hdGNoZXMgPSBmdW5jdGlvbiAobm9kZSwgc2VsZWN0b3IpIHtcbiAgXHRcdFx0dmFyIG5vZGVzLCBwYXJlbnROb2RlLCBpO1xuXG4gIFx0XHRcdHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cbiAgXHRcdFx0aWYgKCFwYXJlbnROb2RlKSB7XG4gIFx0XHRcdFx0Ly8gZW1wdHkgZHVtbXkgPGRpdj5cbiAgXHRcdFx0XHRkb21fX2Rpdi5pbm5lckhUTUwgPSBcIlwiO1xuXG4gIFx0XHRcdFx0cGFyZW50Tm9kZSA9IGRvbV9fZGl2O1xuICBcdFx0XHRcdG5vZGUgPSBub2RlLmNsb25lTm9kZSgpO1xuXG4gIFx0XHRcdFx0ZG9tX19kaXYuYXBwZW5kQ2hpbGQobm9kZSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRub2RlcyA9IHBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG5cbiAgXHRcdFx0aSA9IG5vZGVzLmxlbmd0aDtcbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdGlmIChub2Rlc1tpXSA9PT0gbm9kZSkge1xuICBcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBkZXRhY2hOb2RlKG5vZGUpIHtcbiAgXHRpZiAobm9kZSAmJiB0eXBlb2Ygbm9kZS5wYXJlbnROb2RlICE9PSBcInVua25vd25cIiAmJiBub2RlLnBhcmVudE5vZGUpIHtcbiAgXHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZmVUb1N0cmluZ1ZhbHVlKHZhbHVlKSB7XG4gIFx0cmV0dXJuIHZhbHVlID09IG51bGwgfHwgIXZhbHVlLnRvU3RyaW5nID8gXCJcIiA6IHZhbHVlO1xuICB9XG5cbiAgdmFyIGxlZ2FjeSA9IG51bGw7XG5cbiAgdmFyIGNyZWF0ZSwgZGVmaW5lUHJvcGVydHksIGRlZmluZVByb3BlcnRpZXM7XG5cbiAgdHJ5IHtcbiAgXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIFwidGVzdFwiLCB7IHZhbHVlOiAwIH0pO1xuXG4gIFx0aWYgKGlzQ2xpZW50KSB7XG4gIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgXCJ0ZXN0XCIsIHsgdmFsdWU6IDAgfSk7XG4gIFx0fVxuXG4gIFx0ZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gIH0gY2F0Y2ggKGVycikge1xuICBcdC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBkb2Vzbid0IGV4aXN0LCBvciB3ZSdyZSBpbiBJRTggd2hlcmUgeW91IGNhblxuICBcdC8vIG9ubHkgdXNlIGl0IHdpdGggRE9NIG9iamVjdHMgKHdoYXQgd2VyZSB5b3Ugc21va2luZywgTVNGVD8pXG4gIFx0ZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBkZXNjKSB7XG4gIFx0XHRvYmpbcHJvcF0gPSBkZXNjLnZhbHVlO1xuICBcdH07XG4gIH1cblxuICB0cnkge1xuICBcdHRyeSB7XG4gIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7fSwgeyB0ZXN0OiB7IHZhbHVlOiAwIH0gfSk7XG4gIFx0fSBjYXRjaCAoZXJyKSB7XG4gIFx0XHQvLyBUT0RPIGhvdyBkbyB3ZSBhY2NvdW50IGZvciB0aGlzPyBub01hZ2ljID0gdHJ1ZTtcbiAgXHRcdHRocm93IGVycjtcbiAgXHR9XG5cbiAgXHRpZiAoaXNDbGllbnQpIHtcbiAgXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHsgdGVzdDogeyB2YWx1ZTogMCB9IH0pO1xuICBcdH1cblxuICBcdGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbiAgfSBjYXRjaCAoZXJyKSB7XG4gIFx0ZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmosIHByb3BzKSB7XG4gIFx0XHR2YXIgcHJvcDtcblxuICBcdFx0Zm9yIChwcm9wIGluIHByb3BzKSB7XG4gIFx0XHRcdGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICBcdFx0XHRcdGRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgcHJvcHNbcHJvcF0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fTtcbiAgfVxuXG4gIHRyeSB7XG4gIFx0T2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBcdGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG4gIH0gY2F0Y2ggKGVycikge1xuICBcdC8vIHNpZ2hcbiAgXHRjcmVhdGUgPSAoZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIEYgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBcdFx0cmV0dXJuIGZ1bmN0aW9uIChwcm90bywgcHJvcHMpIHtcbiAgXHRcdFx0dmFyIG9iajtcblxuICBcdFx0XHRpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgXHRcdFx0XHRyZXR1cm4ge307XG4gIFx0XHRcdH1cblxuICBcdFx0XHRGLnByb3RvdHlwZSA9IHByb3RvO1xuICBcdFx0XHRvYmogPSBuZXcgRigpO1xuXG4gIFx0XHRcdGlmIChwcm9wcykge1xuICBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9iaiwgcHJvcHMpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIG9iajtcbiAgXHRcdH07XG4gIFx0fSkoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHV0aWxzX29iamVjdF9fZXh0ZW5kKHRhcmdldCkge1xuICBcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICBcdFx0c291cmNlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIFx0fVxuXG4gIFx0dmFyIHByb3AsIHNvdXJjZTtcblxuICBcdHdoaWxlIChzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCkpIHtcbiAgXHRcdGZvciAocHJvcCBpbiBzb3VyY2UpIHtcbiAgXHRcdFx0aWYgKGhhc093bi5jYWxsKHNvdXJjZSwgcHJvcCkpIHtcbiAgXHRcdFx0XHR0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsbEdhcHModGFyZ2V0KSB7XG4gIFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gIFx0XHRzb3VyY2VzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgXHR9XG5cbiAgXHRzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgXHRcdGZvciAodmFyIGtleSBpbiBzKSB7XG4gIFx0XHRcdGlmIChzLmhhc093blByb3BlcnR5KGtleSkgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICBcdFx0XHRcdHRhcmdldFtrZXldID0gc1trZXldO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgLy8gdGhhbmtzLCBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS9pbnN0YW5jZW9mLWNvbnNpZGVyZWQtaGFybWZ1bC1vci1ob3ctdG8td3JpdGUtYS1yb2J1c3QtaXNhcnJheS9cbiAgdmFyIGlzX190b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICBhcnJheUxpa2VQYXR0ZXJuID0gL15cXFtvYmplY3QgKD86QXJyYXl8RmlsZUxpc3QpXFxdJC87XG4gIGZ1bmN0aW9uIGlzQXJyYXkodGhpbmcpIHtcbiAgXHRyZXR1cm4gaXNfX3RvU3RyaW5nLmNhbGwodGhpbmcpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc0FycmF5TGlrZShvYmopIHtcbiAgXHRyZXR1cm4gYXJyYXlMaWtlUGF0dGVybi50ZXN0KGlzX190b1N0cmluZy5jYWxsKG9iaikpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gIFx0aWYgKGEgPT09IG51bGwgJiYgYiA9PT0gbnVsbCkge1xuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuXG4gIFx0aWYgKHR5cGVvZiBhID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBiID09PSBcIm9iamVjdFwiKSB7XG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGEgPT09IGI7XG4gIH1cblxuICBmdW5jdGlvbiBpc19faXNOdW1lcmljKHRoaW5nKSB7XG4gIFx0cmV0dXJuICFpc05hTihwYXJzZUZsb2F0KHRoaW5nKSkgJiYgaXNGaW5pdGUodGhpbmcpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNPYmplY3QodGhpbmcpIHtcbiAgXHRyZXR1cm4gdGhpbmcgJiYgaXNfX3RvU3RyaW5nLmNhbGwodGhpbmcpID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xuICB9XG5cbiAgdmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAvKiBnbG9iYWwgY29uc29sZSAqL1xuICB2YXIgYWxyZWFkeVdhcm5lZCA9IHt9LFxuICAgICAgbG9nLFxuICAgICAgcHJpbnRXYXJuaW5nLFxuICAgICAgd2VsY29tZTtcblxuICBpZiAoaGFzQ29uc29sZSkge1xuICBcdChmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgd2VsY29tZUludHJvID0gW1wiJWNSYWN0aXZlLmpzICVjMC43LjMgJWNpbiBkZWJ1ZyBtb2RlLCAlY21vcmUuLi5cIiwgXCJjb2xvcjogcmdiKDExNCwgMTU3LCA1Mik7IGZvbnQtd2VpZ2h0OiBub3JtYWw7XCIsIFwiY29sb3I6IHJnYig4NSwgODUsIDg1KTsgZm9udC13ZWlnaHQ6IG5vcm1hbDtcIiwgXCJjb2xvcjogcmdiKDg1LCA4NSwgODUpOyBmb250LXdlaWdodDogbm9ybWFsO1wiLCBcImNvbG9yOiByZ2IoODIsIDE0MCwgMjI0KTsgZm9udC13ZWlnaHQ6IG5vcm1hbDsgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XCJdO1xuICBcdFx0dmFyIHdlbGNvbWVNZXNzYWdlID0gXCJZb3UncmUgcnVubmluZyBSYWN0aXZlIDAuNy4zIGluIGRlYnVnIG1vZGUgLSBtZXNzYWdlcyB3aWxsIGJlIHByaW50ZWQgdG8gdGhlIGNvbnNvbGUgdG8gaGVscCB5b3UgZml4IHByb2JsZW1zIGFuZCBvcHRpbWlzZSB5b3VyIGFwcGxpY2F0aW9uLlxcblxcblRvIGRpc2FibGUgZGVidWcgbW9kZSwgYWRkIHRoaXMgbGluZSBhdCB0aGUgc3RhcnQgb2YgeW91ciBhcHA6XFxuICBSYWN0aXZlLkRFQlVHID0gZmFsc2U7XFxuXFxuVG8gZGlzYWJsZSBkZWJ1ZyBtb2RlIHdoZW4geW91ciBhcHAgaXMgbWluaWZpZWQsIGFkZCB0aGlzIHNuaXBwZXQ6XFxuICBSYWN0aXZlLkRFQlVHID0gL3VubWluaWZpZWQvLnRlc3QoZnVuY3Rpb24oKXsvKnVubWluaWZpZWQqL30pO1xcblxcbkdldCBoZWxwIGFuZCBzdXBwb3J0OlxcbiAgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZ1xcbiAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy90YWdnZWQvcmFjdGl2ZWpzXFxuICBodHRwOi8vZ3JvdXBzLmdvb2dsZS5jb20vZm9ydW0vIyFmb3J1bS9yYWN0aXZlLWpzXFxuICBodHRwOi8vdHdpdHRlci5jb20vcmFjdGl2ZWpzXFxuXFxuRm91bmQgYSBidWc/IFJhaXNlIGFuIGlzc3VlOlxcbiAgaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3Vlc1xcblxcblwiO1xuXG4gIFx0XHR3ZWxjb21lID0gZnVuY3Rpb24gKCkge1xuICBcdFx0XHR2YXIgaGFzR3JvdXAgPSAhIWNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gIFx0XHRcdGNvbnNvbGVbaGFzR3JvdXAgPyBcImdyb3VwQ29sbGFwc2VkXCIgOiBcImxvZ1wiXS5hcHBseShjb25zb2xlLCB3ZWxjb21lSW50cm8pO1xuICBcdFx0XHRjb25zb2xlLmxvZyh3ZWxjb21lTWVzc2FnZSk7XG4gIFx0XHRcdGlmIChoYXNHcm91cCkge1xuICBcdFx0XHRcdGNvbnNvbGUuZ3JvdXBFbmQod2VsY29tZUludHJvKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHdlbGNvbWUgPSBub29wO1xuICBcdFx0fTtcblxuICBcdFx0cHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGFyZ3MpIHtcbiAgXHRcdFx0d2VsY29tZSgpO1xuXG4gIFx0XHRcdC8vIGV4dHJhY3QgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGluc3RhbmNlIHRoaXMgbWVzc2FnZSBwZXJ0YWlucyB0bywgaWYgYXBwbGljYWJsZVxuICBcdFx0XHRpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gXCJvYmplY3RcIikge1xuICBcdFx0XHRcdHZhciBvcHRpb25zID0gYXJncy5wb3AoKTtcbiAgXHRcdFx0XHR2YXIgcmFjdGl2ZSA9IG9wdGlvbnMgPyBvcHRpb25zLnJhY3RpdmUgOiBudWxsO1xuXG4gIFx0XHRcdFx0aWYgKHJhY3RpdmUpIHtcbiAgXHRcdFx0XHRcdC8vIGlmIHRoaXMgaXMgYW4gaW5zdGFuY2Ugb2YgYSBjb21wb25lbnQgdGhhdCB3ZSBrbm93IHRoZSBuYW1lIG9mLCBhZGRcbiAgXHRcdFx0XHRcdC8vIGl0IHRvIHRoZSBtZXNzYWdlXG4gIFx0XHRcdFx0XHR2YXIgX25hbWUgPSB1bmRlZmluZWQ7XG4gIFx0XHRcdFx0XHRpZiAocmFjdGl2ZS5jb21wb25lbnQgJiYgKF9uYW1lID0gcmFjdGl2ZS5jb21wb25lbnQubmFtZSkpIHtcbiAgXHRcdFx0XHRcdFx0bWVzc2FnZSA9IFwiPFwiICsgX25hbWUgKyBcIj4gXCIgKyBtZXNzYWdlO1xuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHR2YXIgbm9kZSA9IHVuZGVmaW5lZDtcbiAgXHRcdFx0XHRcdGlmIChub2RlID0gb3B0aW9ucy5ub2RlIHx8IHJhY3RpdmUuZnJhZ21lbnQgJiYgcmFjdGl2ZS5mcmFnbWVudC5yZW5kZXJlZCAmJiByYWN0aXZlLmZpbmQoXCIqXCIpKSB7XG4gIFx0XHRcdFx0XHRcdGFyZ3MucHVzaChub2RlKTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgW1wiJWNSYWN0aXZlLmpzOiAlY1wiICsgbWVzc2FnZSwgXCJjb2xvcjogcmdiKDExNCwgMTU3LCA1Mik7XCIsIFwiY29sb3I6IHJnYig4NSwgODUsIDg1KTtcIl0uY29uY2F0KGFyZ3MpKTtcbiAgXHRcdH07XG5cbiAgXHRcdGxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0Y29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgXHRcdH07XG4gIFx0fSkoKTtcbiAgfSBlbHNlIHtcbiAgXHRwcmludFdhcm5pbmcgPSBsb2cgPSB3ZWxjb21lID0gbm9vcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdChtZXNzYWdlLCBhcmdzKSB7XG4gIFx0cmV0dXJuIG1lc3NhZ2UucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIGFyZ3Muc2hpZnQoKTtcbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZhdGFsKG1lc3NhZ2UpIHtcbiAgXHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgXHRcdGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICBcdH1cblxuICBcdG1lc3NhZ2UgPSBmb3JtYXQobWVzc2FnZSwgYXJncyk7XG4gIFx0dGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gbG9nSWZEZWJ1ZygpIHtcbiAgXHRpZiAoX1JhY3RpdmUuREVCVUcpIHtcbiAgXHRcdGxvZy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4obWVzc2FnZSkge1xuICBcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICBcdFx0YXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIFx0fVxuXG4gIFx0bWVzc2FnZSA9IGZvcm1hdChtZXNzYWdlLCBhcmdzKTtcbiAgXHRwcmludFdhcm5pbmcobWVzc2FnZSwgYXJncyk7XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuT25jZShtZXNzYWdlKSB7XG4gIFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gIFx0XHRhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgXHR9XG5cbiAgXHRtZXNzYWdlID0gZm9ybWF0KG1lc3NhZ2UsIGFyZ3MpO1xuXG4gIFx0aWYgKGFscmVhZHlXYXJuZWRbbWVzc2FnZV0pIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRhbHJlYWR5V2FybmVkW21lc3NhZ2VdID0gdHJ1ZTtcbiAgXHRwcmludFdhcm5pbmcobWVzc2FnZSwgYXJncyk7XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuSWZEZWJ1ZygpIHtcbiAgXHRpZiAoX1JhY3RpdmUuREVCVUcpIHtcbiAgXHRcdHdhcm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuT25jZUlmRGVidWcoKSB7XG4gIFx0aWYgKF9SYWN0aXZlLkRFQlVHKSB7XG4gIFx0XHR3YXJuT25jZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICBcdH1cbiAgfVxuXG4gIC8vIEVycm9yIG1lc3NhZ2VzIHRoYXQgYXJlIHVzZWQgKG9yIGNvdWxkIGJlKSBpbiBtdWx0aXBsZSBwbGFjZXNcbiAgdmFyIGJhZEFyZ3VtZW50cyA9IFwiQmFkIGFyZ3VtZW50c1wiO1xuICB2YXIgbm9SZWdpc3RyeUZ1bmN0aW9uUmV0dXJuID0gXCJBIGZ1bmN0aW9uIHdhcyBzcGVjaWZpZWQgZm9yIFxcXCIlc1xcXCIgJXMsIGJ1dCBubyAlcyB3YXMgcmV0dXJuZWRcIjtcbiAgdmFyIG1pc3NpbmdQbHVnaW4gPSBmdW5jdGlvbiAobmFtZSwgdHlwZSkge1xuICAgIHJldHVybiBcIk1pc3NpbmcgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBcIiArIHR5cGUgKyBcIiBwbHVnaW4uIFlvdSBtYXkgbmVlZCB0byBkb3dubG9hZCBhIHBsdWdpbiB2aWEgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3QvcGx1Z2lucyNcIiArIHR5cGUgKyBcInNcIjtcbiAgfTtcblxuICBmdW5jdGlvbiBmaW5kSW5WaWV3SGllcmFyY2h5KHJlZ2lzdHJ5TmFtZSwgcmFjdGl2ZSwgbmFtZSkge1xuICBcdHZhciBpbnN0YW5jZSA9IGZpbmRJbnN0YW5jZShyZWdpc3RyeU5hbWUsIHJhY3RpdmUsIG5hbWUpO1xuICBcdHJldHVybiBpbnN0YW5jZSA/IGluc3RhbmNlW3JlZ2lzdHJ5TmFtZV1bbmFtZV0gOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEluc3RhbmNlKHJlZ2lzdHJ5TmFtZSwgcmFjdGl2ZSwgbmFtZSkge1xuICBcdHdoaWxlIChyYWN0aXZlKSB7XG4gIFx0XHRpZiAobmFtZSBpbiByYWN0aXZlW3JlZ2lzdHJ5TmFtZV0pIHtcbiAgXHRcdFx0cmV0dXJuIHJhY3RpdmU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChyYWN0aXZlLmlzb2xhdGVkKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyYWN0aXZlID0gcmFjdGl2ZS5wYXJlbnQ7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGludGVycG9sYXRlID0gZnVuY3Rpb24gKGZyb20sIHRvLCByYWN0aXZlLCB0eXBlKSB7XG4gIFx0aWYgKGZyb20gPT09IHRvKSB7XG4gIFx0XHRyZXR1cm4gc25hcCh0byk7XG4gIFx0fVxuXG4gIFx0aWYgKHR5cGUpIHtcblxuICBcdFx0dmFyIGludGVycG9sID0gZmluZEluVmlld0hpZXJhcmNoeShcImludGVycG9sYXRvcnNcIiwgcmFjdGl2ZSwgdHlwZSk7XG4gIFx0XHRpZiAoaW50ZXJwb2wpIHtcbiAgXHRcdFx0cmV0dXJuIGludGVycG9sKGZyb20sIHRvKSB8fCBzbmFwKHRvKTtcbiAgXHRcdH1cblxuICBcdFx0ZmF0YWwobWlzc2luZ1BsdWdpbih0eXBlLCBcImludGVycG9sYXRvclwiKSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHN0YXRpY19pbnRlcnBvbGF0b3JzLm51bWJlcihmcm9tLCB0bykgfHwgc3RhdGljX2ludGVycG9sYXRvcnMuYXJyYXkoZnJvbSwgdG8pIHx8IHN0YXRpY19pbnRlcnBvbGF0b3JzLm9iamVjdChmcm9tLCB0bykgfHwgc25hcCh0byk7XG4gIH07XG5cbiAgdmFyIHNoYXJlZF9pbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlO1xuXG4gIGZ1bmN0aW9uIHNuYXAodG8pIHtcbiAgXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRvO1xuICBcdH07XG4gIH1cblxuICB2YXIgaW50ZXJwb2xhdG9ycyA9IHtcbiAgXHRudW1iZXI6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICBcdFx0dmFyIGRlbHRhO1xuXG4gIFx0XHRpZiAoIWlzX19pc051bWVyaWMoZnJvbSkgfHwgIWlzX19pc051bWVyaWModG8pKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRmcm9tID0gK2Zyb207XG4gIFx0XHR0byA9ICt0bztcblxuICBcdFx0ZGVsdGEgPSB0byAtIGZyb207XG5cbiAgXHRcdGlmICghZGVsdGEpIHtcbiAgXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRyZXR1cm4gZnJvbTtcbiAgXHRcdFx0fTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRcdHJldHVybiBmcm9tICsgdCAqIGRlbHRhO1xuICBcdFx0fTtcbiAgXHR9LFxuXG4gIFx0YXJyYXk6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICBcdFx0dmFyIGludGVybWVkaWF0ZSwgaW50ZXJwb2xhdG9ycywgbGVuLCBpO1xuXG4gIFx0XHRpZiAoIWlzQXJyYXkoZnJvbSkgfHwgIWlzQXJyYXkodG8pKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRpbnRlcm1lZGlhdGUgPSBbXTtcbiAgXHRcdGludGVycG9sYXRvcnMgPSBbXTtcblxuICBcdFx0aSA9IGxlbiA9IE1hdGgubWluKGZyb20ubGVuZ3RoLCB0by5sZW5ndGgpO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRpbnRlcnBvbGF0b3JzW2ldID0gc2hhcmVkX2ludGVycG9sYXRlKGZyb21baV0sIHRvW2ldKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gc3VycGx1cyB2YWx1ZXMgLSBkb24ndCBpbnRlcnBvbGF0ZSwgYnV0IGRvbid0IGV4Y2x1ZGUgdGhlbSBlaXRoZXJcbiAgXHRcdGZvciAoaSA9IGxlbjsgaSA8IGZyb20ubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdFx0aW50ZXJtZWRpYXRlW2ldID0gZnJvbVtpXTtcbiAgXHRcdH1cblxuICBcdFx0Zm9yIChpID0gbGVuOyBpIDwgdG8ubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdFx0aW50ZXJtZWRpYXRlW2ldID0gdG9baV07XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBmdW5jdGlvbiAodCkge1xuICBcdFx0XHR2YXIgaSA9IGxlbjtcblxuICBcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0aW50ZXJtZWRpYXRlW2ldID0gaW50ZXJwb2xhdG9yc1tpXSh0KTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBpbnRlcm1lZGlhdGU7XG4gIFx0XHR9O1xuICBcdH0sXG5cbiAgXHRvYmplY3Q6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICBcdFx0dmFyIHByb3BlcnRpZXMsIGxlbiwgaW50ZXJwb2xhdG9ycywgaW50ZXJtZWRpYXRlLCBwcm9wO1xuXG4gIFx0XHRpZiAoIWlzT2JqZWN0KGZyb20pIHx8ICFpc09iamVjdCh0bykpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHByb3BlcnRpZXMgPSBbXTtcbiAgXHRcdGludGVybWVkaWF0ZSA9IHt9O1xuICBcdFx0aW50ZXJwb2xhdG9ycyA9IHt9O1xuXG4gIFx0XHRmb3IgKHByb3AgaW4gZnJvbSkge1xuICBcdFx0XHRpZiAoaGFzT3duLmNhbGwoZnJvbSwgcHJvcCkpIHtcbiAgXHRcdFx0XHRpZiAoaGFzT3duLmNhbGwodG8sIHByb3ApKSB7XG4gIFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG4gIFx0XHRcdFx0XHRpbnRlcnBvbGF0b3JzW3Byb3BdID0gc2hhcmVkX2ludGVycG9sYXRlKGZyb21bcHJvcF0sIHRvW3Byb3BdKTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0aW50ZXJtZWRpYXRlW3Byb3BdID0gZnJvbVtwcm9wXTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Zm9yIChwcm9wIGluIHRvKSB7XG4gIFx0XHRcdGlmIChoYXNPd24uY2FsbCh0bywgcHJvcCkgJiYgIWhhc093bi5jYWxsKGZyb20sIHByb3ApKSB7XG4gIFx0XHRcdFx0aW50ZXJtZWRpYXRlW3Byb3BdID0gdG9bcHJvcF07XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0bGVuID0gcHJvcGVydGllcy5sZW5ndGg7XG5cbiAgXHRcdHJldHVybiBmdW5jdGlvbiAodCkge1xuICBcdFx0XHR2YXIgaSA9IGxlbixcbiAgXHRcdFx0ICAgIHByb3A7XG5cbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdHByb3AgPSBwcm9wZXJ0aWVzW2ldO1xuXG4gIFx0XHRcdFx0aW50ZXJtZWRpYXRlW3Byb3BdID0gaW50ZXJwb2xhdG9yc1twcm9wXSh0KTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBpbnRlcm1lZGlhdGU7XG4gIFx0XHR9O1xuICBcdH1cbiAgfTtcblxuICB2YXIgc3RhdGljX2ludGVycG9sYXRvcnMgPSBpbnRlcnBvbGF0b3JzO1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBrZXlwYXRoIHN1Y2ggYXMgJ2Zvby5iYXIuYmF6JywgYW5kIHJldHVybnNcbiAgLy8gYWxsIHRoZSB2YXJpYW50cyBvZiB0aGF0IGtleXBhdGggdGhhdCBpbmNsdWRlIGEgd2lsZGNhcmQgaW4gcGxhY2VcbiAgLy8gb2YgYSBrZXksIHN1Y2ggYXMgJ2Zvby5iYXIuKicsICdmb28uKi5iYXonLCAnZm9vLiouKicgYW5kIHNvIG9uLlxuICAvLyBUaGVzZSBhcmUgdGhlbiBjaGVja2VkIGFnYWluc3QgdGhlIGRlcGVuZGFudHMgbWFwIChyYWN0aXZlLnZpZXdtb2RlbC5kZXBzTWFwKVxuICAvLyB0byBzZWUgaWYgYW55IHBhdHRlcm4gb2JzZXJ2ZXJzIGFyZSBkb3duc3RyZWFtIG9mIG9uZSBvciBtb3JlIG9mXG4gIC8vIHRoZXNlIHdpbGRjYXJkIGtleXBhdGhzIChlLmcuICdmb28uYmFyLiouc3RhdHVzJylcbiAgdmFyIHV0aWxzX2dldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyA9IGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcztcblxuICB2YXIgc3Rhck1hcHMgPSB7fTtcbiAgZnVuY3Rpb24gZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzKGtleXBhdGgpIHtcbiAgXHR2YXIga2V5cywgc3Rhck1hcCwgbWFwcGVyLCBpLCByZXN1bHQsIHdpbGRjYXJkS2V5cGF0aDtcblxuICBcdGtleXMgPSBrZXlwYXRoLnNwbGl0KFwiLlwiKTtcbiAgXHRpZiAoIShzdGFyTWFwID0gc3Rhck1hcHNba2V5cy5sZW5ndGhdKSkge1xuICBcdFx0c3Rhck1hcCA9IGdldFN0YXJNYXAoa2V5cy5sZW5ndGgpO1xuICBcdH1cblxuICBcdHJlc3VsdCA9IFtdO1xuXG4gIFx0bWFwcGVyID0gZnVuY3Rpb24gKHN0YXIsIGkpIHtcbiAgXHRcdHJldHVybiBzdGFyID8gXCIqXCIgOiBrZXlzW2ldO1xuICBcdH07XG5cbiAgXHRpID0gc3Rhck1hcC5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0d2lsZGNhcmRLZXlwYXRoID0gc3Rhck1hcFtpXS5tYXAobWFwcGVyKS5qb2luKFwiLlwiKTtcblxuICBcdFx0aWYgKCFyZXN1bHQuaGFzT3duUHJvcGVydHkod2lsZGNhcmRLZXlwYXRoKSkge1xuICBcdFx0XHRyZXN1bHQucHVzaCh3aWxkY2FyZEtleXBhdGgpO1xuICBcdFx0XHRyZXN1bHRbd2lsZGNhcmRLZXlwYXRoXSA9IHRydWU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbGwgdGhlIHBvc3NpYmxlIHRydWUvZmFsc2UgY29tYmluYXRpb25zIGZvclxuICAvLyBhIGdpdmVuIG51bWJlciAtIGUuZy4gZm9yIHR3bywgdGhlIHBvc3NpYmxlIGNvbWJpbmF0aW9ucyBhcmVcbiAgLy8gWyB0cnVlLCB0cnVlIF0sIFsgdHJ1ZSwgZmFsc2UgXSwgWyBmYWxzZSwgdHJ1ZSBdLCBbIGZhbHNlLCBmYWxzZSBdLlxuICAvLyBJdCBkb2VzIHNvIGJ5IGdldHRpbmcgYWxsIHRoZSBiaW5hcnkgdmFsdWVzIGJldHdlZW4gMCBhbmQgZS5nLiAxMVxuICBmdW5jdGlvbiBnZXRTdGFyTWFwKG51bSkge1xuICBcdHZhciBvbmVzID0gXCJcIixcbiAgXHQgICAgbWF4LFxuICBcdCAgICBiaW5hcnksXG4gIFx0ICAgIHN0YXJNYXAsXG4gIFx0ICAgIG1hcHBlcixcbiAgXHQgICAgaSxcbiAgXHQgICAgaixcbiAgXHQgICAgbCxcbiAgXHQgICAgbWFwO1xuXG4gIFx0aWYgKCFzdGFyTWFwc1tudW1dKSB7XG4gIFx0XHRzdGFyTWFwID0gW107XG5cbiAgXHRcdHdoaWxlIChvbmVzLmxlbmd0aCA8IG51bSkge1xuICBcdFx0XHRvbmVzICs9IDE7XG4gIFx0XHR9XG5cbiAgXHRcdG1heCA9IHBhcnNlSW50KG9uZXMsIDIpO1xuXG4gIFx0XHRtYXBwZXIgPSBmdW5jdGlvbiAoZGlnaXQpIHtcbiAgXHRcdFx0cmV0dXJuIGRpZ2l0ID09PSBcIjFcIjtcbiAgXHRcdH07XG5cbiAgXHRcdGZvciAoaSA9IDA7IGkgPD0gbWF4OyBpICs9IDEpIHtcbiAgXHRcdFx0YmluYXJ5ID0gaS50b1N0cmluZygyKTtcbiAgXHRcdFx0d2hpbGUgKGJpbmFyeS5sZW5ndGggPCBudW0pIHtcbiAgXHRcdFx0XHRiaW5hcnkgPSBcIjBcIiArIGJpbmFyeTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdG1hcCA9IFtdO1xuICBcdFx0XHRsID0gYmluYXJ5Lmxlbmd0aDtcbiAgXHRcdFx0Zm9yIChqID0gMDsgaiA8IGw7IGorKykge1xuICBcdFx0XHRcdG1hcC5wdXNoKG1hcHBlcihiaW5hcnlbal0pKTtcbiAgXHRcdFx0fVxuICBcdFx0XHRzdGFyTWFwW2ldID0gbWFwO1xuICBcdFx0fVxuXG4gIFx0XHRzdGFyTWFwc1tudW1dID0gc3Rhck1hcDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc3Rhck1hcHNbbnVtXTtcbiAgfVxuXG4gIHZhciByZWZQYXR0ZXJuID0gL1xcW1xccyooXFwqfFswLTldfFsxLTldWzAtOV0rKVxccypcXF0vZztcbiAgdmFyIHBhdHRlcm5QYXR0ZXJuID0gL1xcKi87XG4gIHZhciBrZXlwYXRoQ2FjaGUgPSB7fTtcblxuICB2YXIgS2V5cGF0aCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgXHR2YXIga2V5cyA9IHN0ci5zcGxpdChcIi5cIik7XG5cbiAgXHR0aGlzLnN0ciA9IHN0cjtcblxuICBcdGlmIChzdHJbMF0gPT09IFwiQFwiKSB7XG4gIFx0XHR0aGlzLmlzU3BlY2lhbCA9IHRydWU7XG4gIFx0XHR0aGlzLnZhbHVlID0gZGVjb2RlS2V5cGF0aChzdHIpO1xuICBcdH1cblxuICBcdHRoaXMuZmlyc3RLZXkgPSBrZXlzWzBdO1xuICBcdHRoaXMubGFzdEtleSA9IGtleXMucG9wKCk7XG5cbiAgXHR0aGlzLmlzUGF0dGVybiA9IHBhdHRlcm5QYXR0ZXJuLnRlc3Qoc3RyKTtcblxuICBcdHRoaXMucGFyZW50ID0gc3RyID09PSBcIlwiID8gbnVsbCA6IGdldEtleXBhdGgoa2V5cy5qb2luKFwiLlwiKSk7XG4gIFx0dGhpcy5pc1Jvb3QgPSAhc3RyO1xuICB9O1xuXG4gIEtleXBhdGgucHJvdG90eXBlID0ge1xuICBcdGVxdWFsc09yU3RhcnRzV2l0aDogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHJldHVybiBrZXlwYXRoID09PSB0aGlzIHx8IHRoaXMuc3RhcnRzV2l0aChrZXlwYXRoKTtcbiAgXHR9LFxuXG4gIFx0am9pbjogZnVuY3Rpb24gKHN0cikge1xuICBcdFx0cmV0dXJuIGdldEtleXBhdGgodGhpcy5pc1Jvb3QgPyBTdHJpbmcoc3RyKSA6IHRoaXMuc3RyICsgXCIuXCIgKyBzdHIpO1xuICBcdH0sXG5cbiAgXHRyZXBsYWNlOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0aWYgKHRoaXMgPT09IG9sZEtleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuIG5ld0tleXBhdGg7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLnN0YXJ0c1dpdGgob2xkS2V5cGF0aCkpIHtcbiAgXHRcdFx0cmV0dXJuIG5ld0tleXBhdGggPT09IG51bGwgPyBuZXdLZXlwYXRoIDogZ2V0S2V5cGF0aCh0aGlzLnN0ci5yZXBsYWNlKG9sZEtleXBhdGguc3RyICsgXCIuXCIsIG5ld0tleXBhdGguc3RyICsgXCIuXCIpKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0c3RhcnRzV2l0aDogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdGlmICgha2V5cGF0aCkge1xuICBcdFx0XHQvLyBUT0RPIHVuZGVyIHdoYXQgY2lyY3Vtc3RhbmNlcyBkb2VzIHRoaXMgaGFwcGVuP1xuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBrZXlwYXRoICYmIHRoaXMuc3RyLnN1YnN0cigwLCBrZXlwYXRoLnN0ci5sZW5ndGggKyAxKSA9PT0ga2V5cGF0aC5zdHIgKyBcIi5cIjtcbiAgXHR9LFxuXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkJhZCBjb2VyY2lvblwiKTtcbiAgXHR9LFxuXG4gIFx0dmFsdWVPZjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQmFkIGNvZXJjaW9uXCIpO1xuICBcdH0sXG5cbiAgXHR3aWxkY2FyZE1hdGNoZXM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl93aWxkY2FyZE1hdGNoZXMgfHwgKHRoaXMuX3dpbGRjYXJkTWF0Y2hlcyA9IHV0aWxzX2dldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyh0aGlzLnN0cikpO1xuICBcdH1cbiAgfTtcbiAgZnVuY3Rpb24gYXNzaWduTmV3S2V5cGF0aCh0YXJnZXQsIHByb3BlcnR5LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0dmFyIGV4aXN0aW5nS2V5cGF0aCA9IHRhcmdldFtwcm9wZXJ0eV07XG5cbiAgXHRpZiAoZXhpc3RpbmdLZXlwYXRoICYmIChleGlzdGluZ0tleXBhdGguZXF1YWxzT3JTdGFydHNXaXRoKG5ld0tleXBhdGgpIHx8ICFleGlzdGluZ0tleXBhdGguZXF1YWxzT3JTdGFydHNXaXRoKG9sZEtleXBhdGgpKSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHRhcmdldFtwcm9wZXJ0eV0gPSBleGlzdGluZ0tleXBhdGggPyBleGlzdGluZ0tleXBhdGgucmVwbGFjZShvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSA6IG5ld0tleXBhdGg7XG4gIFx0cmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGVLZXlwYXRoKGtleXBhdGgpIHtcbiAgXHR2YXIgdmFsdWUgPSBrZXlwYXRoLnNsaWNlKDIpO1xuXG4gIFx0aWYgKGtleXBhdGhbMV0gPT09IFwiaVwiKSB7XG4gIFx0XHRyZXR1cm4gaXNfX2lzTnVtZXJpYyh2YWx1ZSkgPyArdmFsdWUgOiB2YWx1ZTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cmV0dXJuIHZhbHVlO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEtleXBhdGgoc3RyKSB7XG4gIFx0aWYgKHN0ciA9PSBudWxsKSB7XG4gIFx0XHRyZXR1cm4gc3RyO1xuICBcdH1cblxuICBcdC8vIFRPRE8gaXQgKm1heSogYmUgd29ydGggaGF2aW5nIHR3byB2ZXJzaW9ucyBvZiB0aGlzIGZ1bmN0aW9uIC0gb25lIHdoZXJlXG4gIFx0Ly8ga2V5cGF0aENhY2hlIGluaGVyaXRzIGZyb20gbnVsbCwgYW5kIG9uZSBmb3IgSUU4LiBEZXBlbmRzIG9uIGhvd1xuICBcdC8vIG11Y2ggb2YgYW4gb3ZlcmhlYWQgaGFzT3duUHJvcGVydHkgaXMgLSBwcm9iYWJseSBuZWdsaWdpYmxlXG4gIFx0aWYgKCFrZXlwYXRoQ2FjaGUuaGFzT3duUHJvcGVydHkoc3RyKSkge1xuICBcdFx0a2V5cGF0aENhY2hlW3N0cl0gPSBuZXcgS2V5cGF0aChzdHIpO1xuICBcdH1cblxuICBcdHJldHVybiBrZXlwYXRoQ2FjaGVbc3RyXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1hdGNoaW5nS2V5cGF0aHMocmFjdGl2ZSwga2V5cGF0aCkge1xuICBcdHZhciBrZXlzLCBrZXksIG1hdGNoaW5nS2V5cGF0aHM7XG5cbiAgXHRrZXlzID0ga2V5cGF0aC5zdHIuc3BsaXQoXCIuXCIpO1xuICBcdG1hdGNoaW5nS2V5cGF0aHMgPSBbcm9vdEtleXBhdGhdO1xuXG4gIFx0d2hpbGUgKGtleSA9IGtleXMuc2hpZnQoKSkge1xuICBcdFx0aWYgKGtleSA9PT0gXCIqXCIpIHtcbiAgXHRcdFx0Ly8gZXhwYW5kIHRvIGZpbmQgYWxsIHZhbGlkIGNoaWxkIGtleXBhdGhzXG4gIFx0XHRcdG1hdGNoaW5nS2V5cGF0aHMgPSBtYXRjaGluZ0tleXBhdGhzLnJlZHVjZShleHBhbmQsIFtdKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGlmIChtYXRjaGluZ0tleXBhdGhzWzBdID09PSByb290S2V5cGF0aCkge1xuICBcdFx0XHRcdC8vIGZpcnN0IGtleVxuICBcdFx0XHRcdG1hdGNoaW5nS2V5cGF0aHNbMF0gPSBnZXRLZXlwYXRoKGtleSk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0bWF0Y2hpbmdLZXlwYXRocyA9IG1hdGNoaW5nS2V5cGF0aHMubWFwKGNvbmNhdGVuYXRlKGtleSkpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG1hdGNoaW5nS2V5cGF0aHM7XG5cbiAgXHRmdW5jdGlvbiBleHBhbmQobWF0Y2hpbmdLZXlwYXRocywga2V5cGF0aCkge1xuICBcdFx0dmFyIHdyYXBwZXIsIHZhbHVlLCBrZXlzO1xuXG4gIFx0XHRpZiAoa2V5cGF0aC5pc1Jvb3QpIHtcbiAgXHRcdFx0a2V5cyA9IFtdLmNvbmNhdChPYmplY3Qua2V5cyhyYWN0aXZlLnZpZXdtb2RlbC5kYXRhKSwgT2JqZWN0LmtleXMocmFjdGl2ZS52aWV3bW9kZWwubWFwcGluZ3MpLCBPYmplY3Qua2V5cyhyYWN0aXZlLnZpZXdtb2RlbC5jb21wdXRhdGlvbnMpKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHdyYXBwZXIgPSByYWN0aXZlLnZpZXdtb2RlbC53cmFwcGVkW2tleXBhdGguc3RyXTtcbiAgXHRcdFx0dmFsdWUgPSB3cmFwcGVyID8gd3JhcHBlci5nZXQoKSA6IHJhY3RpdmUudmlld21vZGVsLmdldChrZXlwYXRoKTtcblxuICBcdFx0XHRrZXlzID0gdmFsdWUgPyBPYmplY3Qua2V5cyh2YWx1ZSkgOiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoa2V5cykge1xuICBcdFx0XHRrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBcdFx0XHRcdGlmIChrZXkgIT09IFwiX3JhY3RpdmVcIiB8fCAhaXNBcnJheSh2YWx1ZSkpIHtcbiAgXHRcdFx0XHRcdG1hdGNoaW5nS2V5cGF0aHMucHVzaChrZXlwYXRoLmpvaW4oa2V5KSk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9KTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG1hdGNoaW5nS2V5cGF0aHM7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gY29uY2F0ZW5hdGUoa2V5KSB7XG4gIFx0cmV0dXJuIGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRyZXR1cm4ga2V5cGF0aC5qb2luKGtleSk7XG4gIFx0fTtcbiAgfVxuICBmdW5jdGlvbiBub3JtYWxpc2UocmVmKSB7XG4gIFx0cmV0dXJuIHJlZiA/IHJlZi5yZXBsYWNlKHJlZlBhdHRlcm4sIFwiLiQxXCIpIDogXCJcIjtcbiAgfVxuXG4gIHZhciByb290S2V5cGF0aCA9IGdldEtleXBhdGgoXCJcIik7XG5cbiAgdmFyIHNoYXJlZF9hZGQgPSBhZGQ7XG4gIHZhciBzaGFyZWRfYWRkX19lcnJvck1lc3NhZ2UgPSBcIkNhbm5vdCBhZGQgdG8gYSBub24tbnVtZXJpYyB2YWx1ZVwiO1xuICBmdW5jdGlvbiBhZGQocm9vdCwga2V5cGF0aCwgZCkge1xuICBcdGlmICh0eXBlb2Yga2V5cGF0aCAhPT0gXCJzdHJpbmdcIiB8fCAhaXNfX2lzTnVtZXJpYyhkKSkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQmFkIGFyZ3VtZW50c1wiKTtcbiAgXHR9XG5cbiAgXHR2YXIgdmFsdWUgPSB1bmRlZmluZWQsXG4gIFx0ICAgIGNoYW5nZXMgPSB1bmRlZmluZWQ7XG5cbiAgXHRpZiAoL1xcKi8udGVzdChrZXlwYXRoKSkge1xuICBcdFx0Y2hhbmdlcyA9IHt9O1xuXG4gIFx0XHRnZXRNYXRjaGluZ0tleXBhdGhzKHJvb3QsIGdldEtleXBhdGgobm9ybWFsaXNlKGtleXBhdGgpKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHR2YXIgdmFsdWUgPSByb290LnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRcdFx0aWYgKCFpc19faXNOdW1lcmljKHZhbHVlKSkge1xuICBcdFx0XHRcdHRocm93IG5ldyBFcnJvcihzaGFyZWRfYWRkX19lcnJvck1lc3NhZ2UpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Y2hhbmdlc1trZXlwYXRoLnN0cl0gPSB2YWx1ZSArIGQ7XG4gIFx0XHR9KTtcblxuICBcdFx0cmV0dXJuIHJvb3Quc2V0KGNoYW5nZXMpO1xuICBcdH1cblxuICBcdHZhbHVlID0gcm9vdC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRpZiAoIWlzX19pc051bWVyaWModmFsdWUpKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3Ioc2hhcmVkX2FkZF9fZXJyb3JNZXNzYWdlKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcm9vdC5zZXQoa2V5cGF0aCwgK3ZhbHVlICsgZCk7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2FkZCA9IFJhY3RpdmUkYWRkO1xuICBmdW5jdGlvbiBSYWN0aXZlJGFkZChrZXlwYXRoLCBkKSB7XG4gIFx0cmV0dXJuIHNoYXJlZF9hZGQodGhpcywga2V5cGF0aCwgZCA9PT0gdW5kZWZpbmVkID8gMSA6ICtkKTtcbiAgfVxuXG4gIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cbiAgLy8gSWYgd2luZG93IGRvZXNuJ3QgZXhpc3QsIHdlIGRvbid0IG5lZWQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgXHQvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvMTU3OTY3MVxuICBcdChmdW5jdGlvbiAodmVuZG9ycywgbGFzdFRpbWUsIHdpbmRvdykge1xuXG4gIFx0XHR2YXIgeCwgc2V0VGltZW91dDtcblxuICBcdFx0aWYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRmb3IgKHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCkge1xuICBcdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbeF0gKyBcIlJlcXVlc3RBbmltYXRpb25GcmFtZVwiXTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gIFx0XHRcdHNldFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dDtcblxuICBcdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIFx0XHRcdFx0dmFyIGN1cnJUaW1lLCB0aW1lVG9DYWxsLCBpZDtcblxuICBcdFx0XHRcdGN1cnJUaW1lID0gRGF0ZS5ub3coKTtcbiAgXHRcdFx0XHR0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xuICBcdFx0XHRcdGlkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHRjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xuICBcdFx0XHRcdH0sIHRpbWVUb0NhbGwpO1xuXG4gIFx0XHRcdFx0bGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG4gIFx0XHRcdFx0cmV0dXJuIGlkO1xuICBcdFx0XHR9O1xuICBcdFx0fVxuICBcdH0pKHZlbmRvcnMsIDAsIHdpbmRvdyk7XG5cbiAgXHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICB9XG5cbiAgdmFyIHJBRiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZTtcblxuICB2YXIgZ2V0VGltZTtcblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucGVyZm9ybWFuY2UgJiYgdHlwZW9mIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdGdldFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICBcdH07XG4gIH0gZWxzZSB7XG4gIFx0Z2V0VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBEYXRlLm5vdygpO1xuICBcdH07XG4gIH1cblxuICB2YXIgdXRpbHNfZ2V0VGltZSA9IGdldFRpbWU7XG5cbiAgdmFyIGRlcHJlY2F0aW9ucyA9IHtcbiAgXHRjb25zdHJ1Y3Q6IHtcbiAgXHRcdGRlcHJlY2F0ZWQ6IFwiYmVmb3JlSW5pdFwiLFxuICBcdFx0cmVwbGFjZW1lbnQ6IFwib25jb25zdHJ1Y3RcIlxuICBcdH0sXG4gIFx0cmVuZGVyOiB7XG4gIFx0XHRkZXByZWNhdGVkOiBcImluaXRcIixcbiAgXHRcdG1lc3NhZ2U6IFwiVGhlIFxcXCJpbml0XFxcIiBtZXRob2QgaGFzIGJlZW4gZGVwcmVjYXRlZCBcIiArIFwiYW5kIHdpbGwgbGlrZWx5IGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4gXCIgKyBcIllvdSBjYW4gZWl0aGVyIHVzZSB0aGUgXFxcIm9uaW5pdFxcXCIgbWV0aG9kIHdoaWNoIHdpbGwgZmlyZSBcIiArIFwib25seSBvbmNlIHByaW9yIHRvLCBhbmQgcmVnYXJkbGVzcyBvZiwgYW55IGV2ZW50dWFsIHJhY3RpdmUgXCIgKyBcImluc3RhbmNlIGJlaW5nIHJlbmRlcmVkLCBvciBpZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIFwiICsgXCJyZW5kZXJlZCBET00sIHVzZSBcXFwib25yZW5kZXJcXFwiIGluc3RlYWQuIFwiICsgXCJTZWUgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3QvbWlncmF0aW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiXG4gIFx0fSxcbiAgXHRjb21wbGV0ZToge1xuICBcdFx0ZGVwcmVjYXRlZDogXCJjb21wbGV0ZVwiLFxuICBcdFx0cmVwbGFjZW1lbnQ6IFwib25jb21wbGV0ZVwiXG4gIFx0fVxuICB9O1xuXG4gIGZ1bmN0aW9uIEhvb2soZXZlbnQpIHtcbiAgXHR0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gIFx0dGhpcy5tZXRob2QgPSBcIm9uXCIgKyBldmVudDtcbiAgXHR0aGlzLmRlcHJlY2F0ZSA9IGRlcHJlY2F0aW9uc1tldmVudF07XG4gIH1cblxuICBIb29rLnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24gKHJhY3RpdmUsIGFyZykge1xuICBcdGZ1bmN0aW9uIGNhbGwobWV0aG9kKSB7XG4gIFx0XHRpZiAocmFjdGl2ZVttZXRob2RdKSB7XG4gIFx0XHRcdGFyZyA/IHJhY3RpdmVbbWV0aG9kXShhcmcpIDogcmFjdGl2ZVttZXRob2RdKCk7XG4gIFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGNhbGwodGhpcy5tZXRob2QpO1xuXG4gIFx0aWYgKCFyYWN0aXZlW3RoaXMubWV0aG9kXSAmJiB0aGlzLmRlcHJlY2F0ZSAmJiBjYWxsKHRoaXMuZGVwcmVjYXRlLmRlcHJlY2F0ZWQpKSB7XG4gIFx0XHRpZiAodGhpcy5kZXByZWNhdGUubWVzc2FnZSkge1xuICBcdFx0XHR3YXJuSWZEZWJ1Zyh0aGlzLmRlcHJlY2F0ZS5tZXNzYWdlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHdhcm5JZkRlYnVnKFwiVGhlIG1ldGhvZCBcXFwiJXNcXFwiIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgXFxcIiVzXFxcIiBhbmQgd2lsbCBsaWtlbHkgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiBTZWUgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3QvbWlncmF0aW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiLCB0aGlzLmRlcHJlY2F0ZS5kZXByZWNhdGVkLCB0aGlzLmRlcHJlY2F0ZS5yZXBsYWNlbWVudCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0YXJnID8gcmFjdGl2ZS5maXJlKHRoaXMuZXZlbnQsIGFyZykgOiByYWN0aXZlLmZpcmUodGhpcy5ldmVudCk7XG4gIH07XG5cbiAgdmFyIGhvb2tzX0hvb2sgPSBIb29rO1xuXG4gIGZ1bmN0aW9uIGFkZFRvQXJyYXkoYXJyYXksIHZhbHVlKSB7XG4gIFx0dmFyIGluZGV4ID0gYXJyYXkuaW5kZXhPZih2YWx1ZSk7XG5cbiAgXHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRhcnJheS5wdXNoKHZhbHVlKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBhcnJheUNvbnRhaW5zKGFycmF5LCB2YWx1ZSkge1xuICBcdGZvciAodmFyIGkgPSAwLCBjID0gYXJyYXkubGVuZ3RoOyBpIDwgYzsgaSsrKSB7XG4gIFx0XHRpZiAoYXJyYXlbaV0gPT0gdmFsdWUpIHtcbiAgXHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlDb250ZW50c01hdGNoKGEsIGIpIHtcbiAgXHR2YXIgaTtcblxuICBcdGlmICghaXNBcnJheShhKSB8fCAhaXNBcnJheShiKSkge1xuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH1cblxuICBcdGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgXHRcdHJldHVybiBmYWxzZTtcbiAgXHR9XG5cbiAgXHRpID0gYS5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5zdXJlQXJyYXkoeCkge1xuICBcdGlmICh0eXBlb2YgeCA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0cmV0dXJuIFt4XTtcbiAgXHR9XG5cbiAgXHRpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRyZXR1cm4gW107XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHg7XG4gIH1cblxuICBmdW5jdGlvbiBsYXN0SXRlbShhcnJheSkge1xuICBcdHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUZyb21BcnJheShhcnJheSwgbWVtYmVyKSB7XG4gIFx0dmFyIGluZGV4ID0gYXJyYXkuaW5kZXhPZihtZW1iZXIpO1xuXG4gIFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0YXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiB0b0FycmF5KGFycmF5TGlrZSkge1xuICBcdHZhciBhcnJheSA9IFtdLFxuICBcdCAgICBpID0gYXJyYXlMaWtlLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRhcnJheVtpXSA9IGFycmF5TGlrZVtpXTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gYXJyYXk7XG4gIH1cblxuICB2YXIgX1Byb21pc2UsXG4gICAgICBQRU5ESU5HID0ge30sXG4gICAgICBGVUxGSUxMRUQgPSB7fSxcbiAgICAgIFJFSkVDVEVEID0ge307XG5cbiAgaWYgKHR5cGVvZiBQcm9taXNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHQvLyB1c2UgbmF0aXZlIFByb21pc2VcbiAgXHRfUHJvbWlzZSA9IFByb21pc2U7XG4gIH0gZWxzZSB7XG4gIFx0X1Byb21pc2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgXHRcdHZhciBmdWxmaWxsZWRIYW5kbGVycyA9IFtdLFxuICBcdFx0ICAgIHJlamVjdGVkSGFuZGxlcnMgPSBbXSxcbiAgXHRcdCAgICBzdGF0ZSA9IFBFTkRJTkcsXG4gIFx0XHQgICAgcmVzdWx0LFxuICBcdFx0ICAgIGRpc3BhdGNoSGFuZGxlcnMsXG4gIFx0XHQgICAgbWFrZVJlc29sdmVyLFxuICBcdFx0ICAgIGZ1bGZpbCxcbiAgXHRcdCAgICByZWplY3QsXG4gIFx0XHQgICAgcHJvbWlzZTtcblxuICBcdFx0bWFrZVJlc29sdmVyID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gIFx0XHRcdHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdFx0XHRpZiAoc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgXHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRyZXN1bHQgPSB2YWx1ZTtcbiAgXHRcdFx0XHRzdGF0ZSA9IG5ld1N0YXRlO1xuXG4gIFx0XHRcdFx0ZGlzcGF0Y2hIYW5kbGVycyA9IG1ha2VEaXNwYXRjaGVyKHN0YXRlID09PSBGVUxGSUxMRUQgPyBmdWxmaWxsZWRIYW5kbGVycyA6IHJlamVjdGVkSGFuZGxlcnMsIHJlc3VsdCk7XG5cbiAgXHRcdFx0XHQvLyBkaXNwYXRjaCBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBoYW5kbGVycyBhc3luY2hyb25vdXNseVxuICBcdFx0XHRcdHdhaXQoZGlzcGF0Y2hIYW5kbGVycyk7XG4gIFx0XHRcdH07XG4gIFx0XHR9O1xuXG4gIFx0XHRmdWxmaWwgPSBtYWtlUmVzb2x2ZXIoRlVMRklMTEVEKTtcbiAgXHRcdHJlamVjdCA9IG1ha2VSZXNvbHZlcihSRUpFQ1RFRCk7XG5cbiAgXHRcdHRyeSB7XG4gIFx0XHRcdGNhbGxiYWNrKGZ1bGZpbCwgcmVqZWN0KTtcbiAgXHRcdH0gY2F0Y2ggKGVycikge1xuICBcdFx0XHRyZWplY3QoZXJyKTtcbiAgXHRcdH1cblxuICBcdFx0cHJvbWlzZSA9IHtcbiAgXHRcdFx0Ly8gYHRoZW4oKWAgcmV0dXJucyBhIFByb21pc2UgLSAyLjIuN1xuICBcdFx0XHR0aGVuOiBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgXHRcdFx0XHR2YXIgcHJvbWlzZTIgPSBuZXcgX1Byb21pc2UoZnVuY3Rpb24gKGZ1bGZpbCwgcmVqZWN0KSB7XG5cbiAgXHRcdFx0XHRcdHZhciBwcm9jZXNzUmVzb2x1dGlvbkhhbmRsZXIgPSBmdW5jdGlvbiAoaGFuZGxlciwgaGFuZGxlcnMsIGZvcndhcmQpIHtcblxuICBcdFx0XHRcdFx0XHQvLyAyLjIuMS4xXG4gIFx0XHRcdFx0XHRcdGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdFx0XHRcdFx0aGFuZGxlcnMucHVzaChmdW5jdGlvbiAocDFyZXN1bHQpIHtcbiAgXHRcdFx0XHRcdFx0XHRcdHZhciB4O1xuXG4gIFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuICBcdFx0XHRcdFx0XHRcdFx0XHR4ID0gaGFuZGxlcihwMXJlc3VsdCk7XG4gIFx0XHRcdFx0XHRcdFx0XHRcdHV0aWxzX1Byb21pc2VfX3Jlc29sdmUocHJvbWlzZTIsIHgsIGZ1bGZpbCwgcmVqZWN0KTtcbiAgXHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuICBcdFx0XHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyKTtcbiAgXHRcdFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0XHQvLyBGb3J3YXJkIHRoZSByZXN1bHQgb2YgcHJvbWlzZTEgdG8gcHJvbWlzZTIsIGlmIHJlc29sdXRpb24gaGFuZGxlcnNcbiAgXHRcdFx0XHRcdFx0XHQvLyBhcmUgbm90IGdpdmVuXG4gIFx0XHRcdFx0XHRcdFx0aGFuZGxlcnMucHVzaChmb3J3YXJkKTtcbiAgXHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0fTtcblxuICBcdFx0XHRcdFx0Ly8gMi4yXG4gIFx0XHRcdFx0XHRwcm9jZXNzUmVzb2x1dGlvbkhhbmRsZXIob25GdWxmaWxsZWQsIGZ1bGZpbGxlZEhhbmRsZXJzLCBmdWxmaWwpO1xuICBcdFx0XHRcdFx0cHJvY2Vzc1Jlc29sdXRpb25IYW5kbGVyKG9uUmVqZWN0ZWQsIHJlamVjdGVkSGFuZGxlcnMsIHJlamVjdCk7XG5cbiAgXHRcdFx0XHRcdGlmIChzdGF0ZSAhPT0gUEVORElORykge1xuICBcdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJvbWlzZSBoYXMgcmVzb2x2ZWQgYWxyZWFkeSwgZGlzcGF0Y2ggdGhlIGFwcHJvcHJpYXRlIGhhbmRsZXJzIGFzeW5jaHJvbm91c2x5XG4gIFx0XHRcdFx0XHRcdHdhaXQoZGlzcGF0Y2hIYW5kbGVycyk7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fSk7XG5cbiAgXHRcdFx0XHRyZXR1cm4gcHJvbWlzZTI7XG4gIFx0XHRcdH1cbiAgXHRcdH07XG5cbiAgXHRcdHByb21pc2VbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG4gIFx0XHR9O1xuXG4gIFx0XHRyZXR1cm4gcHJvbWlzZTtcbiAgXHR9O1xuXG4gIFx0X1Byb21pc2UuYWxsID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gIFx0XHRyZXR1cm4gbmV3IF9Qcm9taXNlKGZ1bmN0aW9uIChmdWxmaWwsIHJlamVjdCkge1xuICBcdFx0XHR2YXIgcmVzdWx0ID0gW10sXG4gIFx0XHRcdCAgICBwZW5kaW5nLFxuICBcdFx0XHQgICAgaSxcbiAgXHRcdFx0ICAgIHByb2Nlc3NQcm9taXNlO1xuXG4gIFx0XHRcdGlmICghcHJvbWlzZXMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0ZnVsZmlsKHJlc3VsdCk7XG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cHJvY2Vzc1Byb21pc2UgPSBmdW5jdGlvbiAocHJvbWlzZSwgaSkge1xuICBcdFx0XHRcdGlmIChwcm9taXNlICYmIHR5cGVvZiBwcm9taXNlLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRcdFx0cHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0XHRcdFx0XHRyZXN1bHRbaV0gPSB2YWx1ZTtcbiAgXHRcdFx0XHRcdFx0LS1wZW5kaW5nIHx8IGZ1bGZpbChyZXN1bHQpO1xuICBcdFx0XHRcdFx0fSwgcmVqZWN0KTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0cmVzdWx0W2ldID0gcHJvbWlzZTtcbiAgXHRcdFx0XHRcdC0tcGVuZGluZyB8fCBmdWxmaWwocmVzdWx0KTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0cGVuZGluZyA9IGkgPSBwcm9taXNlcy5sZW5ndGg7XG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRwcm9jZXNzUHJvbWlzZShwcm9taXNlc1tpXSwgaSk7XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuICBcdH07XG5cbiAgXHRfUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHRyZXR1cm4gbmV3IF9Qcm9taXNlKGZ1bmN0aW9uIChmdWxmaWwpIHtcbiAgXHRcdFx0ZnVsZmlsKHZhbHVlKTtcbiAgXHRcdH0pO1xuICBcdH07XG5cbiAgXHRfUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gIFx0XHRyZXR1cm4gbmV3IF9Qcm9taXNlKGZ1bmN0aW9uIChmdWxmaWwsIHJlamVjdCkge1xuICBcdFx0XHRyZWplY3QocmVhc29uKTtcbiAgXHRcdH0pO1xuICBcdH07XG4gIH1cblxuICB2YXIgdXRpbHNfUHJvbWlzZSA9IF9Qcm9taXNlO1xuXG4gIC8vIFRPRE8gdXNlIE11dGF0aW9uT2JzZXJ2ZXJzIG9yIHNvbWV0aGluZyB0byBzaW11bGF0ZSBzZXRJbW1lZGlhdGVcbiAgZnVuY3Rpb24gd2FpdChjYWxsYmFjaykge1xuICBcdHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZURpc3BhdGNoZXIoaGFuZGxlcnMsIHJlc3VsdCkge1xuICBcdHJldHVybiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgaGFuZGxlcjtcblxuICBcdFx0d2hpbGUgKGhhbmRsZXIgPSBoYW5kbGVycy5zaGlmdCgpKSB7XG4gIFx0XHRcdGhhbmRsZXIocmVzdWx0KTtcbiAgXHRcdH1cbiAgXHR9O1xuICB9XG5cbiAgZnVuY3Rpb24gdXRpbHNfUHJvbWlzZV9fcmVzb2x2ZShwcm9taXNlLCB4LCBmdWxmaWwsIHJlamVjdCkge1xuICBcdC8vIFByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmVcbiAgXHR2YXIgdGhlbjtcblxuICBcdC8vIDIuMy4xXG4gIFx0aWYgKHggPT09IHByb21pc2UpIHtcbiAgXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHByb21pc2UncyBmdWxmaWxsbWVudCBoYW5kbGVyIGNhbm5vdCByZXR1cm4gdGhlIHNhbWUgcHJvbWlzZVwiKTtcbiAgXHR9XG5cbiAgXHQvLyAyLjMuMlxuICBcdGlmICh4IGluc3RhbmNlb2YgX1Byb21pc2UpIHtcbiAgXHRcdHgudGhlbihmdWxmaWwsIHJlamVjdCk7XG4gIFx0fVxuXG4gIFx0Ly8gMi4zLjNcbiAgXHRlbHNlIGlmICh4ICYmICh0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICBcdFx0dHJ5IHtcbiAgXHRcdFx0dGhlbiA9IHgudGhlbjsgLy8gMi4zLjMuMVxuICBcdFx0fSBjYXRjaCAoZSkge1xuICBcdFx0XHRyZWplY3QoZSk7IC8vIDIuMy4zLjJcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHQvLyAyLjMuMy4zXG4gIFx0XHRpZiAodHlwZW9mIHRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHR2YXIgY2FsbGVkLCByZXNvbHZlUHJvbWlzZSwgcmVqZWN0UHJvbWlzZTtcblxuICBcdFx0XHRyZXNvbHZlUHJvbWlzZSA9IGZ1bmN0aW9uICh5KSB7XG4gIFx0XHRcdFx0aWYgKGNhbGxlZCkge1xuICBcdFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0XHRjYWxsZWQgPSB0cnVlO1xuICBcdFx0XHRcdHV0aWxzX1Byb21pc2VfX3Jlc29sdmUocHJvbWlzZSwgeSwgZnVsZmlsLCByZWplY3QpO1xuICBcdFx0XHR9O1xuXG4gIFx0XHRcdHJlamVjdFByb21pc2UgPSBmdW5jdGlvbiAocikge1xuICBcdFx0XHRcdGlmIChjYWxsZWQpIHtcbiAgXHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcbiAgXHRcdFx0XHRyZWplY3Qocik7XG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0dHJ5IHtcbiAgXHRcdFx0XHR0aGVuLmNhbGwoeCwgcmVzb2x2ZVByb21pc2UsIHJlamVjdFByb21pc2UpO1xuICBcdFx0XHR9IGNhdGNoIChlKSB7XG4gIFx0XHRcdFx0aWYgKCFjYWxsZWQpIHtcbiAgXHRcdFx0XHRcdC8vIDIuMy4zLjMuNC4xXG4gIFx0XHRcdFx0XHRyZWplY3QoZSk7IC8vIDIuMy4zLjMuNC4yXG4gIFx0XHRcdFx0XHRjYWxsZWQgPSB0cnVlO1xuICBcdFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZnVsZmlsKHgpO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHRmdWxmaWwoeCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGdldElubmVyQ29udGV4dCA9IGZ1bmN0aW9uIChmcmFnbWVudCkge1xuICBcdGRvIHtcbiAgXHRcdGlmIChmcmFnbWVudC5jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmV0dXJuIGZyYWdtZW50LmNvbnRleHQ7XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQpO1xuXG4gIFx0cmV0dXJuIHJvb3RLZXlwYXRoO1xuICB9O1xuXG4gIHZhciBzaGFyZWRfcmVzb2x2ZVJlZiA9IHJlc29sdmVSZWY7XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVJlZihyYWN0aXZlLCByZWYsIGZyYWdtZW50KSB7XG4gIFx0dmFyIGtleXBhdGg7XG5cbiAgXHRyZWYgPSBub3JtYWxpc2UocmVmKTtcblxuICBcdC8vIElmIGEgcmVmZXJlbmNlIGJlZ2lucyAnfi8nLCBpdCdzIGEgdG9wLWxldmVsIHJlZmVyZW5jZVxuICBcdGlmIChyZWYuc3Vic3RyKDAsIDIpID09PSBcIn4vXCIpIHtcbiAgXHRcdGtleXBhdGggPSBnZXRLZXlwYXRoKHJlZi5zdWJzdHJpbmcoMikpO1xuICBcdFx0Y3JlYXRlTWFwcGluZ0lmTmVjZXNzYXJ5KHJhY3RpdmUsIGtleXBhdGguZmlyc3RLZXksIGZyYWdtZW50KTtcbiAgXHR9XG5cbiAgXHQvLyBJZiBhIHJlZmVyZW5jZSBiZWdpbnMgd2l0aCAnLicsIGl0J3MgZWl0aGVyIGEgcmVzdHJpY3RlZCByZWZlcmVuY2Ugb3JcbiAgXHQvLyBhbiBhbmNlc3RvciByZWZlcmVuY2UuLi5cbiAgXHRlbHNlIGlmIChyZWZbMF0gPT09IFwiLlwiKSB7XG4gIFx0XHRrZXlwYXRoID0gcmVzb2x2ZUFuY2VzdG9yUmVmKGdldElubmVyQ29udGV4dChmcmFnbWVudCksIHJlZik7XG5cbiAgXHRcdGlmIChrZXlwYXRoKSB7XG4gIFx0XHRcdGNyZWF0ZU1hcHBpbmdJZk5lY2Vzc2FyeShyYWN0aXZlLCBrZXlwYXRoLmZpcnN0S2V5LCBmcmFnbWVudCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gLi4ub3RoZXJ3aXNlIHdlIG5lZWQgdG8gZmlndXJlIG91dCB0aGUga2V5cGF0aCBiYXNlZCBvbiBjb250ZXh0XG4gIFx0ZWxzZSB7XG4gIFx0XHRrZXlwYXRoID0gcmVzb2x2ZUFtYmlndW91c1JlZmVyZW5jZShyYWN0aXZlLCBnZXRLZXlwYXRoKHJlZiksIGZyYWdtZW50KTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ga2V5cGF0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVBbmNlc3RvclJlZihiYXNlQ29udGV4dCwgcmVmKSB7XG4gIFx0dmFyIGNvbnRleHRLZXlzO1xuXG4gIFx0Ly8gVE9ETy4uLlxuICBcdGlmIChiYXNlQ29udGV4dCAhPSB1bmRlZmluZWQgJiYgdHlwZW9mIGJhc2VDb250ZXh0ICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRiYXNlQ29udGV4dCA9IGJhc2VDb250ZXh0LnN0cjtcbiAgXHR9XG5cbiAgXHQvLyB7ey59fSBtZWFucyAnY3VycmVudCBjb250ZXh0J1xuICBcdGlmIChyZWYgPT09IFwiLlwiKSByZXR1cm4gZ2V0S2V5cGF0aChiYXNlQ29udGV4dCk7XG5cbiAgXHRjb250ZXh0S2V5cyA9IGJhc2VDb250ZXh0ID8gYmFzZUNvbnRleHQuc3BsaXQoXCIuXCIpIDogW107XG5cbiAgXHQvLyBhbmNlc3RvciByZWZlcmVuY2VzIChzdGFydGluZyBcIi4uL1wiKSBnbyB1cCB0aGUgdHJlZVxuICBcdGlmIChyZWYuc3Vic3RyKDAsIDMpID09PSBcIi4uL1wiKSB7XG4gIFx0XHR3aGlsZSAocmVmLnN1YnN0cigwLCAzKSA9PT0gXCIuLi9cIikge1xuICBcdFx0XHRpZiAoIWNvbnRleHRLZXlzLmxlbmd0aCkge1xuICBcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIHJlZmVyZW5jZSAtIHRvbyBtYW55IFxcXCIuLi9cXFwiIHByZWZpeGVzXCIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Y29udGV4dEtleXMucG9wKCk7XG4gIFx0XHRcdHJlZiA9IHJlZi5zdWJzdHJpbmcoMyk7XG4gIFx0XHR9XG5cbiAgXHRcdGNvbnRleHRLZXlzLnB1c2gocmVmKTtcbiAgXHRcdHJldHVybiBnZXRLZXlwYXRoKGNvbnRleHRLZXlzLmpvaW4oXCIuXCIpKTtcbiAgXHR9XG5cbiAgXHQvLyBub3QgYW4gYW5jZXN0b3IgcmVmZXJlbmNlIC0gbXVzdCBiZSBhIHJlc3RyaWN0ZWQgcmVmZXJlbmNlIChwcmVwZW5kZWQgd2l0aCBcIi5cIiBvciBcIi4vXCIpXG4gIFx0aWYgKCFiYXNlQ29udGV4dCkge1xuICBcdFx0cmV0dXJuIGdldEtleXBhdGgocmVmLnJlcGxhY2UoL15cXC5cXC8/LywgXCJcIikpO1xuICBcdH1cblxuICBcdHJldHVybiBnZXRLZXlwYXRoKGJhc2VDb250ZXh0ICsgcmVmLnJlcGxhY2UoL15cXC5cXC8vLCBcIi5cIikpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUFtYmlndW91c1JlZmVyZW5jZShyYWN0aXZlLCByZWYsIGZyYWdtZW50LCBpc1BhcmVudExvb2t1cCkge1xuICBcdHZhciBjb250ZXh0LCBrZXksIHBhcmVudFZhbHVlLCBoYXNDb250ZXh0Q2hhaW4sIHBhcmVudEtleXBhdGg7XG5cbiAgXHRpZiAocmVmLmlzUm9vdCkge1xuICBcdFx0cmV0dXJuIHJlZjtcbiAgXHR9XG5cbiAgXHRrZXkgPSByZWYuZmlyc3RLZXk7XG5cbiAgXHR3aGlsZSAoZnJhZ21lbnQpIHtcbiAgXHRcdGNvbnRleHQgPSBmcmFnbWVudC5jb250ZXh0O1xuICBcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQ7XG5cbiAgXHRcdGlmICghY29udGV4dCkge1xuICBcdFx0XHRjb250aW51ZTtcbiAgXHRcdH1cblxuICBcdFx0aGFzQ29udGV4dENoYWluID0gdHJ1ZTtcbiAgXHRcdHBhcmVudFZhbHVlID0gcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KGNvbnRleHQpO1xuXG4gIFx0XHRpZiAocGFyZW50VmFsdWUgJiYgKHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgcGFyZW50VmFsdWUgPT09IFwiZnVuY3Rpb25cIikgJiYga2V5IGluIHBhcmVudFZhbHVlKSB7XG4gIFx0XHRcdHJldHVybiBjb250ZXh0LmpvaW4ocmVmLnN0cik7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gUm9vdC9jb21wdXRlZC9tYXBwZWQgcHJvcGVydHk/XG4gIFx0aWYgKGlzUm9vdFByb3BlcnR5KHJhY3RpdmUudmlld21vZGVsLCBrZXkpKSB7XG4gIFx0XHRyZXR1cm4gcmVmO1xuICBcdH1cblxuICBcdC8vIElmIHRoaXMgaXMgYW4gaW5saW5lIGNvbXBvbmVudCwgYW5kIGl0J3Mgbm90IGlzb2xhdGVkLCB3ZVxuICBcdC8vIGNhbiB0cnkgZ29pbmcgdXAgdGhlIHNjb3BlIGNoYWluXG4gIFx0aWYgKHJhY3RpdmUucGFyZW50ICYmICFyYWN0aXZlLmlzb2xhdGVkKSB7XG4gIFx0XHRoYXNDb250ZXh0Q2hhaW4gPSB0cnVlO1xuICBcdFx0ZnJhZ21lbnQgPSByYWN0aXZlLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcblxuICBcdFx0a2V5ID0gZ2V0S2V5cGF0aChrZXkpO1xuXG4gIFx0XHRpZiAocGFyZW50S2V5cGF0aCA9IHJlc29sdmVBbWJpZ3VvdXNSZWZlcmVuY2UocmFjdGl2ZS5wYXJlbnQsIGtleSwgZnJhZ21lbnQsIHRydWUpKSB7XG4gIFx0XHRcdC8vIFdlIG5lZWQgdG8gY3JlYXRlIGFuIGludGVyLWNvbXBvbmVudCBiaW5kaW5nXG4gIFx0XHRcdHJhY3RpdmUudmlld21vZGVsLm1hcChrZXksIHtcbiAgXHRcdFx0XHRvcmlnaW46IHJhY3RpdmUucGFyZW50LnZpZXdtb2RlbCxcbiAgXHRcdFx0XHRrZXlwYXRoOiBwYXJlbnRLZXlwYXRoXG4gIFx0XHRcdH0pO1xuXG4gIFx0XHRcdHJldHVybiByZWY7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gSWYgdGhlcmUncyBubyBjb250ZXh0IGNoYWluLCBhbmQgdGhlIGluc3RhbmNlIGlzIGVpdGhlciBhKSBpc29sYXRlZCBvclxuICBcdC8vIGIpIGFuIG9ycGhhbiwgdGhlbiB3ZSBrbm93IHRoYXQgdGhlIGtleXBhdGggaXMgaWRlbnRpY2FsIHRvIHRoZSByZWZlcmVuY2VcbiAgXHRpZiAoIWlzUGFyZW50TG9va3VwICYmICFoYXNDb250ZXh0Q2hhaW4pIHtcbiAgXHRcdC8vIHRoZSBkYXRhIG9iamVjdCBuZWVkcyB0byBoYXZlIGEgcHJvcGVydHkgYnkgdGhpcyBuYW1lLFxuICBcdFx0Ly8gdG8gcHJldmVudCBmdXR1cmUgZmFpbGVkIGxvb2t1cHNcbiAgXHRcdHJhY3RpdmUudmlld21vZGVsLnNldChyZWYsIHVuZGVmaW5lZCk7XG4gIFx0XHRyZXR1cm4gcmVmO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU1hcHBpbmdJZk5lY2Vzc2FyeShyYWN0aXZlLCBrZXkpIHtcbiAgXHR2YXIgcGFyZW50S2V5cGF0aDtcblxuICBcdGlmICghcmFjdGl2ZS5wYXJlbnQgfHwgcmFjdGl2ZS5pc29sYXRlZCB8fCBpc1Jvb3RQcm9wZXJ0eShyYWN0aXZlLnZpZXdtb2RlbCwga2V5KSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGtleSA9IGdldEtleXBhdGgoa2V5KTtcblxuICBcdGlmIChwYXJlbnRLZXlwYXRoID0gcmVzb2x2ZUFtYmlndW91c1JlZmVyZW5jZShyYWN0aXZlLnBhcmVudCwga2V5LCByYWN0aXZlLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudCwgdHJ1ZSkpIHtcbiAgXHRcdHJhY3RpdmUudmlld21vZGVsLm1hcChrZXksIHtcbiAgXHRcdFx0b3JpZ2luOiByYWN0aXZlLnBhcmVudC52aWV3bW9kZWwsXG4gIFx0XHRcdGtleXBhdGg6IHBhcmVudEtleXBhdGhcbiAgXHRcdH0pO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUm9vdFByb3BlcnR5KHZpZXdtb2RlbCwga2V5KSB7XG4gIFx0Ly8gc3BlY2lhbCBjYXNlIGZvciByZWZlcmVuY2UgdG8gcm9vdFxuICBcdHJldHVybiBrZXkgPT09IFwiXCIgfHwga2V5IGluIHZpZXdtb2RlbC5kYXRhIHx8IGtleSBpbiB2aWV3bW9kZWwuY29tcHV0YXRpb25zIHx8IGtleSBpbiB2aWV3bW9kZWwubWFwcGluZ3M7XG4gIH1cblxuICBmdW5jdGlvbiB0ZWFyZG93bih4KSB7XG4gICAgeC50ZWFyZG93bigpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWV0aG9kQ2FsbGVyc19fdW5iaW5kKHgpIHtcbiAgICB4LnVuYmluZCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWV0aG9kQ2FsbGVyc19fdW5yZW5kZXIoeCkge1xuICAgIHgudW5yZW5kZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCh4KSB7XG4gICAgeC5jYW5jZWwoKTtcbiAgfVxuXG4gIHZhciBUcmFuc2l0aW9uTWFuYWdlciA9IGZ1bmN0aW9uIChjYWxsYmFjaywgcGFyZW50KSB7XG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICBcdHRoaXMucGFyZW50ID0gcGFyZW50O1xuXG4gIFx0dGhpcy5pbnRyb3MgPSBbXTtcbiAgXHR0aGlzLm91dHJvcyA9IFtdO1xuXG4gIFx0dGhpcy5jaGlsZHJlbiA9IFtdO1xuICBcdHRoaXMudG90YWxDaGlsZHJlbiA9IHRoaXMub3V0cm9DaGlsZHJlbiA9IDA7XG5cbiAgXHR0aGlzLmRldGFjaFF1ZXVlID0gW107XG4gIFx0dGhpcy5kZWNvcmF0b3JRdWV1ZSA9IFtdO1xuICBcdHRoaXMub3V0cm9zQ29tcGxldGUgPSBmYWxzZTtcblxuICBcdGlmIChwYXJlbnQpIHtcbiAgXHRcdHBhcmVudC5hZGRDaGlsZCh0aGlzKTtcbiAgXHR9XG4gIH07XG5cbiAgVHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlID0ge1xuICBcdGFkZENoaWxkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgXHRcdHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG5cbiAgXHRcdHRoaXMudG90YWxDaGlsZHJlbiArPSAxO1xuICBcdFx0dGhpcy5vdXRyb0NoaWxkcmVuICs9IDE7XG4gIFx0fSxcblxuICBcdGRlY3JlbWVudE91dHJvczogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5vdXRyb0NoaWxkcmVuIC09IDE7XG4gIFx0XHRjaGVjayh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0ZGVjcmVtZW50VG90YWw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMudG90YWxDaGlsZHJlbiAtPSAxO1xuICBcdFx0Y2hlY2sodGhpcyk7XG4gIFx0fSxcblxuICBcdGFkZDogZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcbiAgXHRcdHZhciBsaXN0ID0gdHJhbnNpdGlvbi5pc0ludHJvID8gdGhpcy5pbnRyb3MgOiB0aGlzLm91dHJvcztcbiAgXHRcdGxpc3QucHVzaCh0cmFuc2l0aW9uKTtcbiAgXHR9LFxuXG4gIFx0YWRkRGVjb3JhdG9yOiBmdW5jdGlvbiAoZGVjb3JhdG9yKSB7XG4gIFx0XHR0aGlzLmRlY29yYXRvclF1ZXVlLnB1c2goZGVjb3JhdG9yKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlOiBmdW5jdGlvbiAodHJhbnNpdGlvbikge1xuICBcdFx0dmFyIGxpc3QgPSB0cmFuc2l0aW9uLmlzSW50cm8gPyB0aGlzLmludHJvcyA6IHRoaXMub3V0cm9zO1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KGxpc3QsIHRyYW5zaXRpb24pO1xuICBcdFx0Y2hlY2sodGhpcyk7XG4gIFx0fSxcblxuICBcdGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMucmVhZHkgPSB0cnVlO1xuICBcdFx0Y2hlY2sodGhpcyk7XG4gIFx0fSxcblxuICBcdGRldGFjaE5vZGVzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmRlY29yYXRvclF1ZXVlLmZvckVhY2godGVhcmRvd24pO1xuICBcdFx0dGhpcy5kZXRhY2hRdWV1ZS5mb3JFYWNoKGRldGFjaCk7XG4gIFx0XHR0aGlzLmNoaWxkcmVuLmZvckVhY2goZGV0YWNoTm9kZXMpO1xuICBcdH1cbiAgfTtcblxuICBmdW5jdGlvbiBkZXRhY2goZWxlbWVudCkge1xuICBcdGVsZW1lbnQuZGV0YWNoKCk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXRhY2hOb2Rlcyh0bSkge1xuICBcdHRtLmRldGFjaE5vZGVzKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVjayh0bSkge1xuICBcdGlmICghdG0ucmVhZHkgfHwgdG0ub3V0cm9zLmxlbmd0aCB8fCB0bS5vdXRyb0NoaWxkcmVuKSByZXR1cm47XG5cbiAgXHQvLyBJZiBhbGwgb3V0cm9zIGFyZSBjb21wbGV0ZSwgYW5kIHdlIGhhdmVuJ3QgYWxyZWFkeSBkb25lIHRoaXMsXG4gIFx0Ly8gd2Ugbm90aWZ5IHRoZSBwYXJlbnQgaWYgdGhlcmUgaXMgb25lLCBvdGhlcndpc2VcbiAgXHQvLyBzdGFydCBkZXRhY2hpbmcgbm9kZXNcbiAgXHRpZiAoIXRtLm91dHJvc0NvbXBsZXRlKSB7XG4gIFx0XHRpZiAodG0ucGFyZW50KSB7XG4gIFx0XHRcdHRtLnBhcmVudC5kZWNyZW1lbnRPdXRyb3ModG0pO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dG0uZGV0YWNoTm9kZXMoKTtcbiAgXHRcdH1cblxuICBcdFx0dG0ub3V0cm9zQ29tcGxldGUgPSB0cnVlO1xuICBcdH1cblxuICBcdC8vIE9uY2UgZXZlcnl0aGluZyBpcyBkb25lLCB3ZSBjYW4gbm90aWZ5IHBhcmVudCB0cmFuc2l0aW9uXG4gIFx0Ly8gbWFuYWdlciBhbmQgY2FsbCB0aGUgY2FsbGJhY2tcbiAgXHRpZiAoIXRtLmludHJvcy5sZW5ndGggJiYgIXRtLnRvdGFsQ2hpbGRyZW4pIHtcbiAgXHRcdGlmICh0eXBlb2YgdG0uY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHR0bS5jYWxsYmFjaygpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodG0ucGFyZW50KSB7XG4gIFx0XHRcdHRtLnBhcmVudC5kZWNyZW1lbnRUb3RhbCgpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBnbG9iYWxfVHJhbnNpdGlvbk1hbmFnZXIgPSBUcmFuc2l0aW9uTWFuYWdlcjtcblxuICB2YXIgYmF0Y2gsXG4gICAgICBydW5sb29wLFxuICAgICAgdW5yZXNvbHZlZCA9IFtdLFxuICAgICAgY2hhbmdlSG9vayA9IG5ldyBob29rc19Ib29rKFwiY2hhbmdlXCIpO1xuXG4gIHJ1bmxvb3AgPSB7XG4gIFx0c3RhcnQ6IGZ1bmN0aW9uIChpbnN0YW5jZSwgcmV0dXJuUHJvbWlzZSkge1xuICBcdFx0dmFyIHByb21pc2UsIGZ1bGZpbFByb21pc2U7XG5cbiAgXHRcdGlmIChyZXR1cm5Qcm9taXNlKSB7XG4gIFx0XHRcdHByb21pc2UgPSBuZXcgdXRpbHNfUHJvbWlzZShmdW5jdGlvbiAoZikge1xuICBcdFx0XHRcdHJldHVybiBmdWxmaWxQcm9taXNlID0gZjtcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdGJhdGNoID0ge1xuICBcdFx0XHRwcmV2aW91c0JhdGNoOiBiYXRjaCxcbiAgXHRcdFx0dHJhbnNpdGlvbk1hbmFnZXI6IG5ldyBnbG9iYWxfVHJhbnNpdGlvbk1hbmFnZXIoZnVsZmlsUHJvbWlzZSwgYmF0Y2ggJiYgYmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIpLFxuICBcdFx0XHR2aWV3czogW10sXG4gIFx0XHRcdHRhc2tzOiBbXSxcbiAgXHRcdFx0cmFjdGl2ZXM6IFtdLFxuICBcdFx0XHRpbnN0YW5jZTogaW5zdGFuY2VcbiAgXHRcdH07XG5cbiAgXHRcdGlmIChpbnN0YW5jZSkge1xuICBcdFx0XHRiYXRjaC5yYWN0aXZlcy5wdXNoKGluc3RhbmNlKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHByb21pc2U7XG4gIFx0fSxcblxuICBcdGVuZDogZnVuY3Rpb24gKCkge1xuICBcdFx0Zmx1c2hDaGFuZ2VzKCk7XG5cbiAgXHRcdGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyLmluaXQoKTtcbiAgXHRcdGlmICghYmF0Y2gucHJldmlvdXNCYXRjaCAmJiAhIWJhdGNoLmluc3RhbmNlKSBiYXRjaC5pbnN0YW5jZS52aWV3bW9kZWwuY2hhbmdlcyA9IFtdO1xuICBcdFx0YmF0Y2ggPSBiYXRjaC5wcmV2aW91c0JhdGNoO1xuICBcdH0sXG5cbiAgXHRhZGRSYWN0aXZlOiBmdW5jdGlvbiAocmFjdGl2ZSkge1xuICBcdFx0aWYgKGJhdGNoKSB7XG4gIFx0XHRcdGFkZFRvQXJyYXkoYmF0Y2gucmFjdGl2ZXMsIHJhY3RpdmUpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZWdpc3RlclRyYW5zaXRpb246IGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7XG4gIFx0XHR0cmFuc2l0aW9uLl9tYW5hZ2VyID0gYmF0Y2gudHJhbnNpdGlvbk1hbmFnZXI7XG4gIFx0XHRiYXRjaC50cmFuc2l0aW9uTWFuYWdlci5hZGQodHJhbnNpdGlvbik7XG4gIFx0fSxcblxuICBcdHJlZ2lzdGVyRGVjb3JhdG9yOiBmdW5jdGlvbiAoZGVjb3JhdG9yKSB7XG4gIFx0XHRiYXRjaC50cmFuc2l0aW9uTWFuYWdlci5hZGREZWNvcmF0b3IoZGVjb3JhdG9yKTtcbiAgXHR9LFxuXG4gIFx0YWRkVmlldzogZnVuY3Rpb24gKHZpZXcpIHtcbiAgXHRcdGJhdGNoLnZpZXdzLnB1c2godmlldyk7XG4gIFx0fSxcblxuICBcdGFkZFVucmVzb2x2ZWQ6IGZ1bmN0aW9uICh0aGluZykge1xuICBcdFx0dW5yZXNvbHZlZC5wdXNoKHRoaW5nKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlVW5yZXNvbHZlZDogZnVuY3Rpb24gKHRoaW5nKSB7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkodW5yZXNvbHZlZCwgdGhpbmcpO1xuICBcdH0sXG5cbiAgXHQvLyBzeW5jaHJvbmlzZSBub2RlIGRldGFjaG1lbnRzIHdpdGggdHJhbnNpdGlvbiBlbmRzXG4gIFx0ZGV0YWNoV2hlblJlYWR5OiBmdW5jdGlvbiAodGhpbmcpIHtcbiAgXHRcdGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyLmRldGFjaFF1ZXVlLnB1c2godGhpbmcpO1xuICBcdH0sXG5cbiAgXHRzY2hlZHVsZVRhc2s6IGZ1bmN0aW9uICh0YXNrLCBwb3N0UmVuZGVyKSB7XG4gIFx0XHR2YXIgX2JhdGNoO1xuXG4gIFx0XHRpZiAoIWJhdGNoKSB7XG4gIFx0XHRcdHRhc2soKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdF9iYXRjaCA9IGJhdGNoO1xuICBcdFx0XHR3aGlsZSAocG9zdFJlbmRlciAmJiBfYmF0Y2gucHJldmlvdXNCYXRjaCkge1xuICBcdFx0XHRcdC8vIHRoaXMgY2FuJ3QgaGFwcGVuIHVudGlsIHRoZSBET00gaGFzIGJlZW4gZnVsbHkgdXBkYXRlZFxuICBcdFx0XHRcdC8vIG90aGVyd2lzZSBpbiBzb21lIHNpdHVhdGlvbnMgKHdpdGggY29tcG9uZW50cyBpbnNpZGUgZWxlbWVudHMpXG4gIFx0XHRcdFx0Ly8gdHJhbnNpdGlvbnMgYW5kIGRlY29yYXRvcnMgd2lsbCBpbml0aWFsaXNlIHByZW1hdHVyZWx5XG4gIFx0XHRcdFx0X2JhdGNoID0gX2JhdGNoLnByZXZpb3VzQmF0Y2g7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRfYmF0Y2gudGFza3MucHVzaCh0YXNrKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIGdsb2JhbF9ydW5sb29wID0gcnVubG9vcDtcblxuICBmdW5jdGlvbiBmbHVzaENoYW5nZXMoKSB7XG4gIFx0dmFyIGksIHRoaW5nLCBjaGFuZ2VIYXNoO1xuXG4gIFx0d2hpbGUgKGJhdGNoLnJhY3RpdmVzLmxlbmd0aCkge1xuICBcdFx0dGhpbmcgPSBiYXRjaC5yYWN0aXZlcy5wb3AoKTtcbiAgXHRcdGNoYW5nZUhhc2ggPSB0aGluZy52aWV3bW9kZWwuYXBwbHlDaGFuZ2VzKCk7XG5cbiAgXHRcdGlmIChjaGFuZ2VIYXNoKSB7XG4gIFx0XHRcdGNoYW5nZUhvb2suZmlyZSh0aGluZywgY2hhbmdlSGFzaCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0YXR0ZW1wdEtleXBhdGhSZXNvbHV0aW9uKCk7XG5cbiAgXHQvLyBOb3cgdGhhdCBjaGFuZ2VzIGhhdmUgYmVlbiBmdWxseSBwcm9wYWdhdGVkLCB3ZSBjYW4gdXBkYXRlIHRoZSBET01cbiAgXHQvLyBhbmQgY29tcGxldGUgb3RoZXIgdGFza3NcbiAgXHRmb3IgKGkgPSAwOyBpIDwgYmF0Y2gudmlld3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdGJhdGNoLnZpZXdzW2ldLnVwZGF0ZSgpO1xuICBcdH1cbiAgXHRiYXRjaC52aWV3cy5sZW5ndGggPSAwO1xuXG4gIFx0Zm9yIChpID0gMDsgaSA8IGJhdGNoLnRhc2tzLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRiYXRjaC50YXNrc1tpXSgpO1xuICBcdH1cbiAgXHRiYXRjaC50YXNrcy5sZW5ndGggPSAwO1xuXG4gIFx0Ly8gSWYgdXBkYXRpbmcgdGhlIHZpZXcgY2F1c2VkIHNvbWUgbW9kZWwgYmxvd2JhY2sgLSBlLmcuIGEgdHJpcGxlXG4gIFx0Ly8gY29udGFpbmluZyA8b3B0aW9uPiBlbGVtZW50cyBjYXVzZWQgdGhlIGJpbmRpbmcgb24gdGhlIDxzZWxlY3Q+XG4gIFx0Ly8gdG8gdXBkYXRlIC0gdGhlbiB3ZSBzdGFydCBvdmVyXG4gIFx0aWYgKGJhdGNoLnJhY3RpdmVzLmxlbmd0aCkgcmV0dXJuIGZsdXNoQ2hhbmdlcygpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXR0ZW1wdEtleXBhdGhSZXNvbHV0aW9uKCkge1xuICBcdHZhciBpLCBpdGVtLCBrZXlwYXRoLCByZXNvbHZlZDtcblxuICBcdGkgPSB1bnJlc29sdmVkLmxlbmd0aDtcblxuICBcdC8vIHNlZSBpZiB3ZSBjYW4gcmVzb2x2ZSBhbnkgdW5yZXNvbHZlZCByZWZlcmVuY2VzXG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aXRlbSA9IHVucmVzb2x2ZWRbaV07XG5cbiAgXHRcdGlmIChpdGVtLmtleXBhdGgpIHtcbiAgXHRcdFx0Ly8gaXQgcmVzb2x2ZWQgc29tZSBvdGhlciB3YXkuIFRPRE8gaG93PyB0d28td2F5IGJpbmRpbmc/IFNlZW1zXG4gIFx0XHRcdC8vIHdlaXJkIHRoYXQgd2UnZCBzdGlsbCBlbmQgdXAgaGVyZVxuICBcdFx0XHR1bnJlc29sdmVkLnNwbGljZShpLCAxKTtcbiAgXHRcdFx0Y29udGludWU7IC8vIGF2b2lkIHJlbW92aW5nIHRoZSB3cm9uZyB0aGluZyBzaG91bGQgdGhlIG5leHQgY29uZGl0aW9uIGJlIHRydWVcbiAgXHRcdH1cblxuICBcdFx0aWYgKGtleXBhdGggPSBzaGFyZWRfcmVzb2x2ZVJlZihpdGVtLnJvb3QsIGl0ZW0ucmVmLCBpdGVtLnBhcmVudEZyYWdtZW50KSkge1xuICBcdFx0XHQocmVzb2x2ZWQgfHwgKHJlc29sdmVkID0gW10pKS5wdXNoKHtcbiAgXHRcdFx0XHRpdGVtOiBpdGVtLFxuICBcdFx0XHRcdGtleXBhdGg6IGtleXBhdGhcbiAgXHRcdFx0fSk7XG5cbiAgXHRcdFx0dW5yZXNvbHZlZC5zcGxpY2UoaSwgMSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKHJlc29sdmVkKSB7XG4gIFx0XHRyZXNvbHZlZC5mb3JFYWNoKGdsb2JhbF9ydW5sb29wX19yZXNvbHZlKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBnbG9iYWxfcnVubG9vcF9fcmVzb2x2ZShyZXNvbHZlZCkge1xuICBcdHJlc29sdmVkLml0ZW0ucmVzb2x2ZShyZXNvbHZlZC5rZXlwYXRoKTtcbiAgfVxuXG4gIHZhciBxdWV1ZSA9IFtdO1xuXG4gIHZhciBhbmltYXRpb25zID0ge1xuICBcdHRpY2s6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBpLCBhbmltYXRpb24sIG5vdztcblxuICBcdFx0bm93ID0gdXRpbHNfZ2V0VGltZSgpO1xuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zdGFydCgpO1xuXG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdFx0YW5pbWF0aW9uID0gcXVldWVbaV07XG5cbiAgXHRcdFx0aWYgKCFhbmltYXRpb24udGljayhub3cpKSB7XG4gIFx0XHRcdFx0Ly8gYW5pbWF0aW9uIGlzIGNvbXBsZXRlLCByZW1vdmUgaXQgZnJvbSB0aGUgc3RhY2ssIGFuZCBkZWNyZW1lbnQgaSBzbyB3ZSBkb24ndCBtaXNzIG9uZVxuICBcdFx0XHRcdHF1ZXVlLnNwbGljZShpLS0sIDEpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0XHRpZiAocXVldWUubGVuZ3RoKSB7XG4gIFx0XHRcdHJBRihhbmltYXRpb25zLnRpY2spO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0YW5pbWF0aW9ucy5ydW5uaW5nID0gZmFsc2U7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGFkZDogZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICBcdFx0cXVldWUucHVzaChhbmltYXRpb24pO1xuXG4gIFx0XHRpZiAoIWFuaW1hdGlvbnMucnVubmluZykge1xuICBcdFx0XHRhbmltYXRpb25zLnJ1bm5pbmcgPSB0cnVlO1xuICBcdFx0XHRyQUYoYW5pbWF0aW9ucy50aWNrKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Ly8gVE9ETyBvcHRpbWlzZSB0aGlzXG4gIFx0YWJvcnQ6IGZ1bmN0aW9uIChrZXlwYXRoLCByb290KSB7XG4gIFx0XHR2YXIgaSA9IHF1ZXVlLmxlbmd0aCxcbiAgXHRcdCAgICBhbmltYXRpb247XG5cbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0YW5pbWF0aW9uID0gcXVldWVbaV07XG5cbiAgXHRcdFx0aWYgKGFuaW1hdGlvbi5yb290ID09PSByb290ICYmIGFuaW1hdGlvbi5rZXlwYXRoID09PSBrZXlwYXRoKSB7XG4gIFx0XHRcdFx0YW5pbWF0aW9uLnN0b3AoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgc2hhcmVkX2FuaW1hdGlvbnMgPSBhbmltYXRpb25zO1xuXG4gIHZhciBBbmltYXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHZhciBrZXk7XG5cbiAgXHR0aGlzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgXHQvLyBmcm9tIGFuZCB0b1xuICBcdGZvciAoa2V5IGluIG9wdGlvbnMpIHtcbiAgXHRcdGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgXHRcdFx0dGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHRoaXMuaW50ZXJwb2xhdG9yID0gc2hhcmVkX2ludGVycG9sYXRlKHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5yb290LCB0aGlzLmludGVycG9sYXRvcik7XG4gIFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcblxuICBcdHRoaXMudGljaygpO1xuICB9O1xuXG4gIEFuaW1hdGlvbi5wcm90b3R5cGUgPSB7XG4gIFx0dGljazogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGVsYXBzZWQsIHQsIHZhbHVlLCB0aW1lTm93LCBpbmRleCwga2V5cGF0aDtcblxuICBcdFx0a2V5cGF0aCA9IHRoaXMua2V5cGF0aDtcblxuICBcdFx0aWYgKHRoaXMucnVubmluZykge1xuICBcdFx0XHR0aW1lTm93ID0gRGF0ZS5ub3coKTtcbiAgXHRcdFx0ZWxhcHNlZCA9IHRpbWVOb3cgLSB0aGlzLnN0YXJ0VGltZTtcblxuICBcdFx0XHRpZiAoZWxhcHNlZCA+PSB0aGlzLmR1cmF0aW9uKSB7XG4gIFx0XHRcdFx0aWYgKGtleXBhdGggIT09IG51bGwpIHtcbiAgXHRcdFx0XHRcdGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMucm9vdCk7XG4gIFx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldChrZXlwYXRoLCB0aGlzLnRvKTtcbiAgXHRcdFx0XHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGlmICh0aGlzLnN0ZXApIHtcbiAgXHRcdFx0XHRcdHRoaXMuc3RlcCgxLCB0aGlzLnRvKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHR0aGlzLmNvbXBsZXRlKHRoaXMudG8pO1xuXG4gIFx0XHRcdFx0aW5kZXggPSB0aGlzLnJvb3QuX2FuaW1hdGlvbnMuaW5kZXhPZih0aGlzKTtcblxuICBcdFx0XHRcdC8vIFRPRE8gaW52ZXN0aWdhdGUgd2h5IHRoaXMgaGFwcGVuc1xuICBcdFx0XHRcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0XHRcdHdhcm5JZkRlYnVnKFwiQW5pbWF0aW9uIHdhcyBub3QgZm91bmRcIik7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0dGhpcy5yb290Ll9hbmltYXRpb25zLnNwbGljZShpbmRleCwgMSk7XG5cbiAgXHRcdFx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgXHRcdFx0XHRyZXR1cm4gZmFsc2U7IC8vIHJlbW92ZSBmcm9tIHRoZSBzdGFja1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dCA9IHRoaXMuZWFzaW5nID8gdGhpcy5lYXNpbmcoZWxhcHNlZCAvIHRoaXMuZHVyYXRpb24pIDogZWxhcHNlZCAvIHRoaXMuZHVyYXRpb247XG5cbiAgXHRcdFx0aWYgKGtleXBhdGggIT09IG51bGwpIHtcbiAgXHRcdFx0XHR2YWx1ZSA9IHRoaXMuaW50ZXJwb2xhdG9yKHQpO1xuICBcdFx0XHRcdGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMucm9vdCk7XG4gIFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoa2V5cGF0aCwgdmFsdWUpO1xuICBcdFx0XHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKHRoaXMuc3RlcCkge1xuICBcdFx0XHRcdHRoaXMuc3RlcCh0LCB2YWx1ZSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gdHJ1ZTsgLy8ga2VlcCBpbiB0aGUgc3RhY2tcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGZhbHNlOyAvLyByZW1vdmUgZnJvbSB0aGUgc3RhY2tcbiAgXHR9LFxuXG4gIFx0c3RvcDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGluZGV4O1xuXG4gIFx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblxuICBcdFx0aW5kZXggPSB0aGlzLnJvb3QuX2FuaW1hdGlvbnMuaW5kZXhPZih0aGlzKTtcblxuICBcdFx0Ly8gVE9ETyBpbnZlc3RpZ2F0ZSB3aHkgdGhpcyBoYXBwZW5zXG4gIFx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdHdhcm5JZkRlYnVnKFwiQW5pbWF0aW9uIHdhcyBub3QgZm91bmRcIik7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMucm9vdC5fYW5pbWF0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgYW5pbWF0ZV9BbmltYXRpb24gPSBBbmltYXRpb247XG5cbiAgdmFyIHByb3RvdHlwZV9hbmltYXRlID0gUmFjdGl2ZSRhbmltYXRlO1xuXG4gIHZhciBub0FuaW1hdGlvbiA9IHsgc3RvcDogbm9vcCB9O1xuICBmdW5jdGlvbiBSYWN0aXZlJGFuaW1hdGUoa2V5cGF0aCwgdG8sIG9wdGlvbnMpIHtcbiAgXHR2YXIgcHJvbWlzZSwgZnVsZmlsUHJvbWlzZSwgaywgYW5pbWF0aW9uLCBhbmltYXRpb25zLCBlYXNpbmcsIGR1cmF0aW9uLCBzdGVwLCBjb21wbGV0ZSwgbWFrZVZhbHVlQ29sbGVjdG9yLCBjdXJyZW50VmFsdWVzLCBjb2xsZWN0VmFsdWUsIGR1bW15LCBkdW1teU9wdGlvbnM7XG5cbiAgXHRwcm9taXNlID0gbmV3IHV0aWxzX1Byb21pc2UoZnVuY3Rpb24gKGZ1bGZpbCkge1xuICBcdFx0cmV0dXJuIGZ1bGZpbFByb21pc2UgPSBmdWxmaWw7XG4gIFx0fSk7XG5cbiAgXHQvLyBhbmltYXRlIG11bHRpcGxlIGtleXBhdGhzXG4gIFx0aWYgKHR5cGVvZiBrZXlwYXRoID09PSBcIm9iamVjdFwiKSB7XG4gIFx0XHRvcHRpb25zID0gdG8gfHwge307XG4gIFx0XHRlYXNpbmcgPSBvcHRpb25zLmVhc2luZztcbiAgXHRcdGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcblxuICBcdFx0YW5pbWF0aW9ucyA9IFtdO1xuXG4gIFx0XHQvLyB3ZSBkb24ndCB3YW50IHRvIHBhc3MgdGhlIGBzdGVwYCBhbmQgYGNvbXBsZXRlYCBoYW5kbGVycywgYXMgdGhleSB3aWxsXG4gIFx0XHQvLyBydW4gZm9yIGVhY2ggYW5pbWF0aW9uISBTbyBpbnN0ZWFkIHdlJ2xsIHN0b3JlIHRoZSBoYW5kbGVycyBhbmQgY3JlYXRlXG4gIFx0XHQvLyBvdXIgb3duLi4uXG4gIFx0XHRzdGVwID0gb3B0aW9ucy5zdGVwO1xuICBcdFx0Y29tcGxldGUgPSBvcHRpb25zLmNvbXBsZXRlO1xuXG4gIFx0XHRpZiAoc3RlcCB8fCBjb21wbGV0ZSkge1xuICBcdFx0XHRjdXJyZW50VmFsdWVzID0ge307XG5cbiAgXHRcdFx0b3B0aW9ucy5zdGVwID0gbnVsbDtcbiAgXHRcdFx0b3B0aW9ucy5jb21wbGV0ZSA9IG51bGw7XG5cbiAgXHRcdFx0bWFrZVZhbHVlQ29sbGVjdG9yID0gZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKHQsIHZhbHVlKSB7XG4gIFx0XHRcdFx0XHRjdXJyZW50VmFsdWVzW2tleXBhdGhdID0gdmFsdWU7XG4gIFx0XHRcdFx0fTtcbiAgXHRcdFx0fTtcbiAgXHRcdH1cblxuICBcdFx0Zm9yIChrIGluIGtleXBhdGgpIHtcbiAgXHRcdFx0aWYgKGtleXBhdGguaGFzT3duUHJvcGVydHkoaykpIHtcbiAgXHRcdFx0XHRpZiAoc3RlcCB8fCBjb21wbGV0ZSkge1xuICBcdFx0XHRcdFx0Y29sbGVjdFZhbHVlID0gbWFrZVZhbHVlQ29sbGVjdG9yKGspO1xuICBcdFx0XHRcdFx0b3B0aW9ucyA9IHsgZWFzaW5nOiBlYXNpbmcsIGR1cmF0aW9uOiBkdXJhdGlvbiB9O1xuXG4gIFx0XHRcdFx0XHRpZiAoc3RlcCkge1xuICBcdFx0XHRcdFx0XHRvcHRpb25zLnN0ZXAgPSBjb2xsZWN0VmFsdWU7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0b3B0aW9ucy5jb21wbGV0ZSA9IGNvbXBsZXRlID8gY29sbGVjdFZhbHVlIDogbm9vcDtcbiAgXHRcdFx0XHRhbmltYXRpb25zLnB1c2goYW5pbWF0ZSh0aGlzLCBrLCBrZXlwYXRoW2tdLCBvcHRpb25zKSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gQ3JlYXRlIGEgZHVtbXkgYW5pbWF0aW9uLCB0byBmYWNpbGl0YXRlIHN0ZXAvY29tcGxldGVcbiAgXHRcdC8vIGNhbGxiYWNrcywgYW5kIFByb21pc2UgZnVsZmlsbWVudFxuICBcdFx0ZHVtbXlPcHRpb25zID0geyBlYXNpbmc6IGVhc2luZywgZHVyYXRpb246IGR1cmF0aW9uIH07XG5cbiAgXHRcdGlmIChzdGVwKSB7XG4gIFx0XHRcdGR1bW15T3B0aW9ucy5zdGVwID0gZnVuY3Rpb24gKHQpIHtcbiAgXHRcdFx0XHRyZXR1cm4gc3RlcCh0LCBjdXJyZW50VmFsdWVzKTtcbiAgXHRcdFx0fTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGNvbXBsZXRlKSB7XG4gIFx0XHRcdHByb21pc2UudGhlbihmdW5jdGlvbiAodCkge1xuICBcdFx0XHRcdHJldHVybiBjb21wbGV0ZSh0LCBjdXJyZW50VmFsdWVzKTtcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdGR1bW15T3B0aW9ucy5jb21wbGV0ZSA9IGZ1bGZpbFByb21pc2U7XG5cbiAgXHRcdGR1bW15ID0gYW5pbWF0ZSh0aGlzLCBudWxsLCBudWxsLCBkdW1teU9wdGlvbnMpO1xuICBcdFx0YW5pbWF0aW9ucy5wdXNoKGR1bW15KTtcblxuICBcdFx0cHJvbWlzZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICBcdFx0XHR2YXIgYW5pbWF0aW9uO1xuXG4gIFx0XHRcdHdoaWxlIChhbmltYXRpb24gPSBhbmltYXRpb25zLnBvcCgpKSB7XG4gIFx0XHRcdFx0YW5pbWF0aW9uLnN0b3AoKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChkdW1teSkge1xuICBcdFx0XHRcdGR1bW15LnN0b3AoKTtcbiAgXHRcdFx0fVxuICBcdFx0fTtcblxuICBcdFx0cmV0dXJuIHByb21pc2U7XG4gIFx0fVxuXG4gIFx0Ly8gYW5pbWF0ZSBhIHNpbmdsZSBrZXlwYXRoXG4gIFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgXHRpZiAob3B0aW9ucy5jb21wbGV0ZSkge1xuICBcdFx0cHJvbWlzZS50aGVuKG9wdGlvbnMuY29tcGxldGUpO1xuICBcdH1cblxuICBcdG9wdGlvbnMuY29tcGxldGUgPSBmdWxmaWxQcm9taXNlO1xuICBcdGFuaW1hdGlvbiA9IGFuaW1hdGUodGhpcywga2V5cGF0aCwgdG8sIG9wdGlvbnMpO1xuXG4gIFx0cHJvbWlzZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIGFuaW1hdGlvbi5zdG9wKCk7XG4gIFx0fTtcbiAgXHRyZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFuaW1hdGUocm9vdCwga2V5cGF0aCwgdG8sIG9wdGlvbnMpIHtcbiAgXHR2YXIgZWFzaW5nLCBkdXJhdGlvbiwgYW5pbWF0aW9uLCBmcm9tO1xuXG4gIFx0aWYgKGtleXBhdGgpIHtcbiAgXHRcdGtleXBhdGggPSBnZXRLZXlwYXRoKG5vcm1hbGlzZShrZXlwYXRoKSk7XG4gIFx0fVxuXG4gIFx0aWYgKGtleXBhdGggIT09IG51bGwpIHtcbiAgXHRcdGZyb20gPSByb290LnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG4gIFx0fVxuXG4gIFx0Ly8gY2FuY2VsIGFueSBleGlzdGluZyBhbmltYXRpb25cbiAgXHQvLyBUT0RPIHdoYXQgYWJvdXQgdXBzdHJlYW0vZG93bnN0cmVhbSBrZXlwYXRocz9cbiAgXHRzaGFyZWRfYW5pbWF0aW9ucy5hYm9ydChrZXlwYXRoLCByb290KTtcblxuICBcdC8vIGRvbid0IGJvdGhlciBhbmltYXRpbmcgdmFsdWVzIHRoYXQgc3RheSB0aGUgc2FtZVxuICBcdGlmIChpc0VxdWFsKGZyb20sIHRvKSkge1xuICBcdFx0aWYgKG9wdGlvbnMuY29tcGxldGUpIHtcbiAgXHRcdFx0b3B0aW9ucy5jb21wbGV0ZShvcHRpb25zLnRvKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG5vQW5pbWF0aW9uO1xuICBcdH1cblxuICBcdC8vIGVhc2luZyBmdW5jdGlvblxuICBcdGlmIChvcHRpb25zLmVhc2luZykge1xuICBcdFx0aWYgKHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZWFzaW5nID0gcm9vdC5lYXNpbmdbb3B0aW9ucy5lYXNpbmddO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodHlwZW9mIGVhc2luZyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdGVhc2luZyA9IG51bGw7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gZHVyYXRpb25cbiAgXHRkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gPT09IHVuZGVmaW5lZCA/IDQwMCA6IG9wdGlvbnMuZHVyYXRpb247XG5cbiAgXHQvLyBUT0RPIHN0b3JlIGtleXMsIHVzZSBhbiBpbnRlcm5hbCBzZXQgbWV0aG9kXG4gIFx0YW5pbWF0aW9uID0gbmV3IGFuaW1hdGVfQW5pbWF0aW9uKHtcbiAgXHRcdGtleXBhdGg6IGtleXBhdGgsXG4gIFx0XHRmcm9tOiBmcm9tLFxuICBcdFx0dG86IHRvLFxuICBcdFx0cm9vdDogcm9vdCxcbiAgXHRcdGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgXHRcdGVhc2luZzogZWFzaW5nLFxuICBcdFx0aW50ZXJwb2xhdG9yOiBvcHRpb25zLmludGVycG9sYXRvcixcblxuICBcdFx0Ly8gVE9ETyB3cmFwIGNhbGxiYWNrcyBpZiBuZWNlc3NhcnksIHRvIHVzZSBpbnN0YW5jZSBhcyBjb250ZXh0XG4gIFx0XHRzdGVwOiBvcHRpb25zLnN0ZXAsXG4gIFx0XHRjb21wbGV0ZTogb3B0aW9ucy5jb21wbGV0ZVxuICBcdH0pO1xuXG4gIFx0c2hhcmVkX2FuaW1hdGlvbnMuYWRkKGFuaW1hdGlvbik7XG4gIFx0cm9vdC5fYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG5cbiAgXHRyZXR1cm4gYW5pbWF0aW9uO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9kZXRhY2ggPSBSYWN0aXZlJGRldGFjaDtcbiAgdmFyIHByb3RvdHlwZV9kZXRhY2hfX2RldGFjaEhvb2sgPSBuZXcgaG9va3NfSG9vayhcImRldGFjaFwiKTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRkZXRhY2goKSB7XG4gIFx0aWYgKHRoaXMuZGV0YWNoZWQpIHtcbiAgXHRcdHJldHVybiB0aGlzLmRldGFjaGVkO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmVsKSB7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkodGhpcy5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18sIHRoaXMpO1xuICBcdH1cbiAgXHR0aGlzLmRldGFjaGVkID0gdGhpcy5mcmFnbWVudC5kZXRhY2goKTtcbiAgXHRwcm90b3R5cGVfZGV0YWNoX19kZXRhY2hIb29rLmZpcmUodGhpcyk7XG4gIFx0cmV0dXJuIHRoaXMuZGV0YWNoZWQ7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2ZpbmQgPSBSYWN0aXZlJGZpbmQ7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRmaW5kKHNlbGVjdG9yKSB7XG4gIFx0aWYgKCF0aGlzLmVsKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kKHNlbGVjdG9yKTtcbiAgfVxuXG4gIHZhciB0ZXN0ID0gUXVlcnkkdGVzdDtcbiAgZnVuY3Rpb24gUXVlcnkkdGVzdChpdGVtLCBub0RpcnR5KSB7XG4gIFx0dmFyIGl0ZW1NYXRjaGVzO1xuXG4gIFx0aWYgKHRoaXMuX2lzQ29tcG9uZW50UXVlcnkpIHtcbiAgXHRcdGl0ZW1NYXRjaGVzID0gIXRoaXMuc2VsZWN0b3IgfHwgaXRlbS5uYW1lID09PSB0aGlzLnNlbGVjdG9yO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRpdGVtTWF0Y2hlcyA9IGl0ZW0ubm9kZSA/IG1hdGNoZXMoaXRlbS5ub2RlLCB0aGlzLnNlbGVjdG9yKSA6IG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKGl0ZW1NYXRjaGVzKSB7XG4gIFx0XHR0aGlzLnB1c2goaXRlbS5ub2RlIHx8IGl0ZW0uaW5zdGFuY2UpO1xuXG4gIFx0XHRpZiAoIW5vRGlydHkpIHtcbiAgXHRcdFx0dGhpcy5fbWFrZURpcnR5KCk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cbiAgfVxuXG4gIHZhciBtYWtlUXVlcnlfY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICBcdHZhciBsaXZlUXVlcmllcywgc2VsZWN0b3IsIGluZGV4O1xuXG4gIFx0bGl2ZVF1ZXJpZXMgPSB0aGlzLl9yb290W3RoaXMuX2lzQ29tcG9uZW50UXVlcnkgPyBcImxpdmVDb21wb25lbnRRdWVyaWVzXCIgOiBcImxpdmVRdWVyaWVzXCJdO1xuICBcdHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcjtcblxuICBcdGluZGV4ID0gbGl2ZVF1ZXJpZXMuaW5kZXhPZihzZWxlY3Rvcik7XG5cbiAgXHRpZiAoaW5kZXggIT09IC0xKSB7XG4gIFx0XHRsaXZlUXVlcmllcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdFx0bGl2ZVF1ZXJpZXNbc2VsZWN0b3JdID0gbnVsbDtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIHNvcnRCeUl0ZW1Qb3NpdGlvbiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIFx0dmFyIGFuY2VzdHJ5QSwgYW5jZXN0cnlCLCBvbGRlc3RBLCBvbGRlc3RCLCBtdXR1YWxBbmNlc3RvciwgaW5kZXhBLCBpbmRleEIsIGZyYWdtZW50cywgZnJhZ21lbnRBLCBmcmFnbWVudEI7XG5cbiAgXHRhbmNlc3RyeUEgPSBnZXRBbmNlc3RyeShhLmNvbXBvbmVudCB8fCBhLl9yYWN0aXZlLnByb3h5KTtcbiAgXHRhbmNlc3RyeUIgPSBnZXRBbmNlc3RyeShiLmNvbXBvbmVudCB8fCBiLl9yYWN0aXZlLnByb3h5KTtcblxuICBcdG9sZGVzdEEgPSBsYXN0SXRlbShhbmNlc3RyeUEpO1xuICBcdG9sZGVzdEIgPSBsYXN0SXRlbShhbmNlc3RyeUIpO1xuXG4gIFx0Ly8gcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIGVuZCBvZiBib3RoIGFuY2VzdHJpZXMgYXMgbG9uZyBhcyB0aGV5IGFyZSBpZGVudGljYWxcbiAgXHQvLyAtIHRoZSBmaW5hbCBvbmUgcmVtb3ZlZCBpcyB0aGUgY2xvc2VzdCBtdXR1YWwgYW5jZXN0b3JcbiAgXHR3aGlsZSAob2xkZXN0QSAmJiBvbGRlc3RBID09PSBvbGRlc3RCKSB7XG4gIFx0XHRhbmNlc3RyeUEucG9wKCk7XG4gIFx0XHRhbmNlc3RyeUIucG9wKCk7XG5cbiAgXHRcdG11dHVhbEFuY2VzdG9yID0gb2xkZXN0QTtcblxuICBcdFx0b2xkZXN0QSA9IGxhc3RJdGVtKGFuY2VzdHJ5QSk7XG4gIFx0XHRvbGRlc3RCID0gbGFzdEl0ZW0oYW5jZXN0cnlCKTtcbiAgXHR9XG5cbiAgXHQvLyBub3cgdGhhdCB3ZSBoYXZlIHRoZSBtdXR1YWwgYW5jZXN0b3IsIHdlIGNhbiBmaW5kIHdoaWNoIGlzIGVhcmxpZXN0XG4gIFx0b2xkZXN0QSA9IG9sZGVzdEEuY29tcG9uZW50IHx8IG9sZGVzdEE7XG4gIFx0b2xkZXN0QiA9IG9sZGVzdEIuY29tcG9uZW50IHx8IG9sZGVzdEI7XG5cbiAgXHRmcmFnbWVudEEgPSBvbGRlc3RBLnBhcmVudEZyYWdtZW50O1xuICBcdGZyYWdtZW50QiA9IG9sZGVzdEIucGFyZW50RnJhZ21lbnQ7XG5cbiAgXHQvLyBpZiBib3RoIGl0ZW1zIHNoYXJlIGEgcGFyZW50IGZyYWdtZW50LCBvdXIgam9iIGlzIGVhc3lcbiAgXHRpZiAoZnJhZ21lbnRBID09PSBmcmFnbWVudEIpIHtcbiAgXHRcdGluZGV4QSA9IGZyYWdtZW50QS5pdGVtcy5pbmRleE9mKG9sZGVzdEEpO1xuICBcdFx0aW5kZXhCID0gZnJhZ21lbnRCLml0ZW1zLmluZGV4T2Yob2xkZXN0Qik7XG5cbiAgXHRcdC8vIGlmIGl0J3MgdGhlIHNhbWUgaW5kZXgsIGl0IG1lYW5zIG9uZSBjb250YWlucyB0aGUgb3RoZXIsXG4gIFx0XHQvLyBzbyB3ZSBzZWUgd2hpY2ggaGFzIHRoZSBsb25nZXN0IGFuY2VzdHJ5XG4gIFx0XHRyZXR1cm4gaW5kZXhBIC0gaW5kZXhCIHx8IGFuY2VzdHJ5QS5sZW5ndGggLSBhbmNlc3RyeUIubGVuZ3RoO1xuICBcdH1cblxuICBcdC8vIGlmIG11dHVhbCBhbmNlc3RvciBpcyBhIHNlY3Rpb24sIHdlIGZpcnN0IHRlc3QgdG8gc2VlIHdoaWNoIHNlY3Rpb25cbiAgXHQvLyBmcmFnbWVudCBjb21lcyBmaXJzdFxuICBcdGlmIChmcmFnbWVudHMgPSBtdXR1YWxBbmNlc3Rvci5mcmFnbWVudHMpIHtcbiAgXHRcdGluZGV4QSA9IGZyYWdtZW50cy5pbmRleE9mKGZyYWdtZW50QSk7XG4gIFx0XHRpbmRleEIgPSBmcmFnbWVudHMuaW5kZXhPZihmcmFnbWVudEIpO1xuXG4gIFx0XHRyZXR1cm4gaW5kZXhBIC0gaW5kZXhCIHx8IGFuY2VzdHJ5QS5sZW5ndGggLSBhbmNlc3RyeUIubGVuZ3RoO1xuICBcdH1cblxuICBcdHRocm93IG5ldyBFcnJvcihcIkFuIHVuZXhwZWN0ZWQgY29uZGl0aW9uIHdhcyBtZXQgd2hpbGUgY29tcGFyaW5nIHRoZSBwb3NpdGlvbiBvZiB0d28gY29tcG9uZW50cy4gUGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL1JhY3RpdmVKUy9SYWN0aXZlL2lzc3VlcyAtIHRoYW5rcyFcIik7XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0UGFyZW50KGl0ZW0pIHtcbiAgXHR2YXIgcGFyZW50RnJhZ21lbnQ7XG5cbiAgXHRpZiAocGFyZW50RnJhZ21lbnQgPSBpdGVtLnBhcmVudEZyYWdtZW50KSB7XG4gIFx0XHRyZXR1cm4gcGFyZW50RnJhZ21lbnQub3duZXI7XG4gIFx0fVxuXG4gIFx0aWYgKGl0ZW0uY29tcG9uZW50ICYmIChwYXJlbnRGcmFnbWVudCA9IGl0ZW0uY29tcG9uZW50LnBhcmVudEZyYWdtZW50KSkge1xuICBcdFx0cmV0dXJuIHBhcmVudEZyYWdtZW50Lm93bmVyO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFuY2VzdHJ5KGl0ZW0pIHtcbiAgXHR2YXIgYW5jZXN0cnksIGFuY2VzdG9yO1xuXG4gIFx0YW5jZXN0cnkgPSBbaXRlbV07XG5cbiAgXHRhbmNlc3RvciA9IGdldFBhcmVudChpdGVtKTtcblxuICBcdHdoaWxlIChhbmNlc3Rvcikge1xuICBcdFx0YW5jZXN0cnkucHVzaChhbmNlc3Rvcik7XG4gIFx0XHRhbmNlc3RvciA9IGdldFBhcmVudChhbmNlc3Rvcik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGFuY2VzdHJ5O1xuICB9XG5cbiAgdmFyIHNvcnRCeURvY3VtZW50UG9zaXRpb24gPSBmdW5jdGlvbiAobm9kZSwgb3RoZXJOb2RlKSB7XG4gIFx0dmFyIGJpdG1hc2s7XG5cbiAgXHRpZiAobm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICBcdFx0Yml0bWFzayA9IG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24ob3RoZXJOb2RlKTtcbiAgXHRcdHJldHVybiBiaXRtYXNrICYgMiA/IDEgOiAtMTtcbiAgXHR9XG5cbiAgXHQvLyBJbiBvbGQgSUUsIHdlIGNhbiBwaWdneSBiYWNrIG9uIHRoZSBtZWNoYW5pc20gZm9yXG4gIFx0Ly8gY29tcGFyaW5nIGNvbXBvbmVudCBwb3NpdGlvbnNcbiAgXHRyZXR1cm4gc29ydEJ5SXRlbVBvc2l0aW9uKG5vZGUsIG90aGVyTm9kZSk7XG4gIH07XG5cbiAgdmFyIHNvcnQgPSBmdW5jdGlvbiAoKSB7XG4gIFx0dGhpcy5zb3J0KHRoaXMuX2lzQ29tcG9uZW50UXVlcnkgPyBzb3J0QnlJdGVtUG9zaXRpb24gOiBzb3J0QnlEb2N1bWVudFBvc2l0aW9uKTtcbiAgXHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICB9O1xuXG4gIHZhciBtYWtlUXVlcnlfZGlydHkgPSBmdW5jdGlvbiAoKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdGlmICghdGhpcy5fZGlydHkpIHtcbiAgXHRcdHRoaXMuX2RpcnR5ID0gdHJ1ZTtcblxuICBcdFx0Ly8gT25jZSB0aGUgRE9NIGhhcyBiZWVuIHVwZGF0ZWQsIGVuc3VyZSB0aGUgcXVlcnlcbiAgXHRcdC8vIGlzIGNvcnJlY3RseSBvcmRlcmVkXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRfdGhpcy5fc29ydCgpO1xuICBcdFx0fSk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciByZW1vdmUgPSBmdW5jdGlvbiAobm9kZU9yQ29tcG9uZW50KSB7XG4gIFx0dmFyIGluZGV4ID0gdGhpcy5pbmRleE9mKHRoaXMuX2lzQ29tcG9uZW50UXVlcnkgPyBub2RlT3JDb21wb25lbnQuaW5zdGFuY2UgOiBub2RlT3JDb21wb25lbnQpO1xuXG4gIFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0dGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgX21ha2VRdWVyeSA9IG1ha2VRdWVyeTtcbiAgZnVuY3Rpb24gbWFrZVF1ZXJ5KHJhY3RpdmUsIHNlbGVjdG9yLCBsaXZlLCBpc0NvbXBvbmVudFF1ZXJ5KSB7XG4gIFx0dmFyIHF1ZXJ5ID0gW107XG5cbiAgXHRkZWZpbmVQcm9wZXJ0aWVzKHF1ZXJ5LCB7XG4gIFx0XHRzZWxlY3RvcjogeyB2YWx1ZTogc2VsZWN0b3IgfSxcbiAgXHRcdGxpdmU6IHsgdmFsdWU6IGxpdmUgfSxcblxuICBcdFx0X2lzQ29tcG9uZW50UXVlcnk6IHsgdmFsdWU6IGlzQ29tcG9uZW50UXVlcnkgfSxcbiAgXHRcdF90ZXN0OiB7IHZhbHVlOiB0ZXN0IH1cbiAgXHR9KTtcblxuICBcdGlmICghbGl2ZSkge1xuICBcdFx0cmV0dXJuIHF1ZXJ5O1xuICBcdH1cblxuICBcdGRlZmluZVByb3BlcnRpZXMocXVlcnksIHtcbiAgXHRcdGNhbmNlbDogeyB2YWx1ZTogbWFrZVF1ZXJ5X2NhbmNlbCB9LFxuXG4gIFx0XHRfcm9vdDogeyB2YWx1ZTogcmFjdGl2ZSB9LFxuICBcdFx0X3NvcnQ6IHsgdmFsdWU6IHNvcnQgfSxcbiAgXHRcdF9tYWtlRGlydHk6IHsgdmFsdWU6IG1ha2VRdWVyeV9kaXJ0eSB9LFxuICBcdFx0X3JlbW92ZTogeyB2YWx1ZTogcmVtb3ZlIH0sXG5cbiAgXHRcdF9kaXJ0eTogeyB2YWx1ZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlIH1cbiAgXHR9KTtcblxuICBcdHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZmluZEFsbCA9IFJhY3RpdmUkZmluZEFsbDtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRmaW5kQWxsKHNlbGVjdG9yLCBvcHRpb25zKSB7XG4gIFx0dmFyIGxpdmVRdWVyaWVzLCBxdWVyeTtcblxuICBcdGlmICghdGhpcy5lbCkge1xuICBcdFx0cmV0dXJuIFtdO1xuICBcdH1cblxuICBcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBcdGxpdmVRdWVyaWVzID0gdGhpcy5fbGl2ZVF1ZXJpZXM7XG5cbiAgXHQvLyBTaG9ydGN1dDogaWYgd2UncmUgbWFpbnRhaW5pbmcgYSBsaXZlIHF1ZXJ5IHdpdGggdGhpc1xuICBcdC8vIHNlbGVjdG9yLCB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIHRoZSBwYXJhbGxlbCBET01cbiAgXHRpZiAocXVlcnkgPSBsaXZlUXVlcmllc1tzZWxlY3Rvcl0pIHtcblxuICBcdFx0Ly8gRWl0aGVyIHJldHVybiB0aGUgZXhhY3Qgc2FtZSBxdWVyeSwgb3IgKGlmIG5vdCBsaXZlKSBhIHNuYXBzaG90XG4gIFx0XHRyZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmxpdmUgPyBxdWVyeSA6IHF1ZXJ5LnNsaWNlKCk7XG4gIFx0fVxuXG4gIFx0cXVlcnkgPSBfbWFrZVF1ZXJ5KHRoaXMsIHNlbGVjdG9yLCAhIW9wdGlvbnMubGl2ZSwgZmFsc2UpO1xuXG4gIFx0Ly8gQWRkIHRoaXMgdG8gdGhlIGxpc3Qgb2YgbGl2ZSBxdWVyaWVzIFJhY3RpdmUgbmVlZHMgdG8gbWFpbnRhaW4sXG4gIFx0Ly8gaWYgYXBwbGljYWJsZVxuICBcdGlmIChxdWVyeS5saXZlKSB7XG4gIFx0XHRsaXZlUXVlcmllcy5wdXNoKHNlbGVjdG9yKTtcbiAgXHRcdGxpdmVRdWVyaWVzW1wiX1wiICsgc2VsZWN0b3JdID0gcXVlcnk7XG4gIFx0fVxuXG4gIFx0dGhpcy5mcmFnbWVudC5maW5kQWxsKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0cmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9maW5kQWxsQ29tcG9uZW50cyA9IFJhY3RpdmUkZmluZEFsbENvbXBvbmVudHM7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIG9wdGlvbnMpIHtcbiAgXHR2YXIgbGl2ZVF1ZXJpZXMsIHF1ZXJ5O1xuXG4gIFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIFx0bGl2ZVF1ZXJpZXMgPSB0aGlzLl9saXZlQ29tcG9uZW50UXVlcmllcztcblxuICBcdC8vIFNob3J0Y3V0OiBpZiB3ZSdyZSBtYWludGFpbmluZyBhIGxpdmUgcXVlcnkgd2l0aCB0aGlzXG4gIFx0Ly8gc2VsZWN0b3IsIHdlIGRvbid0IG5lZWQgdG8gdHJhdmVyc2UgdGhlIHBhcmFsbGVsIERPTVxuICBcdGlmIChxdWVyeSA9IGxpdmVRdWVyaWVzW3NlbGVjdG9yXSkge1xuXG4gIFx0XHQvLyBFaXRoZXIgcmV0dXJuIHRoZSBleGFjdCBzYW1lIHF1ZXJ5LCBvciAoaWYgbm90IGxpdmUpIGEgc25hcHNob3RcbiAgXHRcdHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMubGl2ZSA/IHF1ZXJ5IDogcXVlcnkuc2xpY2UoKTtcbiAgXHR9XG5cbiAgXHRxdWVyeSA9IF9tYWtlUXVlcnkodGhpcywgc2VsZWN0b3IsICEhb3B0aW9ucy5saXZlLCB0cnVlKTtcblxuICBcdC8vIEFkZCB0aGlzIHRvIHRoZSBsaXN0IG9mIGxpdmUgcXVlcmllcyBSYWN0aXZlIG5lZWRzIHRvIG1haW50YWluLFxuICBcdC8vIGlmIGFwcGxpY2FibGVcbiAgXHRpZiAocXVlcnkubGl2ZSkge1xuICBcdFx0bGl2ZVF1ZXJpZXMucHVzaChzZWxlY3Rvcik7XG4gIFx0XHRsaXZlUXVlcmllc1tcIl9cIiArIHNlbGVjdG9yXSA9IHF1ZXJ5O1xuICBcdH1cblxuICBcdHRoaXMuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHRyZXR1cm4gcXVlcnk7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2ZpbmRDb21wb25lbnQgPSBSYWN0aXZlJGZpbmRDb21wb25lbnQ7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRmaW5kQ29tcG9uZW50KHNlbGVjdG9yKSB7XG4gIFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudChzZWxlY3Rvcik7XG4gIH1cblxuICB2YXIgZmluZENvbnRhaW5lciA9IFJhY3RpdmUkZmluZENvbnRhaW5lcjtcblxuICBmdW5jdGlvbiBSYWN0aXZlJGZpbmRDb250YWluZXIoc2VsZWN0b3IpIHtcbiAgXHRpZiAodGhpcy5jb250YWluZXIpIHtcbiAgXHRcdGlmICh0aGlzLmNvbnRhaW5lci5jb21wb25lbnQgJiYgdGhpcy5jb250YWluZXIuY29tcG9uZW50Lm5hbWUgPT09IHNlbGVjdG9yKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLmNvbnRhaW5lci5maW5kQ29udGFpbmVyKHNlbGVjdG9yKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBmaW5kUGFyZW50ID0gUmFjdGl2ZSRmaW5kUGFyZW50O1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkZmluZFBhcmVudChzZWxlY3Rvcikge1xuXG4gIFx0aWYgKHRoaXMucGFyZW50KSB7XG4gIFx0XHRpZiAodGhpcy5wYXJlbnQuY29tcG9uZW50ICYmIHRoaXMucGFyZW50LmNvbXBvbmVudC5uYW1lID09PSBzZWxlY3Rvcikge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5wYXJlbnQ7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5wYXJlbnQuZmluZFBhcmVudChzZWxlY3Rvcik7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXZlbnRTdGFjayA9IHtcbiAgXHRlbnF1ZXVlOiBmdW5jdGlvbiAocmFjdGl2ZSwgZXZlbnQpIHtcbiAgXHRcdGlmIChyYWN0aXZlLmV2ZW50KSB7XG4gIFx0XHRcdHJhY3RpdmUuX2V2ZW50UXVldWUgPSByYWN0aXZlLl9ldmVudFF1ZXVlIHx8IFtdO1xuICBcdFx0XHRyYWN0aXZlLl9ldmVudFF1ZXVlLnB1c2gocmFjdGl2ZS5ldmVudCk7XG4gIFx0XHR9XG4gIFx0XHRyYWN0aXZlLmV2ZW50ID0gZXZlbnQ7XG4gIFx0fSxcbiAgXHRkZXF1ZXVlOiBmdW5jdGlvbiAocmFjdGl2ZSkge1xuICBcdFx0aWYgKHJhY3RpdmUuX2V2ZW50UXVldWUgJiYgcmFjdGl2ZS5fZXZlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgXHRcdFx0cmFjdGl2ZS5ldmVudCA9IHJhY3RpdmUuX2V2ZW50UXVldWUucG9wKCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRkZWxldGUgcmFjdGl2ZS5ldmVudDtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIHNoYXJlZF9ldmVudFN0YWNrID0gZXZlbnRTdGFjaztcblxuICB2YXIgc2hhcmVkX2ZpcmVFdmVudCA9IGZpcmVFdmVudDtcblxuICBmdW5jdGlvbiBmaXJlRXZlbnQocmFjdGl2ZSwgZXZlbnROYW1lKSB7XG4gIFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzJdO1xuXG4gIFx0aWYgKCFldmVudE5hbWUpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRpZiAoIW9wdGlvbnMuZXZlbnQpIHtcbiAgXHRcdG9wdGlvbnMuZXZlbnQgPSB7XG4gIFx0XHRcdG5hbWU6IGV2ZW50TmFtZSxcbiAgXHRcdFx0Ly8gdW50aWwgZXZlbnQgbm90IGluY2x1ZGVkIGFzIGFyZ3VtZW50IGRlZmF1bHRcbiAgXHRcdFx0X25vQXJnOiB0cnVlXG4gIFx0XHR9O1xuICBcdH0gZWxzZSB7XG4gIFx0XHRvcHRpb25zLmV2ZW50Lm5hbWUgPSBldmVudE5hbWU7XG4gIFx0fVxuXG4gIFx0dmFyIGV2ZW50TmFtZXMgPSBnZXRLZXlwYXRoKGV2ZW50TmFtZSkud2lsZGNhcmRNYXRjaGVzKCk7XG4gIFx0ZmlyZUV2ZW50QXMocmFjdGl2ZSwgZXZlbnROYW1lcywgb3B0aW9ucy5ldmVudCwgb3B0aW9ucy5hcmdzLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmVFdmVudEFzKHJhY3RpdmUsIGV2ZW50TmFtZXMsIGV2ZW50LCBhcmdzKSB7XG4gIFx0dmFyIGluaXRpYWxGaXJlID0gYXJndW1lbnRzWzRdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1s0XTtcblxuICBcdHZhciBzdWJzY3JpYmVycyxcbiAgXHQgICAgaSxcbiAgXHQgICAgYnViYmxlID0gdHJ1ZTtcblxuICBcdHNoYXJlZF9ldmVudFN0YWNrLmVucXVldWUocmFjdGl2ZSwgZXZlbnQpO1xuXG4gIFx0Zm9yIChpID0gZXZlbnROYW1lcy5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gIFx0XHRzdWJzY3JpYmVycyA9IHJhY3RpdmUuX3N1YnNbZXZlbnROYW1lc1tpXV07XG5cbiAgXHRcdGlmIChzdWJzY3JpYmVycykge1xuICBcdFx0XHRidWJibGUgPSBub3RpZnlTdWJzY3JpYmVycyhyYWN0aXZlLCBzdWJzY3JpYmVycywgZXZlbnQsIGFyZ3MpICYmIGJ1YmJsZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRzaGFyZWRfZXZlbnRTdGFjay5kZXF1ZXVlKHJhY3RpdmUpO1xuXG4gIFx0aWYgKHJhY3RpdmUucGFyZW50ICYmIGJ1YmJsZSkge1xuXG4gIFx0XHRpZiAoaW5pdGlhbEZpcmUgJiYgcmFjdGl2ZS5jb21wb25lbnQpIHtcbiAgXHRcdFx0dmFyIGZ1bGxOYW1lID0gcmFjdGl2ZS5jb21wb25lbnQubmFtZSArIFwiLlwiICsgZXZlbnROYW1lc1tldmVudE5hbWVzLmxlbmd0aCAtIDFdO1xuICBcdFx0XHRldmVudE5hbWVzID0gZ2V0S2V5cGF0aChmdWxsTmFtZSkud2lsZGNhcmRNYXRjaGVzKCk7XG5cbiAgXHRcdFx0aWYgKGV2ZW50KSB7XG4gIFx0XHRcdFx0ZXZlbnQuY29tcG9uZW50ID0gcmFjdGl2ZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRmaXJlRXZlbnRBcyhyYWN0aXZlLnBhcmVudCwgZXZlbnROYW1lcywgZXZlbnQsIGFyZ3MpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeVN1YnNjcmliZXJzKHJhY3RpdmUsIHN1YnNjcmliZXJzLCBldmVudCwgYXJncykge1xuICBcdHZhciBvcmlnaW5hbEV2ZW50ID0gbnVsbCxcbiAgXHQgICAgc3RvcEV2ZW50ID0gZmFsc2U7XG5cbiAgXHRpZiAoZXZlbnQgJiYgIWV2ZW50Ll9ub0FyZykge1xuICBcdFx0YXJncyA9IFtldmVudF0uY29uY2F0KGFyZ3MpO1xuICBcdH1cblxuICBcdC8vIHN1YnNjcmliZXJzIGNhbiBiZSBtb2RpZmllZCBpbmZsaWdodCwgZS5nLiBcIm9uY2VcIiBmdW5jdGlvbmFsaXR5XG4gIFx0Ly8gc28gd2UgbmVlZCB0byBjb3B5IHRvIG1ha2Ugc3VyZSBldmVyeW9uZSBnZXRzIGNhbGxlZFxuICBcdHN1YnNjcmliZXJzID0gc3Vic2NyaWJlcnMuc2xpY2UoKTtcblxuICBcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdWJzY3JpYmVycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0aWYgKHN1YnNjcmliZXJzW2ldLmFwcGx5KHJhY3RpdmUsIGFyZ3MpID09PSBmYWxzZSkge1xuICBcdFx0XHRzdG9wRXZlbnQgPSB0cnVlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChldmVudCAmJiAhZXZlbnQuX25vQXJnICYmIHN0b3BFdmVudCAmJiAob3JpZ2luYWxFdmVudCA9IGV2ZW50Lm9yaWdpbmFsKSkge1xuICBcdFx0b3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCAmJiBvcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIFx0XHRvcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbiAmJiBvcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICBcdH1cblxuICBcdHJldHVybiAhc3RvcEV2ZW50O1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9maXJlID0gUmFjdGl2ZSRmaXJlO1xuICBmdW5jdGlvbiBSYWN0aXZlJGZpcmUoZXZlbnROYW1lKSB7XG5cbiAgXHR2YXIgb3B0aW9ucyA9IHtcbiAgXHRcdGFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgXHR9O1xuXG4gIFx0c2hhcmVkX2ZpcmVFdmVudCh0aGlzLCBldmVudE5hbWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9nZXQgPSBSYWN0aXZlJGdldDtcbiAgdmFyIG9wdGlvbnMgPSB7XG4gIFx0Y2FwdHVyZTogdHJ1ZSwgLy8gdG9wLWxldmVsIGNhbGxzIHNob3VsZCBiZSBpbnRlcmNlcHRlZFxuICBcdG5vVW53cmFwOiB0cnVlLCAvLyB3cmFwcGVkIHZhbHVlcyBzaG91bGQgTk9UIGJlIHVud3JhcHBlZFxuICBcdGZ1bGxSb290R2V0OiB0cnVlIC8vIHJvb3QgZ2V0IHNob3VsZCByZXR1cm4gbWFwcGluZ3NcbiAgfTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRnZXQoa2V5cGF0aCkge1xuICBcdHZhciB2YWx1ZTtcblxuICBcdGtleXBhdGggPSBnZXRLZXlwYXRoKG5vcm1hbGlzZShrZXlwYXRoKSk7XG4gIFx0dmFsdWUgPSB0aGlzLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCwgb3B0aW9ucyk7XG5cbiAgXHQvLyBDcmVhdGUgaW50ZXItY29tcG9uZW50IGJpbmRpbmcsIGlmIG5lY2Vzc2FyeVxuICBcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMucGFyZW50ICYmICF0aGlzLmlzb2xhdGVkKSB7XG4gIFx0XHRpZiAoc2hhcmVkX3Jlc29sdmVSZWYodGhpcywga2V5cGF0aC5zdHIsIHRoaXMuY29tcG9uZW50LnBhcmVudEZyYWdtZW50KSkge1xuICBcdFx0XHQvLyBjcmVhdGVzIGJpbmRpbmcgYXMgc2lkZS1lZmZlY3QsIGlmIGFwcHJvcHJpYXRlXG4gIFx0XHRcdHZhbHVlID0gdGhpcy52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHZhciBpbnNlcnQgPSBSYWN0aXZlJGluc2VydDtcblxuICB2YXIgaW5zZXJ0SG9vayA9IG5ldyBob29rc19Ib29rKFwiaW5zZXJ0XCIpO1xuICBmdW5jdGlvbiBSYWN0aXZlJGluc2VydCh0YXJnZXQsIGFuY2hvcikge1xuICBcdGlmICghdGhpcy5mcmFnbWVudC5yZW5kZXJlZCkge1xuICBcdFx0Ly8gVE9ETyBjcmVhdGUsIGFuZCBsaW5rIHRvLCBkb2N1bWVudGF0aW9uIGV4cGxhaW5pbmcgdGhpc1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIEFQSSBoYXMgY2hhbmdlZCAtIHlvdSBtdXN0IGNhbGwgYHJhY3RpdmUucmVuZGVyKHRhcmdldFssIGFuY2hvcl0pYCB0byByZW5kZXIgeW91ciBSYWN0aXZlIGluc3RhbmNlLiBPbmNlIHJlbmRlcmVkIHlvdSBjYW4gdXNlIGByYWN0aXZlLmluc2VydCgpYC5cIik7XG4gIFx0fVxuXG4gIFx0dGFyZ2V0ID0gZ2V0RWxlbWVudCh0YXJnZXQpO1xuICBcdGFuY2hvciA9IGdldEVsZW1lbnQoYW5jaG9yKSB8fCBudWxsO1xuXG4gIFx0aWYgKCF0YXJnZXQpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHNwZWNpZnkgYSB2YWxpZCB0YXJnZXQgdG8gaW5zZXJ0IGludG9cIik7XG4gIFx0fVxuXG4gIFx0dGFyZ2V0Lmluc2VydEJlZm9yZSh0aGlzLmRldGFjaCgpLCBhbmNob3IpO1xuICBcdHRoaXMuZWwgPSB0YXJnZXQ7XG5cbiAgXHQodGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXyB8fCAodGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXyA9IFtdKSkucHVzaCh0aGlzKTtcbiAgXHR0aGlzLmRldGFjaGVkID0gbnVsbDtcblxuICBcdGZpcmVJbnNlcnRIb29rKHRoaXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyZUluc2VydEhvb2socmFjdGl2ZSkge1xuICBcdGluc2VydEhvb2suZmlyZShyYWN0aXZlKTtcblxuICBcdHJhY3RpdmUuZmluZEFsbENvbXBvbmVudHMoXCIqXCIpLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gIFx0XHRmaXJlSW5zZXJ0SG9vayhjaGlsZC5pbnN0YW5jZSk7XG4gIFx0fSk7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX21lcmdlID0gUmFjdGl2ZSRtZXJnZTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRtZXJnZShrZXlwYXRoLCBhcnJheSwgb3B0aW9ucykge1xuICBcdHZhciBjdXJyZW50QXJyYXksIHByb21pc2U7XG5cbiAgXHRrZXlwYXRoID0gZ2V0S2V5cGF0aChub3JtYWxpc2Uoa2V5cGF0aCkpO1xuICBcdGN1cnJlbnRBcnJheSA9IHRoaXMudmlld21vZGVsLmdldChrZXlwYXRoKTtcblxuICBcdC8vIElmIGVpdGhlciB0aGUgZXhpc3RpbmcgdmFsdWUgb3IgdGhlIG5ldyB2YWx1ZSBpc24ndCBhblxuICBcdC8vIGFycmF5LCBqdXN0IGRvIGEgcmVndWxhciBzZXRcbiAgXHRpZiAoIWlzQXJyYXkoY3VycmVudEFycmF5KSB8fCAhaXNBcnJheShhcnJheSkpIHtcbiAgXHRcdHJldHVybiB0aGlzLnNldChrZXlwYXRoLCBhcnJheSwgb3B0aW9ucyAmJiBvcHRpb25zLmNvbXBsZXRlKTtcbiAgXHR9XG5cbiAgXHQvLyBNYW5hZ2UgdHJhbnNpdGlvbnNcbiAgXHRwcm9taXNlID0gZ2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcywgdHJ1ZSk7XG4gIFx0dGhpcy52aWV3bW9kZWwubWVyZ2Uoa2V5cGF0aCwgY3VycmVudEFycmF5LCBhcnJheSwgb3B0aW9ucyk7XG4gIFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG5cbiAgXHRyZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIChyYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICBcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG4gIFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIFx0dGhpcy5kZWZlciA9IG9wdGlvbnMuZGVmZXI7XG5cbiAgXHQvLyBkZWZhdWx0IHRvIHJvb3QgYXMgY29udGV4dCwgYnV0IGFsbG93IGl0IHRvIGJlIG92ZXJyaWRkZW5cbiAgXHR0aGlzLmNvbnRleHQgPSBvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCA/IG9wdGlvbnMuY29udGV4dCA6IHJhY3RpdmU7XG4gIH07XG5cbiAgT2JzZXJ2ZXIucHJvdG90eXBlID0ge1xuICBcdGluaXQ6IGZ1bmN0aW9uIChpbW1lZGlhdGUpIHtcbiAgXHRcdHRoaXMudmFsdWUgPSB0aGlzLnJvb3QuZ2V0KHRoaXMua2V5cGF0aC5zdHIpO1xuXG4gIFx0XHRpZiAoaW1tZWRpYXRlICE9PSBmYWxzZSkge1xuICBcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5vbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdGlmICghaXNFcXVhbCh2YWx1ZSwgdGhpcy52YWx1ZSkpIHtcbiAgXHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXG4gIFx0XHRcdGlmICh0aGlzLmRlZmVyICYmIHRoaXMucmVhZHkpIHtcbiAgXHRcdFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0cmV0dXJuIF90aGlzLnVwZGF0ZSgpO1xuICBcdFx0XHRcdH0pO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHRoaXMudXBkYXRlKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBQcmV2ZW50IGluZmluaXRlIGxvb3BzXG4gIFx0XHRpZiAodGhpcy51cGRhdGluZykge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuXG4gIFx0XHR0aGlzLmNhbGxiYWNrLmNhbGwodGhpcy5jb250ZXh0LCB0aGlzLnZhbHVlLCB0aGlzLm9sZFZhbHVlLCB0aGlzLmtleXBhdGguc3RyKTtcbiAgXHRcdHRoaXMub2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuXG4gIFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBvYnNlcnZlX09ic2VydmVyID0gT2JzZXJ2ZXI7XG5cbiAgdmFyIG9ic2VydmVfZ2V0UGF0dGVybiA9IGdldFBhdHRlcm47XG4gIGZ1bmN0aW9uIGdldFBhdHRlcm4ocmFjdGl2ZSwgcGF0dGVybikge1xuICBcdHZhciBtYXRjaGluZ0tleXBhdGhzLCB2YWx1ZXM7XG5cbiAgXHRtYXRjaGluZ0tleXBhdGhzID0gZ2V0TWF0Y2hpbmdLZXlwYXRocyhyYWN0aXZlLCBwYXR0ZXJuKTtcblxuICBcdHZhbHVlcyA9IHt9O1xuICBcdG1hdGNoaW5nS2V5cGF0aHMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0dmFsdWVzW2tleXBhdGguc3RyXSA9IHJhY3RpdmUuZ2V0KGtleXBhdGguc3RyKTtcbiAgXHR9KTtcblxuICBcdHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICB2YXIgUGF0dGVybk9ic2VydmVyLFxuICAgICAgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgUGF0dGVybk9ic2VydmVyID0gZnVuY3Rpb24gKHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcblxuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgXHR0aGlzLmRlZmVyID0gb3B0aW9ucy5kZWZlcjtcblxuICBcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0dGhpcy5yZWdleCA9IG5ldyBSZWdFeHAoXCJeXCIgKyBrZXlwYXRoLnN0ci5yZXBsYWNlKC9cXC4vZywgXCJcXFxcLlwiKS5yZXBsYWNlKC9cXCovZywgXCIoW15cXFxcLl0rKVwiKSArIFwiJFwiKTtcbiAgXHR0aGlzLnZhbHVlcyA9IHt9O1xuXG4gIFx0aWYgKHRoaXMuZGVmZXIpIHtcbiAgXHRcdHRoaXMucHJveGllcyA9IFtdO1xuICBcdH1cblxuICBcdC8vIGRlZmF1bHQgdG8gcm9vdCBhcyBjb250ZXh0LCBidXQgYWxsb3cgaXQgdG8gYmUgb3ZlcnJpZGRlblxuICBcdHRoaXMuY29udGV4dCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0ID8gb3B0aW9ucy5jb250ZXh0IDogcmFjdGl2ZTtcbiAgfTtcblxuICBQYXR0ZXJuT2JzZXJ2ZXIucHJvdG90eXBlID0ge1xuICBcdGluaXQ6IGZ1bmN0aW9uIChpbW1lZGlhdGUpIHtcbiAgXHRcdHZhciB2YWx1ZXMsIGtleXBhdGg7XG5cbiAgXHRcdHZhbHVlcyA9IG9ic2VydmVfZ2V0UGF0dGVybih0aGlzLnJvb3QsIHRoaXMua2V5cGF0aCk7XG5cbiAgXHRcdGlmIChpbW1lZGlhdGUgIT09IGZhbHNlKSB7XG4gIFx0XHRcdGZvciAoa2V5cGF0aCBpbiB2YWx1ZXMpIHtcbiAgXHRcdFx0XHRpZiAodmFsdWVzLmhhc093blByb3BlcnR5KGtleXBhdGgpKSB7XG4gIFx0XHRcdFx0XHR0aGlzLnVwZGF0ZShnZXRLZXlwYXRoKGtleXBhdGgpKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1cGRhdGU6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgdmFsdWVzO1xuXG4gIFx0XHRpZiAoa2V5cGF0aC5pc1BhdHRlcm4pIHtcbiAgXHRcdFx0dmFsdWVzID0gb2JzZXJ2ZV9nZXRQYXR0ZXJuKHRoaXMucm9vdCwga2V5cGF0aCk7XG5cbiAgXHRcdFx0Zm9yIChrZXlwYXRoIGluIHZhbHVlcykge1xuICBcdFx0XHRcdGlmICh2YWx1ZXMuaGFzT3duUHJvcGVydHkoa2V5cGF0aCkpIHtcbiAgXHRcdFx0XHRcdHRoaXMudXBkYXRlKGdldEtleXBhdGgoa2V5cGF0aCkpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gYXJyYXkgbXV0YXRpb24gc2hvdWxkIG5vdCB0cmlnZ2VyIGBhcnJheS4qYFxuICBcdFx0Ly8gcGF0dGVybiBvYnNlcnZlciB3aXRoIGBhcnJheS5sZW5ndGhgXG4gIFx0XHRpZiAodGhpcy5yb290LnZpZXdtb2RlbC5pbXBsaWNpdENoYW5nZXNba2V5cGF0aC5zdHJdKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMuZGVmZXIgJiYgdGhpcy5yZWFkeSkge1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdHJldHVybiBfdGhpcy5nZXRQcm94eShrZXlwYXRoKS51cGRhdGUoKTtcbiAgXHRcdFx0fSk7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5yZWFsbHlVcGRhdGUoa2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdHJlYWxseVVwZGF0ZTogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHZhciBrZXlwYXRoU3RyLCB2YWx1ZSwga2V5cywgYXJncztcblxuICBcdFx0a2V5cGF0aFN0ciA9IGtleXBhdGguc3RyO1xuICBcdFx0dmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldChrZXlwYXRoKTtcblxuICBcdFx0Ly8gUHJldmVudCBpbmZpbml0ZSBsb29wc1xuICBcdFx0aWYgKHRoaXMudXBkYXRpbmcpIHtcbiAgXHRcdFx0dGhpcy52YWx1ZXNba2V5cGF0aFN0cl0gPSB2YWx1ZTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblxuICBcdFx0aWYgKCFpc0VxdWFsKHZhbHVlLCB0aGlzLnZhbHVlc1trZXlwYXRoU3RyXSkgfHwgIXRoaXMucmVhZHkpIHtcbiAgXHRcdFx0a2V5cyA9IHNsaWNlLmNhbGwodGhpcy5yZWdleC5leGVjKGtleXBhdGhTdHIpLCAxKTtcbiAgXHRcdFx0YXJncyA9IFt2YWx1ZSwgdGhpcy52YWx1ZXNba2V5cGF0aFN0cl0sIGtleXBhdGhTdHJdLmNvbmNhdChrZXlzKTtcblxuICBcdFx0XHR0aGlzLnZhbHVlc1trZXlwYXRoU3RyXSA9IHZhbHVlO1xuICBcdFx0XHR0aGlzLmNhbGxiYWNrLmFwcGx5KHRoaXMuY29udGV4dCwgYXJncyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcbiAgXHR9LFxuXG4gIFx0Z2V0UHJveHk6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHRpZiAoIXRoaXMucHJveGllc1trZXlwYXRoLnN0cl0pIHtcbiAgXHRcdFx0dGhpcy5wcm94aWVzW2tleXBhdGguc3RyXSA9IHtcbiAgXHRcdFx0XHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRcdHJldHVybiBfdGhpcy5yZWFsbHlVcGRhdGUoa2V5cGF0aCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdGhpcy5wcm94aWVzW2tleXBhdGguc3RyXTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIG9ic2VydmVfUGF0dGVybk9ic2VydmVyID0gUGF0dGVybk9ic2VydmVyO1xuXG4gIHZhciBvYnNlcnZlX2dldE9ic2VydmVyRmFjYWRlID0gZ2V0T2JzZXJ2ZXJGYWNhZGU7XG4gIHZhciBlbXB0eU9iamVjdCA9IHt9O1xuICBmdW5jdGlvbiBnZXRPYnNlcnZlckZhY2FkZShyYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICBcdHZhciBvYnNlcnZlciwgaXNQYXR0ZXJuT2JzZXJ2ZXIsIGNhbmNlbGxlZDtcblxuICBcdGtleXBhdGggPSBnZXRLZXlwYXRoKG5vcm1hbGlzZShrZXlwYXRoKSk7XG4gIFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwgZW1wdHlPYmplY3Q7XG5cbiAgXHQvLyBwYXR0ZXJuIG9ic2VydmVycyBhcmUgdHJlYXRlZCBkaWZmZXJlbnRseVxuICBcdGlmIChrZXlwYXRoLmlzUGF0dGVybikge1xuICBcdFx0b2JzZXJ2ZXIgPSBuZXcgb2JzZXJ2ZV9QYXR0ZXJuT2JzZXJ2ZXIocmFjdGl2ZSwga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICBcdFx0cmFjdGl2ZS52aWV3bW9kZWwucGF0dGVybk9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgXHRcdGlzUGF0dGVybk9ic2VydmVyID0gdHJ1ZTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0b2JzZXJ2ZXIgPSBuZXcgb2JzZXJ2ZV9PYnNlcnZlcihyYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gIFx0fVxuXG4gIFx0b2JzZXJ2ZXIuaW5pdChvcHRpb25zLmluaXQpO1xuICBcdHJhY3RpdmUudmlld21vZGVsLnJlZ2lzdGVyKGtleXBhdGgsIG9ic2VydmVyLCBpc1BhdHRlcm5PYnNlcnZlciA/IFwicGF0dGVybk9ic2VydmVyc1wiIDogXCJvYnNlcnZlcnNcIik7XG5cbiAgXHQvLyBUaGlzIGZsYWcgYWxsb3dzIG9ic2VydmVycyB0byBpbml0aWFsaXNlIGV2ZW4gd2l0aCB1bmRlZmluZWQgdmFsdWVzXG4gIFx0b2JzZXJ2ZXIucmVhZHkgPSB0cnVlO1xuXG4gIFx0dmFyIGZhY2FkZSA9IHtcbiAgXHRcdGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICBcdFx0XHR2YXIgaW5kZXg7XG5cbiAgXHRcdFx0aWYgKGNhbmNlbGxlZCkge1xuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChpc1BhdHRlcm5PYnNlcnZlcikge1xuICBcdFx0XHRcdGluZGV4ID0gcmFjdGl2ZS52aWV3bW9kZWwucGF0dGVybk9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKTtcblxuICBcdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC51bnJlZ2lzdGVyKGtleXBhdGgsIG9ic2VydmVyLCBcInBhdHRlcm5PYnNlcnZlcnNcIik7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwudW5yZWdpc3RlcihrZXlwYXRoLCBvYnNlcnZlciwgXCJvYnNlcnZlcnNcIik7XG4gIFx0XHRcdH1cbiAgXHRcdFx0Y2FuY2VsbGVkID0gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0cmFjdGl2ZS5fb2JzZXJ2ZXJzLnB1c2goZmFjYWRlKTtcbiAgXHRyZXR1cm4gZmFjYWRlO1xuICB9XG5cbiAgdmFyIG9ic2VydmUgPSBSYWN0aXZlJG9ic2VydmU7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkb2JzZXJ2ZShrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucykge1xuXG4gIFx0dmFyIG9ic2VydmVycywgbWFwLCBrZXlwYXRocywgaTtcblxuICBcdC8vIEFsbG93IGEgbWFwIG9mIGtleXBhdGhzIHRvIGhhbmRsZXJzXG4gIFx0aWYgKGlzT2JqZWN0KGtleXBhdGgpKSB7XG4gIFx0XHRvcHRpb25zID0gY2FsbGJhY2s7XG4gIFx0XHRtYXAgPSBrZXlwYXRoO1xuXG4gIFx0XHRvYnNlcnZlcnMgPSBbXTtcblxuICBcdFx0Zm9yIChrZXlwYXRoIGluIG1hcCkge1xuICBcdFx0XHRpZiAobWFwLmhhc093blByb3BlcnR5KGtleXBhdGgpKSB7XG4gIFx0XHRcdFx0Y2FsbGJhY2sgPSBtYXBba2V5cGF0aF07XG4gIFx0XHRcdFx0b2JzZXJ2ZXJzLnB1c2godGhpcy5vYnNlcnZlKGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0Y2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0d2hpbGUgKG9ic2VydmVycy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRcdG9ic2VydmVycy5wb3AoKS5jYW5jZWwoKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0Ly8gQWxsb3cgYHJhY3RpdmUub2JzZXJ2ZSggY2FsbGJhY2sgKWAgLSBpLmUuIG9ic2VydmUgZW50aXJlIG1vZGVsXG4gIFx0aWYgKHR5cGVvZiBrZXlwYXRoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdG9wdGlvbnMgPSBjYWxsYmFjaztcbiAgXHRcdGNhbGxiYWNrID0ga2V5cGF0aDtcbiAgXHRcdGtleXBhdGggPSBcIlwiO1xuXG4gIFx0XHRyZXR1cm4gb2JzZXJ2ZV9nZXRPYnNlcnZlckZhY2FkZSh0aGlzLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gIFx0fVxuXG4gIFx0a2V5cGF0aHMgPSBrZXlwYXRoLnNwbGl0KFwiIFwiKTtcblxuICBcdC8vIFNpbmdsZSBrZXlwYXRoXG4gIFx0aWYgKGtleXBhdGhzLmxlbmd0aCA9PT0gMSkge1xuICBcdFx0cmV0dXJuIG9ic2VydmVfZ2V0T2JzZXJ2ZXJGYWNhZGUodGhpcywga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICBcdH1cblxuICBcdC8vIE11bHRpcGxlIHNwYWNlLXNlcGFyYXRlZCBrZXlwYXRoc1xuICBcdG9ic2VydmVycyA9IFtdO1xuXG4gIFx0aSA9IGtleXBhdGhzLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRrZXlwYXRoID0ga2V5cGF0aHNbaV07XG5cbiAgXHRcdGlmIChrZXlwYXRoKSB7XG4gIFx0XHRcdG9ic2VydmVycy5wdXNoKG9ic2VydmVfZ2V0T2JzZXJ2ZXJGYWNhZGUodGhpcywga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0Y2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHdoaWxlIChvYnNlcnZlcnMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0b2JzZXJ2ZXJzLnBvcCgpLmNhbmNlbCgpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fTtcbiAgfVxuXG4gIHZhciBvYnNlcnZlT25jZSA9IFJhY3RpdmUkb2JzZXJ2ZU9uY2U7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRvYnNlcnZlT25jZShwcm9wZXJ0eSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcblxuICBcdHZhciBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZShwcm9wZXJ0eSwgZnVuY3Rpb24gKCkge1xuICBcdFx0Y2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgXHRcdG9ic2VydmVyLmNhbmNlbCgpO1xuICBcdH0sIHsgaW5pdDogZmFsc2UsIGRlZmVyOiBvcHRpb25zICYmIG9wdGlvbnMuZGVmZXIgfSk7XG5cbiAgXHRyZXR1cm4gb2JzZXJ2ZXI7XG4gIH1cblxuICB2YXIgc2hhcmVkX3RyaW0gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50cmltKCk7XG4gIH07XG5cbiAgdmFyIG5vdEVtcHR5U3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIgIT09IFwiXCI7XG4gIH07XG5cbiAgdmFyIG9mZiA9IFJhY3RpdmUkb2ZmO1xuICBmdW5jdGlvbiBSYWN0aXZlJG9mZihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciBldmVudE5hbWVzO1xuXG4gIFx0Ly8gaWYgbm8gYXJndW1lbnRzIHNwZWNpZmllZCwgcmVtb3ZlIGFsbCBjYWxsYmFja3NcbiAgXHRpZiAoIWV2ZW50TmFtZSkge1xuICBcdFx0Ly8gVE9ETyB1c2UgdGhpcyBjb2RlIGluc3RlYWQsIG9uY2UgdGhlIGZvbGxvd2luZyBpc3N1ZSBoYXMgYmVlbiByZXNvbHZlZFxuICBcdFx0Ly8gaW4gUGhhbnRvbUpTICh0ZXN0cyBhcmUgdW5wYXNzYWJsZSBvdGhlcndpc2UhKVxuICBcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTE4NTZcbiAgXHRcdC8vIGRlZmluZVByb3BlcnR5KCB0aGlzLCAnX3N1YnMnLCB7IHZhbHVlOiBjcmVhdGUoIG51bGwgKSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICBcdFx0Zm9yIChldmVudE5hbWUgaW4gdGhpcy5fc3Vicykge1xuICBcdFx0XHRkZWxldGUgdGhpcy5fc3Vic1tldmVudE5hbWVdO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgc3BhY2Utc2VwYXJhdGVkIGV2ZW50IG5hbWVzXG4gIFx0XHRldmVudE5hbWVzID0gZXZlbnROYW1lLnNwbGl0KFwiIFwiKS5tYXAoc2hhcmVkX3RyaW0pLmZpbHRlcihub3RFbXB0eVN0cmluZyk7XG5cbiAgXHRcdGV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gIFx0XHRcdHZhciBzdWJzY3JpYmVycywgaW5kZXg7XG5cbiAgXHRcdFx0Ly8gSWYgd2UgaGF2ZSBzdWJzY3JpYmVycyBmb3IgdGhpcyBldmVudC4uLlxuICBcdFx0XHRpZiAoc3Vic2NyaWJlcnMgPSBfdGhpcy5fc3Vic1tldmVudE5hbWVdKSB7XG4gIFx0XHRcdFx0Ly8gLi4uaWYgYSBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCBvbmx5IHJlbW92ZSB0aGF0XG4gIFx0XHRcdFx0aWYgKGNhbGxiYWNrKSB7XG4gIFx0XHRcdFx0XHRpbmRleCA9IHN1YnNjcmliZXJzLmluZGV4T2YoY2FsbGJhY2spO1xuICBcdFx0XHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0XHRcdFx0XHRzdWJzY3JpYmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSByZW1vdmUgYWxsIGNhbGxiYWNrc1xuICBcdFx0XHRcdGVsc2Uge1xuICBcdFx0XHRcdFx0X3RoaXMuX3N1YnNbZXZlbnROYW1lXSA9IFtdO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgb24gPSBSYWN0aXZlJG9uO1xuICBmdW5jdGlvbiBSYWN0aXZlJG9uKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIGxpc3RlbmVycywgbiwgZXZlbnROYW1lcztcblxuICBcdC8vIGFsbG93IG11dGxpcGxlIGxpc3RlbmVycyB0byBiZSBib3VuZCBpbiBvbmUgZ29cbiAgXHRpZiAodHlwZW9mIGV2ZW50TmFtZSA9PT0gXCJvYmplY3RcIikge1xuICBcdFx0bGlzdGVuZXJzID0gW107XG5cbiAgXHRcdGZvciAobiBpbiBldmVudE5hbWUpIHtcbiAgXHRcdFx0aWYgKGV2ZW50TmFtZS5oYXNPd25Qcm9wZXJ0eShuKSkge1xuICBcdFx0XHRcdGxpc3RlbmVycy5wdXNoKHRoaXMub24obiwgZXZlbnROYW1lW25dKSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0Y2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0dmFyIGxpc3RlbmVyO1xuXG4gIFx0XHRcdFx0d2hpbGUgKGxpc3RlbmVyID0gbGlzdGVuZXJzLnBvcCgpKSB7XG4gIFx0XHRcdFx0XHRsaXN0ZW5lci5jYW5jZWwoKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0Ly8gSGFuZGxlIG11bHRpcGxlIHNwYWNlLXNlcGFyYXRlZCBldmVudCBuYW1lc1xuICBcdGV2ZW50TmFtZXMgPSBldmVudE5hbWUuc3BsaXQoXCIgXCIpLm1hcChzaGFyZWRfdHJpbSkuZmlsdGVyKG5vdEVtcHR5U3RyaW5nKTtcblxuICBcdGV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gIFx0XHQoX3RoaXMuX3N1YnNbZXZlbnROYW1lXSB8fCAoX3RoaXMuX3N1YnNbZXZlbnROYW1lXSA9IFtdKSkucHVzaChjYWxsYmFjayk7XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0Y2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHJldHVybiBfdGhpcy5vZmYoZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gIFx0XHR9XG4gIFx0fTtcbiAgfVxuXG4gIHZhciBvbmNlID0gUmFjdGl2ZSRvbmNlO1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkb25jZShldmVudE5hbWUsIGhhbmRsZXIpIHtcblxuICBcdHZhciBsaXN0ZW5lciA9IHRoaXMub24oZXZlbnROYW1lLCBmdW5jdGlvbiAoKSB7XG4gIFx0XHRoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIFx0XHRsaXN0ZW5lci5jYW5jZWwoKTtcbiAgXHR9KTtcblxuICBcdC8vIHNvIHdlIGNhbiBzdGlsbCBkbyBsaXN0ZW5lci5jYW5jZWwoKSBtYW51YWxseVxuICBcdHJldHVybiBsaXN0ZW5lcjtcbiAgfVxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgYW4gYXJyYXksIHRoZSBuYW1lIG9mIGEgbXV0YXRvciBtZXRob2QsIGFuZCB0aGVcbiAgLy8gYXJndW1lbnRzIHRvIGNhbGwgdGhhdCBtdXRhdG9yIG1ldGhvZCB3aXRoLCBhbmQgcmV0dXJucyBhbiBhcnJheSB0aGF0XG4gIC8vIG1hcHMgdGhlIG9sZCBpbmRpY2VzIHRvIHRoZWlyIG5ldyBpbmRpY2VzLlxuXG4gIC8vIFNvIGlmIHlvdSBoYWQgc29tZXRoaW5nIGxpa2UgdGhpcy4uLlxuICAvL1xuICAvLyAgICAgYXJyYXkgPSBbICdhJywgJ2InLCAnYycsICdkJyBdO1xuICAvLyAgICAgYXJyYXkucHVzaCggJ2UnICk7XG4gIC8vXG4gIC8vIC4uLnlvdSdkIGdldCBgWyAwLCAxLCAyLCAzIF1gIC0gaW4gb3RoZXIgd29yZHMsIG5vbmUgb2YgdGhlIG9sZCBpbmRpY2VzXG4gIC8vIGhhdmUgY2hhbmdlZC4gSWYgeW91IHRoZW4gZGlkIHRoaXMuLi5cbiAgLy9cbiAgLy8gICAgIGFycmF5LnVuc2hpZnQoICd6JyApO1xuICAvL1xuICAvLyAuLi50aGUgaW5kaWNlcyB3b3VsZCBiZSBgWyAxLCAyLCAzLCA0LCA1IF1gIC0gZXZlcnkgaXRlbSBoYXMgYmVlbiBtb3ZlZFxuICAvLyBvbmUgaGlnaGVyIHRvIG1ha2Ugcm9vbSBmb3IgdGhlICd6Jy4gSWYgeW91IHJlbW92ZWQgYW4gaXRlbSwgdGhlIG5ldyBpbmRleFxuICAvLyB3b3VsZCBiZSAtMS4uLlxuICAvL1xuICAvLyAgICAgYXJyYXkuc3BsaWNlKCAyLCAyICk7XG4gIC8vXG4gIC8vIC4uLnRoaXMgd291bGQgcmVzdWx0IGluIFsgMCwgMSwgLTEsIC0xLCAyLCAzIF0uXG4gIC8vXG4gIC8vIFRoaXMgaW5mb3JtYXRpb24gaXMgdXNlZCB0byBlbmFibGUgZmFzdCwgbm9uLWRlc3RydWN0aXZlIHNodWZmbGluZyBvZiBsaXN0XG4gIC8vIHNlY3Rpb25zIHdoZW4geW91IGRvIGUuZy4gYHJhY3RpdmUuc3BsaWNlKCAnaXRlbXMnLCAyLCAyICk7XG5cbiAgdmFyIHNoYXJlZF9nZXROZXdJbmRpY2VzID0gZ2V0TmV3SW5kaWNlcztcblxuICBmdW5jdGlvbiBnZXROZXdJbmRpY2VzKGFycmF5LCBtZXRob2ROYW1lLCBhcmdzKSB7XG4gIFx0dmFyIHNwbGljZUFyZ3VtZW50cyxcbiAgXHQgICAgbGVuLFxuICBcdCAgICBuZXdJbmRpY2VzID0gW10sXG4gIFx0ICAgIHJlbW92ZVN0YXJ0LFxuICBcdCAgICByZW1vdmVFbmQsXG4gIFx0ICAgIGJhbGFuY2UsXG4gIFx0ICAgIGk7XG5cbiAgXHRzcGxpY2VBcmd1bWVudHMgPSBnZXRTcGxpY2VFcXVpdmFsZW50KGFycmF5LCBtZXRob2ROYW1lLCBhcmdzKTtcblxuICBcdGlmICghc3BsaWNlQXJndW1lbnRzKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDsgLy8gVE9ETyBzdXBwb3J0IHJldmVyc2UgYW5kIHNvcnQ/XG4gIFx0fVxuXG4gIFx0bGVuID0gYXJyYXkubGVuZ3RoO1xuICBcdGJhbGFuY2UgPSBzcGxpY2VBcmd1bWVudHMubGVuZ3RoIC0gMiAtIHNwbGljZUFyZ3VtZW50c1sxXTtcblxuICBcdHJlbW92ZVN0YXJ0ID0gTWF0aC5taW4obGVuLCBzcGxpY2VBcmd1bWVudHNbMF0pO1xuICBcdHJlbW92ZUVuZCA9IHJlbW92ZVN0YXJ0ICsgc3BsaWNlQXJndW1lbnRzWzFdO1xuXG4gIFx0Zm9yIChpID0gMDsgaSA8IHJlbW92ZVN0YXJ0OyBpICs9IDEpIHtcbiAgXHRcdG5ld0luZGljZXMucHVzaChpKTtcbiAgXHR9XG5cbiAgXHRmb3IgKDsgaSA8IHJlbW92ZUVuZDsgaSArPSAxKSB7XG4gIFx0XHRuZXdJbmRpY2VzLnB1c2goLTEpO1xuICBcdH1cblxuICBcdGZvciAoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdG5ld0luZGljZXMucHVzaChpICsgYmFsYW5jZSk7XG4gIFx0fVxuXG4gIFx0Ly8gdGhlcmUgaXMgYSBuZXQgc2hpZnQgZm9yIHRoZSByZXN0IG9mIHRoZSBhcnJheSBzdGFydGluZyB3aXRoIGluZGV4ICsgYmFsYW5jZVxuICBcdGlmIChiYWxhbmNlICE9PSAwKSB7XG4gIFx0XHRuZXdJbmRpY2VzLnRvdWNoZWRGcm9tID0gc3BsaWNlQXJndW1lbnRzWzBdO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRuZXdJbmRpY2VzLnRvdWNoZWRGcm9tID0gYXJyYXkubGVuZ3RoO1xuICBcdH1cblxuICBcdHJldHVybiBuZXdJbmRpY2VzO1xuICB9XG5cbiAgLy8gVGhlIHBvcCwgcHVzaCwgc2hpZnQgYW4gdW5zaGlmdCBtZXRob2RzIGNhbiBhbGwgYmUgcmVwcmVzZW50ZWRcbiAgLy8gYXMgYW4gZXF1aXZhbGVudCBzcGxpY2VcbiAgZnVuY3Rpb24gZ2V0U3BsaWNlRXF1aXZhbGVudChhcnJheSwgbWV0aG9kTmFtZSwgYXJncykge1xuICBcdHN3aXRjaCAobWV0aG9kTmFtZSkge1xuICBcdFx0Y2FzZSBcInNwbGljZVwiOlxuICBcdFx0XHRpZiAoYXJnc1swXSAhPT0gdW5kZWZpbmVkICYmIGFyZ3NbMF0gPCAwKSB7XG4gIFx0XHRcdFx0YXJnc1swXSA9IGFycmF5Lmxlbmd0aCArIE1hdGgubWF4KGFyZ3NbMF0sIC1hcnJheS5sZW5ndGgpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0d2hpbGUgKGFyZ3MubGVuZ3RoIDwgMikge1xuICBcdFx0XHRcdGFyZ3MucHVzaCgwKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIGVuc3VyZSB3ZSBvbmx5IHJlbW92ZSBlbGVtZW50cyB0aGF0IGV4aXN0XG4gIFx0XHRcdGFyZ3NbMV0gPSBNYXRoLm1pbihhcmdzWzFdLCBhcnJheS5sZW5ndGggLSBhcmdzWzBdKTtcblxuICBcdFx0XHRyZXR1cm4gYXJncztcblxuICBcdFx0Y2FzZSBcInNvcnRcIjpcbiAgXHRcdGNhc2UgXCJyZXZlcnNlXCI6XG4gIFx0XHRcdHJldHVybiBudWxsO1xuXG4gIFx0XHRjYXNlIFwicG9wXCI6XG4gIFx0XHRcdGlmIChhcnJheS5sZW5ndGgpIHtcbiAgXHRcdFx0XHRyZXR1cm4gW2FycmF5Lmxlbmd0aCAtIDEsIDFdO1xuICBcdFx0XHR9XG4gIFx0XHRcdHJldHVybiBbMCwgMF07XG5cbiAgXHRcdGNhc2UgXCJwdXNoXCI6XG4gIFx0XHRcdHJldHVybiBbYXJyYXkubGVuZ3RoLCAwXS5jb25jYXQoYXJncyk7XG5cbiAgXHRcdGNhc2UgXCJzaGlmdFwiOlxuICBcdFx0XHRyZXR1cm4gWzAsIGFycmF5Lmxlbmd0aCA/IDEgOiAwXTtcblxuICBcdFx0Y2FzZSBcInVuc2hpZnRcIjpcbiAgXHRcdFx0cmV0dXJuIFswLCAwXS5jb25jYXQoYXJncyk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbiAgdmFyIG1ha2VBcnJheU1ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gIFx0cmV0dXJuIGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgXHRcdFx0YXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBhcnJheSxcbiAgXHRcdCAgICBuZXdJbmRpY2VzID0gW10sXG4gIFx0XHQgICAgbGVuLFxuICBcdFx0ICAgIHByb21pc2UsXG4gIFx0XHQgICAgcmVzdWx0O1xuXG4gIFx0XHRrZXlwYXRoID0gZ2V0S2V5cGF0aChub3JtYWxpc2Uoa2V5cGF0aCkpO1xuXG4gIFx0XHRhcnJheSA9IHRoaXMudmlld21vZGVsLmdldChrZXlwYXRoKTtcbiAgXHRcdGxlbiA9IGFycmF5Lmxlbmd0aDtcblxuICBcdFx0aWYgKCFpc0FycmF5KGFycmF5KSkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgcmFjdGl2ZS5cIiArIG1ldGhvZE5hbWUgKyBcIignXCIgKyBrZXlwYXRoLnN0ciArIFwiJyksIGJ1dCAnXCIgKyBrZXlwYXRoLnN0ciArIFwiJyBkb2VzIG5vdCByZWZlciB0byBhbiBhcnJheVwiKTtcbiAgXHRcdH1cblxuICBcdFx0bmV3SW5kaWNlcyA9IHNoYXJlZF9nZXROZXdJbmRpY2VzKGFycmF5LCBtZXRob2ROYW1lLCBhcmdzKTtcblxuICBcdFx0cmVzdWx0ID0gYXJyYXlQcm90b1ttZXRob2ROYW1lXS5hcHBseShhcnJheSwgYXJncyk7XG4gIFx0XHRwcm9taXNlID0gZ2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcywgdHJ1ZSkudGhlbihmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHJldHVybiByZXN1bHQ7XG4gIFx0XHR9KTtcblxuICBcdFx0aWYgKCEhbmV3SW5kaWNlcykge1xuICBcdFx0XHR0aGlzLnZpZXdtb2RlbC5zbWFydFVwZGF0ZShrZXlwYXRoLCBhcnJheSwgbmV3SW5kaWNlcyk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKGtleXBhdGgpO1xuICBcdFx0fVxuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcblxuICBcdFx0cmV0dXJuIHByb21pc2U7XG4gIFx0fTtcbiAgfTtcblxuICB2YXIgcG9wID0gbWFrZUFycmF5TWV0aG9kKFwicG9wXCIpO1xuXG4gIHZhciBwdXNoID0gbWFrZUFycmF5TWV0aG9kKFwicHVzaFwiKTtcblxuICB2YXIgY3NzLFxuICAgICAgdXBkYXRlLFxuICAgICAgc3R5bGVFbGVtZW50LFxuICAgICAgaGVhZCxcbiAgICAgIHN0eWxlU2hlZXQsXG4gICAgICBpbkRvbSxcbiAgICAgIGdsb2JhbF9jc3NfX3ByZWZpeCA9IFwiLyogUmFjdGl2ZS5qcyBjb21wb25lbnQgc3R5bGVzICovXFxuXCIsXG4gICAgICBzdHlsZXMgPSBbXSxcbiAgICAgIGRpcnR5ID0gZmFsc2U7XG5cbiAgaWYgKCFpc0NsaWVudCkge1xuICBcdC8vIFRPRE8gaGFuZGxlIGVuY2Fwc3VsYXRlZCBDU1MgaW4gc2VydmVyLXJlbmRlcmVkIEhUTUwhXG4gIFx0Y3NzID0ge1xuICBcdFx0YWRkOiBub29wLFxuICBcdFx0YXBwbHk6IG5vb3BcbiAgXHR9O1xuICB9IGVsc2Uge1xuICBcdHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgXHRzdHlsZUVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcblxuICBcdGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG5cbiAgXHRpbkRvbSA9IGZhbHNlO1xuXG4gIFx0Ly8gSW50ZXJuZXQgRXhwbG9kZXIgd29uJ3QgbGV0IHlvdSB1c2Ugc3R5bGVTaGVldC5pbm5lckhUTUwgLSB3ZSBoYXZlIHRvXG4gIFx0Ly8gdXNlIHN0eWxlU2hlZXQuY3NzVGV4dCBpbnN0ZWFkXG4gIFx0c3R5bGVTaGVldCA9IHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0O1xuXG4gIFx0dXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGNzcyA9IGdsb2JhbF9jc3NfX3ByZWZpeCArIHN0eWxlcy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgXHRcdFx0cmV0dXJuIFwiXFxuLyoge1wiICsgcy5pZCArIFwifSAqL1xcblwiICsgcy5zdHlsZXM7XG4gIFx0XHR9KS5qb2luKFwiXFxuXCIpO1xuXG4gIFx0XHRpZiAoc3R5bGVTaGVldCkge1xuICBcdFx0XHRzdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRzdHlsZUVsZW1lbnQuaW5uZXJIVE1MID0gY3NzO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIWluRG9tKSB7XG4gIFx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcbiAgXHRcdFx0aW5Eb20gPSB0cnVlO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRjc3MgPSB7XG4gIFx0XHRhZGQ6IGZ1bmN0aW9uIChzKSB7XG4gIFx0XHRcdHN0eWxlcy5wdXNoKHMpO1xuICBcdFx0XHRkaXJ0eSA9IHRydWU7XG4gIFx0XHR9LFxuXG4gIFx0XHRhcHBseTogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRpZiAoZGlydHkpIHtcbiAgXHRcdFx0XHR1cGRhdGUoKTtcbiAgXHRcdFx0XHRkaXJ0eSA9IGZhbHNlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fTtcbiAgfVxuXG4gIHZhciBnbG9iYWxfY3NzID0gY3NzO1xuXG4gIHZhciBwcm90b3R5cGVfcmVuZGVyID0gUmFjdGl2ZSRyZW5kZXI7XG5cbiAgdmFyIHJlbmRlckhvb2sgPSBuZXcgaG9va3NfSG9vayhcInJlbmRlclwiKSxcbiAgICAgIGNvbXBsZXRlSG9vayA9IG5ldyBob29rc19Ib29rKFwiY29tcGxldGVcIik7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkcmVuZGVyKHRhcmdldCwgYW5jaG9yKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciBwcm9taXNlLCBpbnN0YW5jZXMsIHRyYW5zaXRpb25zRW5hYmxlZDtcblxuICBcdC8vIGlmIGBub0ludHJvYCBpcyBgdHJ1ZWAsIHRlbXBvcmFyaWx5IGRpc2FibGUgdHJhbnNpdGlvbnNcbiAgXHR0cmFuc2l0aW9uc0VuYWJsZWQgPSB0aGlzLnRyYW5zaXRpb25zRW5hYmxlZDtcbiAgXHRpZiAodGhpcy5ub0ludHJvKSB7XG4gIFx0XHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IGZhbHNlO1xuICBcdH1cblxuICBcdHByb21pc2UgPSBnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLCB0cnVlKTtcbiAgXHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHJlbmRlckhvb2suZmlyZShfdGhpcyk7XG4gIFx0fSwgdHJ1ZSk7XG5cbiAgXHRpZiAodGhpcy5mcmFnbWVudC5yZW5kZXJlZCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBjYWxsIHJhY3RpdmUucmVuZGVyKCkgb24gYW4gYWxyZWFkeSByZW5kZXJlZCBpbnN0YW5jZSEgQ2FsbCByYWN0aXZlLnVucmVuZGVyKCkgZmlyc3RcIik7XG4gIFx0fVxuXG4gIFx0dGFyZ2V0ID0gZ2V0RWxlbWVudCh0YXJnZXQpIHx8IHRoaXMuZWw7XG4gIFx0YW5jaG9yID0gZ2V0RWxlbWVudChhbmNob3IpIHx8IHRoaXMuYW5jaG9yO1xuXG4gIFx0dGhpcy5lbCA9IHRhcmdldDtcbiAgXHR0aGlzLmFuY2hvciA9IGFuY2hvcjtcblxuICBcdGlmICghdGhpcy5hcHBlbmQgJiYgdGFyZ2V0KSB7XG4gIFx0XHQvLyBUZWFyZG93biBhbnkgZXhpc3RpbmcgaW5zdGFuY2VzICpiZWZvcmUqIHRyeWluZyB0byBzZXQgdXAgdGhlIG5ldyBvbmUgLVxuICBcdFx0Ly8gYXZvaWRzIGNlcnRhaW4gd2VpcmQgYnVnc1xuICBcdFx0dmFyIG90aGVycyA9IHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX187XG4gIFx0XHRpZiAob3RoZXJzICYmIG90aGVycy5sZW5ndGgpIHtcbiAgXHRcdFx0cmVtb3ZlT3RoZXJJbnN0YW5jZXMob3RoZXJzKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gbWFrZSBzdXJlIHdlIGFyZSB0aGUgb25seSBvY2N1cGFudHNcbiAgXHRcdHRhcmdldC5pbm5lckhUTUwgPSBcIlwiOyAvLyBUT0RPIGlzIHRoaXMgcXVpY2tlciB0aGFuIHJlbW92ZUNoaWxkPyBJbml0aWFsIHJlc2VhcmNoIGluY29uY2x1c2l2ZVxuICBcdH1cblxuICBcdGlmICh0aGlzLmNzc0lkKSB7XG4gIFx0XHQvLyBlbnN1cmUgZW5jYXBzdWxhdGVkIENTUyBpcyB1cC10by1kYXRlXG4gIFx0XHRnbG9iYWxfY3NzLmFwcGx5KCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRhcmdldCkge1xuICBcdFx0aWYgKCEoaW5zdGFuY2VzID0gdGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXykpIHtcbiAgXHRcdFx0dGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXyA9IFt0aGlzXTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGluc3RhbmNlcy5wdXNoKHRoaXMpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoYW5jaG9yKSB7XG4gIFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUodGhpcy5mcmFnbWVudC5yZW5kZXIoKSwgYW5jaG9yKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCh0aGlzLmZyYWdtZW50LnJlbmRlcigpKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcblxuICBcdHRoaXMudHJhbnNpdGlvbnNFbmFibGVkID0gdHJhbnNpdGlvbnNFbmFibGVkO1xuXG4gIFx0cmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gY29tcGxldGVIb29rLmZpcmUoX3RoaXMpO1xuICBcdH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlT3RoZXJJbnN0YW5jZXMob3RoZXJzKSB7XG4gIFx0b3RoZXJzLnNwbGljZSgwLCBvdGhlcnMubGVuZ3RoKS5mb3JFYWNoKHRlYXJkb3duKTtcbiAgfVxuXG4gIHZhciBhZGFwdENvbmZpZ3VyYXRvciA9IHtcbiAgXHRleHRlbmQ6IGZ1bmN0aW9uIChQYXJlbnQsIHByb3RvLCBvcHRpb25zKSB7XG4gIFx0XHRwcm90by5hZGFwdCA9IGN1c3RvbV9hZGFwdF9fY29tYmluZShwcm90by5hZGFwdCwgZW5zdXJlQXJyYXkob3B0aW9ucy5hZGFwdCkpO1xuICBcdH0sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7fVxuICB9O1xuXG4gIHZhciBjdXN0b21fYWRhcHQgPSBhZGFwdENvbmZpZ3VyYXRvcjtcblxuICBmdW5jdGlvbiBjdXN0b21fYWRhcHRfX2NvbWJpbmUoYSwgYikge1xuICBcdHZhciBjID0gYS5zbGljZSgpLFxuICBcdCAgICBpID0gYi5sZW5ndGg7XG5cbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpZiAoISB+Yy5pbmRleE9mKGJbaV0pKSB7XG4gIFx0XHRcdGMucHVzaChiW2ldKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gYztcbiAgfVxuXG4gIHZhciB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1Dc3M7XG5cbiAgdmFyIHNlbGVjdG9yc1BhdHRlcm4gPSAvKD86XnxcXH0pP1xccyooW15cXHtcXH1dKylcXHMqXFx7L2csXG4gICAgICBjb21tZW50c1BhdHRlcm4gPSAvXFwvXFwqLio/XFwqXFwvL2csXG4gICAgICBzZWxlY3RvclVuaXRQYXR0ZXJuID0gLygoPzooPzpcXFtbXlxcXStdXFxdKXwoPzpbXlxcc1xcK1xcPlxcfjpdKSkrKSgoPzo6W15cXHNcXCtcXD5cXH5cXChdKyg/OlxcKFteXFwpXStcXCkpPyk/XFxzKltcXHNcXCtcXD5cXH5dPylcXHMqL2csXG4gICAgICBtZWRpYVF1ZXJ5UGF0dGVybiA9IC9eQG1lZGlhLyxcbiAgICAgIGRhdGFSdmNHdWlkUGF0dGVybiA9IC9cXFtkYXRhLXJhY3RpdmUtY3Nzfj1cIlxce1thLXowLTktXStcXH1cIl0vZztcbiAgZnVuY3Rpb24gdHJhbnNmb3JtQ3NzKGNzcywgaWQpIHtcbiAgXHR2YXIgdHJhbnNmb3JtZWQsIGRhdGFBdHRyLCBhZGRHdWlkO1xuXG4gIFx0ZGF0YUF0dHIgPSBcIltkYXRhLXJhY3RpdmUtY3Nzfj1cXFwie1wiICsgaWQgKyBcIn1cXFwiXVwiO1xuXG4gIFx0YWRkR3VpZCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICBcdFx0dmFyIHNlbGVjdG9yVW5pdHMsXG4gIFx0XHQgICAgbWF0Y2gsXG4gIFx0XHQgICAgdW5pdCxcbiAgXHRcdCAgICBiYXNlLFxuICBcdFx0ICAgIHByZXBlbmRlZCxcbiAgXHRcdCAgICBhcHBlbmRlZCxcbiAgXHRcdCAgICBpLFxuICBcdFx0ICAgIHRyYW5zZm9ybWVkID0gW107XG5cbiAgXHRcdHNlbGVjdG9yVW5pdHMgPSBbXTtcblxuICBcdFx0d2hpbGUgKG1hdGNoID0gc2VsZWN0b3JVbml0UGF0dGVybi5leGVjKHNlbGVjdG9yKSkge1xuICBcdFx0XHRzZWxlY3RvclVuaXRzLnB1c2goe1xuICBcdFx0XHRcdHN0cjogbWF0Y2hbMF0sXG4gIFx0XHRcdFx0YmFzZTogbWF0Y2hbMV0sXG4gIFx0XHRcdFx0bW9kaWZpZXJzOiBtYXRjaFsyXVxuICBcdFx0XHR9KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gRm9yIGVhY2ggc2ltcGxlIHNlbGVjdG9yIHdpdGhpbiB0aGUgc2VsZWN0b3IsIHdlIG5lZWQgdG8gY3JlYXRlIGEgdmVyc2lvblxuICBcdFx0Ly8gdGhhdCBhKSBjb21iaW5lcyB3aXRoIHRoZSBpZCwgYW5kIGIpIGlzIGluc2lkZSB0aGUgaWRcbiAgXHRcdGJhc2UgPSBzZWxlY3RvclVuaXRzLm1hcChleHRyYWN0U3RyaW5nKTtcblxuICBcdFx0aSA9IHNlbGVjdG9yVW5pdHMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRhcHBlbmRlZCA9IGJhc2Uuc2xpY2UoKTtcblxuICBcdFx0XHQvLyBQc2V1ZG8tc2VsZWN0b3JzIHNob3VsZCBnbyBhZnRlciB0aGUgYXR0cmlidXRlIHNlbGVjdG9yXG4gIFx0XHRcdHVuaXQgPSBzZWxlY3RvclVuaXRzW2ldO1xuICBcdFx0XHRhcHBlbmRlZFtpXSA9IHVuaXQuYmFzZSArIGRhdGFBdHRyICsgdW5pdC5tb2RpZmllcnMgfHwgXCJcIjtcblxuICBcdFx0XHRwcmVwZW5kZWQgPSBiYXNlLnNsaWNlKCk7XG4gIFx0XHRcdHByZXBlbmRlZFtpXSA9IGRhdGFBdHRyICsgXCIgXCIgKyBwcmVwZW5kZWRbaV07XG5cbiAgXHRcdFx0dHJhbnNmb3JtZWQucHVzaChhcHBlbmRlZC5qb2luKFwiIFwiKSwgcHJlcGVuZGVkLmpvaW4oXCIgXCIpKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRyYW5zZm9ybWVkLmpvaW4oXCIsIFwiKTtcbiAgXHR9O1xuXG4gIFx0aWYgKGRhdGFSdmNHdWlkUGF0dGVybi50ZXN0KGNzcykpIHtcbiAgXHRcdHRyYW5zZm9ybWVkID0gY3NzLnJlcGxhY2UoZGF0YVJ2Y0d1aWRQYXR0ZXJuLCBkYXRhQXR0cik7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHRyYW5zZm9ybWVkID0gY3NzLnJlcGxhY2UoY29tbWVudHNQYXR0ZXJuLCBcIlwiKS5yZXBsYWNlKHNlbGVjdG9yc1BhdHRlcm4sIGZ1bmN0aW9uIChtYXRjaCwgJDEpIHtcbiAgXHRcdFx0dmFyIHNlbGVjdG9ycywgdHJhbnNmb3JtZWQ7XG5cbiAgXHRcdFx0Ly8gZG9uJ3QgdHJhbnNmb3JtIG1lZGlhIHF1ZXJpZXMhXG4gIFx0XHRcdGlmIChtZWRpYVF1ZXJ5UGF0dGVybi50ZXN0KCQxKSkgcmV0dXJuIG1hdGNoO1xuXG4gIFx0XHRcdHNlbGVjdG9ycyA9ICQxLnNwbGl0KFwiLFwiKS5tYXAodHJpbSk7XG4gIFx0XHRcdHRyYW5zZm9ybWVkID0gc2VsZWN0b3JzLm1hcChhZGRHdWlkKS5qb2luKFwiLCBcIikgKyBcIiBcIjtcblxuICBcdFx0XHRyZXR1cm4gbWF0Y2gucmVwbGFjZSgkMSwgdHJhbnNmb3JtZWQpO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRyYW5zZm9ybWVkO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgXHRpZiAoc3RyLnRyaW0pIHtcbiAgXHRcdHJldHVybiBzdHIudHJpbSgpO1xuICBcdH1cblxuICBcdHJldHVybiBzdHIucmVwbGFjZSgvXlxccysvLCBcIlwiKS5yZXBsYWNlKC9cXHMrJC8sIFwiXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdFN0cmluZyh1bml0KSB7XG4gIFx0cmV0dXJuIHVuaXQuc3RyO1xuICB9XG5cbiAgdmFyIGNzc19jc3NfX3VpZCA9IDE7XG5cbiAgdmFyIGNzc0NvbmZpZ3VyYXRvciA9IHtcbiAgXHRuYW1lOiBcImNzc1wiLFxuXG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiAoUGFyZW50LCBwcm90bywgb3B0aW9ucykge1xuICBcdFx0aWYgKG9wdGlvbnMuY3NzKSB7XG4gIFx0XHRcdHZhciBpZCA9IGNzc19jc3NfX3VpZCsrO1xuICBcdFx0XHR2YXIgc3R5bGVzID0gb3B0aW9ucy5ub0Nzc1RyYW5zZm9ybSA/IG9wdGlvbnMuY3NzIDogdHJhbnNmb3JtKG9wdGlvbnMuY3NzLCBpZCk7XG5cbiAgXHRcdFx0cHJvdG8uY3NzSWQgPSBpZDtcbiAgXHRcdFx0Z2xvYmFsX2Nzcy5hZGQoeyBpZDogaWQsIHN0eWxlczogc3R5bGVzIH0pO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7fVxuICB9O1xuXG4gIHZhciBjc3NfY3NzID0gY3NzQ29uZmlndXJhdG9yO1xuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKGRhdGEpIHtcbiAgXHQvLyBXYXJuIGlmIHVzZXJPcHRpb25zLmRhdGEgaXMgYSBub24tUE9KT1xuICBcdGlmIChkYXRhICYmIGRhdGEuY29uc3RydWN0b3IgIT09IE9iamVjdCkge1xuICBcdFx0aWYgKHR5cGVvZiBkYXRhID09PSBcImZ1bmN0aW9uXCIpIHt9IGVsc2UgaWYgKHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiKSB7XG4gIFx0XHRcdGZhdGFsKFwiZGF0YSBvcHRpb24gbXVzdCBiZSBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgYFwiICsgZGF0YSArIFwiYCBpcyBub3QgdmFsaWRcIik7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR3YXJuSWZEZWJ1ZyhcIklmIHN1cHBsaWVkLCBvcHRpb25zLmRhdGEgc2hvdWxkIGJlIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QgLSB1c2luZyBhIG5vbi1QT0pPIGFzIHRoZSByb290IG9iamVjdCBtYXkgd29yaywgYnV0IGlzIGRpc2NvdXJhZ2VkXCIpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBkYXRhQ29uZmlndXJhdG9yID0ge1xuICBcdG5hbWU6IFwiZGF0YVwiLFxuXG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiAoUGFyZW50LCBwcm90bywgb3B0aW9ucykge1xuICBcdFx0dmFyIGtleSA9IHVuZGVmaW5lZCxcbiAgXHRcdCAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcblxuICBcdFx0Ly8gY2hlY2sgZm9yIG5vbi1wcmltaXRpdmVzLCB3aGljaCBjb3VsZCBjYXVzZSBtdXRhdGlvbi1yZWxhdGVkIGJ1Z3NcbiAgXHRcdGlmIChvcHRpb25zLmRhdGEgJiYgaXNPYmplY3Qob3B0aW9ucy5kYXRhKSkge1xuICBcdFx0XHRmb3IgKGtleSBpbiBvcHRpb25zLmRhdGEpIHtcbiAgXHRcdFx0XHR2YWx1ZSA9IG9wdGlvbnMuZGF0YVtrZXldO1xuXG4gIFx0XHRcdFx0aWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICBcdFx0XHRcdFx0aWYgKGlzT2JqZWN0KHZhbHVlKSB8fCBpc0FycmF5KHZhbHVlKSkge1xuICBcdFx0XHRcdFx0XHR3YXJuSWZEZWJ1ZyhcIlBhc3NpbmcgYSBgZGF0YWAgb3B0aW9uIHdpdGggb2JqZWN0IGFuZCBhcnJheSBwcm9wZXJ0aWVzIHRvIFJhY3RpdmUuZXh0ZW5kKCkgaXMgZGlzY291cmFnZWQsIGFzIG11dGF0aW5nIHRoZW0gaXMgbGlrZWx5IHRvIGNhdXNlIGJ1Z3MuIENvbnNpZGVyIHVzaW5nIGEgZGF0YSBmdW5jdGlvbiBpbnN0ZWFkOlxcblxcbiAgLy8gdGhpcy4uLlxcbiAgZGF0YTogZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIG15T2JqZWN0OiB7fVxcbiAgICB9O1xcbiAgfSlcXG5cXG4gIC8vIGluc3RlYWQgb2YgdGhpczpcXG4gIGRhdGE6IHtcXG4gICAgbXlPYmplY3Q6IHt9XFxuICB9XCIpO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRwcm90by5kYXRhID0gY3VzdG9tX2RhdGFfX2NvbWJpbmUocHJvdG8uZGF0YSwgb3B0aW9ucy5kYXRhKTtcbiAgXHR9LFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucykge1xuICBcdFx0dmFyIHJlc3VsdCA9IGN1c3RvbV9kYXRhX19jb21iaW5lKFBhcmVudC5wcm90b3R5cGUuZGF0YSwgb3B0aW9ucy5kYXRhKTtcblxuICBcdFx0aWYgKHR5cGVvZiByZXN1bHQgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRyZXN1bHQgPSByZXN1bHQuY2FsbChyYWN0aXZlKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHJlc3VsdCB8fCB7fTtcbiAgXHR9LFxuXG4gIFx0cmVzZXQ6IGZ1bmN0aW9uIChyYWN0aXZlKSB7XG4gIFx0XHR2YXIgcmVzdWx0ID0gdGhpcy5pbml0KHJhY3RpdmUuY29uc3RydWN0b3IsIHJhY3RpdmUsIHJhY3RpdmUudmlld21vZGVsKTtcblxuICBcdFx0cmFjdGl2ZS52aWV3bW9kZWwucmVzZXQocmVzdWx0KTtcbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cbiAgfTtcblxuICB2YXIgY3VzdG9tX2RhdGEgPSBkYXRhQ29uZmlndXJhdG9yO1xuXG4gIGZ1bmN0aW9uIGN1c3RvbV9kYXRhX19jb21iaW5lKHBhcmVudFZhbHVlLCBjaGlsZFZhbHVlKSB7XG4gIFx0dmFsaWRhdGUoY2hpbGRWYWx1ZSk7XG5cbiAgXHR2YXIgcGFyZW50SXNGbiA9IHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xuICBcdHZhciBjaGlsZElzRm4gPSB0eXBlb2YgY2hpbGRWYWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xuXG4gIFx0Ly8gVmVyeSBpbXBvcnRhbnQsIG90aGVyd2lzZSBjaGlsZCBpbnN0YW5jZSBjYW4gYmVjb21lXG4gIFx0Ly8gdGhlIGRlZmF1bHQgZGF0YSBvYmplY3Qgb24gUmFjdGl2ZSBvciBhIGNvbXBvbmVudC5cbiAgXHQvLyB0aGVuIHJhY3RpdmUuc2V0KCkgZW5kcyB1cCBzZXR0aW5nIG9uIHRoZSBwcm90b3R5cGUhXG4gIFx0aWYgKCFjaGlsZFZhbHVlICYmICFwYXJlbnRJc0ZuKSB7XG4gIFx0XHRjaGlsZFZhbHVlID0ge307XG4gIFx0fVxuXG4gIFx0Ly8gRmFzdCBwYXRoLCB3aGVyZSB3ZSBqdXN0IG5lZWQgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAgXHQvLyBwYXJlbnQgdG8gY2hpbGRcbiAgXHRpZiAoIXBhcmVudElzRm4gJiYgIWNoaWxkSXNGbikge1xuICBcdFx0cmV0dXJuIGZyb21Qcm9wZXJ0aWVzKGNoaWxkVmFsdWUsIHBhcmVudFZhbHVlKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGNoaWxkID0gY2hpbGRJc0ZuID8gY2FsbERhdGFGdW5jdGlvbihjaGlsZFZhbHVlLCB0aGlzKSA6IGNoaWxkVmFsdWU7XG4gIFx0XHR2YXIgcGFyZW50ID0gcGFyZW50SXNGbiA/IGNhbGxEYXRhRnVuY3Rpb24ocGFyZW50VmFsdWUsIHRoaXMpIDogcGFyZW50VmFsdWU7XG5cbiAgXHRcdHJldHVybiBmcm9tUHJvcGVydGllcyhjaGlsZCwgcGFyZW50KTtcbiAgXHR9O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsbERhdGFGdW5jdGlvbihmbiwgY29udGV4dCkge1xuICBcdHZhciBkYXRhID0gZm4uY2FsbChjb250ZXh0KTtcblxuICBcdGlmICghZGF0YSkgcmV0dXJuO1xuXG4gIFx0aWYgKHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiKSB7XG4gIFx0XHRmYXRhbChcIkRhdGEgZnVuY3Rpb24gbXVzdCByZXR1cm4gYW4gb2JqZWN0XCIpO1xuICBcdH1cblxuICBcdGlmIChkYXRhLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgXHRcdHdhcm5PbmNlSWZEZWJ1ZyhcIkRhdGEgZnVuY3Rpb24gcmV0dXJuZWQgc29tZXRoaW5nIG90aGVyIHRoYW4gYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdC4gVGhpcyBtaWdodCB3b3JrLCBidXQgaXMgc3Ryb25nbHkgZGlzY291cmFnZWRcIik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGRhdGE7XG4gIH1cblxuICBmdW5jdGlvbiBmcm9tUHJvcGVydGllcyhwcmltYXJ5LCBzZWNvbmRhcnkpIHtcbiAgXHRpZiAocHJpbWFyeSAmJiBzZWNvbmRhcnkpIHtcbiAgXHRcdGZvciAodmFyIGtleSBpbiBzZWNvbmRhcnkpIHtcbiAgXHRcdFx0aWYgKCEoa2V5IGluIHByaW1hcnkpKSB7XG4gIFx0XHRcdFx0cHJpbWFyeVtrZXldID0gc2Vjb25kYXJ5W2tleV07XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHByaW1hcnk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHByaW1hcnkgfHwgc2Vjb25kYXJ5O1xuICB9XG5cbiAgLy8gVE9ETyBkbyB3ZSBuZWVkIHRvIHN1cHBvcnQgdGhpcyBpbiB0aGUgbmV3IFJhY3RpdmUoKSBjYXNlP1xuXG4gIHZhciBQYXJzZXIsXG4gICAgICBQYXJzZUVycm9yLFxuICAgICAgcGFyc2VfUGFyc2VyX19sZWFkaW5nV2hpdGVzcGFjZSA9IC9eXFxzKy87XG5cbiAgUGFyc2VFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIFx0dGhpcy5uYW1lID0gXCJQYXJzZUVycm9yXCI7XG4gIFx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgXHR0cnkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBcdH0gY2F0Y2ggKGUpIHtcbiAgXHRcdHRoaXMuc3RhY2sgPSBlLnN0YWNrO1xuICBcdH1cbiAgfTtcblxuICBQYXJzZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBQYXJzZXIgPSBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG4gIFx0dmFyIGl0ZW1zLFxuICBcdCAgICBpdGVtLFxuICBcdCAgICBsaW5lU3RhcnQgPSAwO1xuXG4gIFx0dGhpcy5zdHIgPSBzdHI7XG4gIFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgXHR0aGlzLnBvcyA9IDA7XG5cbiAgXHR0aGlzLmxpbmVzID0gdGhpcy5zdHIuc3BsaXQoXCJcXG5cIik7XG4gIFx0dGhpcy5saW5lRW5kcyA9IHRoaXMubGluZXMubWFwKGZ1bmN0aW9uIChsaW5lKSB7XG4gIFx0XHR2YXIgbGluZUVuZCA9IGxpbmVTdGFydCArIGxpbmUubGVuZ3RoICsgMTsgLy8gKzEgZm9yIHRoZSBuZXdsaW5lXG5cbiAgXHRcdGxpbmVTdGFydCA9IGxpbmVFbmQ7XG4gIFx0XHRyZXR1cm4gbGluZUVuZDtcbiAgXHR9LCAwKTtcblxuICBcdC8vIEN1c3RvbSBpbml0IGxvZ2ljXG4gIFx0aWYgKHRoaXMuaW5pdCkgdGhpcy5pbml0KHN0ciwgb3B0aW9ucyk7XG5cbiAgXHRpdGVtcyA9IFtdO1xuXG4gIFx0d2hpbGUgKHRoaXMucG9zIDwgdGhpcy5zdHIubGVuZ3RoICYmIChpdGVtID0gdGhpcy5yZWFkKCkpKSB7XG4gIFx0XHRpdGVtcy5wdXNoKGl0ZW0pO1xuICBcdH1cblxuICBcdHRoaXMubGVmdG92ZXIgPSB0aGlzLnJlbWFpbmluZygpO1xuICBcdHRoaXMucmVzdWx0ID0gdGhpcy5wb3N0UHJvY2VzcyA/IHRoaXMucG9zdFByb2Nlc3MoaXRlbXMsIG9wdGlvbnMpIDogaXRlbXM7XG4gIH07XG5cbiAgUGFyc2VyLnByb3RvdHlwZSA9IHtcbiAgXHRyZWFkOiBmdW5jdGlvbiAoY29udmVydGVycykge1xuICBcdFx0dmFyIHBvcywgaSwgbGVuLCBpdGVtO1xuXG4gIFx0XHRpZiAoIWNvbnZlcnRlcnMpIGNvbnZlcnRlcnMgPSB0aGlzLmNvbnZlcnRlcnM7XG5cbiAgXHRcdHBvcyA9IHRoaXMucG9zO1xuXG4gIFx0XHRsZW4gPSBjb252ZXJ0ZXJzLmxlbmd0aDtcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHR0aGlzLnBvcyA9IHBvczsgLy8gcmVzZXQgZm9yIGVhY2ggYXR0ZW1wdFxuXG4gIFx0XHRcdGlmIChpdGVtID0gY29udmVydGVyc1tpXSh0aGlzKSkge1xuICBcdFx0XHRcdHJldHVybiBpdGVtO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH0sXG5cbiAgXHRnZXRMaW5lUG9zOiBmdW5jdGlvbiAoY2hhcikge1xuICBcdFx0dmFyIGxpbmVOdW0gPSAwLFxuICBcdFx0ICAgIGxpbmVTdGFydCA9IDAsXG4gIFx0XHQgICAgY29sdW1uTnVtO1xuXG4gIFx0XHR3aGlsZSAoY2hhciA+PSB0aGlzLmxpbmVFbmRzW2xpbmVOdW1dKSB7XG4gIFx0XHRcdGxpbmVTdGFydCA9IHRoaXMubGluZUVuZHNbbGluZU51bV07XG4gIFx0XHRcdGxpbmVOdW0gKz0gMTtcbiAgXHRcdH1cblxuICBcdFx0Y29sdW1uTnVtID0gY2hhciAtIGxpbmVTdGFydDtcbiAgXHRcdHJldHVybiBbbGluZU51bSArIDEsIGNvbHVtbk51bSArIDEsIGNoYXJdOyAvLyBsaW5lL2NvbCBzaG91bGQgYmUgb25lLWJhc2VkLCBub3QgemVyby1iYXNlZCFcbiAgXHR9LFxuXG4gIFx0ZXJyb3I6IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIFx0XHR2YXIgcG9zID0gdGhpcy5nZXRMaW5lUG9zKHRoaXMucG9zKTtcbiAgXHRcdHZhciBsaW5lTnVtID0gcG9zWzBdO1xuICBcdFx0dmFyIGNvbHVtbk51bSA9IHBvc1sxXTtcblxuICBcdFx0dmFyIGxpbmUgPSB0aGlzLmxpbmVzW3Bvc1swXSAtIDFdO1xuICBcdFx0dmFyIG51bVRhYnMgPSAwO1xuICBcdFx0dmFyIGFubm90YXRpb24gPSBsaW5lLnJlcGxhY2UoL1xcdC9nLCBmdW5jdGlvbiAobWF0Y2gsIGNoYXIpIHtcbiAgXHRcdFx0aWYgKGNoYXIgPCBwb3NbMV0pIHtcbiAgXHRcdFx0XHRudW1UYWJzICs9IDE7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gXCIgIFwiO1xuICBcdFx0fSkgKyBcIlxcblwiICsgbmV3IEFycmF5KHBvc1sxXSArIG51bVRhYnMpLmpvaW4oXCIgXCIpICsgXCJeLS0tLVwiO1xuXG4gIFx0XHR2YXIgZXJyb3IgPSBuZXcgUGFyc2VFcnJvcihcIlwiICsgbWVzc2FnZSArIFwiIGF0IGxpbmUgXCIgKyBsaW5lTnVtICsgXCIgY2hhcmFjdGVyIFwiICsgY29sdW1uTnVtICsgXCI6XFxuXCIgKyBhbm5vdGF0aW9uKTtcblxuICBcdFx0ZXJyb3IubGluZSA9IHBvc1swXTtcbiAgXHRcdGVycm9yLmNoYXJhY3RlciA9IHBvc1sxXTtcbiAgXHRcdGVycm9yLnNob3J0TWVzc2FnZSA9IG1lc3NhZ2U7XG5cbiAgXHRcdHRocm93IGVycm9yO1xuICBcdH0sXG5cbiAgXHRtYXRjaFN0cmluZzogZnVuY3Rpb24gKHN0cmluZykge1xuICBcdFx0aWYgKHRoaXMuc3RyLnN1YnN0cih0aGlzLnBvcywgc3RyaW5nLmxlbmd0aCkgPT09IHN0cmluZykge1xuICBcdFx0XHR0aGlzLnBvcyArPSBzdHJpbmcubGVuZ3RoO1xuICBcdFx0XHRyZXR1cm4gc3RyaW5nO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRtYXRjaFBhdHRlcm46IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gIFx0XHR2YXIgbWF0Y2g7XG5cbiAgXHRcdGlmIChtYXRjaCA9IHBhdHRlcm4uZXhlYyh0aGlzLnJlbWFpbmluZygpKSkge1xuICBcdFx0XHR0aGlzLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG4gIFx0XHRcdHJldHVybiBtYXRjaFsxXSB8fCBtYXRjaFswXTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0YWxsb3dXaGl0ZXNwYWNlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLm1hdGNoUGF0dGVybihwYXJzZV9QYXJzZXJfX2xlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgXHR9LFxuXG4gIFx0cmVtYWluaW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5zdHIuc3Vic3RyaW5nKHRoaXMucG9zKTtcbiAgXHR9LFxuXG4gIFx0bmV4dENoYXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLnN0ci5jaGFyQXQodGhpcy5wb3MpO1xuICBcdH1cbiAgfTtcblxuICBQYXJzZXIuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3RvKSB7XG4gIFx0dmFyIFBhcmVudCA9IHRoaXMsXG4gIFx0ICAgIENoaWxkLFxuICBcdCAgICBrZXk7XG5cbiAgXHRDaGlsZCA9IGZ1bmN0aW9uIChzdHIsIG9wdGlvbnMpIHtcbiAgXHRcdFBhcnNlci5jYWxsKHRoaXMsIHN0ciwgb3B0aW9ucyk7XG4gIFx0fTtcblxuICBcdENoaWxkLnByb3RvdHlwZSA9IGNyZWF0ZShQYXJlbnQucHJvdG90eXBlKTtcblxuICBcdGZvciAoa2V5IGluIHByb3RvKSB7XG4gIFx0XHRpZiAoaGFzT3duLmNhbGwocHJvdG8sIGtleSkpIHtcbiAgXHRcdFx0Q2hpbGQucHJvdG90eXBlW2tleV0gPSBwcm90b1trZXldO1xuICBcdFx0fVxuICBcdH1cblxuICBcdENoaWxkLmV4dGVuZCA9IFBhcnNlci5leHRlbmQ7XG4gIFx0cmV0dXJuIENoaWxkO1xuICB9O1xuXG4gIHZhciBwYXJzZV9QYXJzZXIgPSBQYXJzZXI7XG5cbiAgdmFyIFRFWFQgPSAxO1xuICB2YXIgSU5URVJQT0xBVE9SID0gMjtcbiAgdmFyIFRSSVBMRSA9IDM7XG4gIHZhciBTRUNUSU9OID0gNDtcbiAgdmFyIElOVkVSVEVEID0gNTtcbiAgdmFyIENMT1NJTkcgPSA2O1xuICB2YXIgRUxFTUVOVCA9IDc7XG4gIHZhciBQQVJUSUFMID0gODtcbiAgdmFyIENPTU1FTlQgPSA5O1xuICB2YXIgREVMSU1DSEFOR0UgPSAxMDtcbiAgdmFyIEFUVFJJQlVURSA9IDEzO1xuICB2YXIgQ0xPU0lOR19UQUcgPSAxNDtcbiAgdmFyIENPTVBPTkVOVCA9IDE1O1xuICB2YXIgWUlFTERFUiA9IDE2O1xuICB2YXIgSU5MSU5FX1BBUlRJQUwgPSAxNztcbiAgdmFyIERPQ1RZUEUgPSAxODtcblxuICB2YXIgTlVNQkVSX0xJVEVSQUwgPSAyMDtcbiAgdmFyIFNUUklOR19MSVRFUkFMID0gMjE7XG4gIHZhciBBUlJBWV9MSVRFUkFMID0gMjI7XG4gIHZhciBPQkpFQ1RfTElURVJBTCA9IDIzO1xuICB2YXIgQk9PTEVBTl9MSVRFUkFMID0gMjQ7XG4gIHZhciBSRUdFWFBfTElURVJBTCA9IDI1O1xuXG4gIHZhciBHTE9CQUwgPSAyNjtcbiAgdmFyIEtFWV9WQUxVRV9QQUlSID0gMjc7XG5cbiAgdmFyIFJFRkVSRU5DRSA9IDMwO1xuICB2YXIgUkVGSU5FTUVOVCA9IDMxO1xuICB2YXIgTUVNQkVSID0gMzI7XG4gIHZhciBQUkVGSVhfT1BFUkFUT1IgPSAzMztcbiAgdmFyIEJSQUNLRVRFRCA9IDM0O1xuICB2YXIgQ09ORElUSU9OQUwgPSAzNTtcbiAgdmFyIElORklYX09QRVJBVE9SID0gMzY7XG5cbiAgdmFyIElOVk9DQVRJT04gPSA0MDtcblxuICB2YXIgU0VDVElPTl9JRiA9IDUwO1xuICB2YXIgU0VDVElPTl9VTkxFU1MgPSA1MTtcbiAgdmFyIFNFQ1RJT05fRUFDSCA9IDUyO1xuICB2YXIgU0VDVElPTl9XSVRIID0gNTM7XG4gIHZhciBTRUNUSU9OX0lGX1dJVEggPSA1NDtcblxuICB2YXIgRUxTRSA9IDYwO1xuICB2YXIgRUxTRUlGID0gNjE7XG5cbiAgdmFyIG11c3RhY2hlX3JlYWREZWxpbWl0ZXJDaGFuZ2UgPSByZWFkRGVsaW1pdGVyQ2hhbmdlO1xuICB2YXIgZGVsaW1pdGVyQ2hhbmdlUGF0dGVybiA9IC9eW15cXHM9XSsvLFxuICAgICAgd2hpdGVzcGFjZVBhdHRlcm4gPSAvXlxccysvO1xuICBmdW5jdGlvbiByZWFkRGVsaW1pdGVyQ2hhbmdlKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgb3BlbmluZywgY2xvc2luZztcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiPVwiKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgbmV3IG9wZW5pbmcgZGVsaW1pdGVyXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0b3BlbmluZyA9IHBhcnNlci5tYXRjaFBhdHRlcm4oZGVsaW1pdGVyQ2hhbmdlUGF0dGVybik7XG4gIFx0aWYgKCFvcGVuaW5nKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIChpbiBmYWN0LCBpdCdzIG5lY2Vzc2FyeS4uLilcbiAgXHRpZiAoIXBhcnNlci5tYXRjaFBhdHRlcm4od2hpdGVzcGFjZVBhdHRlcm4pKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRjbG9zaW5nID0gcGFyc2VyLm1hdGNoUGF0dGVybihkZWxpbWl0ZXJDaGFuZ2VQYXR0ZXJuKTtcbiAgXHRpZiAoIWNsb3NpbmcpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlIGNsb3NpbmcgJz0nXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI9XCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gW29wZW5pbmcsIGNsb3NpbmddO1xuICB9XG5cbiAgdmFyIHJlYWRSZWdleHBMaXRlcmFsID0gcmVhZFJlZ2V4cExpdGVyYWxfX3JlYWROdW1iZXJMaXRlcmFsO1xuICB2YXIgcmVnZXhwUGF0dGVybiA9IC9eKFxcLyg/OlteXFxuXFxyXFx1MjAyOFxcdTIwMjkvXFxcXFtdfFxcXFwufFxcWyg/OlteXFxuXFxyXFx1MjAyOFxcdTIwMjlcXF1cXFxcXXxcXFxcLikqXSkrXFwvKD86KFtnaW11eV0pKD8hW2Etel0qXFwyKSkqKD8hW2EtekEtWl8kMC05XSkpLztcbiAgZnVuY3Rpb24gcmVhZFJlZ2V4cExpdGVyYWxfX3JlYWROdW1iZXJMaXRlcmFsKHBhcnNlcikge1xuICBcdHZhciByZXN1bHQ7XG5cbiAgXHRpZiAocmVzdWx0ID0gcGFyc2VyLm1hdGNoUGF0dGVybihyZWdleHBQYXR0ZXJuKSkge1xuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogUkVHRVhQX0xJVEVSQUwsXG4gIFx0XHRcdHY6IHJlc3VsdFxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBjb252ZXJ0ZXJzX3JlYWRNdXN0YWNoZSA9IHJlYWRNdXN0YWNoZTtcblxuICB2YXIgZGVsaW1pdGVyQ2hhbmdlVG9rZW4gPSB7IHQ6IERFTElNQ0hBTkdFLCBleGNsdWRlOiB0cnVlIH07XG4gIGZ1bmN0aW9uIHJlYWRNdXN0YWNoZShwYXJzZXIpIHtcbiAgXHR2YXIgbXVzdGFjaGUsIGk7XG5cbiAgXHQvLyBJZiB3ZSdyZSBpbnNpZGUgYSA8c2NyaXB0PiBvciA8c3R5bGU+IHRhZywgYW5kIHdlJ3JlIG5vdFxuICBcdC8vIGludGVycG9sYXRpbmcsIGJ1ZyBvdXRcbiAgXHRpZiAocGFyc2VyLmludGVycG9sYXRlW3BhcnNlci5pbnNpZGVdID09PSBmYWxzZSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Zm9yIChpID0gMDsgaSA8IHBhcnNlci50YWdzLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRpZiAobXVzdGFjaGUgPSByZWFkTXVzdGFjaGVPZlR5cGUocGFyc2VyLCBwYXJzZXIudGFnc1tpXSkpIHtcbiAgXHRcdFx0cmV0dXJuIG11c3RhY2hlO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRNdXN0YWNoZU9mVHlwZShwYXJzZXIsIHRhZykge1xuICBcdHZhciBzdGFydCwgbXVzdGFjaGUsIHJlYWRlciwgaTtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJcXFxcXCIgKyB0YWcub3BlbikpIHtcbiAgXHRcdGlmIChzdGFydCA9PT0gMCB8fCBwYXJzZXIuc3RyW3N0YXJ0IC0gMV0gIT09IFwiXFxcXFwiKSB7XG4gIFx0XHRcdHJldHVybiB0YWcub3BlbjtcbiAgXHRcdH1cbiAgXHR9IGVsc2UgaWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLm9wZW4pKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBkZWxpbWl0ZXIgY2hhbmdlP1xuICBcdGlmIChtdXN0YWNoZSA9IG11c3RhY2hlX3JlYWREZWxpbWl0ZXJDaGFuZ2UocGFyc2VyKSkge1xuICBcdFx0Ly8gZmluZCBjbG9zaW5nIGRlbGltaXRlciBvciBhYm9ydC4uLlxuICBcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0Ly8gLi4udGhlbiBtYWtlIHRoZSBzd2l0Y2hcbiAgXHRcdHRhZy5vcGVuID0gbXVzdGFjaGVbMF07XG4gIFx0XHR0YWcuY2xvc2UgPSBtdXN0YWNoZVsxXTtcbiAgXHRcdHBhcnNlci5zb3J0TXVzdGFjaGVUYWdzKCk7XG5cbiAgXHRcdHJldHVybiBkZWxpbWl0ZXJDaGFuZ2VUb2tlbjtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHQvLyBpbGxlZ2FsIHNlY3Rpb24gY2xvc2VyXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIi9cIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgLT0gMTtcbiAgXHRcdHZhciByZXdpbmQgPSBwYXJzZXIucG9zO1xuICBcdFx0aWYgKCFyZWFkUmVnZXhwTGl0ZXJhbChwYXJzZXIpKSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgPSByZXdpbmQgLSB0YWcuY2xvc2UubGVuZ3RoO1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoXCJBdHRlbXB0ZWQgdG8gY2xvc2UgYSBzZWN0aW9uIHRoYXQgd2Fzbid0IG9wZW5cIik7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRwYXJzZXIucG9zID0gcmV3aW5kO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGZvciAoaSA9IDA7IGkgPCB0YWcucmVhZGVycy5sZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0cmVhZGVyID0gdGFnLnJlYWRlcnNbaV07XG5cbiAgXHRcdGlmIChtdXN0YWNoZSA9IHJlYWRlcihwYXJzZXIsIHRhZykpIHtcbiAgXHRcdFx0aWYgKHRhZy5pc1N0YXRpYykge1xuICBcdFx0XHRcdG11c3RhY2hlLnMgPSB0cnVlOyAvLyBUT0RPIG1ha2UgdGhpcyBgMWAgaW5zdGVhZCAtIG1vcmUgY29tcGFjdFxuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKHBhcnNlci5pbmNsdWRlTGluZVBvc2l0aW9ucykge1xuICBcdFx0XHRcdG11c3RhY2hlLnAgPSBwYXJzZXIuZ2V0TGluZVBvcyhzdGFydCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gbXVzdGFjaGU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGV4cGVjdGVkRXhwcmVzc2lvbiA9IFwiRXhwZWN0ZWQgYSBKYXZhU2NyaXB0IGV4cHJlc3Npb25cIjtcbiAgdmFyIGV4cGVjdGVkUGFyZW4gPSBcIkV4cGVjdGVkIGNsb3NpbmcgcGFyZW5cIjtcblxuICB2YXIgbGl0ZXJhbF9yZWFkTnVtYmVyTGl0ZXJhbCA9IGxpdGVyYWxfcmVhZE51bWJlckxpdGVyYWxfX3JlYWROdW1iZXJMaXRlcmFsO1xuICB2YXIgbGl0ZXJhbF9yZWFkTnVtYmVyTGl0ZXJhbF9fbnVtYmVyUGF0dGVybiA9IC9eKD86WystXT8pMCooPzooPzooPzpbMS05XVxcZCopP1xcLlxcZCspfCg/Oig/OjB8WzEtOV1cXGQqKVxcLil8KD86MHxbMS05XVxcZCopKSg/OltlRV1bKy1dP1xcZCspPy87XG4gIGZ1bmN0aW9uIGxpdGVyYWxfcmVhZE51bWJlckxpdGVyYWxfX3JlYWROdW1iZXJMaXRlcmFsKHBhcnNlcikge1xuICBcdHZhciByZXN1bHQ7XG5cbiAgXHRpZiAocmVzdWx0ID0gcGFyc2VyLm1hdGNoUGF0dGVybihsaXRlcmFsX3JlYWROdW1iZXJMaXRlcmFsX19udW1iZXJQYXR0ZXJuKSkge1xuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogTlVNQkVSX0xJVEVSQUwsXG4gIFx0XHRcdHY6IHJlc3VsdFxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBsaXRlcmFsX3JlYWRCb29sZWFuTGl0ZXJhbCA9IHJlYWRCb29sZWFuTGl0ZXJhbDtcbiAgZnVuY3Rpb24gcmVhZEJvb2xlYW5MaXRlcmFsKHBhcnNlcikge1xuICBcdHZhciByZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cbiAgXHRpZiAocmVtYWluaW5nLnN1YnN0cigwLCA0KSA9PT0gXCJ0cnVlXCIpIHtcbiAgXHRcdHBhcnNlci5wb3MgKz0gNDtcbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IEJPT0xFQU5fTElURVJBTCxcbiAgXHRcdFx0djogXCJ0cnVlXCJcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0aWYgKHJlbWFpbmluZy5zdWJzdHIoMCwgNSkgPT09IFwiZmFsc2VcIikge1xuICBcdFx0cGFyc2VyLnBvcyArPSA1O1xuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogQk9PTEVBTl9MSVRFUkFMLFxuICBcdFx0XHR2OiBcImZhbHNlXCJcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgc3RyaW5nTWlkZGxlUGF0dGVybiwgZXNjYXBlU2VxdWVuY2VQYXR0ZXJuLCBsaW5lQ29udGludWF0aW9uUGF0dGVybjtcblxuICAvLyBNYXRjaCBvbmUgb3IgbW9yZSBjaGFyYWN0ZXJzIHVudGlsOiBcIiwgJywgXFwsIG9yIEVPTC9FT0YuXG4gIC8vIEVPTC9FT0YgaXMgd3JpdHRlbiBhcyAoPyEuKSAobWVhbmluZyB0aGVyZSdzIG5vIG5vbi1uZXdsaW5lIGNoYXIgbmV4dCkuXG4gIHN0cmluZ01pZGRsZVBhdHRlcm4gPSAvXig/PS4pW15cIidcXFxcXSs/KD86KD8hLil8KD89W1wiJ1xcXFxdKSkvO1xuXG4gIC8vIE1hdGNoIG9uZSBlc2NhcGUgc2VxdWVuY2UsIGluY2x1ZGluZyB0aGUgYmFja3NsYXNoLlxuICBlc2NhcGVTZXF1ZW5jZVBhdHRlcm4gPSAvXlxcXFwoPzpbJ1wiXFxcXGJmbnJ0XXwwKD8hWzAtOV0pfHhbMC05YS1mQS1GXXsyfXx1WzAtOWEtZkEtRl17NH18KD89LilbXnV4MC05XSkvO1xuXG4gIC8vIE1hdGNoIG9uZSBFUzUgbGluZSBjb250aW51YXRpb24gKGJhY2tzbGFzaCArIGxpbmUgdGVybWluYXRvcikuXG4gIGxpbmVDb250aW51YXRpb25QYXR0ZXJuID0gL15cXFxcKD86XFxyXFxufFtcXHUwMDBBXFx1MDAwRFxcdTIwMjhcXHUyMDI5XSkvO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgZ2V0RG91YmxlUXVvdGVkU3RyaW5nIGFuZCBnZXRTaW5nbGVRdW90ZWRTdHJpbmcuXG4gIHZhciBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlciA9IGZ1bmN0aW9uIChva1F1b3RlKSB7XG4gIFx0cmV0dXJuIGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgXHRcdHZhciBzdGFydCwgbGl0ZXJhbCwgZG9uZSwgbmV4dDtcblxuICBcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuICBcdFx0bGl0ZXJhbCA9IFwiXFxcIlwiO1xuICBcdFx0ZG9uZSA9IGZhbHNlO1xuXG4gIFx0XHR3aGlsZSAoIWRvbmUpIHtcbiAgXHRcdFx0bmV4dCA9IHBhcnNlci5tYXRjaFBhdHRlcm4oc3RyaW5nTWlkZGxlUGF0dGVybikgfHwgcGFyc2VyLm1hdGNoUGF0dGVybihlc2NhcGVTZXF1ZW5jZVBhdHRlcm4pIHx8IHBhcnNlci5tYXRjaFN0cmluZyhva1F1b3RlKTtcbiAgXHRcdFx0aWYgKG5leHQpIHtcbiAgXHRcdFx0XHRpZiAobmV4dCA9PT0gXCJcXFwiXCIpIHtcbiAgXHRcdFx0XHRcdGxpdGVyYWwgKz0gXCJcXFxcXFxcIlwiO1xuICBcdFx0XHRcdH0gZWxzZSBpZiAobmV4dCA9PT0gXCJcXFxcJ1wiKSB7XG4gIFx0XHRcdFx0XHRsaXRlcmFsICs9IFwiJ1wiO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRsaXRlcmFsICs9IG5leHQ7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdG5leHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKGxpbmVDb250aW51YXRpb25QYXR0ZXJuKTtcbiAgXHRcdFx0XHRpZiAobmV4dCkge1xuICBcdFx0XHRcdFx0Ly8gY29udmVydCBcXChuZXdsaW5lLWxpa2UpIGludG8gYSBcXHUgZXNjYXBlLCB3aGljaCBpcyBhbGxvd2VkIGluIEpTT05cbiAgXHRcdFx0XHRcdGxpdGVyYWwgKz0gXCJcXFxcdVwiICsgKFwiMDAwXCIgKyBuZXh0LmNoYXJDb2RlQXQoMSkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdGRvbmUgPSB0cnVlO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRsaXRlcmFsICs9IFwiXFxcIlwiO1xuXG4gIFx0XHQvLyB1c2UgSlNPTi5wYXJzZSB0byBpbnRlcnByZXQgZXNjYXBlc1xuICBcdFx0cmV0dXJuIEpTT04ucGFyc2UobGl0ZXJhbCk7XG4gIFx0fTtcbiAgfTtcblxuICB2YXIgZ2V0U2luZ2xlUXVvdGVkU3RyaW5nID0gbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIoXCJcXFwiXCIpO1xuICB2YXIgZ2V0RG91YmxlUXVvdGVkU3RyaW5nID0gbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIoXCInXCIpO1xuXG4gIHZhciByZWFkU3RyaW5nTGl0ZXJhbCA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIHN0cmluZztcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJcXFwiXCIpKSB7XG4gIFx0XHRzdHJpbmcgPSBnZXREb3VibGVRdW90ZWRTdHJpbmcocGFyc2VyKTtcblxuICBcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCJcXFwiXCIpKSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IFNUUklOR19MSVRFUkFMLFxuICBcdFx0XHR2OiBzdHJpbmdcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIidcIikpIHtcbiAgXHRcdHN0cmluZyA9IGdldFNpbmdsZVF1b3RlZFN0cmluZyhwYXJzZXIpO1xuXG4gIFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIidcIikpIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogU1RSSU5HX0xJVEVSQUwsXG4gIFx0XHRcdHY6IHN0cmluZ1xuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfTtcblxuICB2YXIgcGF0dGVybnNfX25hbWUgPSAvXlthLXpBLVpfJF1bYS16QS1aXyQwLTldKi87XG5cbiAgLy8gaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1wcm9wZXJ0aWVzXG4gIC8vIGNhbiBiZSBhbnkgbmFtZSwgc3RyaW5nIGxpdGVyYWwsIG9yIG51bWJlciBsaXRlcmFsXG4gIHZhciBzaGFyZWRfcmVhZEtleSA9IHJlYWRLZXk7XG4gIHZhciBpZGVudGlmaWVyID0gL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSokLztcbiAgZnVuY3Rpb24gcmVhZEtleShwYXJzZXIpIHtcbiAgXHR2YXIgdG9rZW47XG5cbiAgXHRpZiAodG9rZW4gPSByZWFkU3RyaW5nTGl0ZXJhbChwYXJzZXIpKSB7XG4gIFx0XHRyZXR1cm4gaWRlbnRpZmllci50ZXN0KHRva2VuLnYpID8gdG9rZW4udiA6IFwiXFxcIlwiICsgdG9rZW4udi5yZXBsYWNlKC9cIi9nLCBcIlxcXFxcXFwiXCIpICsgXCJcXFwiXCI7XG4gIFx0fVxuXG4gIFx0aWYgKHRva2VuID0gbGl0ZXJhbF9yZWFkTnVtYmVyTGl0ZXJhbChwYXJzZXIpKSB7XG4gIFx0XHRyZXR1cm4gdG9rZW4udjtcbiAgXHR9XG5cbiAgXHRpZiAodG9rZW4gPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHBhdHRlcm5zX19uYW1lKSkge1xuICBcdFx0cmV0dXJuIHRva2VuO1xuICBcdH1cbiAgfVxuXG4gIHZhciBrZXlWYWx1ZVBhaXIgPSByZWFkS2V5VmFsdWVQYWlyO1xuICBmdW5jdGlvbiByZWFkS2V5VmFsdWVQYWlyKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwga2V5LCB2YWx1ZTtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiAneycgYW5kIGtleVxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGtleSA9IHNoYXJlZF9yZWFkS2V5KHBhcnNlcik7XG4gIFx0aWYgKGtleSA9PT0gbnVsbCkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuIGtleSBhbmQgJzonXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0Ly8gbmV4dCBjaGFyYWN0ZXIgbXVzdCBiZSAnOidcbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIjpcIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiAnOicgYW5kIHZhbHVlXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0Ly8gbmV4dCBleHByZXNzaW9uIG11c3QgYmUgYSwgd2VsbC4uLiBleHByZXNzaW9uXG4gIFx0dmFsdWUgPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0aWYgKHZhbHVlID09PSBudWxsKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogS0VZX1ZBTFVFX1BBSVIsXG4gIFx0XHRrOiBrZXksXG4gIFx0XHR2OiB2YWx1ZVxuICBcdH07XG4gIH1cblxuICB2YXIgb2JqZWN0TGl0ZXJhbF9rZXlWYWx1ZVBhaXJzID0gcmVhZEtleVZhbHVlUGFpcnM7XG4gIGZ1bmN0aW9uIHJlYWRLZXlWYWx1ZVBhaXJzKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgcGFpcnMsIHBhaXIsIGtleVZhbHVlUGFpcnM7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRwYWlyID0ga2V5VmFsdWVQYWlyKHBhcnNlcik7XG4gIFx0aWYgKHBhaXIgPT09IG51bGwpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhaXJzID0gW3BhaXJdO1xuXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIixcIikpIHtcbiAgXHRcdGtleVZhbHVlUGFpcnMgPSByZWFkS2V5VmFsdWVQYWlycyhwYXJzZXIpO1xuXG4gIFx0XHRpZiAoIWtleVZhbHVlUGFpcnMpIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHBhaXJzLmNvbmNhdChrZXlWYWx1ZVBhaXJzKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcGFpcnM7XG4gIH1cblxuICB2YXIgcmVhZE9iamVjdExpdGVyYWwgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBrZXlWYWx1ZVBhaXJzO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZVxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwie1wiKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0a2V5VmFsdWVQYWlycyA9IG9iamVjdExpdGVyYWxfa2V5VmFsdWVQYWlycyhwYXJzZXIpO1xuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuIGZpbmFsIHZhbHVlIGFuZCAnfSdcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIn1cIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBPQkpFQ1RfTElURVJBTCxcbiAgXHRcdG06IGtleVZhbHVlUGFpcnNcbiAgXHR9O1xuICB9O1xuXG4gIHZhciBzaGFyZWRfcmVhZEV4cHJlc3Npb25MaXN0ID0gcmVhZEV4cHJlc3Npb25MaXN0O1xuICBmdW5jdGlvbiByZWFkRXhwcmVzc2lvbkxpc3QocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBleHByZXNzaW9ucywgZXhwciwgbmV4dDtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGV4cHIgPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG5cbiAgXHRpZiAoZXhwciA9PT0gbnVsbCkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0ZXhwcmVzc2lvbnMgPSBbZXhwcl07XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gZXhwcmVzc2lvbiBhbmQgJywnXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIixcIikpIHtcbiAgXHRcdG5leHQgPSByZWFkRXhwcmVzc2lvbkxpc3QocGFyc2VyKTtcbiAgXHRcdGlmIChuZXh0ID09PSBudWxsKSB7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihleHBlY3RlZEV4cHJlc3Npb24pO1xuICBcdFx0fVxuXG4gIFx0XHRuZXh0LmZvckVhY2goYXBwZW5kKTtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiBhcHBlbmQoZXhwcmVzc2lvbikge1xuICBcdFx0ZXhwcmVzc2lvbnMucHVzaChleHByZXNzaW9uKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gZXhwcmVzc2lvbnM7XG4gIH1cblxuICB2YXIgcmVhZEFycmF5TGl0ZXJhbCA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIGV4cHJlc3Npb25MaXN0O1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgJ1snXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCJbXCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRleHByZXNzaW9uTGlzdCA9IHNoYXJlZF9yZWFkRXhwcmVzc2lvbkxpc3QocGFyc2VyKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiXVwiKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IEFSUkFZX0xJVEVSQUwsXG4gIFx0XHRtOiBleHByZXNzaW9uTGlzdFxuICBcdH07XG4gIH07XG5cbiAgdmFyIHByaW1hcnlfcmVhZExpdGVyYWwgPSByZWFkTGl0ZXJhbDtcbiAgZnVuY3Rpb24gcmVhZExpdGVyYWwocGFyc2VyKSB7XG4gIFx0cmV0dXJuIGxpdGVyYWxfcmVhZE51bWJlckxpdGVyYWwocGFyc2VyKSB8fCBsaXRlcmFsX3JlYWRCb29sZWFuTGl0ZXJhbChwYXJzZXIpIHx8IHJlYWRTdHJpbmdMaXRlcmFsKHBhcnNlcikgfHwgcmVhZE9iamVjdExpdGVyYWwocGFyc2VyKSB8fCByZWFkQXJyYXlMaXRlcmFsKHBhcnNlcikgfHwgcmVhZFJlZ2V4cExpdGVyYWwocGFyc2VyKTtcbiAgfVxuXG4gIHZhciBwcmltYXJ5X3JlYWRSZWZlcmVuY2UgPSByZWFkUmVmZXJlbmNlO1xuICB2YXIgcHJlZml4UGF0dGVybiA9IC9eKD86flxcL3woPzpcXC5cXC5cXC8pK3xcXC5cXC8oPzpcXC5cXC5cXC8pKnxcXC4pLyxcbiAgICAgIGdsb2JhbHMsXG4gICAgICBrZXl3b3JkcztcblxuICAvLyBpZiBhIHJlZmVyZW5jZSBpcyBhIGJyb3dzZXIgZ2xvYmFsLCB3ZSBkb24ndCBkZWZlcmVuY2UgaXQgbGF0ZXIsIHNvIGl0IG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50XG4gIGdsb2JhbHMgPSAvXig/OkFycmF5fGNvbnNvbGV8RGF0ZXxSZWdFeHB8ZGVjb2RlVVJJQ29tcG9uZW50fGRlY29kZVVSSXxlbmNvZGVVUklDb21wb25lbnR8ZW5jb2RlVVJJfGlzRmluaXRlfGlzTmFOfHBhcnNlRmxvYXR8cGFyc2VJbnR8SlNPTnxNYXRofE5hTnx1bmRlZmluZWR8bnVsbClcXGIvO1xuXG4gIC8vIGtleXdvcmRzIGFyZSBub3QgdmFsaWQgcmVmZXJlbmNlcywgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGB0aGlzYFxuICBrZXl3b3JkcyA9IC9eKD86YnJlYWt8Y2FzZXxjYXRjaHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGZpbmFsbHl8Zm9yfGZ1bmN0aW9ufGlmfGlufGluc3RhbmNlb2Z8bmV3fHJldHVybnxzd2l0Y2h8dGhyb3d8dHJ5fHR5cGVvZnx2YXJ8dm9pZHx3aGlsZXx3aXRoKSQvO1xuXG4gIHZhciBsZWdhbFJlZmVyZW5jZSA9IC9eW2EtekEtWiRfMC05XSsoPzooPzpcXC5bYS16QS1aJF8wLTldKyl8KD86XFxbWzAtOV0rXFxdKSkqLztcbiAgdmFyIHJlbGF4ZWROYW1lID0gL15bYS16QS1aXyRdWy1hLXpBLVpfJDAtOV0qLztcbiAgZnVuY3Rpb24gcmVhZFJlZmVyZW5jZShwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnRQb3MsIHByZWZpeCwgbmFtZSwgZ2xvYmFsLCByZWZlcmVuY2UsIGxhc3REb3RJbmRleDtcblxuICBcdHN0YXJ0UG9zID0gcGFyc2VyLnBvcztcblxuICBcdG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKC9eQCg/OmtleXBhdGh8aW5kZXh8a2V5KS8pO1xuXG4gIFx0aWYgKCFuYW1lKSB7XG4gIFx0XHRwcmVmaXggPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHByZWZpeFBhdHRlcm4pIHx8IFwiXCI7XG4gIFx0XHRuYW1lID0gIXByZWZpeCAmJiBwYXJzZXIucmVsYXhlZE5hbWVzICYmIHBhcnNlci5tYXRjaFBhdHRlcm4ocmVsYXhlZE5hbWUpIHx8IHBhcnNlci5tYXRjaFBhdHRlcm4obGVnYWxSZWZlcmVuY2UpO1xuXG4gIFx0XHRpZiAoIW5hbWUgJiYgcHJlZml4ID09PSBcIi5cIikge1xuICBcdFx0XHRwcmVmaXggPSBcIlwiO1xuICBcdFx0XHRuYW1lID0gXCIuXCI7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKCFuYW1lKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBidWcgb3V0IGlmIGl0J3MgYSBrZXl3b3JkIChleGNlcHRpb24gZm9yIGFuY2VzdG9yL3Jlc3RyaWN0ZWQgcmVmcyAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzLzE0OTcpXG4gIFx0aWYgKCFwcmVmaXggJiYgIXBhcnNlci5yZWxheGVkTmFtZXMgJiYga2V5d29yZHMudGVzdChuYW1lKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0UG9zO1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gaWYgdGhpcyBpcyBhIGJyb3dzZXIgZ2xvYmFsLCBzdG9wIGhlcmVcbiAgXHRpZiAoIXByZWZpeCAmJiBnbG9iYWxzLnRlc3QobmFtZSkpIHtcbiAgXHRcdGdsb2JhbCA9IGdsb2JhbHMuZXhlYyhuYW1lKVswXTtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydFBvcyArIGdsb2JhbC5sZW5ndGg7XG5cbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IEdMT0JBTCxcbiAgXHRcdFx0djogZ2xvYmFsXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHJlZmVyZW5jZSA9IChwcmVmaXggfHwgXCJcIikgKyBub3JtYWxpc2UobmFtZSk7XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiKFwiKSkge1xuICBcdFx0Ly8gaWYgdGhpcyBpcyBhIG1ldGhvZCBpbnZvY2F0aW9uIChhcyBvcHBvc2VkIHRvIGEgZnVuY3Rpb24pIHdlIG5lZWRcbiAgXHRcdC8vIHRvIHN0cmlwIHRoZSBtZXRob2QgbmFtZSBmcm9tIHRoZSByZWZlcmVuY2UgY29tYm8sIGVsc2UgdGhlIGNvbnRleHRcbiAgXHRcdC8vIHdpbGwgYmUgd3JvbmdcbiAgXHRcdGxhc3REb3RJbmRleCA9IHJlZmVyZW5jZS5sYXN0SW5kZXhPZihcIi5cIik7XG4gIFx0XHRpZiAobGFzdERvdEluZGV4ICE9PSAtMSkge1xuICBcdFx0XHRyZWZlcmVuY2UgPSByZWZlcmVuY2Uuc3Vic3RyKDAsIGxhc3REb3RJbmRleCk7XG4gIFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydFBvcyArIHJlZmVyZW5jZS5sZW5ndGg7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRwYXJzZXIucG9zIC09IDE7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IFJFRkVSRU5DRSxcbiAgXHRcdG46IHJlZmVyZW5jZS5yZXBsYWNlKC9edGhpc1xcLi8sIFwiLi9cIikucmVwbGFjZSgvXnRoaXMkLywgXCIuXCIpXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBwcmltYXJ5X3JlYWRCcmFja2V0ZWRFeHByZXNzaW9uID0gcmVhZEJyYWNrZXRlZEV4cHJlc3Npb247XG4gIGZ1bmN0aW9uIHJlYWRCcmFja2V0ZWRFeHByZXNzaW9uKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgZXhwcjtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiKFwiKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0ZXhwciA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgXHRpZiAoIWV4cHIpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihleHBlY3RlZEV4cHJlc3Npb24pO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiKVwiKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKGV4cGVjdGVkUGFyZW4pO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBCUkFDS0VURUQsXG4gIFx0XHR4OiBleHByXG4gIFx0fTtcbiAgfVxuXG4gIHZhciByZWFkUHJpbWFyeSA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgXHRyZXR1cm4gcHJpbWFyeV9yZWFkTGl0ZXJhbChwYXJzZXIpIHx8IHByaW1hcnlfcmVhZFJlZmVyZW5jZShwYXJzZXIpIHx8IHByaW1hcnlfcmVhZEJyYWNrZXRlZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgfTtcblxuICB2YXIgc2hhcmVkX3JlYWRSZWZpbmVtZW50ID0gcmVhZFJlZmluZW1lbnQ7XG4gIGZ1bmN0aW9uIHJlYWRSZWZpbmVtZW50KHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgbmFtZSwgZXhwcjtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdC8vIFwiLlwiIG5hbWVcbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiLlwiKSkge1xuICBcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRpZiAobmFtZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4ocGF0dGVybnNfX25hbWUpKSB7XG4gIFx0XHRcdHJldHVybiB7XG4gIFx0XHRcdFx0dDogUkVGSU5FTUVOVCxcbiAgXHRcdFx0XHRuOiBuYW1lXG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGEgcHJvcGVydHkgbmFtZVwiKTtcbiAgXHR9XG5cbiAgXHQvLyBcIltcIiBleHByZXNzaW9uIFwiXVwiXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIltcIikpIHtcbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0ZXhwciA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgXHRcdGlmICghZXhwcikge1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoZXhwZWN0ZWRFeHByZXNzaW9uKTtcbiAgXHRcdH1cblxuICBcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIl1cIikpIHtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgJ10nXCIpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBSRUZJTkVNRU5ULFxuICBcdFx0XHR4OiBleHByXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHJlYWRNZW1iZXJPckludm9jYXRpb24gPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0dmFyIGN1cnJlbnQsIGV4cHJlc3Npb24sIHJlZmluZW1lbnQsIGV4cHJlc3Npb25MaXN0O1xuXG4gIFx0ZXhwcmVzc2lvbiA9IHJlYWRQcmltYXJ5KHBhcnNlcik7XG5cbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHdoaWxlIChleHByZXNzaW9uKSB7XG4gIFx0XHRjdXJyZW50ID0gcGFyc2VyLnBvcztcblxuICBcdFx0aWYgKHJlZmluZW1lbnQgPSBzaGFyZWRfcmVhZFJlZmluZW1lbnQocGFyc2VyKSkge1xuICBcdFx0XHRleHByZXNzaW9uID0ge1xuICBcdFx0XHRcdHQ6IE1FTUJFUixcbiAgXHRcdFx0XHR4OiBleHByZXNzaW9uLFxuICBcdFx0XHRcdHI6IHJlZmluZW1lbnRcbiAgXHRcdFx0fTtcbiAgXHRcdH0gZWxzZSBpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiKFwiKSkge1xuICBcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gIFx0XHRcdGV4cHJlc3Npb25MaXN0ID0gc2hhcmVkX3JlYWRFeHByZXNzaW9uTGlzdChwYXJzZXIpO1xuXG4gIFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIilcIikpIHtcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoZXhwZWN0ZWRQYXJlbik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRleHByZXNzaW9uID0ge1xuICBcdFx0XHRcdHQ6IElOVk9DQVRJT04sXG4gIFx0XHRcdFx0eDogZXhwcmVzc2lvblxuICBcdFx0XHR9O1xuXG4gIFx0XHRcdGlmIChleHByZXNzaW9uTGlzdCkge1xuICBcdFx0XHRcdGV4cHJlc3Npb24ubyA9IGV4cHJlc3Npb25MaXN0O1xuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRicmVhaztcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gZXhwcmVzc2lvbjtcbiAgfTtcblxuICB2YXIgcmVhZFR5cGVPZiwgbWFrZVByZWZpeFNlcXVlbmNlTWF0Y2hlcjtcblxuICBtYWtlUHJlZml4U2VxdWVuY2VNYXRjaGVyID0gZnVuY3Rpb24gKHN5bWJvbCwgZmFsbHRocm91Z2gpIHtcbiAgXHRyZXR1cm4gZnVuY3Rpb24gKHBhcnNlcikge1xuICBcdFx0dmFyIGV4cHJlc3Npb247XG5cbiAgXHRcdGlmIChleHByZXNzaW9uID0gZmFsbHRocm91Z2gocGFyc2VyKSkge1xuICBcdFx0XHRyZXR1cm4gZXhwcmVzc2lvbjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoc3ltYm9sKSkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRleHByZXNzaW9uID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuICBcdFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihleHBlY3RlZEV4cHJlc3Npb24pO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHRzOiBzeW1ib2wsXG4gIFx0XHRcdG86IGV4cHJlc3Npb24sXG4gIFx0XHRcdHQ6IFBSRUZJWF9PUEVSQVRPUlxuICBcdFx0fTtcbiAgXHR9O1xuICB9O1xuXG4gIC8vIGNyZWF0ZSBhbGwgcHJlZml4IHNlcXVlbmNlIG1hdGNoZXJzLCByZXR1cm4gcmVhZFR5cGVPZlxuICAoZnVuY3Rpb24gKCkge1xuICBcdHZhciBpLCBsZW4sIG1hdGNoZXIsIHByZWZpeE9wZXJhdG9ycywgZmFsbHRocm91Z2g7XG5cbiAgXHRwcmVmaXhPcGVyYXRvcnMgPSBcIiEgfiArIC0gdHlwZW9mXCIuc3BsaXQoXCIgXCIpO1xuXG4gIFx0ZmFsbHRocm91Z2ggPSByZWFkTWVtYmVyT3JJbnZvY2F0aW9uO1xuICBcdGZvciAoaSA9IDAsIGxlbiA9IHByZWZpeE9wZXJhdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0bWF0Y2hlciA9IG1ha2VQcmVmaXhTZXF1ZW5jZU1hdGNoZXIocHJlZml4T3BlcmF0b3JzW2ldLCBmYWxsdGhyb3VnaCk7XG4gIFx0XHRmYWxsdGhyb3VnaCA9IG1hdGNoZXI7XG4gIFx0fVxuXG4gIFx0Ly8gdHlwZW9mIG9wZXJhdG9yIGlzIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gbXVsdGlwbGljYXRpb24sIHNvIHByb3ZpZGVzIHRoZVxuICBcdC8vIGZhbGx0aHJvdWdoIGZvciB0aGUgbXVsdGlwbGljYXRpb24gc2VxdWVuY2UgbWF0Y2hlciB3ZSdyZSBhYm91dCB0byBjcmVhdGVcbiAgXHQvLyAod2UncmUgc2tpcHBpbmcgdm9pZCBhbmQgZGVsZXRlKVxuICBcdHJlYWRUeXBlT2YgPSBmYWxsdGhyb3VnaDtcbiAgfSkoKTtcblxuICB2YXIgcmVhZFR5cGVvZiA9IHJlYWRUeXBlT2Y7XG5cbiAgdmFyIHJlYWRMb2dpY2FsT3IsIG1ha2VJbmZpeFNlcXVlbmNlTWF0Y2hlcjtcblxuICBtYWtlSW5maXhTZXF1ZW5jZU1hdGNoZXIgPSBmdW5jdGlvbiAoc3ltYm9sLCBmYWxsdGhyb3VnaCkge1xuICBcdHJldHVybiBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0XHR2YXIgc3RhcnQsIGxlZnQsIHJpZ2h0O1xuXG4gIFx0XHRsZWZ0ID0gZmFsbHRocm91Z2gocGFyc2VyKTtcbiAgXHRcdGlmICghbGVmdCkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0Ly8gTG9vcCB0byBoYW5kbGUgbGVmdC1yZWN1cnNpb24gaW4gYSBjYXNlIGxpa2UgYGEgKiBiICogY2AgYW5kIHByb2R1Y2VcbiAgXHRcdC8vIGxlZnQgYXNzb2NpYXRpb24sIGkuZS4gYChhICogYikgKiBjYC4gIFRoZSBtYXRjaGVyIGNhbid0IGNhbGwgaXRzZWxmXG4gIFx0XHQvLyB0byBwYXJzZSBgbGVmdGAgYmVjYXVzZSB0aGF0IHdvdWxkIGJlIGluZmluaXRlIHJlZ3Jlc3MuXG4gIFx0XHR3aGlsZSAodHJ1ZSkge1xuICBcdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHN5bWJvbCkpIHtcbiAgXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdFx0cmV0dXJuIGxlZnQ7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBpbiBvcGVyYXRvciBtdXN0IG5vdCBiZSBmb2xsb3dlZCBieSBbYS16QS1aXyQwLTldXG4gIFx0XHRcdGlmIChzeW1ib2wgPT09IFwiaW5cIiAmJiAvW2EtekEtWl8kMC05XS8udGVzdChwYXJzZXIucmVtYWluaW5nKCkuY2hhckF0KDApKSkge1xuICBcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdFx0XHRyZXR1cm4gbGVmdDtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0XHQvLyByaWdodCBvcGVyYW5kIG11c3QgYWxzbyBjb25zaXN0IG9mIG9ubHkgaGlnaGVyLXByZWNlZGVuY2Ugb3BlcmF0b3JzXG4gIFx0XHRcdHJpZ2h0ID0gZmFsbHRocm91Z2gocGFyc2VyKTtcbiAgXHRcdFx0aWYgKCFyaWdodCkge1xuICBcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdFx0XHRyZXR1cm4gbGVmdDtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGxlZnQgPSB7XG4gIFx0XHRcdFx0dDogSU5GSVhfT1BFUkFUT1IsXG4gIFx0XHRcdFx0czogc3ltYm9sLFxuICBcdFx0XHRcdG86IFtsZWZ0LCByaWdodF1cbiAgXHRcdFx0fTtcblxuICBcdFx0XHQvLyBMb29wIGJhY2sgYXJvdW5kLiAgSWYgd2UgZG9uJ3Qgc2VlIGFub3RoZXIgb2NjdXJyZW5jZSBvZiB0aGUgc3ltYm9sLFxuICBcdFx0XHQvLyB3ZSdsbCByZXR1cm4gbGVmdC5cbiAgXHRcdH1cbiAgXHR9O1xuICB9O1xuXG4gIC8vIGNyZWF0ZSBhbGwgaW5maXggc2VxdWVuY2UgbWF0Y2hlcnMsIGFuZCByZXR1cm4gcmVhZExvZ2ljYWxPclxuICAoZnVuY3Rpb24gKCkge1xuICBcdHZhciBpLCBsZW4sIG1hdGNoZXIsIGluZml4T3BlcmF0b3JzLCBmYWxsdGhyb3VnaDtcblxuICBcdC8vIEFsbCB0aGUgaW5maXggb3BlcmF0b3JzIG9uIG9yZGVyIG9mIHByZWNlZGVuY2UgKHNvdXJjZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvT3BlcmF0b3JfUHJlY2VkZW5jZSlcbiAgXHQvLyBFYWNoIHNlcXVlbmNlIG1hdGNoZXIgd2lsbCBpbml0aWFsbHkgZmFsbCB0aHJvdWdoIHRvIGl0cyBoaWdoZXIgcHJlY2VkZW5jZVxuICBcdC8vIG5laWdoYm91ciwgYW5kIG9ubHkgYXR0ZW1wdCB0byBtYXRjaCBpZiBvbmUgb2YgdGhlIGhpZ2hlciBwcmVjZWRlbmNlIG9wZXJhdG9yc1xuICBcdC8vIChvciwgdWx0aW1hdGVseSwgYSBsaXRlcmFsLCByZWZlcmVuY2UsIG9yIGJyYWNrZXRlZCBleHByZXNzaW9uKSBhbHJlYWR5IG1hdGNoZWRcbiAgXHRpbmZpeE9wZXJhdG9ycyA9IFwiKiAvICUgKyAtIDw8ID4+ID4+PiA8IDw9ID4gPj0gaW4gaW5zdGFuY2VvZiA9PSAhPSA9PT0gIT09ICYgXiB8ICYmIHx8XCIuc3BsaXQoXCIgXCIpO1xuXG4gIFx0Ly8gQSB0eXBlb2Ygb3BlcmF0b3IgaXMgaGlnaGVyIHByZWNlZGVuY2UgdGhhbiBtdWx0aXBsaWNhdGlvblxuICBcdGZhbGx0aHJvdWdoID0gcmVhZFR5cGVvZjtcbiAgXHRmb3IgKGkgPSAwLCBsZW4gPSBpbmZpeE9wZXJhdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0bWF0Y2hlciA9IG1ha2VJbmZpeFNlcXVlbmNlTWF0Y2hlcihpbmZpeE9wZXJhdG9yc1tpXSwgZmFsbHRocm91Z2gpO1xuICBcdFx0ZmFsbHRocm91Z2ggPSBtYXRjaGVyO1xuICBcdH1cblxuICBcdC8vIExvZ2ljYWwgT1IgaXMgdGhlIGZhbGx0aHJvdWdoIGZvciB0aGUgY29uZGl0aW9uYWwgbWF0Y2hlclxuICBcdHJlYWRMb2dpY2FsT3IgPSBmYWxsdGhyb3VnaDtcbiAgfSkoKTtcblxuICB2YXIgZXhwcmVzc2lvbnNfcmVhZExvZ2ljYWxPciA9IHJlYWRMb2dpY2FsT3I7XG5cbiAgLy8gVGhlIGNvbmRpdGlvbmFsIG9wZXJhdG9yIGlzIHRoZSBsb3dlc3QgcHJlY2VkZW5jZSBvcGVyYXRvciwgc28gd2Ugc3RhcnQgaGVyZVxuICB2YXIgcmVhZENvbmRpdGlvbmFsID0gZ2V0Q29uZGl0aW9uYWw7XG4gIGZ1bmN0aW9uIGdldENvbmRpdGlvbmFsKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgZXhwcmVzc2lvbiwgaWZUcnVlLCBpZkZhbHNlO1xuXG4gIFx0ZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25zX3JlYWRMb2dpY2FsT3IocGFyc2VyKTtcbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiP1wiKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIGV4cHJlc3Npb247XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWZUcnVlID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuICBcdGlmICghaWZUcnVlKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoZXhwZWN0ZWRFeHByZXNzaW9uKTtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIjpcIikpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIFxcXCI6XFxcIlwiKTtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZkZhbHNlID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuICBcdGlmICghaWZGYWxzZSkge1xuICBcdFx0cGFyc2VyLmVycm9yKGV4cGVjdGVkRXhwcmVzc2lvbik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IENPTkRJVElPTkFMLFxuICBcdFx0bzogW2V4cHJlc3Npb24sIGlmVHJ1ZSwgaWZGYWxzZV1cbiAgXHR9O1xuICB9XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24gPSByZWFkRXhwcmVzc2lvbjtcbiAgZnVuY3Rpb24gcmVhZEV4cHJlc3Npb24ocGFyc2VyKSB7XG4gIFx0Ly8gVGhlIGNvbmRpdGlvbmFsIG9wZXJhdG9yIGlzIHRoZSBsb3dlc3QgcHJlY2VkZW5jZSBvcGVyYXRvciAoZXhjZXB0IHlpZWxkLFxuICBcdC8vIGFzc2lnbm1lbnQgb3BlcmF0b3JzLCBhbmQgY29tbWFzLCBub25lIG9mIHdoaWNoIGFyZSBzdXBwb3J0ZWQpLCBzbyB3ZVxuICBcdC8vIHN0YXJ0IHRoZXJlLiBJZiBpdCBkb2Vzbid0IG1hdGNoLCBpdCAnZmFsbHMgdGhyb3VnaCcgdG8gcHJvZ3Jlc3NpdmVseVxuICBcdC8vIGhpZ2hlciBwcmVjZWRlbmNlIG9wZXJhdG9ycywgdW50aWwgaXQgZXZlbnR1YWxseSBtYXRjaGVzIChvciBmYWlscyB0b1xuICBcdC8vIG1hdGNoKSBhICdwcmltYXJ5JyAtIGEgbGl0ZXJhbCBvciBhIHJlZmVyZW5jZS4gVGhpcyB3YXksIHRoZSBhYnN0cmFjdCBzeW50YXhcbiAgXHQvLyB0cmVlIGhhcyBldmVyeXRoaW5nIGluIGl0cyBwcm9wZXIgcGxhY2UsIGkuZS4gMiArIDMgKiA0ID09PSAxNCwgbm90IDIwLlxuICBcdHJldHVybiByZWFkQ29uZGl0aW9uYWwocGFyc2VyKTtcbiAgfVxuXG4gIHZhciB1dGlsc19mbGF0dGVuRXhwcmVzc2lvbiA9IGZsYXR0ZW5FeHByZXNzaW9uO1xuXG4gIGZ1bmN0aW9uIGZsYXR0ZW5FeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcbiAgXHR2YXIgcmVmcztcblxuICBcdGV4dHJhY3RSZWZzKGV4cHJlc3Npb24sIHJlZnMgPSBbXSk7XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0cjogcmVmcyxcbiAgXHRcdHM6IHN0cmluZ2lmeShleHByZXNzaW9uKVxuICBcdH07XG5cbiAgXHRmdW5jdGlvbiBzdHJpbmdpZnkobm9kZSkge1xuICBcdFx0c3dpdGNoIChub2RlLnQpIHtcbiAgXHRcdFx0Y2FzZSBCT09MRUFOX0xJVEVSQUw6XG4gIFx0XHRcdGNhc2UgR0xPQkFMOlxuICBcdFx0XHRjYXNlIE5VTUJFUl9MSVRFUkFMOlxuICBcdFx0XHRjYXNlIFJFR0VYUF9MSVRFUkFMOlxuICBcdFx0XHRcdHJldHVybiBub2RlLnY7XG5cbiAgXHRcdFx0Y2FzZSBTVFJJTkdfTElURVJBTDpcbiAgXHRcdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoU3RyaW5nKG5vZGUudikpO1xuXG4gIFx0XHRcdGNhc2UgQVJSQVlfTElURVJBTDpcbiAgXHRcdFx0XHRyZXR1cm4gXCJbXCIgKyAobm9kZS5tID8gbm9kZS5tLm1hcChzdHJpbmdpZnkpLmpvaW4oXCIsXCIpIDogXCJcIikgKyBcIl1cIjtcblxuICBcdFx0XHRjYXNlIE9CSkVDVF9MSVRFUkFMOlxuICBcdFx0XHRcdHJldHVybiBcIntcIiArIChub2RlLm0gPyBub2RlLm0ubWFwKHN0cmluZ2lmeSkuam9pbihcIixcIikgOiBcIlwiKSArIFwifVwiO1xuXG4gIFx0XHRcdGNhc2UgS0VZX1ZBTFVFX1BBSVI6XG4gIFx0XHRcdFx0cmV0dXJuIG5vZGUuayArIFwiOlwiICsgc3RyaW5naWZ5KG5vZGUudik7XG5cbiAgXHRcdFx0Y2FzZSBQUkVGSVhfT1BFUkFUT1I6XG4gIFx0XHRcdFx0cmV0dXJuIChub2RlLnMgPT09IFwidHlwZW9mXCIgPyBcInR5cGVvZiBcIiA6IG5vZGUucykgKyBzdHJpbmdpZnkobm9kZS5vKTtcblxuICBcdFx0XHRjYXNlIElORklYX09QRVJBVE9SOlxuICBcdFx0XHRcdHJldHVybiBzdHJpbmdpZnkobm9kZS5vWzBdKSArIChub2RlLnMuc3Vic3RyKDAsIDIpID09PSBcImluXCIgPyBcIiBcIiArIG5vZGUucyArIFwiIFwiIDogbm9kZS5zKSArIHN0cmluZ2lmeShub2RlLm9bMV0pO1xuXG4gIFx0XHRcdGNhc2UgSU5WT0NBVElPTjpcbiAgXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KG5vZGUueCkgKyBcIihcIiArIChub2RlLm8gPyBub2RlLm8ubWFwKHN0cmluZ2lmeSkuam9pbihcIixcIikgOiBcIlwiKSArIFwiKVwiO1xuXG4gIFx0XHRcdGNhc2UgQlJBQ0tFVEVEOlxuICBcdFx0XHRcdHJldHVybiBcIihcIiArIHN0cmluZ2lmeShub2RlLngpICsgXCIpXCI7XG5cbiAgXHRcdFx0Y2FzZSBNRU1CRVI6XG4gIFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeShub2RlLngpICsgc3RyaW5naWZ5KG5vZGUucik7XG5cbiAgXHRcdFx0Y2FzZSBSRUZJTkVNRU5UOlxuICBcdFx0XHRcdHJldHVybiBub2RlLm4gPyBcIi5cIiArIG5vZGUubiA6IFwiW1wiICsgc3RyaW5naWZ5KG5vZGUueCkgKyBcIl1cIjtcblxuICBcdFx0XHRjYXNlIENPTkRJVElPTkFMOlxuICBcdFx0XHRcdHJldHVybiBzdHJpbmdpZnkobm9kZS5vWzBdKSArIFwiP1wiICsgc3RyaW5naWZ5KG5vZGUub1sxXSkgKyBcIjpcIiArIHN0cmluZ2lmeShub2RlLm9bMl0pO1xuXG4gIFx0XHRcdGNhc2UgUkVGRVJFTkNFOlxuICBcdFx0XHRcdHJldHVybiBcIl9cIiArIHJlZnMuaW5kZXhPZihub2RlLm4pO1xuXG4gIFx0XHRcdGRlZmF1bHQ6XG4gIFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbGVnYWwgSmF2YVNjcmlwdFwiKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICAvLyBUT0RPIG1heWJlIHJlZmFjdG9yIHRoaXM/XG4gIGZ1bmN0aW9uIGV4dHJhY3RSZWZzKG5vZGUsIHJlZnMpIHtcbiAgXHR2YXIgaSwgbGlzdDtcblxuICBcdGlmIChub2RlLnQgPT09IFJFRkVSRU5DRSkge1xuICBcdFx0aWYgKHJlZnMuaW5kZXhPZihub2RlLm4pID09PSAtMSkge1xuICBcdFx0XHRyZWZzLnVuc2hpZnQobm9kZS5uKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRsaXN0ID0gbm9kZS5vIHx8IG5vZGUubTtcbiAgXHRpZiAobGlzdCkge1xuICBcdFx0aWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gIFx0XHRcdGV4dHJhY3RSZWZzKGxpc3QsIHJlZnMpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0aSA9IGxpc3QubGVuZ3RoO1xuICBcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0ZXh0cmFjdFJlZnMobGlzdFtpXSwgcmVmcyk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAobm9kZS54KSB7XG4gIFx0XHRleHRyYWN0UmVmcyhub2RlLngsIHJlZnMpO1xuICBcdH1cblxuICBcdGlmIChub2RlLnIpIHtcbiAgXHRcdGV4dHJhY3RSZWZzKG5vZGUuciwgcmVmcyk7XG4gIFx0fVxuXG4gIFx0aWYgKG5vZGUudikge1xuICBcdFx0ZXh0cmFjdFJlZnMobm9kZS52LCByZWZzKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgdXRpbHNfcmVmaW5lRXhwcmVzc2lvbiA9IHJlZmluZUV4cHJlc3Npb247XG5cbiAgdmFyIGFycmF5TWVtYmVyUGF0dGVybiA9IC9eWzAtOV1bMS05XSokLztcbiAgZnVuY3Rpb24gcmVmaW5lRXhwcmVzc2lvbihleHByZXNzaW9uLCBtdXN0YWNoZSkge1xuICBcdHZhciByZWZlcmVuY2VFeHByZXNzaW9uO1xuXG4gIFx0aWYgKGV4cHJlc3Npb24pIHtcbiAgXHRcdHdoaWxlIChleHByZXNzaW9uLnQgPT09IEJSQUNLRVRFRCAmJiBleHByZXNzaW9uLngpIHtcbiAgXHRcdFx0ZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24ueDtcbiAgXHRcdH1cblxuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gaW50ZWdlcnMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYXJyYXkgbWVtYmVycyByZWZlcmVuY2VzLFxuICBcdFx0Ly8gcmF0aGVyIHRoYW4gYXMgZXhwcmVzc2lvbnMgaW4gdGhlaXIgb3duIHJpZ2h0XG4gIFx0XHRpZiAoZXhwcmVzc2lvbi50ID09PSBSRUZFUkVOQ0UpIHtcbiAgXHRcdFx0bXVzdGFjaGUuciA9IGV4cHJlc3Npb24ubjtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGlmIChleHByZXNzaW9uLnQgPT09IE5VTUJFUl9MSVRFUkFMICYmIGFycmF5TWVtYmVyUGF0dGVybi50ZXN0KGV4cHJlc3Npb24udikpIHtcbiAgXHRcdFx0XHRtdXN0YWNoZS5yID0gZXhwcmVzc2lvbi52O1xuICBcdFx0XHR9IGVsc2UgaWYgKHJlZmVyZW5jZUV4cHJlc3Npb24gPSBnZXRSZWZlcmVuY2VFeHByZXNzaW9uKGV4cHJlc3Npb24pKSB7XG4gIFx0XHRcdFx0bXVzdGFjaGUucnggPSByZWZlcmVuY2VFeHByZXNzaW9uO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdG11c3RhY2hlLnggPSB1dGlsc19mbGF0dGVuRXhwcmVzc2lvbihleHByZXNzaW9uKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbXVzdGFjaGU7XG4gIFx0fVxuICB9XG5cbiAgLy8gVE9ETyByZWZhY3RvciB0aGlzISBpdCdzIGJld2lsZGVyaW5nXG4gIGZ1bmN0aW9uIGdldFJlZmVyZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICBcdHZhciBtZW1iZXJzID0gW10sXG4gIFx0ICAgIHJlZmluZW1lbnQ7XG5cbiAgXHR3aGlsZSAoZXhwcmVzc2lvbi50ID09PSBNRU1CRVIgJiYgZXhwcmVzc2lvbi5yLnQgPT09IFJFRklORU1FTlQpIHtcbiAgXHRcdHJlZmluZW1lbnQgPSBleHByZXNzaW9uLnI7XG5cbiAgXHRcdGlmIChyZWZpbmVtZW50LngpIHtcbiAgXHRcdFx0aWYgKHJlZmluZW1lbnQueC50ID09PSBSRUZFUkVOQ0UpIHtcbiAgXHRcdFx0XHRtZW1iZXJzLnVuc2hpZnQocmVmaW5lbWVudC54KTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRtZW1iZXJzLnVuc2hpZnQodXRpbHNfZmxhdHRlbkV4cHJlc3Npb24ocmVmaW5lbWVudC54KSk7XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdG1lbWJlcnMudW5zaGlmdChyZWZpbmVtZW50Lm4pO1xuICBcdFx0fVxuXG4gIFx0XHRleHByZXNzaW9uID0gZXhwcmVzc2lvbi54O1xuICBcdH1cblxuICBcdGlmIChleHByZXNzaW9uLnQgIT09IFJFRkVSRU5DRSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHI6IGV4cHJlc3Npb24ubixcbiAgXHRcdG06IG1lbWJlcnNcbiAgXHR9O1xuICB9XG5cbiAgdmFyIG11c3RhY2hlX3JlYWRUcmlwbGUgPSByZWFkVHJpcGxlO1xuICBmdW5jdGlvbiByZWFkVHJpcGxlKHBhcnNlciwgdGFnKSB7XG4gIFx0dmFyIGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlciksXG4gIFx0ICAgIHRyaXBsZTtcblxuICBcdGlmICghZXhwcmVzc2lvbikge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgdGFnLmNsb3NlICsgXCInXCIpO1xuICBcdH1cblxuICBcdHRyaXBsZSA9IHsgdDogVFJJUExFIH07XG4gIFx0dXRpbHNfcmVmaW5lRXhwcmVzc2lvbihleHByZXNzaW9uLCB0cmlwbGUpOyAvLyBUT0RPIGhhbmRsZSB0aGlzIGRpZmZlcmVudGx5IC0gaXQncyBteXN0ZXJpb3VzXG5cbiAgXHRyZXR1cm4gdHJpcGxlO1xuICB9XG5cbiAgdmFyIG11c3RhY2hlX3JlYWRVbmVzY2FwZWQgPSByZWFkVW5lc2NhcGVkO1xuICBmdW5jdGlvbiByZWFkVW5lc2NhcGVkKHBhcnNlciwgdGFnKSB7XG4gIFx0dmFyIGV4cHJlc3Npb24sIHRyaXBsZTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiJlwiKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0ZXhwcmVzc2lvbiA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcblxuICBcdGlmICghZXhwcmVzc2lvbikge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgdGFnLmNsb3NlICsgXCInXCIpO1xuICBcdH1cblxuICBcdHRyaXBsZSA9IHsgdDogVFJJUExFIH07XG4gIFx0dXRpbHNfcmVmaW5lRXhwcmVzc2lvbihleHByZXNzaW9uLCB0cmlwbGUpOyAvLyBUT0RPIGhhbmRsZSB0aGlzIGRpZmZlcmVudGx5IC0gaXQncyBteXN0ZXJpb3VzXG5cbiAgXHRyZXR1cm4gdHJpcGxlO1xuICB9XG5cbiAgdmFyIG11c3RhY2hlX3JlYWRQYXJ0aWFsID0gcmVhZFBhcnRpYWw7XG4gIGZ1bmN0aW9uIHJlYWRQYXJ0aWFsKHBhcnNlciwgdGFnKSB7XG4gIFx0dmFyIHN0YXJ0LCBuYW1lU3RhcnQsIGV4cHJlc3Npb24sIGNvbnRleHQsIHBhcnRpYWw7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIj5cIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcbiAgXHRuYW1lU3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0Ly8gUGFydGlhbCBuYW1lcyBjYW4gaW5jbHVkZSBoeXBoZW5zLCBzbyB3ZSBjYW4ndCB1c2UgcmVhZEV4cHJlc3Npb25cbiAgXHQvLyBibGluZGx5LiBJbnN0ZWFkLCB3ZSB1c2UgdGhlIGByZWxheGVkTmFtZXNgIGZsYWcgdG8gaW5kaWNhdGUgdGhhdFxuICBcdC8vIGBmb28tYmFyYCBzaG91bGQgYmUgcmVhZCBhcyBhIHNpbmdsZSBuYW1lLCByYXRoZXIgdGhhbiAnc3VidHJhY3RcbiAgXHQvLyBiYXIgZnJvbSBmb28nXG4gIFx0cGFyc2VyLnJlbGF4ZWROYW1lcyA9IHRydWU7XG4gIFx0ZXhwcmVzc2lvbiA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgXHRwYXJzZXIucmVsYXhlZE5hbWVzID0gZmFsc2U7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gIFx0Y29udGV4dCA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnRpYWwgPSB7IHQ6IFBBUlRJQUwgfTtcbiAgXHR1dGlsc19yZWZpbmVFeHByZXNzaW9uKGV4cHJlc3Npb24sIHBhcnRpYWwpOyAvLyBUT0RPLi4uXG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHQvLyBpZiB3ZSBoYXZlIGFub3RoZXIgZXhwcmVzc2lvbiAtIGUuZy4gYHt7PmZvbyBiYXJ9fWAgLSB0aGVuXG4gIFx0Ly8gd2UgdHVybiBpdCBpbnRvIGB7eyN3aXRoIGJhcn19e3s+Zm9vfX17ey93aXRofX1gXG4gIFx0aWYgKGNvbnRleHQpIHtcbiAgXHRcdHBhcnRpYWwgPSB7XG4gIFx0XHRcdHQ6IFNFQ1RJT04sXG4gIFx0XHRcdG46IFNFQ1RJT05fV0lUSCxcbiAgXHRcdFx0ZjogW3BhcnRpYWxdXG4gIFx0XHR9O1xuXG4gIFx0XHR1dGlsc19yZWZpbmVFeHByZXNzaW9uKGNvbnRleHQsIHBhcnRpYWwpO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJ1wiKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcGFydGlhbDtcbiAgfVxuXG4gIHZhciByZWFkTXVzdGFjaGVDb21tZW50ID0gcmVhZENvbW1lbnQ7XG4gIGZ1bmN0aW9uIHJlYWRDb21tZW50KHBhcnNlciwgdGFnKSB7XG4gIFx0dmFyIGluZGV4O1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCIhXCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpbmRleCA9IHBhcnNlci5yZW1haW5pbmcoKS5pbmRleE9mKHRhZy5jbG9zZSk7XG5cbiAgXHRpZiAoaW5kZXggIT09IC0xKSB7XG4gIFx0XHRwYXJzZXIucG9zICs9IGluZGV4ICsgdGFnLmNsb3NlLmxlbmd0aDtcbiAgXHRcdHJldHVybiB7IHQ6IENPTU1FTlQgfTtcbiAgXHR9XG4gIH1cblxuICB2YXIgY29udmVydGVyc19yZWFkRXhwcmVzc2lvbk9yUmVmZXJlbmNlID0gcmVhZEV4cHJlc3Npb25PclJlZmVyZW5jZTtcbiAgZnVuY3Rpb24gcmVhZEV4cHJlc3Npb25PclJlZmVyZW5jZShwYXJzZXIsIGV4cGVjdGVkRm9sbG93ZXJzKSB7XG4gIFx0dmFyIHN0YXJ0LCBleHByZXNzaW9uLCBpO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuICBcdGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG5cbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGZvciAoaSA9IDA7IGkgPCBleHBlY3RlZEZvbGxvd2Vycy5sZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0aWYgKHBhcnNlci5yZW1haW5pbmcoKS5zdWJzdHIoMCwgZXhwZWN0ZWRGb2xsb3dlcnNbaV0ubGVuZ3RoKSA9PT0gZXhwZWN0ZWRGb2xsb3dlcnNbaV0pIHtcbiAgXHRcdFx0cmV0dXJuIGV4cHJlc3Npb247XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdHJldHVybiBwcmltYXJ5X3JlYWRSZWZlcmVuY2UocGFyc2VyKTtcbiAgfVxuXG4gIHZhciBtdXN0YWNoZV9yZWFkSW50ZXJwb2xhdG9yID0gcmVhZEludGVycG9sYXRvcjtcbiAgZnVuY3Rpb24gcmVhZEludGVycG9sYXRvcihwYXJzZXIsIHRhZykge1xuICBcdHZhciBzdGFydCwgZXhwcmVzc2lvbiwgaW50ZXJwb2xhdG9yLCBlcnI7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHQvLyBUT0RPIHdvdWxkIGJlIGdvb2QgZm9yIHBlcmYgaWYgd2UgY291bGQgZG8gYXdheSB3aXRoIHRoZSB0cnktY2F0Y2hcbiAgXHR0cnkge1xuICBcdFx0ZXhwcmVzc2lvbiA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb25PclJlZmVyZW5jZShwYXJzZXIsIFt0YWcuY2xvc2VdKTtcbiAgXHR9IGNhdGNoIChlKSB7XG4gIFx0XHRlcnIgPSBlO1xuICBcdH1cblxuICBcdGlmICghZXhwcmVzc2lvbikge1xuICBcdFx0aWYgKHBhcnNlci5zdHIuY2hhckF0KHN0YXJ0KSA9PT0gXCIhXCIpIHtcbiAgXHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gY29tbWVudFxuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoZXJyKSB7XG4gIFx0XHRcdHRocm93IGVycjtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyB0YWcuY2xvc2UgKyBcIicgYWZ0ZXIgcmVmZXJlbmNlXCIpO1xuXG4gIFx0XHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gY29tbWVudFxuICBcdFx0XHRpZiAocGFyc2VyLm5leHRDaGFyKCkgPT09IFwiIVwiKSB7XG4gIFx0XHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBleHByZXNzaW9uIG9yIGxlZ2FsIHJlZmVyZW5jZVwiKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpbnRlcnBvbGF0b3IgPSB7IHQ6IElOVEVSUE9MQVRPUiB9O1xuICBcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgaW50ZXJwb2xhdG9yKTsgLy8gVE9ETyBoYW5kbGUgdGhpcyBkaWZmZXJlbnRseSAtIGl0J3MgbXlzdGVyaW91c1xuXG4gIFx0cmV0dXJuIGludGVycG9sYXRvcjtcbiAgfVxuXG4gIHZhciBtdXN0YWNoZV9yZWFkWWllbGRlciA9IHJlYWRZaWVsZGVyO1xuICB2YXIgeWllbGRQYXR0ZXJuID0gL155aWVsZFxccyovO1xuICBmdW5jdGlvbiByZWFkWWllbGRlcihwYXJzZXIsIHRhZykge1xuICBcdHZhciBzdGFydCwgbmFtZSwgeWllbGRlcjtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoUGF0dGVybih5aWVsZFBhdHRlcm4pKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG4gIFx0bmFtZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oL15bYS16QS1aXyRdW2EtekEtWl8kMC05XFwtXSovKTtcblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcImV4cGVjdGVkIGxlZ2FsIHBhcnRpYWwgbmFtZVwiKTtcbiAgXHR9XG5cbiAgXHR5aWVsZGVyID0geyB0OiBZSUVMREVSIH07XG5cbiAgXHRpZiAobmFtZSkge1xuICBcdFx0eWllbGRlci5uID0gbmFtZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4geWllbGRlcjtcbiAgfVxuXG4gIHZhciBzZWN0aW9uX3JlYWRDbG9zaW5nID0gcmVhZENsb3Npbmc7XG4gIGZ1bmN0aW9uIHJlYWRDbG9zaW5nKHBhcnNlciwgdGFnKSB7XG4gIFx0dmFyIHN0YXJ0LCByZW1haW5pbmcsIGluZGV4LCBjbG9zaW5nO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLm9wZW4pKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIi9cIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcbiAgXHRpbmRleCA9IHJlbWFpbmluZy5pbmRleE9mKHRhZy5jbG9zZSk7XG5cbiAgXHRpZiAoaW5kZXggIT09IC0xKSB7XG4gIFx0XHRjbG9zaW5nID0ge1xuICBcdFx0XHR0OiBDTE9TSU5HLFxuICBcdFx0XHRyOiByZW1haW5pbmcuc3Vic3RyKDAsIGluZGV4KS5zcGxpdChcIiBcIilbMF1cbiAgXHRcdH07XG5cbiAgXHRcdHBhcnNlci5wb3MgKz0gaW5kZXg7XG5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgdGFnLmNsb3NlICsgXCInXCIpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gY2xvc2luZztcbiAgXHR9XG5cbiAgXHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgc2VjdGlvbl9yZWFkRWxzZSA9IHNlY3Rpb25fcmVhZEVsc2VfX3JlYWRFbHNlO1xuICB2YXIgc2VjdGlvbl9yZWFkRWxzZV9fZWxzZVBhdHRlcm4gPSAvXlxccyplbHNlXFxzKi87XG4gIGZ1bmN0aW9uIHNlY3Rpb25fcmVhZEVsc2VfX3JlYWRFbHNlKHBhcnNlciwgdGFnKSB7XG4gIFx0dmFyIHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5vcGVuKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hQYXR0ZXJuKHNlY3Rpb25fcmVhZEVsc2VfX2Vsc2VQYXR0ZXJuKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgdGFnLmNsb3NlICsgXCInXCIpO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBFTFNFXG4gIFx0fTtcbiAgfVxuXG4gIHZhciByZWFkRWxzZUlmID0gcmVhZEVsc2VJZl9fcmVhZEVsc2U7XG4gIHZhciByZWFkRWxzZUlmX19lbHNlUGF0dGVybiA9IC9eXFxzKmVsc2VpZlxccysvO1xuICBmdW5jdGlvbiByZWFkRWxzZUlmX19yZWFkRWxzZShwYXJzZXIsIHRhZykge1xuICBcdHZhciBzdGFydCA9IHBhcnNlci5wb3MsXG4gIFx0ICAgIGV4cHJlc3Npb247XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcub3BlbikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoUGF0dGVybihyZWFkRWxzZUlmX19lbHNlUGF0dGVybikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyB0YWcuY2xvc2UgKyBcIidcIik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IEVMU0VJRixcbiAgXHRcdHg6IGV4cHJlc3Npb25cbiAgXHR9O1xuICB9XG5cbiAgdmFyIGhhbmRsZWJhcnNCbG9ja0NvZGVzID0ge1xuICBcdGVhY2g6IFNFQ1RJT05fRUFDSCxcbiAgXHRcImlmXCI6IFNFQ1RJT05fSUYsXG4gIFx0XCJpZi13aXRoXCI6IFNFQ1RJT05fSUZfV0lUSCxcbiAgXHRcIndpdGhcIjogU0VDVElPTl9XSVRILFxuICBcdHVubGVzczogU0VDVElPTl9VTkxFU1NcbiAgfTtcblxuICB2YXIgbXVzdGFjaGVfcmVhZFNlY3Rpb24gPSByZWFkU2VjdGlvbjtcblxuICB2YXIgaW5kZXhSZWZQYXR0ZXJuID0gL15cXHMqOlxccyooW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKS8sXG4gICAgICBrZXlJbmRleFJlZlBhdHRlcm4gPSAvXlxccyosXFxzKihbYS16QS1aXyRdW2EtekEtWl8kMC05XSopLyxcbiAgICAgIGhhbmRsZWJhcnNCbG9ja1BhdHRlcm4gPSBuZXcgUmVnRXhwKFwiXihcIiArIE9iamVjdC5rZXlzKGhhbmRsZWJhcnNCbG9ja0NvZGVzKS5qb2luKFwifFwiKSArIFwiKVxcXFxiXCIpO1xuICBmdW5jdGlvbiByZWFkU2VjdGlvbihwYXJzZXIsIHRhZykge1xuICBcdHZhciBzdGFydCwgZXhwcmVzc2lvbiwgc2VjdGlvbiwgY2hpbGQsIGNoaWxkcmVuLCBoYXNFbHNlLCBibG9jaywgdW5sZXNzQmxvY2ssIGNvbmRpdGlvbnMsIGNsb3NlZCwgaSwgZXhwZWN0ZWRDbG9zZTtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJeXCIpKSB7XG4gIFx0XHRzZWN0aW9uID0geyB0OiBTRUNUSU9OLCBmOiBbXSwgbjogU0VDVElPTl9VTkxFU1MgfTtcbiAgXHR9IGVsc2UgaWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIiNcIikpIHtcbiAgXHRcdHNlY3Rpb24gPSB7IHQ6IFNFQ1RJT04sIGY6IFtdIH07XG5cbiAgXHRcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJwYXJ0aWFsXCIpKSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydCAtIHBhcnNlci5zdGFuZGFyZERlbGltaXRlcnNbMF0ubGVuZ3RoO1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoXCJQYXJ0aWFsIGRlZmluaXRpb25zIGNhbiBvbmx5IGJlIGF0IHRoZSB0b3AgbGV2ZWwgb2YgdGhlIHRlbXBsYXRlLCBvciBpbW1lZGlhdGVseSBpbnNpZGUgY29tcG9uZW50c1wiKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGJsb2NrID0gcGFyc2VyLm1hdGNoUGF0dGVybihoYW5kbGViYXJzQmxvY2tQYXR0ZXJuKSkge1xuICBcdFx0XHRleHBlY3RlZENsb3NlID0gYmxvY2s7XG4gIFx0XHRcdHNlY3Rpb24ubiA9IGhhbmRsZWJhcnNCbG9ja0NvZGVzW2Jsb2NrXTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0ZXhwcmVzc2lvbiA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcblxuICBcdGlmICghZXhwcmVzc2lvbikge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgZXhwcmVzc2lvblwiKTtcbiAgXHR9XG5cbiAgXHQvLyBvcHRpb25hbCBpbmRleCBhbmQga2V5IHJlZmVyZW5jZXNcbiAgXHRpZiAoaSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oaW5kZXhSZWZQYXR0ZXJuKSkge1xuICBcdFx0dmFyIGV4dHJhID0gdW5kZWZpbmVkO1xuXG4gIFx0XHRpZiAoZXh0cmEgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKGtleUluZGV4UmVmUGF0dGVybikpIHtcbiAgXHRcdFx0c2VjdGlvbi5pID0gaSArIFwiLFwiICsgZXh0cmE7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRzZWN0aW9uLmkgPSBpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJ1wiKTtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuc2VjdGlvbkRlcHRoICs9IDE7XG4gIFx0Y2hpbGRyZW4gPSBzZWN0aW9uLmY7XG5cbiAgXHRjb25kaXRpb25zID0gW107XG5cbiAgXHRkbyB7XG4gIFx0XHRpZiAoY2hpbGQgPSBzZWN0aW9uX3JlYWRDbG9zaW5nKHBhcnNlciwgdGFnKSkge1xuICBcdFx0XHRpZiAoZXhwZWN0ZWRDbG9zZSAmJiBjaGlsZC5yICE9PSBleHBlY3RlZENsb3NlKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgXCIgKyB0YWcub3BlbiArIFwiL1wiICsgZXhwZWN0ZWRDbG9zZSArIFwiXCIgKyB0YWcuY2xvc2UpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cGFyc2VyLnNlY3Rpb25EZXB0aCAtPSAxO1xuICBcdFx0XHRjbG9zZWQgPSB0cnVlO1xuICBcdFx0fSBlbHNlIGlmIChjaGlsZCA9IHJlYWRFbHNlSWYocGFyc2VyLCB0YWcpKSB7XG4gIFx0XHRcdGlmIChzZWN0aW9uLm4gPT09IFNFQ1RJT05fVU5MRVNTKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwie3tlbHNlfX0gbm90IGFsbG93ZWQgaW4ge3sjdW5sZXNzfX1cIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoaGFzRWxzZSkge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihcImlsbGVnYWwge3tlbHNlaWYuLi59fSBhZnRlciB7e2Vsc2V9fVwiKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICghdW5sZXNzQmxvY2spIHtcbiAgXHRcdFx0XHR1bmxlc3NCbG9jayA9IGNyZWF0ZVVubGVzc0Jsb2NrKGV4cHJlc3Npb24sIHNlY3Rpb24ubik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR1bmxlc3NCbG9jay5mLnB1c2goe1xuICBcdFx0XHRcdHQ6IFNFQ1RJT04sXG4gIFx0XHRcdFx0bjogU0VDVElPTl9JRixcbiAgXHRcdFx0XHR4OiB1dGlsc19mbGF0dGVuRXhwcmVzc2lvbihtdXN0YWNoZV9yZWFkU2VjdGlvbl9fY29tYmluZShjb25kaXRpb25zLmNvbmNhdChjaGlsZC54KSkpLFxuICBcdFx0XHRcdGY6IGNoaWxkcmVuID0gW11cbiAgXHRcdFx0fSk7XG5cbiAgXHRcdFx0Y29uZGl0aW9ucy5wdXNoKGludmVydChjaGlsZC54KSk7XG4gIFx0XHR9IGVsc2UgaWYgKGNoaWxkID0gc2VjdGlvbl9yZWFkRWxzZShwYXJzZXIsIHRhZykpIHtcbiAgXHRcdFx0aWYgKHNlY3Rpb24ubiA9PT0gU0VDVElPTl9VTkxFU1MpIHtcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJ7e2Vsc2V9fSBub3QgYWxsb3dlZCBpbiB7eyN1bmxlc3N9fVwiKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChoYXNFbHNlKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwidGhlcmUgY2FuIG9ubHkgYmUgb25lIHt7ZWxzZX19IGJsb2NrLCBhdCB0aGUgZW5kIG9mIGEgc2VjdGlvblwiKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGhhc0Vsc2UgPSB0cnVlO1xuXG4gIFx0XHRcdC8vIHVzZSBhbiB1bmxlc3MgYmxvY2sgaWYgdGhlcmUncyBubyBlbHNlaWZcbiAgXHRcdFx0aWYgKCF1bmxlc3NCbG9jaykge1xuICBcdFx0XHRcdHVubGVzc0Jsb2NrID0gY3JlYXRlVW5sZXNzQmxvY2soZXhwcmVzc2lvbiwgc2VjdGlvbi5uKTtcbiAgXHRcdFx0XHRjaGlsZHJlbiA9IHVubGVzc0Jsb2NrLmY7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0dW5sZXNzQmxvY2suZi5wdXNoKHtcbiAgXHRcdFx0XHRcdHQ6IFNFQ1RJT04sXG4gIFx0XHRcdFx0XHRuOiBTRUNUSU9OX0lGLFxuICBcdFx0XHRcdFx0eDogdXRpbHNfZmxhdHRlbkV4cHJlc3Npb24obXVzdGFjaGVfcmVhZFNlY3Rpb25fX2NvbWJpbmUoY29uZGl0aW9ucykpLFxuICBcdFx0XHRcdFx0ZjogY2hpbGRyZW4gPSBbXVxuICBcdFx0XHRcdH0pO1xuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRjaGlsZCA9IHBhcnNlci5yZWFkKFJFQURFUlMpO1xuXG4gIFx0XHRcdGlmICghY2hpbGQpIHtcbiAgXHRcdFx0XHRicmVhaztcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICBcdFx0fVxuICBcdH0gd2hpbGUgKCFjbG9zZWQpO1xuXG4gIFx0aWYgKHVubGVzc0Jsb2NrKSB7XG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBgd2l0aGAgc2hvdWxkIGJlY29tZSBgaWYtd2l0aGAgKFRPRE8gaXMgdGhpcyByaWdodD9cbiAgXHRcdC8vIHNlZW1zIHRvIG1lIHRoYXQgYHdpdGhgIG91Z2h0IHRvIGJlaGF2ZSBjb25zaXN0ZW50bHksIHJlZ2FyZGxlc3NcbiAgXHRcdC8vIG9mIHRoZSBwcmVzZW5jZS9hYnNlbmNlIG9mIGBlbHNlYC4gSW4gb3RoZXIgd29yZHMgc2hvdWxkIGFsd2F5c1xuICBcdFx0Ly8gYmUgYGlmLXdpdGhgXG4gIFx0XHRpZiAoc2VjdGlvbi5uID09PSBTRUNUSU9OX1dJVEgpIHtcbiAgXHRcdFx0c2VjdGlvbi5uID0gU0VDVElPTl9JRl9XSVRIO1xuICBcdFx0fVxuXG4gIFx0XHRzZWN0aW9uLmwgPSB1bmxlc3NCbG9jaztcbiAgXHR9XG5cbiAgXHR1dGlsc19yZWZpbmVFeHByZXNzaW9uKGV4cHJlc3Npb24sIHNlY3Rpb24pO1xuXG4gIFx0Ly8gVE9ETyBpZiBhIHNlY3Rpb24gaXMgZW1wdHkgaXQgc2hvdWxkIGJlIGRpc2NhcmRlZC4gRG9uJ3QgZG9cbiAgXHQvLyB0aGF0IGhlcmUgdGhvdWdoIC0gd2UgbmVlZCB0byBjbGVhbiBldmVyeXRoaW5nIHVwIGZpcnN0LCBhc1xuICBcdC8vIGl0IG1heSBjb250YWluIHJlbW92ZWFibGUgd2hpdGVzcGFjZS4gQXMgYSB0ZW1wb3JhcnkgbWVhc3VyZSxcbiAgXHQvLyB0byBwYXNzIHRoZSBleGlzdGluZyB0ZXN0cywgcmVtb3ZlIGVtcHR5IGBmYCBhcnJheXNcbiAgXHRpZiAoIXNlY3Rpb24uZi5sZW5ndGgpIHtcbiAgXHRcdGRlbGV0ZSBzZWN0aW9uLmY7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHNlY3Rpb247XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmxlc3NCbG9jayhleHByZXNzaW9uLCBzZWN0aW9uVHlwZSkge1xuICBcdHZhciB1bmxlc3NCbG9jaztcblxuICBcdGlmIChzZWN0aW9uVHlwZSA9PT0gU0VDVElPTl9XSVRIKSB7XG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBhIGB7eyN3aXRoIGZvb319YCBzZWN0aW9uIHdpbGwgcmVuZGVyIGlmIGBmb29gIGlzXG4gIFx0XHQvLyB0cnV0aHksIHNvIHRoZSBge3tlbHNlfX1gIHNlY3Rpb24gbmVlZHMgdG8gcmVuZGVyIGlmIGBmb29gIGlzIGZhbHN5LFxuICBcdFx0Ly8gcmF0aGVyIHRoYW4gYWRoZXJpbmcgdG8gdGhlIG5vcm1hbCBge3sjdW5sZXNzIGZvb319YCBsb2dpYyAod2hpY2hcbiAgXHRcdC8vIHRyZWF0cyBlbXB0eSBhcnJheXMvb2JqZWN0cyBhcyBmYWxzeSlcbiAgXHRcdHVubGVzc0Jsb2NrID0ge1xuICBcdFx0XHR0OiBTRUNUSU9OLFxuICBcdFx0XHRuOiBTRUNUSU9OX0lGLFxuICBcdFx0XHRmOiBbXVxuICBcdFx0fTtcblxuICBcdFx0dXRpbHNfcmVmaW5lRXhwcmVzc2lvbihpbnZlcnQoZXhwcmVzc2lvbiksIHVubGVzc0Jsb2NrKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0dW5sZXNzQmxvY2sgPSB7XG4gIFx0XHRcdHQ6IFNFQ1RJT04sXG4gIFx0XHRcdG46IFNFQ1RJT05fVU5MRVNTLFxuICBcdFx0XHRmOiBbXVxuICBcdFx0fTtcblxuICBcdFx0dXRpbHNfcmVmaW5lRXhwcmVzc2lvbihleHByZXNzaW9uLCB1bmxlc3NCbG9jayk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHVubGVzc0Jsb2NrO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52ZXJ0KGV4cHJlc3Npb24pIHtcbiAgXHRpZiAoZXhwcmVzc2lvbi50ID09PSBQUkVGSVhfT1BFUkFUT1IgJiYgZXhwcmVzc2lvbi5zID09PSBcIiFcIikge1xuICBcdFx0cmV0dXJuIGV4cHJlc3Npb24ubztcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogUFJFRklYX09QRVJBVE9SLFxuICBcdFx0czogXCIhXCIsXG4gIFx0XHRvOiBwYXJlbnNJZk5lY2Vzc2FyeShleHByZXNzaW9uKVxuICBcdH07XG4gIH1cblxuICBmdW5jdGlvbiBtdXN0YWNoZV9yZWFkU2VjdGlvbl9fY29tYmluZShleHByZXNzaW9ucykge1xuICBcdGlmIChleHByZXNzaW9ucy5sZW5ndGggPT09IDEpIHtcbiAgXHRcdHJldHVybiBleHByZXNzaW9uc1swXTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogSU5GSVhfT1BFUkFUT1IsXG4gIFx0XHRzOiBcIiYmXCIsXG4gIFx0XHRvOiBbcGFyZW5zSWZOZWNlc3NhcnkoZXhwcmVzc2lvbnNbMF0pLCBwYXJlbnNJZk5lY2Vzc2FyeShtdXN0YWNoZV9yZWFkU2VjdGlvbl9fY29tYmluZShleHByZXNzaW9ucy5zbGljZSgxKSkpXVxuICBcdH07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJlbnNJZk5lY2Vzc2FyeShleHByZXNzaW9uKSB7XG4gIFx0Ly8gVE9ETyBvbmx5IHdyYXAgaWYgbmVjZXNzYXJ5XG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IEJSQUNLRVRFRCxcbiAgXHRcdHg6IGV4cHJlc3Npb25cbiAgXHR9O1xuICB9XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZEh0bWxDb21tZW50ID0gcmVhZEh0bWxDb21tZW50O1xuICB2YXIgT1BFTl9DT01NRU5UID0gXCI8IS0tXCIsXG4gICAgICBDTE9TRV9DT01NRU5UID0gXCItLT5cIjtcbiAgZnVuY3Rpb24gcmVhZEh0bWxDb21tZW50KHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgY29udGVudCwgcmVtYWluaW5nLCBlbmRJbmRleCwgY29tbWVudDtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKE9QRU5fQ09NTUVOVCkpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcbiAgXHRlbmRJbmRleCA9IHJlbWFpbmluZy5pbmRleE9mKENMT1NFX0NPTU1FTlQpO1xuXG4gIFx0aWYgKGVuZEluZGV4ID09PSAtMSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiSWxsZWdhbCBIVE1MIC0gZXhwZWN0ZWQgY2xvc2luZyBjb21tZW50IHNlcXVlbmNlICgnLS0+JylcIik7XG4gIFx0fVxuXG4gIFx0Y29udGVudCA9IHJlbWFpbmluZy5zdWJzdHIoMCwgZW5kSW5kZXgpO1xuICBcdHBhcnNlci5wb3MgKz0gZW5kSW5kZXggKyAzO1xuXG4gIFx0Y29tbWVudCA9IHtcbiAgXHRcdHQ6IENPTU1FTlQsXG4gIFx0XHRjOiBjb250ZW50XG4gIFx0fTtcblxuICBcdGlmIChwYXJzZXIuaW5jbHVkZUxpbmVQb3NpdGlvbnMpIHtcbiAgXHRcdGNvbW1lbnQucCA9IHBhcnNlci5nZXRMaW5lUG9zKHN0YXJ0KTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gY29tbWVudDtcbiAgfVxuXG4gIHZhciBib29sZWFuQXR0cmlidXRlcywgdm9pZEVsZW1lbnROYW1lcywgaHRtbEVudGl0aWVzLCBjb250cm9sQ2hhcmFjdGVycywgZW50aXR5UGF0dGVybiwgbGVzc1RoYW4sIGdyZWF0ZXJUaGFuLCBhbXA7XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2thbmdheC9odG1sLW1pbmlmaWVyL2lzc3Vlcy82MyNpc3N1ZWNvbW1lbnQtMzc3NjMzMTZcbiAgYm9vbGVhbkF0dHJpYnV0ZXMgPSAvXihhbGxvd0Z1bGxzY3JlZW58YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNoZWNrZWR8Y29tcGFjdHxjb250cm9sc3xkZWNsYXJlfGRlZmF1bHR8ZGVmYXVsdENoZWNrZWR8ZGVmYXVsdE11dGVkfGRlZmF1bHRTZWxlY3RlZHxkZWZlcnxkaXNhYmxlZHxlbmFibGVkfGZvcm1Ob1ZhbGlkYXRlfGhpZGRlbnxpbmRldGVybWluYXRlfGluZXJ0fGlzTWFwfGl0ZW1TY29wZXxsb29wfG11bHRpcGxlfG11dGVkfG5vSHJlZnxub1Jlc2l6ZXxub1NoYWRlfG5vVmFsaWRhdGV8bm9XcmFwfG9wZW58cGF1c2VPbkV4aXR8cmVhZE9ubHl8cmVxdWlyZWR8cmV2ZXJzZWR8c2NvcGVkfHNlYW1sZXNzfHNlbGVjdGVkfHNvcnRhYmxlfHRyYW5zbGF0ZXx0cnVlU3BlZWR8dHlwZU11c3RNYXRjaHx2aXNpYmxlKSQvaTtcbiAgdm9pZEVsZW1lbnROYW1lcyA9IC9eKD86YXJlYXxiYXNlfGJyfGNvbHxjb21tYW5kfGRvY3R5cGV8ZW1iZWR8aHJ8aW1nfGlucHV0fGtleWdlbnxsaW5rfG1ldGF8cGFyYW18c291cmNlfHRyYWNrfHdicikkL2k7XG5cbiAgaHRtbEVudGl0aWVzID0geyBxdW90OiAzNCwgYW1wOiAzOCwgYXBvczogMzksIGx0OiA2MCwgZ3Q6IDYyLCBuYnNwOiAxNjAsIGlleGNsOiAxNjEsIGNlbnQ6IDE2MiwgcG91bmQ6IDE2MywgY3VycmVuOiAxNjQsIHllbjogMTY1LCBicnZiYXI6IDE2Niwgc2VjdDogMTY3LCB1bWw6IDE2OCwgY29weTogMTY5LCBvcmRmOiAxNzAsIGxhcXVvOiAxNzEsIG5vdDogMTcyLCBzaHk6IDE3MywgcmVnOiAxNzQsIG1hY3I6IDE3NSwgZGVnOiAxNzYsIHBsdXNtbjogMTc3LCBzdXAyOiAxNzgsIHN1cDM6IDE3OSwgYWN1dGU6IDE4MCwgbWljcm86IDE4MSwgcGFyYTogMTgyLCBtaWRkb3Q6IDE4MywgY2VkaWw6IDE4NCwgc3VwMTogMTg1LCBvcmRtOiAxODYsIHJhcXVvOiAxODcsIGZyYWMxNDogMTg4LCBmcmFjMTI6IDE4OSwgZnJhYzM0OiAxOTAsIGlxdWVzdDogMTkxLCBBZ3JhdmU6IDE5MiwgQWFjdXRlOiAxOTMsIEFjaXJjOiAxOTQsIEF0aWxkZTogMTk1LCBBdW1sOiAxOTYsIEFyaW5nOiAxOTcsIEFFbGlnOiAxOTgsIENjZWRpbDogMTk5LCBFZ3JhdmU6IDIwMCwgRWFjdXRlOiAyMDEsIEVjaXJjOiAyMDIsIEV1bWw6IDIwMywgSWdyYXZlOiAyMDQsIElhY3V0ZTogMjA1LCBJY2lyYzogMjA2LCBJdW1sOiAyMDcsIEVUSDogMjA4LCBOdGlsZGU6IDIwOSwgT2dyYXZlOiAyMTAsIE9hY3V0ZTogMjExLCBPY2lyYzogMjEyLCBPdGlsZGU6IDIxMywgT3VtbDogMjE0LCB0aW1lczogMjE1LCBPc2xhc2g6IDIxNiwgVWdyYXZlOiAyMTcsIFVhY3V0ZTogMjE4LCBVY2lyYzogMjE5LCBVdW1sOiAyMjAsIFlhY3V0ZTogMjIxLCBUSE9STjogMjIyLCBzemxpZzogMjIzLCBhZ3JhdmU6IDIyNCwgYWFjdXRlOiAyMjUsIGFjaXJjOiAyMjYsIGF0aWxkZTogMjI3LCBhdW1sOiAyMjgsIGFyaW5nOiAyMjksIGFlbGlnOiAyMzAsIGNjZWRpbDogMjMxLCBlZ3JhdmU6IDIzMiwgZWFjdXRlOiAyMzMsIGVjaXJjOiAyMzQsIGV1bWw6IDIzNSwgaWdyYXZlOiAyMzYsIGlhY3V0ZTogMjM3LCBpY2lyYzogMjM4LCBpdW1sOiAyMzksIGV0aDogMjQwLCBudGlsZGU6IDI0MSwgb2dyYXZlOiAyNDIsIG9hY3V0ZTogMjQzLCBvY2lyYzogMjQ0LCBvdGlsZGU6IDI0NSwgb3VtbDogMjQ2LCBkaXZpZGU6IDI0Nywgb3NsYXNoOiAyNDgsIHVncmF2ZTogMjQ5LCB1YWN1dGU6IDI1MCwgdWNpcmM6IDI1MSwgdXVtbDogMjUyLCB5YWN1dGU6IDI1MywgdGhvcm46IDI1NCwgeXVtbDogMjU1LCBPRWxpZzogMzM4LCBvZWxpZzogMzM5LCBTY2Fyb246IDM1Miwgc2Nhcm9uOiAzNTMsIFl1bWw6IDM3NiwgZm5vZjogNDAyLCBjaXJjOiA3MTAsIHRpbGRlOiA3MzIsIEFscGhhOiA5MTMsIEJldGE6IDkxNCwgR2FtbWE6IDkxNSwgRGVsdGE6IDkxNiwgRXBzaWxvbjogOTE3LCBaZXRhOiA5MTgsIEV0YTogOTE5LCBUaGV0YTogOTIwLCBJb3RhOiA5MjEsIEthcHBhOiA5MjIsIExhbWJkYTogOTIzLCBNdTogOTI0LCBOdTogOTI1LCBYaTogOTI2LCBPbWljcm9uOiA5MjcsIFBpOiA5MjgsIFJobzogOTI5LCBTaWdtYTogOTMxLCBUYXU6IDkzMiwgVXBzaWxvbjogOTMzLCBQaGk6IDkzNCwgQ2hpOiA5MzUsIFBzaTogOTM2LCBPbWVnYTogOTM3LCBhbHBoYTogOTQ1LCBiZXRhOiA5NDYsIGdhbW1hOiA5NDcsIGRlbHRhOiA5NDgsIGVwc2lsb246IDk0OSwgemV0YTogOTUwLCBldGE6IDk1MSwgdGhldGE6IDk1MiwgaW90YTogOTUzLCBrYXBwYTogOTU0LCBsYW1iZGE6IDk1NSwgbXU6IDk1NiwgbnU6IDk1NywgeGk6IDk1OCwgb21pY3JvbjogOTU5LCBwaTogOTYwLCByaG86IDk2MSwgc2lnbWFmOiA5NjIsIHNpZ21hOiA5NjMsIHRhdTogOTY0LCB1cHNpbG9uOiA5NjUsIHBoaTogOTY2LCBjaGk6IDk2NywgcHNpOiA5NjgsIG9tZWdhOiA5NjksIHRoZXRhc3ltOiA5NzcsIHVwc2loOiA5NzgsIHBpdjogOTgyLCBlbnNwOiA4MTk0LCBlbXNwOiA4MTk1LCB0aGluc3A6IDgyMDEsIHp3bmo6IDgyMDQsIHp3ajogODIwNSwgbHJtOiA4MjA2LCBybG06IDgyMDcsIG5kYXNoOiA4MjExLCBtZGFzaDogODIxMiwgbHNxdW86IDgyMTYsIHJzcXVvOiA4MjE3LCBzYnF1bzogODIxOCwgbGRxdW86IDgyMjAsIHJkcXVvOiA4MjIxLCBiZHF1bzogODIyMiwgZGFnZ2VyOiA4MjI0LCBEYWdnZXI6IDgyMjUsIGJ1bGw6IDgyMjYsIGhlbGxpcDogODIzMCwgcGVybWlsOiA4MjQwLCBwcmltZTogODI0MiwgUHJpbWU6IDgyNDMsIGxzYXF1bzogODI0OSwgcnNhcXVvOiA4MjUwLCBvbGluZTogODI1NCwgZnJhc2w6IDgyNjAsIGV1cm86IDgzNjQsIGltYWdlOiA4NDY1LCB3ZWllcnA6IDg0NzIsIHJlYWw6IDg0NzYsIHRyYWRlOiA4NDgyLCBhbGVmc3ltOiA4NTAxLCBsYXJyOiA4NTkyLCB1YXJyOiA4NTkzLCByYXJyOiA4NTk0LCBkYXJyOiA4NTk1LCBoYXJyOiA4NTk2LCBjcmFycjogODYyOSwgbEFycjogODY1NiwgdUFycjogODY1NywgckFycjogODY1OCwgZEFycjogODY1OSwgaEFycjogODY2MCwgZm9yYWxsOiA4NzA0LCBwYXJ0OiA4NzA2LCBleGlzdDogODcwNywgZW1wdHk6IDg3MDksIG5hYmxhOiA4NzExLCBpc2luOiA4NzEyLCBub3RpbjogODcxMywgbmk6IDg3MTUsIHByb2Q6IDg3MTksIHN1bTogODcyMSwgbWludXM6IDg3MjIsIGxvd2FzdDogODcyNywgcmFkaWM6IDg3MzAsIHByb3A6IDg3MzMsIGluZmluOiA4NzM0LCBhbmc6IDg3MzYsIGFuZDogODc0Mywgb3I6IDg3NDQsIGNhcDogODc0NSwgY3VwOiA4NzQ2LCBpbnQ6IDg3NDcsIHRoZXJlNDogODc1Niwgc2ltOiA4NzY0LCBjb25nOiA4NzczLCBhc3ltcDogODc3NiwgbmU6IDg4MDAsIGVxdWl2OiA4ODAxLCBsZTogODgwNCwgZ2U6IDg4MDUsIHN1YjogODgzNCwgc3VwOiA4ODM1LCBuc3ViOiA4ODM2LCBzdWJlOiA4ODM4LCBzdXBlOiA4ODM5LCBvcGx1czogODg1Mywgb3RpbWVzOiA4ODU1LCBwZXJwOiA4ODY5LCBzZG90OiA4OTAxLCBsY2VpbDogODk2OCwgcmNlaWw6IDg5NjksIGxmbG9vcjogODk3MCwgcmZsb29yOiA4OTcxLCBsYW5nOiA5MDAxLCByYW5nOiA5MDAyLCBsb3o6IDk2NzQsIHNwYWRlczogOTgyNCwgY2x1YnM6IDk4MjcsIGhlYXJ0czogOTgyOSwgZGlhbXM6IDk4MzAgfTtcbiAgY29udHJvbENoYXJhY3RlcnMgPSBbODM2NCwgMTI5LCA4MjE4LCA0MDIsIDgyMjIsIDgyMzAsIDgyMjQsIDgyMjUsIDcxMCwgODI0MCwgMzUyLCA4MjQ5LCAzMzgsIDE0MSwgMzgxLCAxNDMsIDE0NCwgODIxNiwgODIxNywgODIyMCwgODIyMSwgODIyNiwgODIxMSwgODIxMiwgNzMyLCA4NDgyLCAzNTMsIDgyNTAsIDMzOSwgMTU3LCAzODIsIDM3Nl07XG4gIGVudGl0eVBhdHRlcm4gPSBuZXcgUmVnRXhwKFwiJigjPyg/OnhbXFxcXHdcXFxcZF0rfFxcXFxkK3xcIiArIE9iamVjdC5rZXlzKGh0bWxFbnRpdGllcykuam9pbihcInxcIikgKyBcIikpOz9cIiwgXCJnXCIpO1xuXG4gIGZ1bmN0aW9uIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMoaHRtbCkge1xuICBcdHJldHVybiBodG1sLnJlcGxhY2UoZW50aXR5UGF0dGVybiwgZnVuY3Rpb24gKG1hdGNoLCBlbnRpdHkpIHtcbiAgXHRcdHZhciBjb2RlO1xuXG4gIFx0XHQvLyBIYW5kbGUgbmFtZWQgZW50aXRpZXNcbiAgXHRcdGlmIChlbnRpdHlbMF0gIT09IFwiI1wiKSB7XG4gIFx0XHRcdGNvZGUgPSBodG1sRW50aXRpZXNbZW50aXR5XTtcbiAgXHRcdH0gZWxzZSBpZiAoZW50aXR5WzFdID09PSBcInhcIikge1xuICBcdFx0XHRjb2RlID0gcGFyc2VJbnQoZW50aXR5LnN1YnN0cmluZygyKSwgMTYpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Y29kZSA9IHBhcnNlSW50KGVudGl0eS5zdWJzdHJpbmcoMSksIDEwKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFjb2RlKSB7XG4gIFx0XHRcdHJldHVybiBtYXRjaDtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodmFsaWRhdGVDb2RlKGNvZGUpKTtcbiAgXHR9KTtcbiAgfVxuXG4gIC8vIHNvbWUgY29kZSBwb2ludHMgYXJlIHZlcmJvdGVuLiBJZiB3ZSB3ZXJlIGluc2VydGluZyBIVE1MLCB0aGUgYnJvd3NlciB3b3VsZCByZXBsYWNlIHRoZSBpbGxlZ2FsXG4gIC8vIGNvZGUgcG9pbnRzIHdpdGggYWx0ZXJuYXRpdmVzIGluIHNvbWUgY2FzZXMgLSBzaW5jZSB3ZSdyZSBieXBhc3NpbmcgdGhhdCBtZWNoYW5pc20sIHdlIG5lZWRcbiAgLy8gdG8gcmVwbGFjZSB0aGVtIG91cnNlbHZlc1xuICAvL1xuICAvLyBTb3VyY2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2hhcmFjdGVyX2VuY29kaW5nc19pbl9IVE1MI0lsbGVnYWxfY2hhcmFjdGVyc1xuICBmdW5jdGlvbiB2YWxpZGF0ZUNvZGUoY29kZSkge1xuICBcdGlmICghY29kZSkge1xuICBcdFx0cmV0dXJuIDY1NTMzO1xuICBcdH1cblxuICBcdC8vIGxpbmUgZmVlZCBiZWNvbWVzIGdlbmVyaWMgd2hpdGVzcGFjZVxuICBcdGlmIChjb2RlID09PSAxMCkge1xuICBcdFx0cmV0dXJuIDMyO1xuICBcdH1cblxuICBcdC8vIEFTQ0lJIHJhbmdlLiAoV2h5IHNvbWVvbmUgd291bGQgdXNlIEhUTUwgZW50aXRpZXMgZm9yIEFTQ0lJIGNoYXJhY3RlcnMgSSBkb24ndCBrbm93LCBidXQuLi4pXG4gIFx0aWYgKGNvZGUgPCAxMjgpIHtcbiAgXHRcdHJldHVybiBjb2RlO1xuICBcdH1cblxuICBcdC8vIGNvZGUgcG9pbnRzIDEyOC0xNTkgYXJlIGRlYWx0IHdpdGggbGVuaWVudGx5IGJ5IGJyb3dzZXJzLCBidXQgdGhleSdyZSBpbmNvcnJlY3QuIFdlIG5lZWRcbiAgXHQvLyB0byBjb3JyZWN0IHRoZSBtaXN0YWtlIG9yIHdlJ2xsIGVuZCB1cCB3aXRoIG1pc3Npbmcg4oKsIHNpZ25zIGFuZCBzbyBvblxuICBcdGlmIChjb2RlIDw9IDE1OSkge1xuICBcdFx0cmV0dXJuIGNvbnRyb2xDaGFyYWN0ZXJzW2NvZGUgLSAxMjhdO1xuICBcdH1cblxuICBcdC8vIGJhc2ljIG11bHRpbGluZ3VhbCBwbGFuZVxuICBcdGlmIChjb2RlIDwgNTUyOTYpIHtcbiAgXHRcdHJldHVybiBjb2RlO1xuICBcdH1cblxuICBcdC8vIFVURi0xNiBzdXJyb2dhdGUgaGFsdmVzXG4gIFx0aWYgKGNvZGUgPD0gNTczNDMpIHtcbiAgXHRcdHJldHVybiA2NTUzMztcbiAgXHR9XG5cbiAgXHQvLyByZXN0IG9mIHRoZSBiYXNpYyBtdWx0aWxpbmd1YWwgcGxhbmVcbiAgXHRpZiAoY29kZSA8PSA2NTUzNSkge1xuICBcdFx0cmV0dXJuIGNvZGU7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIDY1NTMzO1xuICB9XG5cbiAgbGVzc1RoYW4gPSAvPC9nO1xuICBncmVhdGVyVGhhbiA9IC8+L2c7XG4gIGFtcCA9IC8mL2c7XG5cbiAgZnVuY3Rpb24gZXNjYXBlSHRtbChzdHIpIHtcbiAgXHRyZXR1cm4gc3RyLnJlcGxhY2UoYW1wLCBcIiZhbXA7XCIpLnJlcGxhY2UobGVzc1RoYW4sIFwiJmx0O1wiKS5yZXBsYWNlKGdyZWF0ZXJUaGFuLCBcIiZndDtcIik7XG4gIH1cblxuICB2YXIgbGVhZGluZ0xpbmVicmVhayA9IC9eXFxzKlxccj9cXG4vLFxuICAgICAgdHJhaWxpbmdMaW5lYnJlYWsgPSAvXFxyP1xcblxccyokLztcblxuICB2YXIgc3RyaXBTdGFuZGFsb25lcyA9IGZ1bmN0aW9uIChpdGVtcykge1xuICBcdHZhciBpLCBjdXJyZW50LCBiYWNrT25lLCBiYWNrVHdvLCBsYXN0U2VjdGlvbkl0ZW07XG5cbiAgXHRmb3IgKGkgPSAxOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdGN1cnJlbnQgPSBpdGVtc1tpXTtcbiAgXHRcdGJhY2tPbmUgPSBpdGVtc1tpIC0gMV07XG4gIFx0XHRiYWNrVHdvID0gaXRlbXNbaSAtIDJdO1xuXG4gIFx0XHQvLyBpZiB3ZSdyZSBhdCB0aGUgZW5kIG9mIGEgW3RleHRdW2NvbW1lbnRdW3RleHRdIHNlcXVlbmNlLi4uXG4gIFx0XHRpZiAoaXNTdHJpbmcoY3VycmVudCkgJiYgaXNDb21tZW50KGJhY2tPbmUpICYmIGlzU3RyaW5nKGJhY2tUd28pKSB7XG5cbiAgXHRcdFx0Ly8gLi4uIGFuZCB0aGUgY29tbWVudCBpcyBhIHN0YW5kYWxvbmUgKGkuZS4gbGluZSBicmVha3MgZWl0aGVyIHNpZGUpLi4uXG4gIFx0XHRcdGlmICh0cmFpbGluZ0xpbmVicmVhay50ZXN0KGJhY2tUd28pICYmIGxlYWRpbmdMaW5lYnJlYWsudGVzdChjdXJyZW50KSkge1xuXG4gIFx0XHRcdFx0Ly8gLi4uIHRoZW4gd2Ugd2FudCB0byByZW1vdmUgdGhlIHdoaXRlc3BhY2UgYWZ0ZXIgdGhlIGZpcnN0IGxpbmUgYnJlYWtcbiAgXHRcdFx0XHRpdGVtc1tpIC0gMl0gPSBiYWNrVHdvLnJlcGxhY2UodHJhaWxpbmdMaW5lYnJlYWssIFwiXFxuXCIpO1xuXG4gIFx0XHRcdFx0Ly8gYW5kIHRoZSBsZWFkaW5nIGxpbmUgYnJlYWsgb2YgdGhlIHNlY29uZCB0ZXh0IHRva2VuXG4gIFx0XHRcdFx0aXRlbXNbaV0gPSBjdXJyZW50LnJlcGxhY2UobGVhZGluZ0xpbmVicmVhaywgXCJcIik7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gaWYgdGhlIGN1cnJlbnQgaXRlbSBpcyBhIHNlY3Rpb24sIGFuZCBpdCBpcyBwcmVjZWRlZCBieSBhIGxpbmVicmVhaywgYW5kXG4gIFx0XHQvLyBpdHMgZmlyc3QgaXRlbSBpcyBhIGxpbmVicmVhay4uLlxuICBcdFx0aWYgKGlzU2VjdGlvbihjdXJyZW50KSAmJiBpc1N0cmluZyhiYWNrT25lKSkge1xuICBcdFx0XHRpZiAodHJhaWxpbmdMaW5lYnJlYWsudGVzdChiYWNrT25lKSAmJiBpc1N0cmluZyhjdXJyZW50LmZbMF0pICYmIGxlYWRpbmdMaW5lYnJlYWsudGVzdChjdXJyZW50LmZbMF0pKSB7XG4gIFx0XHRcdFx0aXRlbXNbaSAtIDFdID0gYmFja09uZS5yZXBsYWNlKHRyYWlsaW5nTGluZWJyZWFrLCBcIlxcblwiKTtcbiAgXHRcdFx0XHRjdXJyZW50LmZbMF0gPSBjdXJyZW50LmZbMF0ucmVwbGFjZShsZWFkaW5nTGluZWJyZWFrLCBcIlwiKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBpZiB0aGUgbGFzdCBpdGVtIHdhcyBhIHNlY3Rpb24sIGFuZCBpdCBpcyBmb2xsb3dlZCBieSBhIGxpbmVicmVhaywgYW5kXG4gIFx0XHQvLyBpdHMgbGFzdCBpdGVtIGlzIGEgbGluZWJyZWFrLi4uXG4gIFx0XHRpZiAoaXNTdHJpbmcoY3VycmVudCkgJiYgaXNTZWN0aW9uKGJhY2tPbmUpKSB7XG4gIFx0XHRcdGxhc3RTZWN0aW9uSXRlbSA9IGxhc3RJdGVtKGJhY2tPbmUuZik7XG5cbiAgXHRcdFx0aWYgKGlzU3RyaW5nKGxhc3RTZWN0aW9uSXRlbSkgJiYgdHJhaWxpbmdMaW5lYnJlYWsudGVzdChsYXN0U2VjdGlvbkl0ZW0pICYmIGxlYWRpbmdMaW5lYnJlYWsudGVzdChjdXJyZW50KSkge1xuICBcdFx0XHRcdGJhY2tPbmUuZltiYWNrT25lLmYubGVuZ3RoIC0gMV0gPSBsYXN0U2VjdGlvbkl0ZW0ucmVwbGFjZSh0cmFpbGluZ0xpbmVicmVhaywgXCJcXG5cIik7XG4gIFx0XHRcdFx0aXRlbXNbaV0gPSBjdXJyZW50LnJlcGxhY2UobGVhZGluZ0xpbmVicmVhaywgXCJcIik7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gaXRlbXM7XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNTdHJpbmcoaXRlbSkge1xuICBcdHJldHVybiB0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ29tbWVudChpdGVtKSB7XG4gIFx0cmV0dXJuIGl0ZW0udCA9PT0gQ09NTUVOVCB8fCBpdGVtLnQgPT09IERFTElNQ0hBTkdFO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTZWN0aW9uKGl0ZW0pIHtcbiAgXHRyZXR1cm4gKGl0ZW0udCA9PT0gU0VDVElPTiB8fCBpdGVtLnQgPT09IElOVkVSVEVEKSAmJiBpdGVtLmY7XG4gIH1cblxuICB2YXIgdHJpbVdoaXRlc3BhY2UgPSBmdW5jdGlvbiAoaXRlbXMsIGxlYWRpbmdQYXR0ZXJuLCB0cmFpbGluZ1BhdHRlcm4pIHtcbiAgXHR2YXIgaXRlbTtcblxuICBcdGlmIChsZWFkaW5nUGF0dGVybikge1xuICBcdFx0aXRlbSA9IGl0ZW1zWzBdO1xuICBcdFx0aWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdGl0ZW0gPSBpdGVtLnJlcGxhY2UobGVhZGluZ1BhdHRlcm4sIFwiXCIpO1xuXG4gIFx0XHRcdGlmICghaXRlbSkge1xuICBcdFx0XHRcdGl0ZW1zLnNoaWZ0KCk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0aXRlbXNbMF0gPSBpdGVtO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKHRyYWlsaW5nUGF0dGVybikge1xuICBcdFx0aXRlbSA9IGxhc3RJdGVtKGl0ZW1zKTtcbiAgXHRcdGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRpdGVtID0gaXRlbS5yZXBsYWNlKHRyYWlsaW5nUGF0dGVybiwgXCJcIik7XG5cbiAgXHRcdFx0aWYgKCFpdGVtKSB7XG4gIFx0XHRcdFx0aXRlbXMucG9wKCk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0aXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0gPSBpdGVtO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciB1dGlsc19jbGVhbnVwID0gY2xlYW51cDtcbiAgdmFyIGNvbnRpZ3VvdXNXaGl0ZXNwYWNlID0gL1sgXFx0XFxmXFxyXFxuXSsvZztcbiAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZUVsZW1lbnRzID0gL14oPzpwcmV8c2NyaXB0fHN0eWxlfHRleHRhcmVhKSQvaTtcbiAgdmFyIHV0aWxzX2NsZWFudXBfX2xlYWRpbmdXaGl0ZXNwYWNlID0gL15bIFxcdFxcZlxcclxcbl0rLztcbiAgdmFyIHRyYWlsaW5nV2hpdGVzcGFjZSA9IC9bIFxcdFxcZlxcclxcbl0rJC87XG4gIHZhciBsZWFkaW5nTmV3TGluZSA9IC9eKD86XFxyXFxufFxccnxcXG4pLztcbiAgdmFyIHRyYWlsaW5nTmV3TGluZSA9IC8oPzpcXHJcXG58XFxyfFxcbikkLztcbiAgZnVuY3Rpb24gY2xlYW51cChpdGVtcywgc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZSwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlKSB7XG4gIFx0dmFyIGksIGl0ZW0sIHByZXZpb3VzSXRlbSwgbmV4dEl0ZW0sIHByZXNlcnZlV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwga2V5O1xuXG4gIFx0Ly8gRmlyc3QgcGFzcyAtIHJlbW92ZSBzdGFuZGFsb25lcyBhbmQgY29tbWVudHMgZXRjXG4gIFx0c3RyaXBTdGFuZGFsb25lcyhpdGVtcyk7XG5cbiAgXHRpID0gaXRlbXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGl0ZW0gPSBpdGVtc1tpXTtcblxuICBcdFx0Ly8gUmVtb3ZlIGRlbGltaXRlciBjaGFuZ2VzLCB1bnNhZmUgZWxlbWVudHMgZXRjXG4gIFx0XHRpZiAoaXRlbS5leGNsdWRlKSB7XG4gIFx0XHRcdGl0ZW1zLnNwbGljZShpLCAxKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gUmVtb3ZlIGNvbW1lbnRzLCB1bmxlc3Mgd2Ugd2FudCB0byBrZWVwIHRoZW1cbiAgXHRcdGVsc2UgaWYgKHN0cmlwQ29tbWVudHMgJiYgaXRlbS50ID09PSBDT01NRU5UKSB7XG4gIFx0XHRcdGl0ZW1zLnNwbGljZShpLCAxKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBJZiBuZWNlc3NhcnksIHJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gIFx0dHJpbVdoaXRlc3BhY2UoaXRlbXMsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlID8gdXRpbHNfY2xlYW51cF9fbGVhZGluZ1doaXRlc3BhY2UgOiBudWxsLCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2UgPyB0cmFpbGluZ1doaXRlc3BhY2UgOiBudWxsKTtcblxuICBcdGkgPSBpdGVtcy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aXRlbSA9IGl0ZW1zW2ldO1xuXG4gIFx0XHQvLyBSZWN1cnNlXG4gIFx0XHRpZiAoaXRlbS5mKSB7XG4gIFx0XHRcdHZhciBpc1ByZXNlcnZlV2hpdGVzcGFjZUVsZW1lbnQgPSBpdGVtLnQgPT09IEVMRU1FTlQgJiYgcHJlc2VydmVXaGl0ZXNwYWNlRWxlbWVudHMudGVzdChpdGVtLmUpO1xuICBcdFx0XHRwcmVzZXJ2ZVdoaXRlc3BhY2VJbnNpZGVGcmFnbWVudCA9IHByZXNlcnZlV2hpdGVzcGFjZSB8fCBpc1ByZXNlcnZlV2hpdGVzcGFjZUVsZW1lbnQ7XG5cbiAgXHRcdFx0aWYgKCFwcmVzZXJ2ZVdoaXRlc3BhY2UgJiYgaXNQcmVzZXJ2ZVdoaXRlc3BhY2VFbGVtZW50KSB7XG4gIFx0XHRcdFx0dHJpbVdoaXRlc3BhY2UoaXRlbS5mLCBsZWFkaW5nTmV3TGluZSwgdHJhaWxpbmdOZXdMaW5lKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICghcHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQpIHtcbiAgXHRcdFx0XHRwcmV2aW91c0l0ZW0gPSBpdGVtc1tpIC0gMV07XG4gIFx0XHRcdFx0bmV4dEl0ZW0gPSBpdGVtc1tpICsgMV07XG5cbiAgXHRcdFx0XHQvLyBpZiB0aGUgcHJldmlvdXMgaXRlbSB3YXMgYSB0ZXh0IGl0ZW0gd2l0aCB0cmFpbGluZyB3aGl0ZXNwYWNlLFxuICBcdFx0XHRcdC8vIHJlbW92ZSBsZWFkaW5nIHdoaXRlc3BhY2UgaW5zaWRlIHRoZSBmcmFnbWVudFxuICBcdFx0XHRcdGlmICghcHJldmlvdXNJdGVtIHx8IHR5cGVvZiBwcmV2aW91c0l0ZW0gPT09IFwic3RyaW5nXCIgJiYgdHJhaWxpbmdXaGl0ZXNwYWNlLnRlc3QocHJldmlvdXNJdGVtKSkge1xuICBcdFx0XHRcdFx0cmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCA9IHRydWU7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0Ly8gYW5kIHZpY2UgdmVyc2FcbiAgXHRcdFx0XHRpZiAoIW5leHRJdGVtIHx8IHR5cGVvZiBuZXh0SXRlbSA9PT0gXCJzdHJpbmdcIiAmJiB1dGlsc19jbGVhbnVwX19sZWFkaW5nV2hpdGVzcGFjZS50ZXN0KG5leHRJdGVtKSkge1xuICBcdFx0XHRcdFx0cmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgPSB0cnVlO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNsZWFudXAoaXRlbS5mLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBTcGxpdCBpZi1lbHNlIGJsb2NrcyBpbnRvIHR3byAoYW4gaWYsIGFuZCBhbiB1bmxlc3MpXG4gIFx0XHRpZiAoaXRlbS5sKSB7XG4gIFx0XHRcdGNsZWFudXAoaXRlbS5sLmYsIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQpO1xuXG4gIFx0XHRcdGl0ZW1zLnNwbGljZShpICsgMSwgMCwgaXRlbS5sKTtcbiAgXHRcdFx0ZGVsZXRlIGl0ZW0ubDsgLy8gVE9ETyB3b3VsZCBiZSBuaWNlIGlmIHRoZXJlIHdhcyBhIHdheSBhcm91bmQgdGhpc1xuICBcdFx0fVxuXG4gIFx0XHQvLyBDbGVhbiB1cCBlbGVtZW50IGF0dHJpYnV0ZXNcbiAgXHRcdGlmIChpdGVtLmEpIHtcbiAgXHRcdFx0Zm9yIChrZXkgaW4gaXRlbS5hKSB7XG4gIFx0XHRcdFx0aWYgKGl0ZW0uYS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHR5cGVvZiBpdGVtLmFba2V5XSAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRcdFx0Y2xlYW51cChpdGVtLmFba2V5XSwgc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIENsZWFuIHVwIGNvbmRpdGlvbmFsIGF0dHJpYnV0ZXNcbiAgXHRcdGlmIChpdGVtLm0pIHtcbiAgXHRcdFx0Y2xlYW51cChpdGVtLm0sIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBDbGVhbiB1cCBldmVudCBoYW5kbGVyc1xuICBcdFx0aWYgKGl0ZW0udikge1xuICBcdFx0XHRmb3IgKGtleSBpbiBpdGVtLnYpIHtcbiAgXHRcdFx0XHRpZiAoaXRlbS52Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgXHRcdFx0XHRcdC8vIGNsZWFuIHVwIG5hbWVzXG4gIFx0XHRcdFx0XHRpZiAoaXNBcnJheShpdGVtLnZba2V5XS5uKSkge1xuICBcdFx0XHRcdFx0XHRjbGVhbnVwKGl0ZW0udltrZXldLm4sIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQpO1xuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHQvLyBjbGVhbiB1cCBwYXJhbXNcbiAgXHRcdFx0XHRcdGlmIChpc0FycmF5KGl0ZW0udltrZXldLmQpKSB7XG4gIFx0XHRcdFx0XHRcdGNsZWFudXAoaXRlbS52W2tleV0uZCwgc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCk7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gZmluYWwgcGFzcyAtIGZ1c2UgdGV4dCBub2RlcyB0b2dldGhlclxuICBcdGkgPSBpdGVtcy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aWYgKHR5cGVvZiBpdGVtc1tpXSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRpZiAodHlwZW9mIGl0ZW1zW2kgKyAxXSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRcdGl0ZW1zW2ldID0gaXRlbXNbaV0gKyBpdGVtc1tpICsgMV07XG4gIFx0XHRcdFx0aXRlbXMuc3BsaWNlKGkgKyAxLCAxKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICghcHJlc2VydmVXaGl0ZXNwYWNlKSB7XG4gIFx0XHRcdFx0aXRlbXNbaV0gPSBpdGVtc1tpXS5yZXBsYWNlKGNvbnRpZ3VvdXNXaGl0ZXNwYWNlLCBcIiBcIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoaXRlbXNbaV0gPT09IFwiXCIpIHtcbiAgXHRcdFx0XHRpdGVtcy5zcGxpY2UoaSwgMSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgZWxlbWVudF9yZWFkQ2xvc2luZ1RhZyA9IHJlYWRDbG9zaW5nVGFnO1xuICB2YXIgY2xvc2luZ1RhZ1BhdHRlcm4gPSAvXihbYS16QS1aXXsxLH06P1thLXpBLVowLTlcXC1dKilcXHMqXFw+LztcbiAgZnVuY3Rpb24gcmVhZENsb3NpbmdUYWcocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCB0YWc7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHQvLyBhcmUgd2UgbG9va2luZyBhdCBhIGNsb3NpbmcgdGFnP1xuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiPC9cIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICh0YWcgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKGNsb3NpbmdUYWdQYXR0ZXJuKSkge1xuICBcdFx0aWYgKHBhcnNlci5pbnNpZGUgJiYgdGFnICE9PSBwYXJzZXIuaW5zaWRlKSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IENMT1NJTkdfVEFHLFxuICBcdFx0XHRlOiB0YWdcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0Ly8gV2UgaGF2ZSBhbiBpbGxlZ2FsIGNsb3NpbmcgdGFnLCByZXBvcnQgaXRcbiAgXHRwYXJzZXIucG9zIC09IDI7XG4gIFx0cGFyc2VyLmVycm9yKFwiSWxsZWdhbCBjbG9zaW5nIHRhZ1wiKTtcbiAgfVxuXG4gIHZhciBnZXRMb3dlc3RJbmRleCA9IGZ1bmN0aW9uIChoYXlzdGFjaywgbmVlZGxlcykge1xuICBcdHZhciBpLCBpbmRleCwgbG93ZXN0O1xuXG4gIFx0aSA9IG5lZWRsZXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGluZGV4ID0gaGF5c3RhY2suaW5kZXhPZihuZWVkbGVzW2ldKTtcblxuICBcdFx0Ly8gc2hvcnQgY2lyY3VpdFxuICBcdFx0aWYgKCFpbmRleCkge1xuICBcdFx0XHRyZXR1cm4gMDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0XHRjb250aW51ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFsb3dlc3QgfHwgaW5kZXggPCBsb3dlc3QpIHtcbiAgXHRcdFx0bG93ZXN0ID0gaW5kZXg7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGxvd2VzdCB8fCAtMTtcbiAgfTtcblxuICB2YXIgZWxlbWVudF9yZWFkQXR0cmlidXRlID0gcmVhZEF0dHJpYnV0ZTtcblxuICB2YXIgYXR0cmlidXRlTmFtZVBhdHRlcm4gPSAvXlteXFxzXCInPlxcLz1dKy8sXG4gICAgICB1bnF1b3RlZEF0dHJpYnV0ZVZhbHVlVGV4dFBhdHRlcm4gPSAvXlteXFxzXCInPTw+YF0rLztcbiAgZnVuY3Rpb24gcmVhZEF0dHJpYnV0ZShwYXJzZXIpIHtcbiAgXHR2YXIgYXR0ciwgbmFtZSwgdmFsdWU7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybihhdHRyaWJ1dGVOYW1lUGF0dGVybik7XG4gIFx0aWYgKCFuYW1lKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRhdHRyID0geyBuYW1lOiBuYW1lIH07XG5cbiAgXHR2YWx1ZSA9IHJlYWRBdHRyaWJ1dGVWYWx1ZShwYXJzZXIpO1xuICBcdGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gIFx0XHQvLyBub3QgbnVsbC91bmRlZmluZWRcbiAgXHRcdGF0dHIudmFsdWUgPSB2YWx1ZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gYXR0cjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBdHRyaWJ1dGVWYWx1ZShwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIHZhbHVlU3RhcnQsIHN0YXJ0RGVwdGgsIHZhbHVlO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0Ly8gbmV4dCBjaGFyYWN0ZXIgbXVzdCBiZSBgPWAsIGAvYCwgYD5gIG9yIHdoaXRlc3BhY2VcbiAgXHRpZiAoIS9bPVxcLz5cXHNdLy50ZXN0KHBhcnNlci5uZXh0Q2hhcigpKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgYD1gLCBgL2AsIGA+YCBvciB3aGl0ZXNwYWNlXCIpO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiPVwiKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0dmFsdWVTdGFydCA9IHBhcnNlci5wb3M7XG4gIFx0c3RhcnREZXB0aCA9IHBhcnNlci5zZWN0aW9uRGVwdGg7XG5cbiAgXHR2YWx1ZSA9IHJlYWRRdW90ZWRBdHRyaWJ1dGVWYWx1ZShwYXJzZXIsIFwiJ1wiKSB8fCByZWFkUXVvdGVkQXR0cmlidXRlVmFsdWUocGFyc2VyLCBcIlxcXCJcIikgfHwgcmVhZFVucXVvdGVkQXR0cmlidXRlVmFsdWUocGFyc2VyKTtcblxuICBcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgdmFsaWQgYXR0cmlidXRlIHZhbHVlXCIpO1xuICBcdH1cblxuICBcdGlmIChwYXJzZXIuc2VjdGlvbkRlcHRoICE9PSBzdGFydERlcHRoKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gdmFsdWVTdGFydDtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkFuIGF0dHJpYnV0ZSB2YWx1ZSBtdXN0IGNvbnRhaW4gYXMgbWFueSBvcGVuaW5nIHNlY3Rpb24gdGFncyBhcyBjbG9zaW5nIHNlY3Rpb24gdGFnc1wiKTtcbiAgXHR9XG5cbiAgXHRpZiAoIXZhbHVlLmxlbmd0aCkge1xuICBcdFx0cmV0dXJuIFwiXCI7XG4gIFx0fVxuXG4gIFx0aWYgKHZhbHVlLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgdmFsdWVbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHJldHVybiBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKHZhbHVlWzBdKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRva2VuKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgdGV4dCwgaGF5c3RhY2ssIG5lZWRsZXMsIGluZGV4O1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0dGV4dCA9IHBhcnNlci5tYXRjaFBhdHRlcm4odW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRleHRQYXR0ZXJuKTtcblxuICBcdGlmICghdGV4dCkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aGF5c3RhY2sgPSB0ZXh0O1xuICBcdG5lZWRsZXMgPSBwYXJzZXIudGFncy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgXHRcdHJldHVybiB0Lm9wZW47XG4gIFx0fSk7IC8vIFRPRE8gcmVmYWN0b3IuLi4gd2UgZG8gdGhpcyBpbiByZWFkVGV4dC5qcyBhcyB3ZWxsXG5cbiAgXHRpZiAoKGluZGV4ID0gZ2V0TG93ZXN0SW5kZXgoaGF5c3RhY2ssIG5lZWRsZXMpKSAhPT0gLTEpIHtcbiAgXHRcdHRleHQgPSB0ZXh0LnN1YnN0cigwLCBpbmRleCk7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQgKyB0ZXh0Lmxlbmd0aDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlKHBhcnNlcikge1xuICBcdHZhciB0b2tlbnMsIHRva2VuO1xuXG4gIFx0cGFyc2VyLmluQXR0cmlidXRlID0gdHJ1ZTtcblxuICBcdHRva2VucyA9IFtdO1xuXG4gIFx0dG9rZW4gPSBjb252ZXJ0ZXJzX3JlYWRNdXN0YWNoZShwYXJzZXIpIHx8IHJlYWRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlVG9rZW4ocGFyc2VyKTtcbiAgXHR3aGlsZSAodG9rZW4gIT09IG51bGwpIHtcbiAgXHRcdHRva2Vucy5wdXNoKHRva2VuKTtcbiAgXHRcdHRva2VuID0gY29udmVydGVyc19yZWFkTXVzdGFjaGUocGFyc2VyKSB8fCByZWFkVW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRva2VuKHBhcnNlcik7XG4gIFx0fVxuXG4gIFx0aWYgKCF0b2tlbnMubGVuZ3RoKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuaW5BdHRyaWJ1dGUgPSBmYWxzZTtcbiAgXHRyZXR1cm4gdG9rZW5zO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFF1b3RlZEF0dHJpYnV0ZVZhbHVlKHBhcnNlciwgcXVvdGVNYXJrKSB7XG4gIFx0dmFyIHN0YXJ0LCB0b2tlbnMsIHRva2VuO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcocXVvdGVNYXJrKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmluQXR0cmlidXRlID0gcXVvdGVNYXJrO1xuXG4gIFx0dG9rZW5zID0gW107XG5cbiAgXHR0b2tlbiA9IGNvbnZlcnRlcnNfcmVhZE11c3RhY2hlKHBhcnNlcikgfHwgcmVhZFF1b3RlZFN0cmluZ1Rva2VuKHBhcnNlciwgcXVvdGVNYXJrKTtcbiAgXHR3aGlsZSAodG9rZW4gIT09IG51bGwpIHtcbiAgXHRcdHRva2Vucy5wdXNoKHRva2VuKTtcbiAgXHRcdHRva2VuID0gY29udmVydGVyc19yZWFkTXVzdGFjaGUocGFyc2VyKSB8fCByZWFkUXVvdGVkU3RyaW5nVG9rZW4ocGFyc2VyLCBxdW90ZU1hcmspO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHF1b3RlTWFyaykpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IGZhbHNlO1xuXG4gIFx0cmV0dXJuIHRva2VucztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRRdW90ZWRTdHJpbmdUb2tlbihwYXJzZXIsIHF1b3RlTWFyaykge1xuICBcdHZhciBzdGFydCwgaW5kZXgsIGhheXN0YWNrLCBuZWVkbGVzO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuICBcdGhheXN0YWNrID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXG4gIFx0bmVlZGxlcyA9IHBhcnNlci50YWdzLm1hcChmdW5jdGlvbiAodCkge1xuICBcdFx0cmV0dXJuIHQub3BlbjtcbiAgXHR9KTsgLy8gVE9ETyByZWZhY3Rvci4uLiB3ZSBkbyB0aGlzIGluIHJlYWRUZXh0LmpzIGFzIHdlbGxcbiAgXHRuZWVkbGVzLnB1c2gocXVvdGVNYXJrKTtcblxuICBcdGluZGV4ID0gZ2V0TG93ZXN0SW5kZXgoaGF5c3RhY2ssIG5lZWRsZXMpO1xuXG4gIFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiUXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZSBtdXN0IGhhdmUgYSBjbG9zaW5nIHF1b3RlXCIpO1xuICBcdH1cblxuICBcdGlmICghaW5kZXgpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5wb3MgKz0gaW5kZXg7XG4gIFx0cmV0dXJuIGhheXN0YWNrLnN1YnN0cigwLCBpbmRleCk7XG4gIH1cblxuICB2YXIgSnNvblBhcnNlciwgc3BlY2lhbHMsIHNwZWNpYWxzUGF0dGVybiwgcGFyc2VKU09OX19udW1iZXJQYXR0ZXJuLCBwbGFjZWhvbGRlclBhdHRlcm4sIHBsYWNlaG9sZGVyQXRTdGFydFBhdHRlcm4sIG9ubHlXaGl0ZXNwYWNlO1xuXG4gIHNwZWNpYWxzID0ge1xuICBcdFwidHJ1ZVwiOiB0cnVlLFxuICBcdFwiZmFsc2VcIjogZmFsc2UsXG4gIFx0dW5kZWZpbmVkOiB1bmRlZmluZWQsXG4gIFx0XCJudWxsXCI6IG51bGxcbiAgfTtcblxuICBzcGVjaWFsc1BhdHRlcm4gPSBuZXcgUmVnRXhwKFwiXig/OlwiICsgT2JqZWN0LmtleXMoc3BlY2lhbHMpLmpvaW4oXCJ8XCIpICsgXCIpXCIpO1xuICBwYXJzZUpTT05fX251bWJlclBhdHRlcm4gPSAvXig/OlsrLV0/KSg/Oig/Oig/OjB8WzEtOV1cXGQqKT9cXC5cXGQrKXwoPzooPzowfFsxLTldXFxkKilcXC4pfCg/OjB8WzEtOV1cXGQqKSkoPzpbZUVdWystXT9cXGQrKT8vO1xuICBwbGFjZWhvbGRlclBhdHRlcm4gPSAvXFwkXFx7KFteXFx9XSspXFx9L2c7XG4gIHBsYWNlaG9sZGVyQXRTdGFydFBhdHRlcm4gPSAvXlxcJFxceyhbXlxcfV0rKVxcfS87XG4gIG9ubHlXaGl0ZXNwYWNlID0gL15cXHMqJC87XG5cbiAgSnNvblBhcnNlciA9IHBhcnNlX1BhcnNlci5leHRlbmQoe1xuICBcdGluaXQ6IGZ1bmN0aW9uIChzdHIsIG9wdGlvbnMpIHtcbiAgXHRcdHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG4gIFx0XHR0aGlzLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdH0sXG5cbiAgXHRwb3N0UHJvY2VzczogZnVuY3Rpb24gKHJlc3VsdCkge1xuICBcdFx0aWYgKHJlc3VsdC5sZW5ndGggIT09IDEgfHwgIW9ubHlXaGl0ZXNwYWNlLnRlc3QodGhpcy5sZWZ0b3ZlcikpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB7IHZhbHVlOiByZXN1bHRbMF0udiB9O1xuICBcdH0sXG5cbiAgXHRjb252ZXJ0ZXJzOiBbZnVuY3Rpb24gZ2V0UGxhY2Vob2xkZXIocGFyc2VyKSB7XG4gIFx0XHR2YXIgcGxhY2Vob2xkZXI7XG5cbiAgXHRcdGlmICghcGFyc2VyLnZhbHVlcykge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cGxhY2Vob2xkZXIgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHBsYWNlaG9sZGVyQXRTdGFydFBhdHRlcm4pO1xuXG4gIFx0XHRpZiAocGxhY2Vob2xkZXIgJiYgcGFyc2VyLnZhbHVlcy5oYXNPd25Qcm9wZXJ0eShwbGFjZWhvbGRlcikpIHtcbiAgXHRcdFx0cmV0dXJuIHsgdjogcGFyc2VyLnZhbHVlc1twbGFjZWhvbGRlcl0gfTtcbiAgXHRcdH1cbiAgXHR9LCBmdW5jdGlvbiBnZXRTcGVjaWFsKHBhcnNlcikge1xuICBcdFx0dmFyIHNwZWNpYWw7XG5cbiAgXHRcdGlmIChzcGVjaWFsID0gcGFyc2VyLm1hdGNoUGF0dGVybihzcGVjaWFsc1BhdHRlcm4pKSB7XG4gIFx0XHRcdHJldHVybiB7IHY6IHNwZWNpYWxzW3NwZWNpYWxdIH07XG4gIFx0XHR9XG4gIFx0fSwgZnVuY3Rpb24gZ2V0TnVtYmVyKHBhcnNlcikge1xuICBcdFx0dmFyIG51bWJlcjtcblxuICBcdFx0aWYgKG51bWJlciA9IHBhcnNlci5tYXRjaFBhdHRlcm4ocGFyc2VKU09OX19udW1iZXJQYXR0ZXJuKSkge1xuICBcdFx0XHRyZXR1cm4geyB2OiArbnVtYmVyIH07XG4gIFx0XHR9XG4gIFx0fSwgZnVuY3Rpb24gZ2V0U3RyaW5nKHBhcnNlcikge1xuICBcdFx0dmFyIHN0cmluZ0xpdGVyYWwgPSByZWFkU3RyaW5nTGl0ZXJhbChwYXJzZXIpLFxuICBcdFx0ICAgIHZhbHVlcztcblxuICBcdFx0aWYgKHN0cmluZ0xpdGVyYWwgJiYgKHZhbHVlcyA9IHBhcnNlci52YWx1ZXMpKSB7XG4gIFx0XHRcdHJldHVybiB7XG4gIFx0XHRcdFx0djogc3RyaW5nTGl0ZXJhbC52LnJlcGxhY2UocGxhY2Vob2xkZXJQYXR0ZXJuLCBmdW5jdGlvbiAobWF0Y2gsICQxKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gJDEgaW4gdmFsdWVzID8gdmFsdWVzWyQxXSA6ICQxO1xuICBcdFx0XHRcdH0pXG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBzdHJpbmdMaXRlcmFsO1xuICBcdH0sIGZ1bmN0aW9uIGdldE9iamVjdChwYXJzZXIpIHtcbiAgXHRcdHZhciByZXN1bHQsIHBhaXI7XG5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwie1wiKSkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cmVzdWx0ID0ge307XG5cbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIn1cIikpIHtcbiAgXHRcdFx0cmV0dXJuIHsgdjogcmVzdWx0IH07XG4gIFx0XHR9XG5cbiAgXHRcdHdoaWxlIChwYWlyID0gZ2V0S2V5VmFsdWVQYWlyKHBhcnNlcikpIHtcbiAgXHRcdFx0cmVzdWx0W3BhaXIua2V5XSA9IHBhaXIudmFsdWU7XG5cbiAgXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJ9XCIpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIHsgdjogcmVzdWx0IH07XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIixcIikpIHtcbiAgXHRcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9LCBmdW5jdGlvbiBnZXRBcnJheShwYXJzZXIpIHtcbiAgXHRcdHZhciByZXN1bHQsIHZhbHVlVG9rZW47XG5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiW1wiKSkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cmVzdWx0ID0gW107XG5cbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIl1cIikpIHtcbiAgXHRcdFx0cmV0dXJuIHsgdjogcmVzdWx0IH07XG4gIFx0XHR9XG5cbiAgXHRcdHdoaWxlICh2YWx1ZVRva2VuID0gcGFyc2VyLnJlYWQoKSkge1xuICBcdFx0XHRyZXN1bHQucHVzaCh2YWx1ZVRva2VuLnYpO1xuXG4gIFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0XHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiXVwiKSkge1xuICBcdFx0XHRcdHJldHVybiB7IHY6IHJlc3VsdCB9O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCIsXCIpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1dXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGdldEtleVZhbHVlUGFpcihwYXJzZXIpIHtcbiAgXHR2YXIga2V5LCB2YWx1ZVRva2VuLCBwYWlyO1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0a2V5ID0gc2hhcmVkX3JlYWRLZXkocGFyc2VyKTtcblxuICBcdGlmICgha2V5KSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYWlyID0geyBrZXk6IGtleSB9O1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiOlwiKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdHZhbHVlVG9rZW4gPSBwYXJzZXIucmVhZCgpO1xuICBcdGlmICghdmFsdWVUb2tlbikge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFpci52YWx1ZSA9IHZhbHVlVG9rZW4udjtcblxuICBcdHJldHVybiBwYWlyO1xuICB9XG5cbiAgdmFyIHBhcnNlSlNPTiA9IGZ1bmN0aW9uIChzdHIsIHZhbHVlcykge1xuICBcdHZhciBwYXJzZXIgPSBuZXcgSnNvblBhcnNlcihzdHIsIHtcbiAgXHRcdHZhbHVlczogdmFsdWVzXG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gcGFyc2VyLnJlc3VsdDtcbiAgfTtcblxuICAvLyBUT0RPIGNsZWFuIHRoaXMgdXAsIGl0J3Mgc2hvY2tpbmdcbiAgdmFyIGVsZW1lbnRfcHJvY2Vzc0RpcmVjdGl2ZSA9IHByb2Nlc3NEaXJlY3RpdmU7XG4gIHZhciBtZXRob2RDYWxsUGF0dGVybiA9IC9eKFthLXpBLVpfJF1bYS16QS1aXyQwLTldKilcXCgvLFxuICAgICAgbWV0aG9kQ2FsbEV4Y2Vzc1BhdHRlcm4gPSAvXFwpXFxzKiQvLFxuICAgICAgRXhwcmVzc2lvblBhcnNlcjtcblxuICBFeHByZXNzaW9uUGFyc2VyID0gcGFyc2VfUGFyc2VyLmV4dGVuZCh7XG4gIFx0Y29udmVydGVyczogW2NvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb25dXG4gIH0pO1xuICBmdW5jdGlvbiBwcm9jZXNzRGlyZWN0aXZlKHRva2VucywgcGFyZW50UGFyc2VyKSB7XG4gIFx0dmFyIHJlc3VsdCwgbWF0Y2gsIHBhcnNlciwgYXJncywgdG9rZW4sIGNvbG9uSW5kZXgsIGRpcmVjdGl2ZU5hbWUsIGRpcmVjdGl2ZUFyZ3MsIHBhcnNlZDtcblxuICBcdGlmICh0eXBlb2YgdG9rZW5zID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRpZiAobWF0Y2ggPSBtZXRob2RDYWxsUGF0dGVybi5leGVjKHRva2VucykpIHtcbiAgXHRcdFx0dmFyIGVuZCA9IHRva2Vucy5sYXN0SW5kZXhPZihcIilcIik7XG5cbiAgXHRcdFx0Ly8gY2hlY2sgZm9yIGludmFsaWQgbWV0aG9kIGNhbGxzXG4gIFx0XHRcdGlmICghbWV0aG9kQ2FsbEV4Y2Vzc1BhdHRlcm4udGVzdCh0b2tlbnMpKSB7XG4gIFx0XHRcdFx0cGFyZW50UGFyc2VyLmVycm9yKFwiSW52YWxpZCBpbnB1dCBhZnRlciBtZXRob2QgY2FsbCBleHByZXNzaW9uICdcIiArIHRva2Vucy5zbGljZShlbmQgKyAxKSArIFwiJ1wiKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJlc3VsdCA9IHsgbTogbWF0Y2hbMV0gfTtcbiAgXHRcdFx0YXJncyA9IFwiW1wiICsgdG9rZW5zLnNsaWNlKHJlc3VsdC5tLmxlbmd0aCArIDEsIGVuZCkgKyBcIl1cIjtcblxuICBcdFx0XHRwYXJzZXIgPSBuZXcgRXhwcmVzc2lvblBhcnNlcihhcmdzKTtcbiAgXHRcdFx0cmVzdWx0LmEgPSB1dGlsc19mbGF0dGVuRXhwcmVzc2lvbihwYXJzZXIucmVzdWx0WzBdKTtcblxuICBcdFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodG9rZW5zLmluZGV4T2YoXCI6XCIpID09PSAtMSkge1xuICBcdFx0XHRyZXR1cm4gdG9rZW5zLnRyaW0oKTtcbiAgXHRcdH1cblxuICBcdFx0dG9rZW5zID0gW3Rva2Vuc107XG4gIFx0fVxuXG4gIFx0cmVzdWx0ID0ge307XG5cbiAgXHRkaXJlY3RpdmVOYW1lID0gW107XG4gIFx0ZGlyZWN0aXZlQXJncyA9IFtdO1xuXG4gIFx0aWYgKHRva2Vucykge1xuICBcdFx0d2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgXHRcdFx0dG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcblxuICBcdFx0XHRpZiAodHlwZW9mIHRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdFx0Y29sb25JbmRleCA9IHRva2VuLmluZGV4T2YoXCI6XCIpO1xuXG4gIFx0XHRcdFx0aWYgKGNvbG9uSW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdFx0XHRkaXJlY3RpdmVOYW1lLnB1c2godG9rZW4pO1xuICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgXHRcdFx0XHRcdC8vIGlzIHRoZSBjb2xvbiB0aGUgZmlyc3QgY2hhcmFjdGVyP1xuICBcdFx0XHRcdFx0aWYgKGNvbG9uSW5kZXgpIHtcbiAgXHRcdFx0XHRcdFx0Ly8gbm9cbiAgXHRcdFx0XHRcdFx0ZGlyZWN0aXZlTmFtZS5wdXNoKHRva2VuLnN1YnN0cigwLCBjb2xvbkluZGV4KSk7XG4gIFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdC8vIGlmIHRoZXJlIGlzIGFueXRoaW5nIGFmdGVyIHRoZSBjb2xvbiBpbiB0aGlzIHRva2VuLCB0cmVhdFxuICBcdFx0XHRcdFx0Ly8gaXQgYXMgdGhlIGZpcnN0IHRva2VuIG9mIHRoZSBkaXJlY3RpdmVBcmdzIGZyYWdtZW50XG4gIFx0XHRcdFx0XHRpZiAodG9rZW4ubGVuZ3RoID4gY29sb25JbmRleCArIDEpIHtcbiAgXHRcdFx0XHRcdFx0ZGlyZWN0aXZlQXJnc1swXSA9IHRva2VuLnN1YnN0cmluZyhjb2xvbkluZGV4ICsgMSk7XG4gIFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRkaXJlY3RpdmVOYW1lLnB1c2godG9rZW4pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGRpcmVjdGl2ZUFyZ3MgPSBkaXJlY3RpdmVBcmdzLmNvbmNhdCh0b2tlbnMpO1xuICBcdH1cblxuICBcdGlmICghZGlyZWN0aXZlTmFtZS5sZW5ndGgpIHtcbiAgXHRcdHJlc3VsdCA9IFwiXCI7XG4gIFx0fSBlbHNlIGlmIChkaXJlY3RpdmVBcmdzLmxlbmd0aCB8fCB0eXBlb2YgZGlyZWN0aXZlTmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0cmVzdWx0ID0ge1xuICBcdFx0XHQvLyBUT0RPIGlzIHRoaXMgcmVhbGx5IG5lY2Vzc2FyeT8ganVzdCB1c2UgdGhlIGFycmF5XG4gIFx0XHRcdG46IGRpcmVjdGl2ZU5hbWUubGVuZ3RoID09PSAxICYmIHR5cGVvZiBkaXJlY3RpdmVOYW1lWzBdID09PSBcInN0cmluZ1wiID8gZGlyZWN0aXZlTmFtZVswXSA6IGRpcmVjdGl2ZU5hbWVcbiAgXHRcdH07XG5cbiAgXHRcdGlmIChkaXJlY3RpdmVBcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZGlyZWN0aXZlQXJnc1swXSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRwYXJzZWQgPSBwYXJzZUpTT04oXCJbXCIgKyBkaXJlY3RpdmVBcmdzWzBdICsgXCJdXCIpO1xuICBcdFx0XHRyZXN1bHQuYSA9IHBhcnNlZCA/IHBhcnNlZC52YWx1ZSA6IGRpcmVjdGl2ZUFyZ3NbMF0udHJpbSgpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cmVzdWx0LmQgPSBkaXJlY3RpdmVBcmdzO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXN1bHQgPSBkaXJlY3RpdmVOYW1lO1xuICBcdH1cblxuICBcdHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgdGFnTmFtZVBhdHRlcm4gPSAvXlthLXpBLVpdezEsfTo/W2EtekEtWjAtOVxcLV0qLyxcbiAgICAgIHZhbGlkVGFnTmFtZUZvbGxvd2VyID0gL15bXFxzXFxuXFwvPl0vLFxuICAgICAgb25QYXR0ZXJuID0gL15vbi8sXG4gICAgICBwcm94eUV2ZW50UGF0dGVybiA9IC9eb24tKFthLXpBLVpcXFxcKlxcXFwuJF9dW2EtekEtWlxcXFwqXFxcXC4kXzAtOVxcLV0rKSQvLFxuICAgICAgcmVzZXJ2ZWRFdmVudE5hbWVzID0gL14oPzpjaGFuZ2V8cmVzZXR8dGVhcmRvd258dXBkYXRlfGNvbnN0cnVjdHxjb25maWd8aW5pdHxyZW5kZXJ8dW5yZW5kZXJ8ZGV0YWNofGluc2VydCkkLyxcbiAgICAgIGRpcmVjdGl2ZXMgPSB7IFwiaW50cm8tb3V0cm9cIjogXCJ0MFwiLCBpbnRybzogXCJ0MVwiLCBvdXRybzogXCJ0MlwiLCBkZWNvcmF0b3I6IFwib1wiIH0sXG4gICAgICBleGNsdWRlID0geyBleGNsdWRlOiB0cnVlIH0sXG4gICAgICBkaXNhbGxvd2VkQ29udGVudHM7XG5cbiAgLy8gYmFzZWQgb24gaHR0cDovL2RldmVsb3BlcnMud2hhdHdnLm9yZy9zeW50YXguaHRtbCNzeW50YXgtdGFnLW9taXNzaW9uXG4gIGRpc2FsbG93ZWRDb250ZW50cyA9IHtcbiAgXHRsaTogW1wibGlcIl0sXG4gIFx0ZHQ6IFtcImR0XCIsIFwiZGRcIl0sXG4gIFx0ZGQ6IFtcImR0XCIsIFwiZGRcIl0sXG4gIFx0cDogXCJhZGRyZXNzIGFydGljbGUgYXNpZGUgYmxvY2txdW90ZSBkaXYgZGwgZmllbGRzZXQgZm9vdGVyIGZvcm0gaDEgaDIgaDMgaDQgaDUgaDYgaGVhZGVyIGhncm91cCBociBtYWluIG1lbnUgbmF2IG9sIHAgcHJlIHNlY3Rpb24gdGFibGUgdWxcIi5zcGxpdChcIiBcIiksXG4gIFx0cnQ6IFtcInJ0XCIsIFwicnBcIl0sXG4gIFx0cnA6IFtcInJ0XCIsIFwicnBcIl0sXG4gIFx0b3B0Z3JvdXA6IFtcIm9wdGdyb3VwXCJdLFxuICBcdG9wdGlvbjogW1wib3B0aW9uXCIsIFwib3B0Z3JvdXBcIl0sXG4gIFx0dGhlYWQ6IFtcInRib2R5XCIsIFwidGZvb3RcIl0sXG4gIFx0dGJvZHk6IFtcInRib2R5XCIsIFwidGZvb3RcIl0sXG4gIFx0dGZvb3Q6IFtcInRib2R5XCJdLFxuICBcdHRyOiBbXCJ0clwiLCBcInRib2R5XCJdLFxuICBcdHRkOiBbXCJ0ZFwiLCBcInRoXCIsIFwidHJcIl0sXG4gIFx0dGg6IFtcInRkXCIsIFwidGhcIiwgXCJ0clwiXVxuICB9O1xuXG4gIHZhciBjb252ZXJ0ZXJzX3JlYWRFbGVtZW50ID0gcmVhZEVsZW1lbnQ7XG5cbiAgZnVuY3Rpb24gcmVhZEVsZW1lbnQocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBlbGVtZW50LCBkaXJlY3RpdmVOYW1lLCBtYXRjaCwgYWRkUHJveHlFdmVudCwgYXR0cmlidXRlLCBkaXJlY3RpdmUsIHNlbGZDbG9zaW5nLCBjaGlsZHJlbiwgcGFydGlhbHMsIGhhc1BhcnRpYWxzLCBjaGlsZCwgY2xvc2VkLCBwb3MsIHJlbWFpbmluZywgY2xvc2luZ1RhZztcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmIChwYXJzZXIuaW5zaWRlIHx8IHBhcnNlci5pbkF0dHJpYnV0ZSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI8XCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBpZiB0aGlzIGlzIGEgY2xvc2luZyB0YWcsIGFib3J0IHN0cmFpZ2h0IGF3YXlcbiAgXHRpZiAocGFyc2VyLm5leHRDaGFyKCkgPT09IFwiL1wiKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRlbGVtZW50ID0ge307XG4gIFx0aWYgKHBhcnNlci5pbmNsdWRlTGluZVBvc2l0aW9ucykge1xuICBcdFx0ZWxlbWVudC5wID0gcGFyc2VyLmdldExpbmVQb3Moc3RhcnQpO1xuICBcdH1cblxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIhXCIpKSB7XG4gIFx0XHRlbGVtZW50LnQgPSBET0NUWVBFO1xuICBcdFx0aWYgKCFwYXJzZXIubWF0Y2hQYXR0ZXJuKC9eZG9jdHlwZS9pKSkge1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBET0NUWVBFIGRlY2xhcmF0aW9uXCIpO1xuICBcdFx0fVxuXG4gIFx0XHRlbGVtZW50LmEgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKC9eKC4rPyk+Lyk7XG4gIFx0XHRyZXR1cm4gZWxlbWVudDtcbiAgXHR9XG5cbiAgXHRlbGVtZW50LnQgPSBFTEVNRU5UO1xuXG4gIFx0Ly8gZWxlbWVudCBuYW1lXG4gIFx0ZWxlbWVudC5lID0gcGFyc2VyLm1hdGNoUGF0dGVybih0YWdOYW1lUGF0dGVybik7XG4gIFx0aWYgKCFlbGVtZW50LmUpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIG5leHQgY2hhcmFjdGVyIG11c3QgYmUgd2hpdGVzcGFjZSwgY2xvc2luZyBzb2xpZHVzIG9yICc+J1xuICBcdGlmICghdmFsaWRUYWdOYW1lRm9sbG93ZXIudGVzdChwYXJzZXIubmV4dENoYXIoKSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIklsbGVnYWwgdGFnIG5hbWVcIik7XG4gIFx0fVxuXG4gIFx0YWRkUHJveHlFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBkaXJlY3RpdmUpIHtcbiAgXHRcdHZhciBkaXJlY3RpdmVOYW1lID0gZGlyZWN0aXZlLm4gfHwgZGlyZWN0aXZlO1xuXG4gIFx0XHRpZiAocmVzZXJ2ZWRFdmVudE5hbWVzLnRlc3QoZGlyZWN0aXZlTmFtZSkpIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyAtPSBkaXJlY3RpdmVOYW1lLmxlbmd0aDtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiQ2Fubm90IHVzZSByZXNlcnZlZCBldmVudCBuYW1lcyAoY2hhbmdlLCByZXNldCwgdGVhcmRvd24sIHVwZGF0ZSwgY29uc3RydWN0LCBjb25maWcsIGluaXQsIHJlbmRlciwgdW5yZW5kZXIsIGRldGFjaCwgaW5zZXJ0KVwiKTtcbiAgXHRcdH1cblxuICBcdFx0ZWxlbWVudC52W25hbWVdID0gZGlyZWN0aXZlO1xuICBcdH07XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHQvLyBkaXJlY3RpdmVzIGFuZCBhdHRyaWJ1dGVzXG4gIFx0d2hpbGUgKGF0dHJpYnV0ZSA9IGNvbnZlcnRlcnNfcmVhZE11c3RhY2hlKHBhcnNlcikgfHwgZWxlbWVudF9yZWFkQXR0cmlidXRlKHBhcnNlcikpIHtcbiAgXHRcdC8vIHJlZ3VsYXIgYXR0cmlidXRlc1xuICBcdFx0aWYgKGF0dHJpYnV0ZS5uYW1lKSB7XG4gIFx0XHRcdC8vIGludHJvLCBvdXRybywgZGVjb3JhdG9yXG4gIFx0XHRcdGlmIChkaXJlY3RpdmVOYW1lID0gZGlyZWN0aXZlc1thdHRyaWJ1dGUubmFtZV0pIHtcbiAgXHRcdFx0XHRlbGVtZW50W2RpcmVjdGl2ZU5hbWVdID0gZWxlbWVudF9wcm9jZXNzRGlyZWN0aXZlKGF0dHJpYnV0ZS52YWx1ZSwgcGFyc2VyKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIG9uLWNsaWNrIGV0Y1xuICBcdFx0XHRlbHNlIGlmIChtYXRjaCA9IHByb3h5RXZlbnRQYXR0ZXJuLmV4ZWMoYXR0cmlidXRlLm5hbWUpKSB7XG4gIFx0XHRcdFx0aWYgKCFlbGVtZW50LnYpIGVsZW1lbnQudiA9IHt9O1xuICBcdFx0XHRcdGRpcmVjdGl2ZSA9IGVsZW1lbnRfcHJvY2Vzc0RpcmVjdGl2ZShhdHRyaWJ1dGUudmFsdWUsIHBhcnNlcik7XG4gIFx0XHRcdFx0YWRkUHJveHlFdmVudChtYXRjaFsxXSwgZGlyZWN0aXZlKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRpZiAoIXBhcnNlci5zYW5pdGl6ZUV2ZW50QXR0cmlidXRlcyB8fCAhb25QYXR0ZXJuLnRlc3QoYXR0cmlidXRlLm5hbWUpKSB7XG4gIFx0XHRcdFx0XHRpZiAoIWVsZW1lbnQuYSkgZWxlbWVudC5hID0ge307XG4gIFx0XHRcdFx0XHRlbGVtZW50LmFbYXR0cmlidXRlLm5hbWVdID0gYXR0cmlidXRlLnZhbHVlIHx8IChhdHRyaWJ1dGUudmFsdWUgPT09IFwiXCIgPyBcIlwiIDogMCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHt7I2lmIGZvb319Y2xhc3M9J2Zvbyd7ey9pZn19XG4gIFx0XHRlbHNlIHtcbiAgXHRcdFx0aWYgKCFlbGVtZW50Lm0pIGVsZW1lbnQubSA9IFtdO1xuICBcdFx0XHRlbGVtZW50Lm0ucHVzaChhdHRyaWJ1dGUpO1xuICBcdFx0fVxuXG4gIFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gIFx0fVxuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgY2xvc2luZyBzb2xpZHVzXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0Ly8gc2VsZi1jbG9zaW5nIHNvbGlkdXM/XG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIi9cIikpIHtcbiAgXHRcdHNlbGZDbG9zaW5nID0gdHJ1ZTtcbiAgXHR9XG5cbiAgXHQvLyBjbG9zaW5nIGFuZ2xlIGJyYWNrZXRcbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIj5cIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHZhciBsb3dlckNhc2VOYW1lID0gZWxlbWVudC5lLnRvTG93ZXJDYXNlKCk7XG4gIFx0dmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IHBhcnNlci5wcmVzZXJ2ZVdoaXRlc3BhY2U7XG5cbiAgXHRpZiAoIXNlbGZDbG9zaW5nICYmICF2b2lkRWxlbWVudE5hbWVzLnRlc3QoZWxlbWVudC5lKSkge1xuICBcdFx0cGFyc2VyLmVsZW1lbnRTdGFjay5wdXNoKGxvd2VyQ2FzZU5hbWUpO1xuXG4gIFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBpZiB3ZSBvcGVuIGEgc2NyaXB0IGVsZW1lbnQsIGZ1cnRoZXIgdGFncyBzaG91bGRcbiAgXHRcdC8vIGJlIGlnbm9yZWQgdW5sZXNzIHRoZXkncmUgYSBjbG9zaW5nIHNjcmlwdCBlbGVtZW50XG4gIFx0XHRpZiAobG93ZXJDYXNlTmFtZSA9PT0gXCJzY3JpcHRcIiB8fCBsb3dlckNhc2VOYW1lID09PSBcInN0eWxlXCIpIHtcbiAgXHRcdFx0cGFyc2VyLmluc2lkZSA9IGxvd2VyQ2FzZU5hbWU7XG4gIFx0XHR9XG5cbiAgXHRcdGNoaWxkcmVuID0gW107XG4gIFx0XHRwYXJ0aWFscyA9IGNyZWF0ZShudWxsKTtcblxuICBcdFx0ZG8ge1xuICBcdFx0XHRwb3MgPSBwYXJzZXIucG9zO1xuICBcdFx0XHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cbiAgXHRcdFx0Ly8gaWYgZm9yIGV4YW1wbGUgd2UncmUgaW4gYW4gPGxpPiBlbGVtZW50LCBhbmQgd2Ugc2VlIGFub3RoZXJcbiAgXHRcdFx0Ly8gPGxpPiB0YWcsIGNsb3NlIHRoZSBmaXJzdCBzbyB0aGV5IGJlY29tZSBzaWJsaW5nc1xuICBcdFx0XHRpZiAoIWNhbkNvbnRhaW4obG93ZXJDYXNlTmFtZSwgcmVtYWluaW5nKSkge1xuICBcdFx0XHRcdGNsb3NlZCA9IHRydWU7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBjbG9zaW5nIHRhZ1xuICBcdFx0XHRlbHNlIGlmIChjbG9zaW5nVGFnID0gZWxlbWVudF9yZWFkQ2xvc2luZ1RhZyhwYXJzZXIpKSB7XG4gIFx0XHRcdFx0Y2xvc2VkID0gdHJ1ZTtcblxuICBcdFx0XHRcdHZhciBjbG9zaW5nVGFnTmFtZSA9IGNsb3NpbmdUYWcuZS50b0xvd2VyQ2FzZSgpO1xuXG4gIFx0XHRcdFx0Ly8gaWYgdGhpcyAqaXNuJ3QqIHRoZSBjbG9zaW5nIHRhZyBmb3IgdGhlIGN1cnJlbnQgZWxlbWVudC4uLlxuICBcdFx0XHRcdGlmIChjbG9zaW5nVGFnTmFtZSAhPT0gbG93ZXJDYXNlTmFtZSkge1xuICBcdFx0XHRcdFx0Ly8gcmV3aW5kIHBhcnNlclxuICBcdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHBvcztcblxuICBcdFx0XHRcdFx0Ly8gaWYgaXQgZG9lc24ndCBjbG9zZSBhIHBhcmVudCB0YWcsIGVycm9yXG4gIFx0XHRcdFx0XHRpZiAoISB+cGFyc2VyLmVsZW1lbnRTdGFjay5pbmRleE9mKGNsb3NpbmdUYWdOYW1lKSkge1xuICBcdFx0XHRcdFx0XHR2YXIgZXJyb3JNZXNzYWdlID0gXCJVbmV4cGVjdGVkIGNsb3NpbmcgdGFnXCI7XG5cbiAgXHRcdFx0XHRcdFx0Ly8gYWRkIGFkZGl0aW9uYWwgaGVscCBmb3Igdm9pZCBlbGVtZW50cywgc2luY2UgY29tcG9uZW50IG5hbWVzXG4gIFx0XHRcdFx0XHRcdC8vIG1pZ2h0IGNsYXNoIHdpdGggdGhlbVxuICBcdFx0XHRcdFx0XHRpZiAodm9pZEVsZW1lbnROYW1lcy50ZXN0KGNsb3NpbmdUYWdOYW1lKSkge1xuICBcdFx0XHRcdFx0XHRcdGVycm9yTWVzc2FnZSArPSBcIiAoPFwiICsgY2xvc2luZ1RhZ05hbWUgKyBcIj4gaXMgYSB2b2lkIGVsZW1lbnQgLSBpdCBjYW5ub3QgY29udGFpbiBjaGlsZHJlbilcIjtcbiAgXHRcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHRcdHBhcnNlci5lcnJvcihlcnJvck1lc3NhZ2UpO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIGltcGxpY2l0IGNsb3NlIGJ5IGNsb3Npbmcgc2VjdGlvbiB0YWcuIFRPRE8gY2xlYW4gdGhpcyB1cFxuICBcdFx0XHRlbHNlIGlmIChjaGlsZCA9IHNlY3Rpb25fcmVhZENsb3NpbmcocGFyc2VyLCB7IG9wZW46IHBhcnNlci5zdGFuZGFyZERlbGltaXRlcnNbMF0sIGNsb3NlOiBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzFdIH0pKSB7XG4gIFx0XHRcdFx0Y2xvc2VkID0gdHJ1ZTtcbiAgXHRcdFx0XHRwYXJzZXIucG9zID0gcG9zO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdGlmIChjaGlsZCA9IHBhcnNlci5yZWFkKFBBUlRJQUxfUkVBREVSUykpIHtcbiAgXHRcdFx0XHRcdGlmIChwYXJ0aWFsc1tjaGlsZC5uXSkge1xuICBcdFx0XHRcdFx0XHRwYXJzZXIucG9zID0gcG9zO1xuICBcdFx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJEdXBsaWNhdGUgcGFydGlhbCBkZWZpbml0aW9uXCIpO1xuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHR1dGlsc19jbGVhbnVwKGNoaWxkLmYsIHBhcnNlci5zdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsICFwcmVzZXJ2ZVdoaXRlc3BhY2UsICFwcmVzZXJ2ZVdoaXRlc3BhY2UpO1xuXG4gIFx0XHRcdFx0XHRwYXJ0aWFsc1tjaGlsZC5uXSA9IGNoaWxkLmY7XG4gIFx0XHRcdFx0XHRoYXNQYXJ0aWFscyA9IHRydWU7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdGlmIChjaGlsZCA9IHBhcnNlci5yZWFkKFJFQURFUlMpKSB7XG4gIFx0XHRcdFx0XHRcdGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICBcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0Y2xvc2VkID0gdHJ1ZTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0gd2hpbGUgKCFjbG9zZWQpO1xuXG4gIFx0XHRpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gIFx0XHRcdGVsZW1lbnQuZiA9IGNoaWxkcmVuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoaGFzUGFydGlhbHMpIHtcbiAgXHRcdFx0ZWxlbWVudC5wID0gcGFydGlhbHM7XG4gIFx0XHR9XG5cbiAgXHRcdHBhcnNlci5lbGVtZW50U3RhY2sucG9wKCk7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmluc2lkZSA9IG51bGw7XG5cbiAgXHRpZiAocGFyc2VyLnNhbml0aXplRWxlbWVudHMgJiYgcGFyc2VyLnNhbml0aXplRWxlbWVudHMuaW5kZXhPZihsb3dlckNhc2VOYW1lKSAhPT0gLTEpIHtcbiAgXHRcdHJldHVybiBleGNsdWRlO1xuICBcdH1cblxuICBcdHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuQ29udGFpbihuYW1lLCByZW1haW5pbmcpIHtcbiAgXHR2YXIgbWF0Y2gsIGRpc2FsbG93ZWQ7XG5cbiAgXHRtYXRjaCA9IC9ePChbYS16QS1aXVthLXpBLVowLTldKikvLmV4ZWMocmVtYWluaW5nKTtcbiAgXHRkaXNhbGxvd2VkID0gZGlzYWxsb3dlZENvbnRlbnRzW25hbWVdO1xuXG4gIFx0aWYgKCFtYXRjaCB8fCAhZGlzYWxsb3dlZCkge1xuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuXG4gIFx0cmV0dXJuICEgfmRpc2FsbG93ZWQuaW5kZXhPZihtYXRjaFsxXS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIHZhciBjb252ZXJ0ZXJzX3JlYWRUZXh0ID0gcmVhZFRleHQ7XG4gIGZ1bmN0aW9uIHJlYWRUZXh0KHBhcnNlcikge1xuICBcdHZhciBpbmRleCwgcmVtYWluaW5nLCBkaXNhbGxvd2VkLCBiYXJyaWVyO1xuXG4gIFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXG4gIFx0YmFycmllciA9IHBhcnNlci5pbnNpZGUgPyBcIjwvXCIgKyBwYXJzZXIuaW5zaWRlIDogXCI8XCI7XG5cbiAgXHRpZiAocGFyc2VyLmluc2lkZSAmJiAhcGFyc2VyLmludGVycG9sYXRlW3BhcnNlci5pbnNpZGVdKSB7XG4gIFx0XHRpbmRleCA9IHJlbWFpbmluZy5pbmRleE9mKGJhcnJpZXIpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRkaXNhbGxvd2VkID0gcGFyc2VyLnRhZ3MubWFwKGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRcdHJldHVybiB0Lm9wZW47XG4gIFx0XHR9KTtcbiAgXHRcdGRpc2FsbG93ZWQgPSBkaXNhbGxvd2VkLmNvbmNhdChwYXJzZXIudGFncy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgXHRcdFx0cmV0dXJuIFwiXFxcXFwiICsgdC5vcGVuO1xuICBcdFx0fSkpO1xuXG4gIFx0XHQvLyBodHRwOi8vZGV2ZWxvcGVycy53aGF0d2cub3JnL3N5bnRheC5odG1sI3N5bnRheC1hdHRyaWJ1dGVzXG4gIFx0XHRpZiAocGFyc2VyLmluQXR0cmlidXRlID09PSB0cnVlKSB7XG4gIFx0XHRcdC8vIHdlJ3JlIGluc2lkZSBhbiB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWVcbiAgXHRcdFx0ZGlzYWxsb3dlZC5wdXNoKFwiXFxcIlwiLCBcIidcIiwgXCI9XCIsIFwiPFwiLCBcIj5cIiwgXCJgXCIpO1xuICBcdFx0fSBlbHNlIGlmIChwYXJzZXIuaW5BdHRyaWJ1dGUpIHtcbiAgXHRcdFx0Ly8gcXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZVxuICBcdFx0XHRkaXNhbGxvd2VkLnB1c2gocGFyc2VyLmluQXR0cmlidXRlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGRpc2FsbG93ZWQucHVzaChiYXJyaWVyKTtcbiAgXHRcdH1cblxuICBcdFx0aW5kZXggPSBnZXRMb3dlc3RJbmRleChyZW1haW5pbmcsIGRpc2FsbG93ZWQpO1xuICBcdH1cblxuICBcdGlmICghaW5kZXgpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdGluZGV4ID0gcmVtYWluaW5nLmxlbmd0aDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIucG9zICs9IGluZGV4O1xuXG4gIFx0cmV0dXJuIHBhcnNlci5pbnNpZGUgPyByZW1haW5pbmcuc3Vic3RyKDAsIGluZGV4KSA6IGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMocmVtYWluaW5nLnN1YnN0cigwLCBpbmRleCkpO1xuICB9XG5cbiAgdmFyIHV0aWxzX2VzY2FwZVJlZ0V4cCA9IGVzY2FwZVJlZ0V4cDtcbiAgdmFyIHV0aWxzX2VzY2FwZVJlZ0V4cF9fcGF0dGVybiA9IC9bLS9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nO1xuICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyKSB7XG4gIFx0cmV0dXJuIHN0ci5yZXBsYWNlKHV0aWxzX2VzY2FwZVJlZ0V4cF9fcGF0dGVybiwgXCJcXFxcJCZcIik7XG4gIH1cblxuICB2YXIgY29udmVydGVyc19yZWFkUGFydGlhbERlZmluaXRpb25Db21tZW50ID0gcmVhZFBhcnRpYWxEZWZpbml0aW9uQ29tbWVudDtcblxuICB2YXIgc3RhcnRQYXR0ZXJuID0gL148IS0tXFxzKi8sXG4gICAgICBuYW1lUGF0dGVybiA9IC9zKj5cXHMqKFthLXpBLVpfJF1bLWEtekEtWl8kMC05XSopXFxzKi8sXG4gICAgICBmaW5pc2hQYXR0ZXJuID0gL1xccyotLT4vLFxuICAgICAgY2hpbGQ7XG5cbiAgZnVuY3Rpb24gcmVhZFBhcnRpYWxEZWZpbml0aW9uQ29tbWVudChwYXJzZXIpIHtcbiAgXHR2YXIgZmlyc3RQb3MgPSBwYXJzZXIucG9zLFxuICBcdCAgICBvcGVuID0gcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVyc1swXSxcbiAgXHQgICAgY2xvc2UgPSBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzFdLFxuICBcdCAgICBjb250ZW50ID0gdW5kZWZpbmVkLFxuICBcdCAgICBjbG9zZWQgPSB1bmRlZmluZWQ7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFBhdHRlcm4oc3RhcnRQYXR0ZXJuKSB8fCAhcGFyc2VyLm1hdGNoU3RyaW5nKG9wZW4pKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gZmlyc3RQb3M7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHR2YXIgbmFtZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4obmFtZVBhdHRlcm4pO1xuXG4gIFx0d2Fybk9uY2VJZkRlYnVnKFwiSW5saW5lIHBhcnRpYWwgY29tbWVudHMgYXJlIGRlcHJlY2F0ZWQuXFxuVXNlIHRoaXMuLi5cXG4gIHt7I3BhcnRpYWwgXCIgKyBuYW1lICsgXCJ9fSAuLi4ge3svcGFydGlhbH19XFxuXFxuLi4uaW5zdGVhZCBvZiB0aGlzOlxcbiAgPCEtLSB7ez5cIiArIG5hbWUgKyBcIn19IC0tPiAuLi4gPCEtLSB7ey9cIiArIG5hbWUgKyBcIn19IC0tPidcIik7XG5cbiAgXHQvLyBtYWtlIHN1cmUgdGhlIHJlc3Qgb2YgdGhlIGNvbW1lbnQgaXMgaW4gdGhlIGNvcnJlY3QgcGxhY2VcbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhjbG9zZSkgfHwgIXBhcnNlci5tYXRjaFBhdHRlcm4oZmluaXNoUGF0dGVybikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBmaXJzdFBvcztcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGNvbnRlbnQgPSBbXTtcblxuICBcdHZhciBlbmRQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIl48IS0tXFxcXHMqXCIgKyB1dGlsc19lc2NhcGVSZWdFeHAob3BlbikgKyBcIlxcXFxzKlxcXFwvXFxcXHMqXCIgKyBuYW1lICsgXCJcXFxccypcIiArIHV0aWxzX2VzY2FwZVJlZ0V4cChjbG9zZSkgKyBcIlxcXFxzKi0tPlwiKTtcblxuICBcdGRvIHtcbiAgXHRcdGlmIChwYXJzZXIubWF0Y2hQYXR0ZXJuKGVuZFBhdHRlcm4pKSB7XG4gIFx0XHRcdGNsb3NlZCA9IHRydWU7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRjaGlsZCA9IHBhcnNlci5yZWFkKFJFQURFUlMpO1xuICBcdFx0XHRpZiAoIWNoaWxkKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwiZXhwZWN0ZWQgY2xvc2luZyBjb21tZW50ICgnPCEtLSBcIiArIG9wZW4gKyBcIi9cIiArIG5hbWUgKyBcIlwiICsgY2xvc2UgKyBcIiAtLT4nKVwiKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNvbnRlbnQucHVzaChjaGlsZCk7XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoIWNsb3NlZCk7XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogSU5MSU5FX1BBUlRJQUwsXG4gIFx0XHRmOiBjb250ZW50LFxuICBcdFx0bjogbmFtZVxuICBcdH07XG4gIH1cblxuICB2YXIgY29udmVydGVyc19yZWFkUGFydGlhbERlZmluaXRpb25TZWN0aW9uID0gcmVhZFBhcnRpYWxEZWZpbml0aW9uU2VjdGlvbjtcbiAgdmFyIHBhcnRpYWxEZWZpbml0aW9uU2VjdGlvblBhdHRlcm4gPSAvXiNcXHMqcGFydGlhbFxccysvO1xuICBmdW5jdGlvbiByZWFkUGFydGlhbERlZmluaXRpb25TZWN0aW9uKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgbmFtZSwgY29udGVudCwgY2hpbGQsIGNsb3NlZDtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdHZhciBkZWxpbWl0ZXJzID0gcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVycztcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKGRlbGltaXRlcnNbMF0pKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFBhdHRlcm4ocGFydGlhbERlZmluaXRpb25TZWN0aW9uUGF0dGVybikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOVxcLV0qLyk7XG5cbiAgXHRpZiAoIW5hbWUpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcImV4cGVjdGVkIGxlZ2FsIHBhcnRpYWwgbmFtZVwiKTtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhkZWxpbWl0ZXJzWzFdKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgZGVsaW1pdGVyc1sxXSArIFwiJ1wiKTtcbiAgXHR9XG5cbiAgXHRjb250ZW50ID0gW107XG5cbiAgXHRkbyB7XG4gIFx0XHQvLyBUT0RPIGNsZWFuIHRoaXMgdXBcbiAgXHRcdGlmIChjaGlsZCA9IHNlY3Rpb25fcmVhZENsb3NpbmcocGFyc2VyLCB7IG9wZW46IHBhcnNlci5zdGFuZGFyZERlbGltaXRlcnNbMF0sIGNsb3NlOiBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzFdIH0pKSB7XG4gIFx0XHRcdGlmICghY2hpbGQuciA9PT0gXCJwYXJ0aWFsXCIpIHtcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBcIiArIGRlbGltaXRlcnNbMF0gKyBcIi9wYXJ0aWFsXCIgKyBkZWxpbWl0ZXJzWzFdKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNsb3NlZCA9IHRydWU7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRjaGlsZCA9IHBhcnNlci5yZWFkKFJFQURFUlMpO1xuXG4gIFx0XHRcdGlmICghY2hpbGQpIHtcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBcIiArIGRlbGltaXRlcnNbMF0gKyBcIi9wYXJ0aWFsXCIgKyBkZWxpbWl0ZXJzWzFdKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNvbnRlbnQucHVzaChjaGlsZCk7XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoIWNsb3NlZCk7XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogSU5MSU5FX1BBUlRJQUwsXG4gIFx0XHRuOiBuYW1lLFxuICBcdFx0ZjogY29udGVudFxuICBcdH07XG4gIH1cblxuICB2YXIgY29udmVydGVyc19yZWFkVGVtcGxhdGUgPSByZWFkVGVtcGxhdGU7XG4gIGZ1bmN0aW9uIHJlYWRUZW1wbGF0ZShwYXJzZXIpIHtcbiAgXHR2YXIgZnJhZ21lbnQgPSBbXTtcbiAgXHR2YXIgcGFydGlhbHMgPSBjcmVhdGUobnVsbCk7XG4gIFx0dmFyIGhhc1BhcnRpYWxzID0gZmFsc2U7XG5cbiAgXHR2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gcGFyc2VyLnByZXNlcnZlV2hpdGVzcGFjZTtcblxuICBcdHdoaWxlIChwYXJzZXIucG9zIDwgcGFyc2VyLnN0ci5sZW5ndGgpIHtcbiAgXHRcdHZhciBwb3MgPSBwYXJzZXIucG9zLFxuICBcdFx0ICAgIGl0ZW0gPSB1bmRlZmluZWQsXG4gIFx0XHQgICAgcGFydGlhbCA9IHVuZGVmaW5lZDtcblxuICBcdFx0aWYgKHBhcnRpYWwgPSBwYXJzZXIucmVhZChQQVJUSUFMX1JFQURFUlMpKSB7XG4gIFx0XHRcdGlmIChwYXJ0aWFsc1twYXJ0aWFsLm5dKSB7XG4gIFx0XHRcdFx0cGFyc2VyLnBvcyA9IHBvcztcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJEdXBsaWNhdGVkIHBhcnRpYWwgZGVmaW5pdGlvblwiKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHV0aWxzX2NsZWFudXAocGFydGlhbC5mLCBwYXJzZXIuc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCAhcHJlc2VydmVXaGl0ZXNwYWNlLCAhcHJlc2VydmVXaGl0ZXNwYWNlKTtcblxuICBcdFx0XHRwYXJ0aWFsc1twYXJ0aWFsLm5dID0gcGFydGlhbC5mO1xuICBcdFx0XHRoYXNQYXJ0aWFscyA9IHRydWU7XG4gIFx0XHR9IGVsc2UgaWYgKGl0ZW0gPSBwYXJzZXIucmVhZChSRUFERVJTKSkge1xuICBcdFx0XHRmcmFnbWVudC5wdXNoKGl0ZW0pO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiVW5leHBlY3RlZCB0ZW1wbGF0ZSBjb250ZW50XCIpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHZhciByZXN1bHQgPSB7XG4gIFx0XHR2OiBURU1QTEFURV9WRVJTSU9OLFxuICBcdFx0dDogZnJhZ21lbnRcbiAgXHR9O1xuXG4gIFx0aWYgKGhhc1BhcnRpYWxzKSB7XG4gIFx0XHRyZXN1bHQucCA9IHBhcnRpYWxzO1xuICBcdH1cblxuICBcdHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgX3BhcnNlID0gcGFyc2U7XG5cbiAgdmFyIFNUQU5EQVJEX1JFQURFUlMgPSBbbXVzdGFjaGVfcmVhZFBhcnRpYWwsIG11c3RhY2hlX3JlYWRVbmVzY2FwZWQsIG11c3RhY2hlX3JlYWRTZWN0aW9uLCBtdXN0YWNoZV9yZWFkWWllbGRlciwgbXVzdGFjaGVfcmVhZEludGVycG9sYXRvciwgcmVhZE11c3RhY2hlQ29tbWVudF07XG4gIHZhciBUUklQTEVfUkVBREVSUyA9IFttdXN0YWNoZV9yZWFkVHJpcGxlXTtcbiAgdmFyIFNUQVRJQ19SRUFERVJTID0gW211c3RhY2hlX3JlYWRVbmVzY2FwZWQsIG11c3RhY2hlX3JlYWRTZWN0aW9uLCBtdXN0YWNoZV9yZWFkSW50ZXJwb2xhdG9yXTsgLy8gVE9ETyBkb2VzIGl0IG1ha2Ugc2Vuc2UgdG8gaGF2ZSBhIHN0YXRpYyBzZWN0aW9uP1xuXG4gIHZhciBTdGFuZGFyZFBhcnNlciA9IHVuZGVmaW5lZDtcbiAgZnVuY3Rpb24gcGFyc2UodGVtcGxhdGUsIG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IFN0YW5kYXJkUGFyc2VyKHRlbXBsYXRlLCBvcHRpb25zIHx8IHt9KS5yZXN1bHQ7XG4gIH1cblxuICB2YXIgUkVBREVSUyA9IFtjb252ZXJ0ZXJzX3JlYWRNdXN0YWNoZSwgY29udmVydGVyc19yZWFkSHRtbENvbW1lbnQsIGNvbnZlcnRlcnNfcmVhZEVsZW1lbnQsIGNvbnZlcnRlcnNfcmVhZFRleHRdO1xuICB2YXIgUEFSVElBTF9SRUFERVJTID0gW2NvbnZlcnRlcnNfcmVhZFBhcnRpYWxEZWZpbml0aW9uQ29tbWVudCwgY29udmVydGVyc19yZWFkUGFydGlhbERlZmluaXRpb25TZWN0aW9uXTtcblxuICBTdGFuZGFyZFBhcnNlciA9IHBhcnNlX1BhcnNlci5leHRlbmQoe1xuICBcdGluaXQ6IGZ1bmN0aW9uIChzdHIsIG9wdGlvbnMpIHtcbiAgXHRcdHZhciB0cmlwbGVEZWxpbWl0ZXJzID0gb3B0aW9ucy50cmlwbGVEZWxpbWl0ZXJzIHx8IFtcInt7e1wiLCBcIn19fVwiXSxcbiAgXHRcdCAgICBzdGF0aWNEZWxpbWl0ZXJzID0gb3B0aW9ucy5zdGF0aWNEZWxpbWl0ZXJzIHx8IFtcIltbXCIsIFwiXV1cIl0sXG4gIFx0XHQgICAgc3RhdGljVHJpcGxlRGVsaW1pdGVycyA9IG9wdGlvbnMuc3RhdGljVHJpcGxlRGVsaW1pdGVycyB8fCBbXCJbW1tcIiwgXCJdXV1cIl07XG5cbiAgXHRcdHRoaXMuc3RhbmRhcmREZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzIHx8IFtcInt7XCIsIFwifX1cIl07XG5cbiAgXHRcdHRoaXMudGFncyA9IFt7IGlzU3RhdGljOiBmYWxzZSwgaXNUcmlwbGU6IGZhbHNlLCBvcGVuOiB0aGlzLnN0YW5kYXJkRGVsaW1pdGVyc1swXSwgY2xvc2U6IHRoaXMuc3RhbmRhcmREZWxpbWl0ZXJzWzFdLCByZWFkZXJzOiBTVEFOREFSRF9SRUFERVJTIH0sIHsgaXNTdGF0aWM6IGZhbHNlLCBpc1RyaXBsZTogdHJ1ZSwgb3BlbjogdHJpcGxlRGVsaW1pdGVyc1swXSwgY2xvc2U6IHRyaXBsZURlbGltaXRlcnNbMV0sIHJlYWRlcnM6IFRSSVBMRV9SRUFERVJTIH0sIHsgaXNTdGF0aWM6IHRydWUsIGlzVHJpcGxlOiBmYWxzZSwgb3Blbjogc3RhdGljRGVsaW1pdGVyc1swXSwgY2xvc2U6IHN0YXRpY0RlbGltaXRlcnNbMV0sIHJlYWRlcnM6IFNUQVRJQ19SRUFERVJTIH0sIHsgaXNTdGF0aWM6IHRydWUsIGlzVHJpcGxlOiB0cnVlLCBvcGVuOiBzdGF0aWNUcmlwbGVEZWxpbWl0ZXJzWzBdLCBjbG9zZTogc3RhdGljVHJpcGxlRGVsaW1pdGVyc1sxXSwgcmVhZGVyczogVFJJUExFX1JFQURFUlMgfV07XG5cbiAgXHRcdHRoaXMuc29ydE11c3RhY2hlVGFncygpO1xuXG4gIFx0XHR0aGlzLnNlY3Rpb25EZXB0aCA9IDA7XG4gIFx0XHR0aGlzLmVsZW1lbnRTdGFjayA9IFtdO1xuXG4gIFx0XHR0aGlzLmludGVycG9sYXRlID0ge1xuICBcdFx0XHRzY3JpcHQ6ICFvcHRpb25zLmludGVycG9sYXRlIHx8IG9wdGlvbnMuaW50ZXJwb2xhdGUuc2NyaXB0ICE9PSBmYWxzZSxcbiAgXHRcdFx0c3R5bGU6ICFvcHRpb25zLmludGVycG9sYXRlIHx8IG9wdGlvbnMuaW50ZXJwb2xhdGUuc3R5bGUgIT09IGZhbHNlXG4gIFx0XHR9O1xuXG4gIFx0XHRpZiAob3B0aW9ucy5zYW5pdGl6ZSA9PT0gdHJ1ZSkge1xuICBcdFx0XHRvcHRpb25zLnNhbml0aXplID0ge1xuICBcdFx0XHRcdC8vIGJsYWNrbGlzdCBmcm9tIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvZ29vZ2xlLWNhamEvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvY29tL2dvb2dsZS9jYWphL2xhbmcvaHRtbC9odG1sNC1lbGVtZW50cy13aGl0ZWxpc3QuanNvblxuICBcdFx0XHRcdGVsZW1lbnRzOiBcImFwcGxldCBiYXNlIGJhc2Vmb250IGJvZHkgZnJhbWUgZnJhbWVzZXQgaGVhZCBodG1sIGlzaW5kZXggbGluayBtZXRhIG5vZnJhbWVzIG5vc2NyaXB0IG9iamVjdCBwYXJhbSBzY3JpcHQgc3R5bGUgdGl0bGVcIi5zcGxpdChcIiBcIiksXG4gIFx0XHRcdFx0ZXZlbnRBdHRyaWJ1dGVzOiB0cnVlXG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuc3RyaXBDb21tZW50cyA9IG9wdGlvbnMuc3RyaXBDb21tZW50cyAhPT0gZmFsc2U7XG4gIFx0XHR0aGlzLnByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlO1xuICBcdFx0dGhpcy5zYW5pdGl6ZUVsZW1lbnRzID0gb3B0aW9ucy5zYW5pdGl6ZSAmJiBvcHRpb25zLnNhbml0aXplLmVsZW1lbnRzO1xuICBcdFx0dGhpcy5zYW5pdGl6ZUV2ZW50QXR0cmlidXRlcyA9IG9wdGlvbnMuc2FuaXRpemUgJiYgb3B0aW9ucy5zYW5pdGl6ZS5ldmVudEF0dHJpYnV0ZXM7XG4gIFx0XHR0aGlzLmluY2x1ZGVMaW5lUG9zaXRpb25zID0gb3B0aW9ucy5pbmNsdWRlTGluZVBvc2l0aW9ucztcbiAgXHR9LFxuXG4gIFx0cG9zdFByb2Nlc3M6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIGVtcHR5IHN0cmluZ1xuICBcdFx0aWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gIFx0XHRcdHJldHVybiB7IHQ6IFtdLCB2OiBURU1QTEFURV9WRVJTSU9OIH07XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLnNlY3Rpb25EZXB0aCA+IDApIHtcbiAgXHRcdFx0dGhpcy5lcnJvcihcIkEgc2VjdGlvbiB3YXMgbGVmdCBvcGVuXCIpO1xuICBcdFx0fVxuXG4gIFx0XHR1dGlsc19jbGVhbnVwKHJlc3VsdFswXS50LCB0aGlzLnN0cmlwQ29tbWVudHMsIHRoaXMucHJlc2VydmVXaGl0ZXNwYWNlLCAhdGhpcy5wcmVzZXJ2ZVdoaXRlc3BhY2UsICF0aGlzLnByZXNlcnZlV2hpdGVzcGFjZSk7XG5cbiAgXHRcdHJldHVybiByZXN1bHRbMF07XG4gIFx0fSxcblxuICBcdGNvbnZlcnRlcnM6IFtjb252ZXJ0ZXJzX3JlYWRUZW1wbGF0ZV0sXG5cbiAgXHRzb3J0TXVzdGFjaGVUYWdzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBTb3J0IGluIG9yZGVyIG9mIGRlc2NlbmRpbmcgb3BlbmluZyBkZWxpbWl0ZXIgbGVuZ3RoIChsb25nZXIgZmlyc3QpLFxuICBcdFx0Ly8gdG8gcHJvdGVjdCBhZ2FpbnN0IG9wZW5pbmcgZGVsaW1pdGVycyBiZWluZyBzdWJzdHJpbmdzIG9mIGVhY2ggb3RoZXJcbiAgXHRcdHRoaXMudGFncy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gIFx0XHRcdHJldHVybiBiLm9wZW4ubGVuZ3RoIC0gYS5vcGVuLmxlbmd0aDtcbiAgXHRcdH0pO1xuICBcdH1cbiAgfSk7XG5cbiAgdmFyIHBhcnNlT3B0aW9ucyA9IFtcInByZXNlcnZlV2hpdGVzcGFjZVwiLCBcInNhbml0aXplXCIsIFwic3RyaXBDb21tZW50c1wiLCBcImRlbGltaXRlcnNcIiwgXCJ0cmlwbGVEZWxpbWl0ZXJzXCIsIFwiaW50ZXJwb2xhdGVcIl07XG5cbiAgdmFyIHBhcnNlciA9IHtcbiAgXHRmcm9tSWQ6IGZyb21JZCwgaXNIYXNoZWRJZDogaXNIYXNoZWRJZCwgaXNQYXJzZWQ6IGlzUGFyc2VkLCBnZXRQYXJzZU9wdGlvbnM6IGdldFBhcnNlT3B0aW9ucywgY3JlYXRlSGVscGVyOiB0ZW1wbGF0ZV9wYXJzZXJfX2NyZWF0ZUhlbHBlcixcbiAgXHRwYXJzZTogZG9QYXJzZVxuICB9O1xuXG4gIGZ1bmN0aW9uIHRlbXBsYXRlX3BhcnNlcl9fY3JlYXRlSGVscGVyKHBhcnNlT3B0aW9ucykge1xuICBcdHZhciBoZWxwZXIgPSBjcmVhdGUocGFyc2VyKTtcbiAgXHRoZWxwZXIucGFyc2UgPSBmdW5jdGlvbiAodGVtcGxhdGUsIG9wdGlvbnMpIHtcbiAgXHRcdHJldHVybiBkb1BhcnNlKHRlbXBsYXRlLCBvcHRpb25zIHx8IHBhcnNlT3B0aW9ucyk7XG4gIFx0fTtcbiAgXHRyZXR1cm4gaGVscGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9QYXJzZSh0ZW1wbGF0ZSwgcGFyc2VPcHRpb25zKSB7XG4gIFx0aWYgKCFfcGFyc2UpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgUmFjdGl2ZS5wYXJzZSAtIGNhbm5vdCBwYXJzZSB0ZW1wbGF0ZS4gRWl0aGVyIHByZXBhcnNlIG9yIHVzZSB0aGUgdmVyc2lvbiB0aGF0IGluY2x1ZGVzIHRoZSBwYXJzZXJcIik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIF9wYXJzZSh0ZW1wbGF0ZSwgcGFyc2VPcHRpb25zIHx8IHRoaXMub3B0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiBmcm9tSWQoaWQsIG9wdGlvbnMpIHtcbiAgXHR2YXIgdGVtcGxhdGU7XG5cbiAgXHRpZiAoIWlzQ2xpZW50KSB7XG4gIFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5vVGhyb3cpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJldHJpZXZlIHRlbXBsYXRlICNcIiArIGlkICsgXCIgYXMgUmFjdGl2ZSBpcyBub3QgcnVubmluZyBpbiBhIGJyb3dzZXIuXCIpO1xuICBcdH1cblxuICBcdGlmIChpc0hhc2hlZElkKGlkKSkge1xuICBcdFx0aWQgPSBpZC5zdWJzdHJpbmcoMSk7XG4gIFx0fVxuXG4gIFx0aWYgKCEodGVtcGxhdGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkpKSB7XG4gIFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5vVGhyb3cpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgdGVtcGxhdGUgZWxlbWVudCB3aXRoIGlkICNcIiArIGlkKTtcbiAgXHR9XG5cbiAgXHRpZiAodGVtcGxhdGUudGFnTmFtZS50b1VwcGVyQ2FzZSgpICE9PSBcIlNDUklQVFwiKSB7XG4gIFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5vVGhyb3cpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGVtcGxhdGUgZWxlbWVudCB3aXRoIGlkICNcIiArIGlkICsgXCIsIG11c3QgYmUgYSA8c2NyaXB0PiBlbGVtZW50XCIpO1xuICBcdH1cblxuICBcdHJldHVybiBcInRleHRDb250ZW50XCIgaW4gdGVtcGxhdGUgPyB0ZW1wbGF0ZS50ZXh0Q29udGVudCA6IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSGFzaGVkSWQoaWQpIHtcbiAgXHRyZXR1cm4gaWQgJiYgaWRbMF0gPT09IFwiI1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXJzZWQodGVtcGxhdGUpIHtcbiAgXHRyZXR1cm4gISh0eXBlb2YgdGVtcGxhdGUgPT09IFwic3RyaW5nXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGFyc2VPcHRpb25zKHJhY3RpdmUpIHtcbiAgXHQvLyBDb3VsZCBiZSBSYWN0aXZlIG9yIGEgQ29tcG9uZW50XG4gIFx0aWYgKHJhY3RpdmUuZGVmYXVsdHMpIHtcbiAgXHRcdHJhY3RpdmUgPSByYWN0aXZlLmRlZmF1bHRzO1xuICBcdH1cblxuICBcdHJldHVybiBwYXJzZU9wdGlvbnMucmVkdWNlKGZ1bmN0aW9uICh2YWwsIGtleSkge1xuICBcdFx0dmFsW2tleV0gPSByYWN0aXZlW2tleV07XG4gIFx0XHRyZXR1cm4gdmFsO1xuICBcdH0sIHt9KTtcbiAgfVxuXG4gIHZhciB0ZW1wbGF0ZV9wYXJzZXIgPSBwYXJzZXI7XG5cbiAgdmFyIHRlbXBsYXRlQ29uZmlndXJhdG9yID0ge1xuICBcdG5hbWU6IFwidGVtcGxhdGVcIixcblxuICBcdGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpIHtcbiAgXHRcdHZhciB0ZW1wbGF0ZTtcblxuICBcdFx0Ly8gb25seSBhc3NpZ24gaWYgZXhpc3RzXG4gIFx0XHRpZiAoXCJ0ZW1wbGF0ZVwiIGluIG9wdGlvbnMpIHtcbiAgXHRcdFx0dGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuXG4gIFx0XHRcdGlmICh0eXBlb2YgdGVtcGxhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRcdHByb3RvLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0cHJvdG8udGVtcGxhdGUgPSBwYXJzZUlmU3RyaW5nKHRlbXBsYXRlLCBwcm90byk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gaW5pdChQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMpIHtcbiAgXHRcdHZhciB0ZW1wbGF0ZSwgZm47XG5cbiAgXHRcdC8vIFRPRE8gYmVjYXVzZSBvZiBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB3ZSBtaWdodCBqdXN0IGJlIGFibGUgdG8gdXNlXG4gIFx0XHQvLyByYWN0aXZlLnRlbXBsYXRlLCBhbmQgbm90IGJvdGhlciBwYXNzaW5nIHRocm91Z2ggdGhlIFBhcmVudCBvYmplY3QuXG4gIFx0XHQvLyBBdCBwcmVzZW50IHRoYXQgYnJlYWtzIHRoZSB0ZXN0IG1vY2tzJyBleHBlY3RhdGlvbnNcbiAgXHRcdHRlbXBsYXRlID0gXCJ0ZW1wbGF0ZVwiIGluIG9wdGlvbnMgPyBvcHRpb25zLnRlbXBsYXRlIDogUGFyZW50LnByb3RvdHlwZS50ZW1wbGF0ZTtcblxuICBcdFx0aWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdGZuID0gdGVtcGxhdGU7XG4gIFx0XHRcdHRlbXBsYXRlID0gZ2V0RHluYW1pY1RlbXBsYXRlKHJhY3RpdmUsIGZuKTtcblxuICBcdFx0XHRyYWN0aXZlLl9jb25maWcudGVtcGxhdGUgPSB7XG4gIFx0XHRcdFx0Zm46IGZuLFxuICBcdFx0XHRcdHJlc3VsdDogdGVtcGxhdGVcbiAgXHRcdFx0fTtcbiAgXHRcdH1cblxuICBcdFx0dGVtcGxhdGUgPSBwYXJzZUlmU3RyaW5nKHRlbXBsYXRlLCByYWN0aXZlKTtcblxuICBcdFx0Ly8gVE9ETyB0aGUgbmFtaW5nIG9mIHRoaXMgaXMgY29uZnVzaW5nIC0gcmFjdGl2ZS50ZW1wbGF0ZSByZWZlcnMgdG8gWy4uLl0sXG4gIFx0XHQvLyBidXQgQ29tcG9uZW50LnByb3RvdHlwZS50ZW1wbGF0ZSByZWZlcnMgdG8ge3Y6MSx0OltdLHA6W119Li4uXG4gIFx0XHQvLyBpdCdzIHVubmVjZXNzYXJ5LCBiZWNhdXNlIHRoZSBkZXZlbG9wZXIgbmV2ZXIgbmVlZHMgdG8gYWNjZXNzXG4gIFx0XHQvLyByYWN0aXZlLnRlbXBsYXRlXG4gIFx0XHRyYWN0aXZlLnRlbXBsYXRlID0gdGVtcGxhdGUudDtcblxuICBcdFx0aWYgKHRlbXBsYXRlLnApIHtcbiAgXHRcdFx0ZXh0ZW5kUGFydGlhbHMocmFjdGl2ZS5wYXJ0aWFscywgdGVtcGxhdGUucCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlc2V0OiBmdW5jdGlvbiAocmFjdGl2ZSkge1xuICBcdFx0dmFyIHJlc3VsdCA9IHJlc2V0VmFsdWUocmFjdGl2ZSksXG4gIFx0XHQgICAgcGFyc2VkO1xuXG4gIFx0XHRpZiAocmVzdWx0KSB7XG4gIFx0XHRcdHBhcnNlZCA9IHBhcnNlSWZTdHJpbmcocmVzdWx0LCByYWN0aXZlKTtcblxuICBcdFx0XHRyYWN0aXZlLnRlbXBsYXRlID0gcGFyc2VkLnQ7XG4gIFx0XHRcdGV4dGVuZFBhcnRpYWxzKHJhY3RpdmUucGFydGlhbHMsIHBhcnNlZC5wLCB0cnVlKTtcblxuICBcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVzZXRWYWx1ZShyYWN0aXZlKSB7XG4gIFx0dmFyIGluaXRpYWwgPSByYWN0aXZlLl9jb25maWcudGVtcGxhdGUsXG4gIFx0ICAgIHJlc3VsdDtcblxuICBcdC8vIElmIHRoaXMgaXNuJ3QgYSBkeW5hbWljIHRlbXBsYXRlLCB0aGVyZSdzIG5vdGhpbmcgdG8gZG9cbiAgXHRpZiAoIWluaXRpYWwgfHwgIWluaXRpYWwuZm4pIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRyZXN1bHQgPSBnZXREeW5hbWljVGVtcGxhdGUocmFjdGl2ZSwgaW5pdGlhbC5mbik7XG5cbiAgXHQvLyBUT0RPIGRlZXAgZXF1YWxpdHkgY2hlY2sgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSByZS1yZW5kZXJpbmdcbiAgXHQvLyBpbiB0aGUgY2FzZSBvZiBhbHJlYWR5LXBhcnNlZCB0ZW1wbGF0ZXNcbiAgXHRpZiAocmVzdWx0ICE9PSBpbml0aWFsLnJlc3VsdCkge1xuICBcdFx0aW5pdGlhbC5yZXN1bHQgPSByZXN1bHQ7XG4gIFx0XHRyZXN1bHQgPSBwYXJzZUlmU3RyaW5nKHJlc3VsdCwgcmFjdGl2ZSk7XG4gIFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldER5bmFtaWNUZW1wbGF0ZShyYWN0aXZlLCBmbikge1xuICBcdHZhciBoZWxwZXIgPSB0ZW1wbGF0ZV90ZW1wbGF0ZV9fY3JlYXRlSGVscGVyKHRlbXBsYXRlX3BhcnNlci5nZXRQYXJzZU9wdGlvbnMocmFjdGl2ZSkpO1xuICBcdHJldHVybiBmbi5jYWxsKHJhY3RpdmUsIGhlbHBlcik7XG4gIH1cblxuICBmdW5jdGlvbiB0ZW1wbGF0ZV90ZW1wbGF0ZV9fY3JlYXRlSGVscGVyKHBhcnNlT3B0aW9ucykge1xuICBcdHZhciBoZWxwZXIgPSBjcmVhdGUodGVtcGxhdGVfcGFyc2VyKTtcbiAgXHRoZWxwZXIucGFyc2UgPSBmdW5jdGlvbiAodGVtcGxhdGUsIG9wdGlvbnMpIHtcbiAgXHRcdHJldHVybiB0ZW1wbGF0ZV9wYXJzZXIucGFyc2UodGVtcGxhdGUsIG9wdGlvbnMgfHwgcGFyc2VPcHRpb25zKTtcbiAgXHR9O1xuICBcdHJldHVybiBoZWxwZXI7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUlmU3RyaW5nKHRlbXBsYXRlLCByYWN0aXZlKSB7XG4gIFx0aWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0Ly8gSUQgb2YgYW4gZWxlbWVudCBjb250YWluaW5nIHRoZSB0ZW1wbGF0ZT9cbiAgXHRcdGlmICh0ZW1wbGF0ZVswXSA9PT0gXCIjXCIpIHtcbiAgXHRcdFx0dGVtcGxhdGUgPSB0ZW1wbGF0ZV9wYXJzZXIuZnJvbUlkKHRlbXBsYXRlKTtcbiAgXHRcdH1cblxuICBcdFx0dGVtcGxhdGUgPSBfcGFyc2UodGVtcGxhdGUsIHRlbXBsYXRlX3BhcnNlci5nZXRQYXJzZU9wdGlvbnMocmFjdGl2ZSkpO1xuICBcdH1cblxuICBcdC8vIENoZWNrIHRoYXQgdGhlIHRlbXBsYXRlIGV2ZW4gZXhpc3RzXG4gIFx0ZWxzZSBpZiAodGVtcGxhdGUgPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdGVtcGxhdGUgY2Fubm90IGJlIFwiICsgdGVtcGxhdGUgKyBcIi5cIik7XG4gIFx0fVxuXG4gIFx0Ly8gQ2hlY2sgdGhlIHBhcnNlZCB0ZW1wbGF0ZSBoYXMgYSB2ZXJzaW9uIGF0IGFsbFxuICBcdGVsc2UgaWYgKHR5cGVvZiB0ZW1wbGF0ZS52ICE9PSBcIm51bWJlclwiKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdGVtcGxhdGUgcGFyc2VyIHdhcyBwYXNzZWQgYSBub24tc3RyaW5nIHRlbXBsYXRlLCBidXQgdGhlIHRlbXBsYXRlIGRvZXNuJ3QgaGF2ZSBhIHZlcnNpb24uICBNYWtlIHN1cmUgeW91J3JlIHBhc3NpbmcgaW4gdGhlIHRlbXBsYXRlIHlvdSB0aGluayB5b3UgYXJlLlwiKTtcbiAgXHR9XG5cbiAgXHQvLyBDaGVjayB3ZSdyZSB1c2luZyB0aGUgY29ycmVjdCB2ZXJzaW9uXG4gIFx0ZWxzZSBpZiAodGVtcGxhdGUudiAhPT0gVEVNUExBVEVfVkVSU0lPTikge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCB0ZW1wbGF0ZSB2ZXJzaW9uIChleHBlY3RlZCBcIiArIFRFTVBMQVRFX1ZFUlNJT04gKyBcIiwgZ290IFwiICsgdGVtcGxhdGUudiArIFwiKSBQbGVhc2UgZW5zdXJlIHlvdSBhcmUgdXNpbmcgdGhlIGxhdGVzdCB2ZXJzaW9uIG9mIFJhY3RpdmUuanMgaW4geW91ciBidWlsZCBwcm9jZXNzIGFzIHdlbGwgYXMgaW4geW91ciBhcHBcIik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRlbXBsYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kUGFydGlhbHMoZXhpc3RpbmdQYXJ0aWFscywgbmV3UGFydGlhbHMsIG92ZXJ3cml0ZSkge1xuICBcdGlmICghbmV3UGFydGlhbHMpIHJldHVybjtcblxuICBcdC8vIFRPRE8gdGhlcmUncyBhbiBhbWJpZ3VpdHkgaGVyZSAtIHdlIG5lZWQgdG8gb3ZlcndyaXRlIGluIHRoZSBgcmVzZXQoKWBcbiAgXHQvLyBjYXNlLCBidXQgbm90IGluaXRpYWxseS4uLlxuXG4gIFx0Zm9yICh2YXIga2V5IGluIG5ld1BhcnRpYWxzKSB7XG4gIFx0XHRpZiAob3ZlcndyaXRlIHx8ICFleGlzdGluZ1BhcnRpYWxzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgXHRcdFx0ZXhpc3RpbmdQYXJ0aWFsc1trZXldID0gbmV3UGFydGlhbHNba2V5XTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgdGVtcGxhdGVfdGVtcGxhdGUgPSB0ZW1wbGF0ZUNvbmZpZ3VyYXRvcjtcblxuICB2YXIgY29uZmlnX3JlZ2lzdHJpZXNfX3JlZ2lzdHJ5TmFtZXMsIFJlZ2lzdHJ5LCByZWdpc3RyaWVzO1xuXG4gIGNvbmZpZ19yZWdpc3RyaWVzX19yZWdpc3RyeU5hbWVzID0gW1wiYWRhcHRvcnNcIiwgXCJjb21wb25lbnRzXCIsIFwiY29tcHV0ZWRcIiwgXCJkZWNvcmF0b3JzXCIsIFwiZWFzaW5nXCIsIFwiZXZlbnRzXCIsIFwiaW50ZXJwb2xhdG9yc1wiLCBcInBhcnRpYWxzXCIsIFwidHJhbnNpdGlvbnNcIl07XG5cbiAgUmVnaXN0cnkgPSBmdW5jdGlvbiAobmFtZSwgdXNlRGVmYXVsdHMpIHtcbiAgXHR0aGlzLm5hbWUgPSBuYW1lO1xuICBcdHRoaXMudXNlRGVmYXVsdHMgPSB1c2VEZWZhdWx0cztcbiAgfTtcblxuICBSZWdpc3RyeS5wcm90b3R5cGUgPSB7XG4gIFx0Y29uc3RydWN0b3I6IFJlZ2lzdHJ5LFxuXG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiAoUGFyZW50LCBwcm90bywgb3B0aW9ucykge1xuICBcdFx0dGhpcy5jb25maWd1cmUodGhpcy51c2VEZWZhdWx0cyA/IFBhcmVudC5kZWZhdWx0cyA6IFBhcmVudCwgdGhpcy51c2VEZWZhdWx0cyA/IHByb3RvIDogcHJvdG8uY29uc3RydWN0b3IsIG9wdGlvbnMpO1xuICBcdH0sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7fSxcblxuICBcdGNvbmZpZ3VyZTogZnVuY3Rpb24gKFBhcmVudCwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gIFx0XHR2YXIgbmFtZSA9IHRoaXMubmFtZSxcbiAgXHRcdCAgICBvcHRpb24gPSBvcHRpb25zW25hbWVdLFxuICBcdFx0ICAgIHJlZ2lzdHJ5O1xuXG4gIFx0XHRyZWdpc3RyeSA9IGNyZWF0ZShQYXJlbnRbbmFtZV0pO1xuXG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gb3B0aW9uKSB7XG4gIFx0XHRcdHJlZ2lzdHJ5W2tleV0gPSBvcHRpb25ba2V5XTtcbiAgXHRcdH1cblxuICBcdFx0dGFyZ2V0W25hbWVdID0gcmVnaXN0cnk7XG4gIFx0fSxcblxuICBcdHJlc2V0OiBmdW5jdGlvbiAocmFjdGl2ZSkge1xuICBcdFx0dmFyIHJlZ2lzdHJ5ID0gcmFjdGl2ZVt0aGlzLm5hbWVdO1xuICBcdFx0dmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgXHRcdE9iamVjdC5rZXlzKHJlZ2lzdHJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdFx0dmFyIGl0ZW0gPSByZWdpc3RyeVtrZXldO1xuICBcdFx0XHRpZiAoaXRlbS5fZm4pIHtcbiAgXHRcdFx0XHRpZiAoaXRlbS5fZm4uaXNPd25lcikge1xuICBcdFx0XHRcdFx0cmVnaXN0cnlba2V5XSA9IGl0ZW0uX2ZuO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRkZWxldGUgcmVnaXN0cnlba2V5XTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuICBcdFx0cmV0dXJuIGNoYW5nZWQ7XG4gIFx0fVxuICB9O1xuXG4gIHJlZ2lzdHJpZXMgPSBjb25maWdfcmVnaXN0cmllc19fcmVnaXN0cnlOYW1lcy5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgXHRyZXR1cm4gbmV3IFJlZ2lzdHJ5KG5hbWUsIG5hbWUgPT09IFwiY29tcHV0ZWRcIik7XG4gIH0pO1xuXG4gIHZhciBjb25maWdfcmVnaXN0cmllcyA9IHJlZ2lzdHJpZXM7XG5cbiAgLyp0aGlzLmNvbmZpZ3VyZShcbiAgXHR0aGlzLnVzZURlZmF1bHRzID8gUGFyZW50LmRlZmF1bHRzIDogUGFyZW50LFxuICBcdHJhY3RpdmUsXG4gIFx0b3B0aW9ucyApOyovXG5cbiAgdmFyIHdyYXBQcm90b3R5cGUgPSB3cmFwO1xuXG4gIGZ1bmN0aW9uIHdyYXAocGFyZW50LCBuYW1lLCBtZXRob2QpIHtcbiAgXHRpZiAoIS9fc3VwZXIvLnRlc3QobWV0aG9kKSkge1xuICBcdFx0cmV0dXJuIG1ldGhvZDtcbiAgXHR9XG5cbiAgXHR2YXIgd3JhcHBlciA9IGZ1bmN0aW9uIHdyYXBTdXBlcigpIHtcbiAgXHRcdHZhciBzdXBlck1ldGhvZCA9IGdldFN1cGVyTWV0aG9kKHdyYXBwZXIuX3BhcmVudCwgbmFtZSksXG4gIFx0XHQgICAgaGFzU3VwZXIgPSAoXCJfc3VwZXJcIiBpbiB0aGlzKSxcbiAgXHRcdCAgICBvbGRTdXBlciA9IHRoaXMuX3N1cGVyLFxuICBcdFx0ICAgIHJlc3VsdDtcblxuICBcdFx0dGhpcy5fc3VwZXIgPSBzdXBlck1ldGhvZDtcblxuICBcdFx0cmVzdWx0ID0gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgXHRcdGlmIChoYXNTdXBlcikge1xuICBcdFx0XHR0aGlzLl9zdXBlciA9IG9sZFN1cGVyO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuX3N1cGVyO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdH07XG5cbiAgXHR3cmFwcGVyLl9wYXJlbnQgPSBwYXJlbnQ7XG4gIFx0d3JhcHBlci5fbWV0aG9kID0gbWV0aG9kO1xuXG4gIFx0cmV0dXJuIHdyYXBwZXI7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTdXBlck1ldGhvZChwYXJlbnQsIG5hbWUpIHtcbiAgXHR2YXIgdmFsdWUsIG1ldGhvZDtcblxuICBcdGlmIChuYW1lIGluIHBhcmVudCkge1xuICBcdFx0dmFsdWUgPSBwYXJlbnRbbmFtZV07XG5cbiAgXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRtZXRob2QgPSB2YWx1ZTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdG1ldGhvZCA9IGZ1bmN0aW9uIHJldHVyblZhbHVlKCkge1xuICBcdFx0XHRcdHJldHVybiB2YWx1ZTtcbiAgXHRcdFx0fTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0bWV0aG9kID0gbm9vcDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbWV0aG9kO1xuICB9XG5cbiAgdmFyIGNvbmZpZ19kZXByZWNhdGUgPSBkZXByZWNhdGU7XG4gIGZ1bmN0aW9uIGdldE1lc3NhZ2UoZGVwcmVjYXRlZCwgY29ycmVjdCwgaXNFcnJvcikge1xuICBcdHJldHVybiBcIm9wdGlvbnMuXCIgKyBkZXByZWNhdGVkICsgXCIgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvdXIgb2Ygb3B0aW9ucy5cIiArIGNvcnJlY3QgKyBcIi5cIiArIChpc0Vycm9yID8gXCIgWW91IGNhbm5vdCBzcGVjaWZ5IGJvdGggb3B0aW9ucywgcGxlYXNlIHVzZSBvcHRpb25zLlwiICsgY29ycmVjdCArIFwiLlwiIDogXCJcIik7XG4gIH1cblxuICBmdW5jdGlvbiBkZXByZWNhdGVPcHRpb24ob3B0aW9ucywgZGVwcmVjYXRlZE9wdGlvbiwgY29ycmVjdCkge1xuICBcdGlmIChkZXByZWNhdGVkT3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgXHRcdGlmICghKGNvcnJlY3QgaW4gb3B0aW9ucykpIHtcbiAgXHRcdFx0d2FybklmRGVidWcoZ2V0TWVzc2FnZShkZXByZWNhdGVkT3B0aW9uLCBjb3JyZWN0KSk7XG4gIFx0XHRcdG9wdGlvbnNbY29ycmVjdF0gPSBvcHRpb25zW2RlcHJlY2F0ZWRPcHRpb25dO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKGdldE1lc3NhZ2UoZGVwcmVjYXRlZE9wdGlvbiwgY29ycmVjdCwgdHJ1ZSkpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuICBmdW5jdGlvbiBkZXByZWNhdGUob3B0aW9ucykge1xuICBcdGRlcHJlY2F0ZU9wdGlvbihvcHRpb25zLCBcImJlZm9yZUluaXRcIiwgXCJvbmNvbnN0cnVjdFwiKTtcbiAgXHRkZXByZWNhdGVPcHRpb24ob3B0aW9ucywgXCJpbml0XCIsIFwib25yZW5kZXJcIik7XG4gIFx0ZGVwcmVjYXRlT3B0aW9uKG9wdGlvbnMsIFwiY29tcGxldGVcIiwgXCJvbmNvbXBsZXRlXCIpO1xuICBcdGRlcHJlY2F0ZU9wdGlvbihvcHRpb25zLCBcImV2ZW50RGVmaW5pdGlvbnNcIiwgXCJldmVudHNcIik7XG5cbiAgXHQvLyBVc2luZyBleHRlbmQgd2l0aCBDb21wb25lbnQgaW5zdGVhZCBvZiBvcHRpb25zLFxuICBcdC8vIGxpa2UgSHVtYW4uZXh0ZW5kKCBTcGlkZXIgKSBtZWFucyBhZGFwdG9ycyBhcyBhIHJlZ2lzdHJ5XG4gIFx0Ly8gZ2V0cyBjb3BpZWQgdG8gb3B0aW9ucy4gU28gd2UgaGF2ZSB0byBjaGVjayBpZiBhY3R1YWxseSBhbiBhcnJheVxuICBcdGlmIChpc0FycmF5KG9wdGlvbnMuYWRhcHRvcnMpKSB7XG4gIFx0XHRkZXByZWNhdGVPcHRpb24ob3B0aW9ucywgXCJhZGFwdG9yc1wiLCBcImFkYXB0XCIpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBjb25maWcsIG9yZGVyLCBkZWZhdWx0S2V5cywgY3VzdG9tLCBpc0JsYWNrbGlzdGVkLCBpc1N0YW5kYXJkS2V5O1xuXG4gIGN1c3RvbSA9IHtcbiAgXHRhZGFwdDogY3VzdG9tX2FkYXB0LFxuICBcdGNzczogY3NzX2NzcyxcbiAgXHRkYXRhOiBjdXN0b21fZGF0YSxcbiAgXHR0ZW1wbGF0ZTogdGVtcGxhdGVfdGVtcGxhdGVcbiAgfTtcblxuICBkZWZhdWx0S2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZ19kZWZhdWx0cyk7XG5cbiAgaXNTdGFuZGFyZEtleSA9IG1ha2VPYmooZGVmYXVsdEtleXMuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRyZXR1cm4gIWN1c3RvbVtrZXldO1xuICB9KSk7XG5cbiAgLy8gYmxhY2tsaXN0ZWQga2V5cyB0aGF0IHdlIGRvbid0IGRvdWJsZSBleHRlbmRcbiAgaXNCbGFja2xpc3RlZCA9IG1ha2VPYmooZGVmYXVsdEtleXMuY29uY2F0KGNvbmZpZ19yZWdpc3RyaWVzLm1hcChmdW5jdGlvbiAocikge1xuICBcdHJldHVybiByLm5hbWU7XG4gIH0pKSk7XG5cbiAgb3JkZXIgPSBbXS5jb25jYXQoZGVmYXVsdEtleXMuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRyZXR1cm4gIWNvbmZpZ19yZWdpc3RyaWVzW2tleV0gJiYgIWN1c3RvbVtrZXldO1xuICB9KSwgY29uZmlnX3JlZ2lzdHJpZXMsIGN1c3RvbS5kYXRhLCBjdXN0b20udGVtcGxhdGUsIGN1c3RvbS5jc3MpO1xuXG4gIGNvbmZpZyA9IHtcbiAgXHRleHRlbmQ6IGZ1bmN0aW9uIChQYXJlbnQsIHByb3RvLCBvcHRpb25zKSB7XG4gIFx0XHRyZXR1cm4gY29uZmlndXJlKFwiZXh0ZW5kXCIsIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpO1xuICBcdH0sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoUGFyZW50LCByYWN0aXZlLCBvcHRpb25zKSB7XG4gIFx0XHRyZXR1cm4gY29uZmlndXJlKFwiaW5pdFwiLCBQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMpO1xuICBcdH0sXG5cbiAgXHRyZXNldDogZnVuY3Rpb24gKHJhY3RpdmUpIHtcbiAgXHRcdHJldHVybiBvcmRlci5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgXHRcdFx0cmV0dXJuIGMucmVzZXQgJiYgYy5yZXNldChyYWN0aXZlKTtcbiAgXHRcdH0pLm1hcChmdW5jdGlvbiAoYykge1xuICBcdFx0XHRyZXR1cm4gYy5uYW1lO1xuICBcdFx0fSk7XG4gIFx0fSxcblxuICBcdC8vIHRoaXMgZGVmaW5lcyB0aGUgb3JkZXIuIFRPRE8gdGhpcyBpc24ndCB1c2VkIGFueXdoZXJlIGluIHRoZSBjb2RlYmFzZSxcbiAgXHQvLyBvbmx5IGluIHRoZSB0ZXN0IHN1aXRlIC0gc2hvdWxkIGdldCByaWQgb2YgaXRcbiAgXHRvcmRlcjogb3JkZXIgfTtcblxuICBmdW5jdGlvbiBjb25maWd1cmUobWV0aG9kLCBQYXJlbnQsIHRhcmdldCwgb3B0aW9ucykge1xuICBcdGNvbmZpZ19kZXByZWNhdGUob3B0aW9ucyk7XG5cbiAgXHRmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICBcdFx0aWYgKGlzU3RhbmRhcmRLZXkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICBcdFx0XHR2YXIgdmFsdWUgPSBvcHRpb25zW2tleV07XG5cbiAgXHRcdFx0Ly8gd2FybiB0aGUgZGV2ZWxvcGVyIGlmIHRoZXkgcGFzc2VkIGEgZnVuY3Rpb24gYW5kIGlnbm9yZSBpdHMgdmFsdWVcblxuICBcdFx0XHQvLyBOT1RFOiB3ZSBhbGxvdyBzb21lIGZ1bmN0aW9ucyBvbiBcImVsXCIgYmVjYXVzZSB3ZSBkdWNrIHR5cGUgZWxlbWVudCBsaXN0c1xuICBcdFx0XHQvLyBhbmQgc29tZSBsaWJyYXJpZXMgb3IgZWYnZWQtdXAgdmlydHVhbCBicm93c2VycyAocGhhbnRvbUpTKSByZXR1cm4gYVxuICBcdFx0XHQvLyBmdW5jdGlvbiBvYmplY3QgYXMgdGhlIHJlc3VsdCBvZiBxdWVyeVNlbGVjdG9yIG1ldGhvZHNcbiAgXHRcdFx0aWYgKGtleSAhPT0gXCJlbFwiICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdFx0d2FybklmRGVidWcoXCJcIiArIGtleSArIFwiIGlzIGEgUmFjdGl2ZSBvcHRpb24gdGhhdCBkb2VzIG5vdCBleHBlY3QgYSBmdW5jdGlvbiBhbmQgd2lsbCBiZSBpZ25vcmVkXCIsIG1ldGhvZCA9PT0gXCJpbml0XCIgPyB0YXJnZXQgOiBudWxsKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHR0YXJnZXRba2V5XSA9IHZhbHVlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Y29uZmlnX3JlZ2lzdHJpZXMuZm9yRWFjaChmdW5jdGlvbiAocmVnaXN0cnkpIHtcbiAgXHRcdHJlZ2lzdHJ5W21ldGhvZF0oUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMpO1xuICBcdH0pO1xuXG4gIFx0Y3VzdG9tX2FkYXB0W21ldGhvZF0oUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMpO1xuICBcdHRlbXBsYXRlX3RlbXBsYXRlW21ldGhvZF0oUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMpO1xuICBcdGNzc19jc3NbbWV0aG9kXShQYXJlbnQsIHRhcmdldCwgb3B0aW9ucyk7XG5cbiAgXHRleHRlbmRPdGhlck1ldGhvZHMoUGFyZW50LnByb3RvdHlwZSwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZE90aGVyTWV0aG9kcyhwYXJlbnQsIHRhcmdldCwgb3B0aW9ucykge1xuICBcdGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gIFx0XHRpZiAoIWlzQmxhY2tsaXN0ZWRba2V5XSAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgXHRcdFx0dmFyIG1lbWJlciA9IG9wdGlvbnNba2V5XTtcblxuICBcdFx0XHQvLyBpZiB0aGlzIGlzIGEgbWV0aG9kIHRoYXQgb3ZlcndyaXRlcyBhIG1ldGhvZCwgd3JhcCBpdDpcbiAgXHRcdFx0aWYgKHR5cGVvZiBtZW1iZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRcdG1lbWJlciA9IHdyYXBQcm90b3R5cGUocGFyZW50LCBrZXksIG1lbWJlcik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0YXJnZXRba2V5XSA9IG1lbWJlcjtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlT2JqKGFycmF5KSB7XG4gIFx0dmFyIG9iaiA9IHt9O1xuICBcdGFycmF5LmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgXHRcdHJldHVybiBvYmpbeF0gPSB0cnVlO1xuICBcdH0pO1xuICBcdHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgY29uZmlnX2NvbmZpZyA9IGNvbmZpZztcblxuICB2YXIgcHJvdG90eXBlX2J1YmJsZSA9IEZyYWdtZW50JGJ1YmJsZTtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRidWJibGUoKSB7XG4gIFx0dGhpcy5kaXJ0eVZhbHVlID0gdGhpcy5kaXJ0eUFyZ3MgPSB0cnVlO1xuXG4gIFx0aWYgKHRoaXMuYm91bmQgJiYgdHlwZW9mIHRoaXMub3duZXIuYnViYmxlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdHRoaXMub3duZXIuYnViYmxlKCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV9kZXRhY2ggPSBGcmFnbWVudCRkZXRhY2g7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkZGV0YWNoKCkge1xuICBcdHZhciBkb2NGcmFnO1xuXG4gIFx0aWYgKHRoaXMuaXRlbXMubGVuZ3RoID09PSAxKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5pdGVtc1swXS5kZXRhY2goKTtcbiAgXHR9XG5cbiAgXHRkb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gIFx0dGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gIFx0XHR2YXIgbm9kZSA9IGl0ZW0uZGV0YWNoKCk7XG5cbiAgXHRcdC8vIFRPRE8gVGhlIGlmIHsuLi59IHdhc24ndCBwcmV2aW91c2x5IHJlcXVpcmVkIC0gaXQgaXMgbm93LCBiZWNhdXNlIHdlJ3JlXG4gIFx0XHQvLyBmb3JjaWJseSBkZXRhY2hpbmcgZXZlcnl0aGluZyB0byByZW9yZGVyIHNlY3Rpb25zIGFmdGVyIGFuIHVwZGF0ZS4gVGhhdCdzXG4gIFx0XHQvLyBhIG5vbi1pZGVhbCBicnV0ZSBmb3JjZSBhcHByb2FjaCwgaW1wbGVtZW50ZWQgdG8gZ2V0IGFsbCB0aGUgdGVzdHMgdG8gcGFzc1xuICBcdFx0Ly8gLSBhcyBzb29uIGFzIGl0J3MgcmVwbGFjZWQgd2l0aCBzb21ldGhpbmcgbW9yZSBlbGVnYW50LCB0aGlzIHNob3VsZFxuICBcdFx0Ly8gcmV2ZXJ0IHRvIGBkb2NGcmFnLmFwcGVuZENoaWxkKCBpdGVtLmRldGFjaCgpIClgXG4gIFx0XHRpZiAobm9kZSkge1xuICBcdFx0XHRkb2NGcmFnLmFwcGVuZENoaWxkKG5vZGUpO1xuICBcdFx0fVxuICBcdH0pO1xuXG4gIFx0cmV0dXJuIGRvY0ZyYWc7XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX2ZpbmQgPSBGcmFnbWVudCRmaW5kO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGZpbmQoc2VsZWN0b3IpIHtcbiAgXHR2YXIgaSwgbGVuLCBpdGVtLCBxdWVyeVJlc3VsdDtcblxuICBcdGlmICh0aGlzLml0ZW1zKSB7XG4gIFx0XHRsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRpdGVtID0gdGhpcy5pdGVtc1tpXTtcblxuICBcdFx0XHRpZiAoaXRlbS5maW5kICYmIChxdWVyeVJlc3VsdCA9IGl0ZW0uZmluZChzZWxlY3RvcikpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIHF1ZXJ5UmVzdWx0O1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfZmluZEFsbCA9IEZyYWdtZW50JGZpbmRBbGw7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkZmluZEFsbChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHR2YXIgaSwgbGVuLCBpdGVtO1xuXG4gIFx0aWYgKHRoaXMuaXRlbXMpIHtcbiAgXHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zW2ldO1xuXG4gIFx0XHRcdGlmIChpdGVtLmZpbmRBbGwpIHtcbiAgXHRcdFx0XHRpdGVtLmZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMgPSBGcmFnbWVudCRmaW5kQWxsQ29tcG9uZW50cztcblxuICBmdW5jdGlvbiBGcmFnbWVudCRmaW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHR2YXIgaSwgbGVuLCBpdGVtO1xuXG4gIFx0aWYgKHRoaXMuaXRlbXMpIHtcbiAgXHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zW2ldO1xuXG4gIFx0XHRcdGlmIChpdGVtLmZpbmRBbGxDb21wb25lbnRzKSB7XG4gIFx0XHRcdFx0aXRlbS5maW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV9maW5kQ29tcG9uZW50ID0gRnJhZ21lbnQkZmluZENvbXBvbmVudDtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRmaW5kQ29tcG9uZW50KHNlbGVjdG9yKSB7XG4gIFx0dmFyIGxlbiwgaSwgaXRlbSwgcXVlcnlSZXN1bHQ7XG5cbiAgXHRpZiAodGhpcy5pdGVtcykge1xuICBcdFx0bGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbaV07XG5cbiAgXHRcdFx0aWYgKGl0ZW0uZmluZENvbXBvbmVudCAmJiAocXVlcnlSZXN1bHQgPSBpdGVtLmZpbmRDb21wb25lbnQoc2VsZWN0b3IpKSkge1xuICBcdFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2ZpbmROZXh0Tm9kZSA9IEZyYWdtZW50JGZpbmROZXh0Tm9kZTtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRmaW5kTmV4dE5vZGUoaXRlbSkge1xuICBcdHZhciBpbmRleCA9IGl0ZW0uaW5kZXgsXG4gIFx0ICAgIG5vZGU7XG5cbiAgXHRpZiAodGhpcy5pdGVtc1tpbmRleCArIDFdKSB7XG4gIFx0XHRub2RlID0gdGhpcy5pdGVtc1tpbmRleCArIDFdLmZpcnN0Tm9kZSgpO1xuICBcdH1cblxuICBcdC8vIGlmIHRoaXMgaXMgdGhlIHJvb3QgZnJhZ21lbnQsIGFuZCB0aGVyZSBhcmUgbm8gbW9yZSBpdGVtcyxcbiAgXHQvLyBpdCBtZWFucyB3ZSdyZSBhdCB0aGUgZW5kLi4uXG4gIFx0ZWxzZSBpZiAodGhpcy5vd25lciA9PT0gdGhpcy5yb290KSB7XG4gIFx0XHRpZiAoIXRoaXMub3duZXIuY29tcG9uZW50KSB7XG4gIFx0XHRcdC8vIFRPRE8gYnV0IHNvbWV0aGluZyBlbHNlIGNvdWxkIGhhdmUgYmVlbiBhcHBlbmRlZCB0b1xuICBcdFx0XHQvLyB0aGlzLnJvb3QuZWwsIG5vP1xuICBcdFx0XHRub2RlID0gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0Ly8gLi4udW5sZXNzIHRoaXMgaXMgYSBjb21wb25lbnRcbiAgXHRcdGVsc2Uge1xuICBcdFx0XHRub2RlID0gdGhpcy5vd25lci5jb21wb25lbnQuZmluZE5leHROb2RlKCk7XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdG5vZGUgPSB0aGlzLm93bmVyLmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZmlyc3ROb2RlID0gRnJhZ21lbnQkZmlyc3ROb2RlO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGZpcnN0Tm9kZSgpIHtcbiAgXHRpZiAodGhpcy5pdGVtcyAmJiB0aGlzLml0ZW1zWzBdKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5pdGVtc1swXS5maXJzdE5vZGUoKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBzaGFyZWRfcHJvY2Vzc0l0ZW1zID0gcHJvY2Vzc0l0ZW1zO1xuXG4gIGZ1bmN0aW9uIHByb2Nlc3NJdGVtcyhpdGVtcywgdmFsdWVzLCBndWlkLCBjb3VudGVyKSB7XG4gIFx0Y291bnRlciA9IGNvdW50ZXIgfHwgMDtcblxuICBcdHJldHVybiBpdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgXHRcdHZhciBwbGFjZWhvbGRlcklkLCB3cmFwcGVkLCB2YWx1ZTtcblxuICBcdFx0aWYgKGl0ZW0udGV4dCkge1xuICBcdFx0XHRyZXR1cm4gaXRlbS50ZXh0O1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoaXRlbS5mcmFnbWVudHMpIHtcbiAgXHRcdFx0cmV0dXJuIGl0ZW0uZnJhZ21lbnRzLm1hcChmdW5jdGlvbiAoZnJhZ21lbnQpIHtcbiAgXHRcdFx0XHRyZXR1cm4gcHJvY2Vzc0l0ZW1zKGZyYWdtZW50Lml0ZW1zLCB2YWx1ZXMsIGd1aWQsIGNvdW50ZXIpO1xuICBcdFx0XHR9KS5qb2luKFwiXCIpO1xuICBcdFx0fVxuXG4gIFx0XHRwbGFjZWhvbGRlcklkID0gZ3VpZCArIFwiLVwiICsgY291bnRlcisrO1xuXG4gIFx0XHRpZiAoaXRlbS5rZXlwYXRoICYmICh3cmFwcGVkID0gaXRlbS5yb290LnZpZXdtb2RlbC53cmFwcGVkW2l0ZW0ua2V5cGF0aC5zdHJdKSkge1xuICBcdFx0XHR2YWx1ZSA9IHdyYXBwZWQudmFsdWU7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR2YWx1ZSA9IGl0ZW0uZ2V0VmFsdWUoKTtcbiAgXHRcdH1cblxuICBcdFx0dmFsdWVzW3BsYWNlaG9sZGVySWRdID0gdmFsdWU7XG5cbiAgXHRcdHJldHVybiBcIiR7XCIgKyBwbGFjZWhvbGRlcklkICsgXCJ9XCI7XG4gIFx0fSkuam9pbihcIlwiKTtcbiAgfVxuXG4gIHZhciBnZXRBcmdzTGlzdCA9IEZyYWdtZW50JGdldEFyZ3NMaXN0O1xuICBmdW5jdGlvbiBGcmFnbWVudCRnZXRBcmdzTGlzdCgpIHtcbiAgXHR2YXIgdmFsdWVzLCBzb3VyY2UsIHBhcnNlZCwgcmVzdWx0O1xuXG4gIFx0aWYgKHRoaXMuZGlydHlBcmdzKSB7XG4gIFx0XHRzb3VyY2UgPSBzaGFyZWRfcHJvY2Vzc0l0ZW1zKHRoaXMuaXRlbXMsIHZhbHVlcyA9IHt9LCB0aGlzLnJvb3QuX2d1aWQpO1xuICBcdFx0cGFyc2VkID0gcGFyc2VKU09OKFwiW1wiICsgc291cmNlICsgXCJdXCIsIHZhbHVlcyk7XG5cbiAgXHRcdGlmICghcGFyc2VkKSB7XG4gIFx0XHRcdHJlc3VsdCA9IFt0aGlzLnRvU3RyaW5nKCldO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cmVzdWx0ID0gcGFyc2VkLnZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmFyZ3NMaXN0ID0gcmVzdWx0O1xuICBcdFx0dGhpcy5kaXJ0eUFyZ3MgPSBmYWxzZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5hcmdzTGlzdDtcbiAgfVxuXG4gIHZhciBnZXROb2RlID0gRnJhZ21lbnQkZ2V0Tm9kZTtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRnZXROb2RlKCkge1xuICBcdHZhciBmcmFnbWVudCA9IHRoaXM7XG5cbiAgXHRkbyB7XG4gIFx0XHRpZiAoZnJhZ21lbnQucEVsZW1lbnQpIHtcbiAgXHRcdFx0cmV0dXJuIGZyYWdtZW50LnBFbGVtZW50Lm5vZGU7XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQpO1xuXG4gIFx0cmV0dXJuIHRoaXMucm9vdC5kZXRhY2hlZCB8fCB0aGlzLnJvb3QuZWw7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2dldFZhbHVlID0gRnJhZ21lbnQkZ2V0VmFsdWU7XG4gIGZ1bmN0aW9uIEZyYWdtZW50JGdldFZhbHVlKCkge1xuICBcdHZhciB2YWx1ZXMsIHNvdXJjZSwgcGFyc2VkLCByZXN1bHQ7XG5cbiAgXHRpZiAodGhpcy5kaXJ0eVZhbHVlKSB7XG4gIFx0XHRzb3VyY2UgPSBzaGFyZWRfcHJvY2Vzc0l0ZW1zKHRoaXMuaXRlbXMsIHZhbHVlcyA9IHt9LCB0aGlzLnJvb3QuX2d1aWQpO1xuICBcdFx0cGFyc2VkID0gcGFyc2VKU09OKHNvdXJjZSwgdmFsdWVzKTtcblxuICBcdFx0aWYgKCFwYXJzZWQpIHtcbiAgXHRcdFx0cmVzdWx0ID0gdGhpcy50b1N0cmluZygpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cmVzdWx0ID0gcGFyc2VkLnZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnZhbHVlID0gcmVzdWx0O1xuICBcdFx0dGhpcy5kaXJ0eVZhbHVlID0gZmFsc2U7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cblxuICB2YXIgc2hhcmVkX2RldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgXHRyZXR1cm4gZGV0YWNoTm9kZSh0aGlzLm5vZGUpO1xuICB9O1xuXG4gIHZhciBUZXh0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLnR5cGUgPSBURVhUO1xuICBcdHRoaXMudGV4dCA9IG9wdGlvbnMudGVtcGxhdGU7XG4gIH07XG5cbiAgVGV4dC5wcm90b3R5cGUgPSB7XG4gIFx0ZGV0YWNoOiBzaGFyZWRfZGV0YWNoLFxuXG4gIFx0Zmlyc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5ub2RlKSB7XG4gIFx0XHRcdHRoaXMubm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudGV4dCk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzLm5vZGU7XG4gIFx0fSxcblxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoZXNjYXBlKSB7XG4gIFx0XHRyZXR1cm4gZXNjYXBlID8gZXNjYXBlSHRtbCh0aGlzLnRleHQpIDogdGhpcy50ZXh0O1xuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdGlmIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLmRldGFjaCgpO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgaXRlbXNfVGV4dCA9IFRleHQ7XG5cbiAgdmFyIHNoYXJlZF91bmJpbmQgPSBzaGFyZWRfdW5iaW5kX191bmJpbmQ7XG5cbiAgZnVuY3Rpb24gc2hhcmVkX3VuYmluZF9fdW5iaW5kKCkge1xuICBcdGlmICh0aGlzLnJlZ2lzdGVyZWQpIHtcbiAgXHRcdC8vIHRoaXMgd2FzIHJlZ2lzdGVyZWQgYXMgYSBkZXBlbmRhbnRcbiAgXHRcdHRoaXMucm9vdC52aWV3bW9kZWwudW5yZWdpc3Rlcih0aGlzLmtleXBhdGgsIHRoaXMpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLnJlc29sdmVyKSB7XG4gIFx0XHR0aGlzLnJlc29sdmVyLnVuYmluZCgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBNdXN0YWNoZV9nZXRWYWx1ZSA9IE11c3RhY2hlJGdldFZhbHVlO1xuXG4gIGZ1bmN0aW9uIE11c3RhY2hlJGdldFZhbHVlKCkge1xuICBcdHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG5cbiAgdmFyIFJlZmVyZW5jZVJlc29sdmVyID0gZnVuY3Rpb24gKG93bmVyLCByZWYsIGNhbGxiYWNrKSB7XG4gIFx0dmFyIGtleXBhdGg7XG5cbiAgXHR0aGlzLnJlZiA9IHJlZjtcbiAgXHR0aGlzLnJlc29sdmVkID0gZmFsc2U7XG5cbiAgXHR0aGlzLnJvb3QgPSBvd25lci5yb290O1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBvd25lci5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgXHRrZXlwYXRoID0gc2hhcmVkX3Jlc29sdmVSZWYob3duZXIucm9vdCwgcmVmLCBvd25lci5wYXJlbnRGcmFnbWVudCk7XG4gIFx0aWYgKGtleXBhdGggIT0gdW5kZWZpbmVkKSB7XG4gIFx0XHR0aGlzLnJlc29sdmUoa2V5cGF0aCk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLmFkZFVucmVzb2x2ZWQodGhpcyk7XG4gIFx0fVxuICB9O1xuXG4gIFJlZmVyZW5jZVJlc29sdmVyLnByb3RvdHlwZSA9IHtcbiAgXHRyZXNvbHZlOiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0aWYgKHRoaXMua2V5cGF0aCAmJiAha2V5cGF0aCkge1xuICBcdFx0XHQvLyBpdCB3YXMgcmVzb2x2ZWQsIGFuZCBub3cgaXQncyBub3QuIENhbiBoYXBwZW4gaWYgZS5nLiBgYmFyYCBpblxuICBcdFx0XHQvLyBge3tmb29bYmFyXX19YCBiZWNvbWVzIHVuZGVmaW5lZFxuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRVbnJlc29sdmVkKHRoaXMpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnJlc29sdmVkID0gdHJ1ZTtcblxuICBcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcbiAgXHRcdHRoaXMuY2FsbGJhY2soa2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdGZvcmNlUmVzb2x1dGlvbjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5yZXNvbHZlKGdldEtleXBhdGgodGhpcy5yZWYpKTtcbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0dmFyIGtleXBhdGg7XG5cbiAgXHRcdGlmICh0aGlzLmtleXBhdGggIT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdGtleXBhdGggPSB0aGlzLmtleXBhdGgucmVwbGFjZShvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdFx0Ly8gd2FzIGEgbmV3IGtleXBhdGggY3JlYXRlZD9cbiAgXHRcdFx0aWYgKGtleXBhdGggIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdC8vIHJlc29sdmUgaXRcbiAgXHRcdFx0XHR0aGlzLnJlc29sdmUoa2V5cGF0aCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMucmVzb2x2ZWQpIHtcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3AucmVtb3ZlVW5yZXNvbHZlZCh0aGlzKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIFJlc29sdmVyc19SZWZlcmVuY2VSZXNvbHZlciA9IFJlZmVyZW5jZVJlc29sdmVyO1xuXG4gIHZhciBTcGVjaWFsUmVzb2x2ZXIgPSBmdW5jdGlvbiAob3duZXIsIHJlZiwgY2FsbGJhY2spIHtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gb3duZXIucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy5yZWYgPSByZWY7XG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gIFx0dGhpcy5yZWJpbmQoKTtcbiAgfTtcblxuICB2YXIgcHJvcHMgPSB7XG4gIFx0XCJAa2V5cGF0aFwiOiB7IHByZWZpeDogXCJjXCIsIHByb3A6IFtcImNvbnRleHRcIl0gfSxcbiAgXHRcIkBpbmRleFwiOiB7IHByZWZpeDogXCJpXCIsIHByb3A6IFtcImluZGV4XCJdIH0sXG4gIFx0XCJAa2V5XCI6IHsgcHJlZml4OiBcImtcIiwgcHJvcDogW1wia2V5XCIsIFwiaW5kZXhcIl0gfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldFByb3AodGFyZ2V0LCBwcm9wKSB7XG4gIFx0dmFyIHZhbHVlO1xuICBcdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcC5wcm9wLmxlbmd0aDsgaSsrKSB7XG4gIFx0XHRpZiAoKHZhbHVlID0gdGFyZ2V0W3Byb3AucHJvcFtpXV0pICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmV0dXJuIHZhbHVlO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIFNwZWNpYWxSZXNvbHZlci5wcm90b3R5cGUgPSB7XG4gIFx0cmViaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcmVmID0gdGhpcy5yZWYsXG4gIFx0XHQgICAgZnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50LFxuICBcdFx0ICAgIHByb3AgPSBwcm9wc1tyZWZdLFxuICBcdFx0ICAgIHZhbHVlO1xuXG4gIFx0XHRpZiAoIXByb3ApIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzcGVjaWFsIHJlZmVyZW5jZSBcXFwiXCIgKyByZWYgKyBcIlxcXCIgLSB2YWxpZCByZWZlcmVuY2VzIGFyZSBAaW5kZXgsIEBrZXkgYW5kIEBrZXlwYXRoXCIpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBoYXZlIHdlIGFscmVhZHkgZm91bmQgdGhlIG5lYXJlc3QgcGFyZW50P1xuICBcdFx0aWYgKHRoaXMuY2FjaGVkKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLmNhbGxiYWNrKGdldEtleXBhdGgoXCJAXCIgKyBwcm9wLnByZWZpeCArIGdldFByb3AodGhpcy5jYWNoZWQsIHByb3ApKSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSBmb3IgaW5kaWNlcywgd2hpY2ggbWF5IGNyb3NzIGNvbXBvbmVudCBib3VuZGFyaWVzXG4gIFx0XHRpZiAocHJvcC5wcm9wLmluZGV4T2YoXCJpbmRleFwiKSAhPT0gLTEgfHwgcHJvcC5wcm9wLmluZGV4T2YoXCJrZXlcIikgIT09IC0xKSB7XG4gIFx0XHRcdHdoaWxlIChmcmFnbWVudCkge1xuICBcdFx0XHRcdGlmIChmcmFnbWVudC5vd25lci5jdXJyZW50U3VidHlwZSA9PT0gU0VDVElPTl9FQUNIICYmICh2YWx1ZSA9IGdldFByb3AoZnJhZ21lbnQsIHByb3ApKSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0XHR0aGlzLmNhY2hlZCA9IGZyYWdtZW50O1xuXG4gIFx0XHRcdFx0XHRmcmFnbWVudC5yZWdpc3RlckluZGV4UmVmKHRoaXMpO1xuXG4gIFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5jYWxsYmFjayhnZXRLZXlwYXRoKFwiQFwiICsgcHJvcC5wcmVmaXggKyB2YWx1ZSkpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdC8vIHdhdGNoIGZvciBjb21wb25lbnQgYm91bmRhcmllc1xuICBcdFx0XHRcdGlmICghZnJhZ21lbnQucGFyZW50ICYmIGZyYWdtZW50Lm93bmVyICYmIGZyYWdtZW50Lm93bmVyLmNvbXBvbmVudCAmJiBmcmFnbWVudC5vd25lci5jb21wb25lbnQucGFyZW50RnJhZ21lbnQgJiYgIWZyYWdtZW50Lm93bmVyLmNvbXBvbmVudC5pbnN0YW5jZS5pc29sYXRlZCkge1xuICBcdFx0XHRcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5vd25lci5jb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50O1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0d2hpbGUgKGZyYWdtZW50KSB7XG4gIFx0XHRcdFx0aWYgKCh2YWx1ZSA9IGdldFByb3AoZnJhZ21lbnQsIHByb3ApKSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5jYWxsYmFjayhnZXRLZXlwYXRoKFwiQFwiICsgcHJvcC5wcmVmaXggKyB2YWx1ZS5zdHIpKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudDtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLmNhY2hlZCkge1xuICBcdFx0XHR0aGlzLmNhY2hlZC51bnJlZ2lzdGVySW5kZXhSZWYodGhpcyk7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBSZXNvbHZlcnNfU3BlY2lhbFJlc29sdmVyID0gU3BlY2lhbFJlc29sdmVyO1xuXG4gIHZhciBJbmRleFJlc29sdmVyID0gZnVuY3Rpb24gKG93bmVyLCByZWYsIGNhbGxiYWNrKSB7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IG93bmVyLnBhcmVudEZyYWdtZW50O1xuICBcdHRoaXMucmVmID0gcmVmO1xuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICBcdHJlZi5yZWYuZnJhZ21lbnQucmVnaXN0ZXJJbmRleFJlZih0aGlzKTtcblxuICBcdHRoaXMucmViaW5kKCk7XG4gIH07XG5cbiAgSW5kZXhSZXNvbHZlci5wcm90b3R5cGUgPSB7XG4gIFx0cmViaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgaW5kZXgsXG4gIFx0XHQgICAgcmVmID0gdGhpcy5yZWYucmVmO1xuXG4gIFx0XHRpZiAocmVmLnJlZi50ID09PSBcImtcIikge1xuICBcdFx0XHRpbmRleCA9IFwia1wiICsgcmVmLmZyYWdtZW50LmtleTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGluZGV4ID0gXCJpXCIgKyByZWYuZnJhZ21lbnQuaW5kZXg7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHRoaXMuY2FsbGJhY2soZ2V0S2V5cGF0aChcIkBcIiArIGluZGV4KSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5yZWYucmVmLmZyYWdtZW50LnVucmVnaXN0ZXJJbmRleFJlZih0aGlzKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIFJlc29sdmVyc19JbmRleFJlc29sdmVyID0gSW5kZXhSZXNvbHZlcjtcblxuICB2YXIgUmVzb2x2ZXJzX2ZpbmRJbmRleFJlZnMgPSBmaW5kSW5kZXhSZWZzO1xuXG4gIGZ1bmN0aW9uIGZpbmRJbmRleFJlZnMoZnJhZ21lbnQsIHJlZk5hbWUpIHtcbiAgXHR2YXIgcmVzdWx0ID0ge30sXG4gIFx0ICAgIHJlZnMsXG4gIFx0ICAgIGZyYWdSZWZzLFxuICBcdCAgICByZWYsXG4gIFx0ICAgIGksXG4gIFx0ICAgIG93bmVyLFxuICBcdCAgICBoaXQgPSBmYWxzZTtcblxuICBcdGlmICghcmVmTmFtZSkge1xuICBcdFx0cmVzdWx0LnJlZnMgPSByZWZzID0ge307XG4gIFx0fVxuXG4gIFx0d2hpbGUgKGZyYWdtZW50KSB7XG4gIFx0XHRpZiAoKG93bmVyID0gZnJhZ21lbnQub3duZXIpICYmIChmcmFnUmVmcyA9IG93bmVyLmluZGV4UmVmcykpIHtcblxuICBcdFx0XHQvLyB3ZSdyZSBsb29raW5nIGZvciBhIHBhcnRpY3VsYXIgcmVmLCBhbmQgaXQncyBoZXJlXG4gIFx0XHRcdGlmIChyZWZOYW1lICYmIChyZWYgPSBvd25lci5nZXRJbmRleFJlZihyZWZOYW1lKSkpIHtcbiAgXHRcdFx0XHRyZXN1bHQucmVmID0ge1xuICBcdFx0XHRcdFx0ZnJhZ21lbnQ6IGZyYWdtZW50LFxuICBcdFx0XHRcdFx0cmVmOiByZWZcbiAgXHRcdFx0XHR9O1xuICBcdFx0XHRcdHJldHVybiByZXN1bHQ7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyB3ZSdyZSBjb2xsZWN0aW5nIHJlZnMgdXAtdHJlZVxuICBcdFx0XHRlbHNlIGlmICghcmVmTmFtZSkge1xuICBcdFx0XHRcdGZvciAoaSBpbiBmcmFnUmVmcykge1xuICBcdFx0XHRcdFx0cmVmID0gZnJhZ1JlZnNbaV07XG5cbiAgXHRcdFx0XHRcdC8vIGRvbid0IG92ZXJ3cml0ZSBleGlzdGluZyByZWZzIC0gdGhleSBzaG91bGQgc2hhZG93IHBhcmVudHNcbiAgXHRcdFx0XHRcdGlmICghcmVmc1tyZWYubl0pIHtcbiAgXHRcdFx0XHRcdFx0aGl0ID0gdHJ1ZTtcbiAgXHRcdFx0XHRcdFx0cmVmc1tyZWYubl0gPSB7XG4gIFx0XHRcdFx0XHRcdFx0ZnJhZ21lbnQ6IGZyYWdtZW50LFxuICBcdFx0XHRcdFx0XHRcdHJlZjogcmVmXG4gIFx0XHRcdFx0XHRcdH07XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHdhdGNoIGZvciBjb21wb25lbnQgYm91bmRhcmllc1xuICBcdFx0aWYgKCFmcmFnbWVudC5wYXJlbnQgJiYgZnJhZ21lbnQub3duZXIgJiYgZnJhZ21lbnQub3duZXIuY29tcG9uZW50ICYmIGZyYWdtZW50Lm93bmVyLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudCAmJiAhZnJhZ21lbnQub3duZXIuY29tcG9uZW50Lmluc3RhbmNlLmlzb2xhdGVkKSB7XG4gIFx0XHRcdHJlc3VsdC5jb21wb25lbnRCb3VuZGFyeSA9IHRydWU7XG4gIFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQub3duZXIuY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKCFoaXQpIHtcbiAgXHRcdHJldHVybiB1bmRlZmluZWQ7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJldHVybiByZXN1bHQ7XG4gIFx0fVxuICB9XG5cbiAgZmluZEluZGV4UmVmcy5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZShpbmRpY2VzKSB7XG4gIFx0dmFyIHJlZnMgPSB7fSxcbiAgXHQgICAgayxcbiAgXHQgICAgcmVmO1xuXG4gIFx0Zm9yIChrIGluIGluZGljZXMucmVmcykge1xuICBcdFx0cmVmID0gaW5kaWNlcy5yZWZzW2tdO1xuICBcdFx0cmVmc1tyZWYucmVmLm5dID0gcmVmLnJlZi50ID09PSBcImtcIiA/IHJlZi5mcmFnbWVudC5rZXkgOiByZWYuZnJhZ21lbnQuaW5kZXg7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHJlZnM7XG4gIH07XG5cbiAgdmFyIFJlc29sdmVyc19jcmVhdGVSZWZlcmVuY2VSZXNvbHZlciA9IGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyO1xuICBmdW5jdGlvbiBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlcihvd25lciwgcmVmLCBjYWxsYmFjaykge1xuICBcdHZhciBpbmRleFJlZjtcblxuICBcdGlmIChyZWYuY2hhckF0KDApID09PSBcIkBcIikge1xuICBcdFx0cmV0dXJuIG5ldyBSZXNvbHZlcnNfU3BlY2lhbFJlc29sdmVyKG93bmVyLCByZWYsIGNhbGxiYWNrKTtcbiAgXHR9XG5cbiAgXHRpZiAoaW5kZXhSZWYgPSBSZXNvbHZlcnNfZmluZEluZGV4UmVmcyhvd25lci5wYXJlbnRGcmFnbWVudCwgcmVmKSkge1xuICBcdFx0cmV0dXJuIG5ldyBSZXNvbHZlcnNfSW5kZXhSZXNvbHZlcihvd25lciwgaW5kZXhSZWYsIGNhbGxiYWNrKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbmV3IFJlc29sdmVyc19SZWZlcmVuY2VSZXNvbHZlcihvd25lciwgcmVmLCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgc2hhcmVkX2dldEZ1bmN0aW9uRnJvbVN0cmluZyA9IGdldEZ1bmN0aW9uRnJvbVN0cmluZztcbiAgdmFyIGNhY2hlID0ge307XG4gIGZ1bmN0aW9uIGdldEZ1bmN0aW9uRnJvbVN0cmluZyhzdHIsIGkpIHtcbiAgXHR2YXIgZm4sIGFyZ3M7XG5cbiAgXHRpZiAoY2FjaGVbc3RyXSkge1xuICBcdFx0cmV0dXJuIGNhY2hlW3N0cl07XG4gIFx0fVxuXG4gIFx0YXJncyA9IFtdO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGFyZ3NbaV0gPSBcIl9cIiArIGk7XG4gIFx0fVxuXG4gIFx0Zm4gPSBuZXcgRnVuY3Rpb24oYXJncy5qb2luKFwiLFwiKSwgXCJyZXR1cm4oXCIgKyBzdHIgKyBcIilcIik7XG5cbiAgXHRjYWNoZVtzdHJdID0gZm47XG4gIFx0cmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIEV4cHJlc3Npb25SZXNvbHZlcixcbiAgICAgIFJlc29sdmVyc19FeHByZXNzaW9uUmVzb2x2ZXJfX2JpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZDtcblxuICBFeHByZXNzaW9uUmVzb2x2ZXIgPSBmdW5jdGlvbiAob3duZXIsIHBhcmVudEZyYWdtZW50LCBleHByZXNzaW9uLCBjYWxsYmFjaykge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgcmFjdGl2ZTtcblxuICBcdHJhY3RpdmUgPSBvd25lci5yb290O1xuXG4gIFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gcGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICBcdHRoaXMub3duZXIgPSBvd25lcjtcbiAgXHR0aGlzLnN0ciA9IGV4cHJlc3Npb24ucztcbiAgXHR0aGlzLmtleXBhdGhzID0gW107XG5cbiAgXHQvLyBDcmVhdGUgcmVzb2x2ZXJzIGZvciBlYWNoIHJlZmVyZW5jZVxuICBcdHRoaXMucGVuZGluZyA9IGV4cHJlc3Npb24uci5sZW5ndGg7XG4gIFx0dGhpcy5yZWZSZXNvbHZlcnMgPSBleHByZXNzaW9uLnIubWFwKGZ1bmN0aW9uIChyZWYsIGkpIHtcbiAgXHRcdHJldHVybiBSZXNvbHZlcnNfY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIoX3RoaXMsIHJlZiwgZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0X3RoaXMucmVzb2x2ZShpLCBrZXlwYXRoKTtcbiAgXHRcdH0pO1xuICBcdH0pO1xuXG4gIFx0dGhpcy5yZWFkeSA9IHRydWU7XG4gIFx0dGhpcy5idWJibGUoKTtcbiAgfTtcblxuICBFeHByZXNzaW9uUmVzb2x2ZXIucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLnJlYWR5KSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy51bmlxdWVTdHJpbmcgPSBnZXRVbmlxdWVTdHJpbmcodGhpcy5zdHIsIHRoaXMua2V5cGF0aHMpO1xuICBcdFx0dGhpcy5rZXlwYXRoID0gY3JlYXRlRXhwcmVzc2lvbktleXBhdGgodGhpcy51bmlxdWVTdHJpbmcpO1xuXG4gIFx0XHR0aGlzLmNyZWF0ZUV2YWx1YXRvcigpO1xuICBcdFx0dGhpcy5jYWxsYmFjayh0aGlzLmtleXBhdGgpO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciByZXNvbHZlcjtcblxuICBcdFx0d2hpbGUgKHJlc29sdmVyID0gdGhpcy5yZWZSZXNvbHZlcnMucG9wKCkpIHtcbiAgXHRcdFx0cmVzb2x2ZXIudW5iaW5kKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlc29sdmU6IGZ1bmN0aW9uIChpbmRleCwga2V5cGF0aCkge1xuICBcdFx0dGhpcy5rZXlwYXRoc1tpbmRleF0gPSBrZXlwYXRoO1xuICBcdFx0dGhpcy5idWJibGUoKTtcbiAgXHR9LFxuXG4gIFx0Y3JlYXRlRXZhbHVhdG9yOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgY29tcHV0YXRpb24sIHZhbHVlR2V0dGVycywgc2lnbmF0dXJlLCBrZXlwYXRoLCBmbjtcblxuICBcdFx0a2V5cGF0aCA9IHRoaXMua2V5cGF0aDtcbiAgXHRcdGNvbXB1dGF0aW9uID0gdGhpcy5yb290LnZpZXdtb2RlbC5jb21wdXRhdGlvbnNba2V5cGF0aC5zdHJdO1xuXG4gIFx0XHQvLyBvbmx5IGlmIGl0IGRvZXNuJ3QgZXhpc3QgeWV0IVxuICBcdFx0aWYgKCFjb21wdXRhdGlvbikge1xuICBcdFx0XHRmbiA9IHNoYXJlZF9nZXRGdW5jdGlvbkZyb21TdHJpbmcodGhpcy5zdHIsIHRoaXMucmVmUmVzb2x2ZXJzLmxlbmd0aCk7XG5cbiAgXHRcdFx0dmFsdWVHZXR0ZXJzID0gdGhpcy5rZXlwYXRocy5tYXAoZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0XHR2YXIgdmFsdWU7XG5cbiAgXHRcdFx0XHRpZiAoa2V5cGF0aCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICBcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcbiAgXHRcdFx0XHRcdH07XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0Ly8gJ3NwZWNpYWwnIGtleXBhdGhzIGVuY29kZSBhIHZhbHVlXG4gIFx0XHRcdFx0aWYgKGtleXBhdGguaXNTcGVjaWFsKSB7XG4gIFx0XHRcdFx0XHR2YWx1ZSA9IGtleXBhdGgudmFsdWU7XG4gIFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0XHRcdFx0XHR9O1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHR2YXIgdmFsdWUgPSBfdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoa2V5cGF0aCwgeyBub1Vud3JhcDogdHJ1ZSwgZnVsbFJvb3RHZXQ6IHRydWUgfSk7XG4gIFx0XHRcdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0XHRcdFx0dmFsdWUgPSB3cmFwRnVuY3Rpb24odmFsdWUsIF90aGlzLnJvb3QpO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuICBcdFx0XHRcdH07XG4gIFx0XHRcdH0pO1xuXG4gIFx0XHRcdHNpZ25hdHVyZSA9IHtcbiAgXHRcdFx0XHRkZXBzOiB0aGlzLmtleXBhdGhzLmZpbHRlcihpc1ZhbGlkRGVwZW5kZW5jeSksXG4gIFx0XHRcdFx0Z2V0dGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHR2YXIgYXJncyA9IHZhbHVlR2V0dGVycy5tYXAoY2FsbCk7XG4gIFx0XHRcdFx0XHRyZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9O1xuXG4gIFx0XHRcdGNvbXB1dGF0aW9uID0gdGhpcy5yb290LnZpZXdtb2RlbC5jb21wdXRlKGtleXBhdGgsIHNpZ25hdHVyZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLm1hcmsoa2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdC8vIFRPRE8gb25seSBidWJibGUgb25jZSwgbm8gbWF0dGVyIGhvdyBtYW55IHJlZmVyZW5jZXMgYXJlIGFmZmVjdGVkIGJ5IHRoZSByZWJpbmRcbiAgXHRcdHRoaXMucmVmUmVzb2x2ZXJzLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgXHRcdFx0cmV0dXJuIHIucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0fSk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBSZXNvbHZlcnNfRXhwcmVzc2lvblJlc29sdmVyID0gRXhwcmVzc2lvblJlc29sdmVyO1xuXG4gIGZ1bmN0aW9uIGNhbGwodmFsdWUpIHtcbiAgXHRyZXR1cm4gdmFsdWUuY2FsbCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VW5pcXVlU3RyaW5nKHN0ciwga2V5cGF0aHMpIHtcbiAgXHQvLyBnZXQgc3RyaW5nIHRoYXQgaXMgdW5pcXVlIHRvIHRoaXMgZXhwcmVzc2lvblxuICBcdHJldHVybiBzdHIucmVwbGFjZSgvXyhbMC05XSspL2csIGZ1bmN0aW9uIChtYXRjaCwgJDEpIHtcbiAgXHRcdHZhciBrZXlwYXRoLCB2YWx1ZTtcblxuICBcdFx0Ly8gbWFrZSBzdXJlIHdlJ3JlIG5vdCByZXBsYWNpbmcgYSBub24ta2V5cGF0aCBfWzAtOV1cbiAgXHRcdGlmICgrJDEgPj0ga2V5cGF0aHMubGVuZ3RoKSB7XG4gIFx0XHRcdHJldHVybiBcIl9cIiArICQxO1xuICBcdFx0fVxuXG4gIFx0XHRrZXlwYXRoID0ga2V5cGF0aHNbJDFdO1xuXG4gIFx0XHRpZiAoa2V5cGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHJldHVybiBcInVuZGVmaW5lZFwiO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoa2V5cGF0aC5pc1NwZWNpYWwpIHtcbiAgXHRcdFx0dmFsdWUgPSBrZXlwYXRoLnZhbHVlO1xuICBcdFx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiID8gdmFsdWUgOiBcIlxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCI7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBrZXlwYXRoLnN0cjtcbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUV4cHJlc3Npb25LZXlwYXRoKHVuaXF1ZVN0cmluZykge1xuICBcdC8vIFNhbml0aXplIGJ5IHJlbW92aW5nIGFueSBwZXJpb2RzIG9yIHNxdWFyZSBicmFja2V0cy4gT3RoZXJ3aXNlXG4gIFx0Ly8gd2UgY2FuJ3Qgc3BsaXQgdGhlIGtleXBhdGggaW50byBrZXlzIVxuICBcdC8vIFJlbW92ZSBhc3Rlcmlza3MgdG9vLCBzaW5jZSB0aGV5IG1lc3Mgd2l0aCBwYXR0ZXJuIG9ic2VydmVyc1xuICBcdHJldHVybiBnZXRLZXlwYXRoKFwiJHtcIiArIHVuaXF1ZVN0cmluZy5yZXBsYWNlKC9bXFwuXFxbXFxdXS9nLCBcIi1cIikucmVwbGFjZSgvXFwqLywgXCIjTVVMI1wiKSArIFwifVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVmFsaWREZXBlbmRlbmN5KGtleXBhdGgpIHtcbiAgXHRyZXR1cm4ga2V5cGF0aCAhPT0gdW5kZWZpbmVkICYmIGtleXBhdGhbMF0gIT09IFwiQFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcEZ1bmN0aW9uKGZuLCByYWN0aXZlKSB7XG4gIFx0dmFyIHdyYXBwZWQsIHByb3AsIGtleTtcblxuICBcdGlmIChmbi5fX3JhY3RpdmVfbm93cmFwKSB7XG4gIFx0XHRyZXR1cm4gZm47XG4gIFx0fVxuXG4gIFx0cHJvcCA9IFwiX19yYWN0aXZlX1wiICsgcmFjdGl2ZS5fZ3VpZDtcbiAgXHR3cmFwcGVkID0gZm5bcHJvcF07XG5cbiAgXHRpZiAod3JhcHBlZCkge1xuICBcdFx0cmV0dXJuIHdyYXBwZWQ7XG4gIFx0fSBlbHNlIGlmICgvdGhpcy8udGVzdChmbi50b1N0cmluZygpKSkge1xuICBcdFx0ZGVmaW5lUHJvcGVydHkoZm4sIHByb3AsIHtcbiAgXHRcdFx0dmFsdWU6IFJlc29sdmVyc19FeHByZXNzaW9uUmVzb2x2ZXJfX2JpbmQuY2FsbChmbiwgcmFjdGl2ZSksXG4gIFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICBcdFx0fSk7XG5cbiAgXHRcdC8vIEFkZCBwcm9wZXJ0aWVzL21ldGhvZHMgdG8gd3JhcHBlZCBmdW5jdGlvblxuICBcdFx0Zm9yIChrZXkgaW4gZm4pIHtcbiAgXHRcdFx0aWYgKGZuLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgXHRcdFx0XHRmbltwcm9wXVtrZXldID0gZm5ba2V5XTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyYWN0aXZlLl9ib3VuZEZ1bmN0aW9ucy5wdXNoKHtcbiAgXHRcdFx0Zm46IGZuLFxuICBcdFx0XHRwcm9wOiBwcm9wXG4gIFx0XHR9KTtcblxuICBcdFx0cmV0dXJuIGZuW3Byb3BdO1xuICBcdH1cblxuICBcdGRlZmluZVByb3BlcnR5KGZuLCBcIl9fcmFjdGl2ZV9ub3dyYXBcIiwge1xuICBcdFx0dmFsdWU6IGZuXG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gZm4uX19yYWN0aXZlX25vd3JhcDtcbiAgfVxuXG4gIHZhciBNZW1iZXJSZXNvbHZlciA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgcmVzb2x2ZXIsIHBhcmVudEZyYWdtZW50KSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHRoaXMucmVzb2x2ZXIgPSByZXNvbHZlcjtcbiAgXHR0aGlzLnJvb3QgPSByZXNvbHZlci5yb290O1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLnZpZXdtb2RlbCA9IHJlc29sdmVyLnJvb3Qudmlld21vZGVsO1xuXG4gIFx0aWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0dGhpcy52YWx1ZSA9IHRlbXBsYXRlO1xuICBcdH1cblxuICBcdC8vIFNpbXBsZSByZWZlcmVuY2U/XG4gIFx0ZWxzZSBpZiAodGVtcGxhdGUudCA9PT0gUkVGRVJFTkNFKSB7XG4gIFx0XHR0aGlzLnJlZlJlc29sdmVyID0gUmVzb2x2ZXJzX2NyZWF0ZVJlZmVyZW5jZVJlc29sdmVyKHRoaXMsIHRlbXBsYXRlLm4sIGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdF90aGlzLnJlc29sdmUoa2V5cGF0aCk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHQvLyBPdGhlcndpc2Ugd2UgaGF2ZSBhbiBleHByZXNzaW9uIGluIGl0cyBvd24gcmlnaHRcbiAgXHRlbHNlIHtcbiAgXHRcdG5ldyBSZXNvbHZlcnNfRXhwcmVzc2lvblJlc29sdmVyKHJlc29sdmVyLCBwYXJlbnRGcmFnbWVudCwgdGVtcGxhdGUsIGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdF90aGlzLnJlc29sdmUoa2V5cGF0aCk7XG4gIFx0XHR9KTtcbiAgXHR9XG4gIH07XG5cbiAgTWVtYmVyUmVzb2x2ZXIucHJvdG90eXBlID0ge1xuICBcdHJlc29sdmU6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRpZiAodGhpcy5rZXlwYXRoKSB7XG4gIFx0XHRcdHRoaXMudmlld21vZGVsLnVucmVnaXN0ZXIodGhpcy5rZXlwYXRoLCB0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcbiAgXHRcdHRoaXMudmFsdWUgPSB0aGlzLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRcdHRoaXMuYmluZCgpO1xuXG4gIFx0XHR0aGlzLnJlc29sdmVyLmJ1YmJsZSgpO1xuICBcdH0sXG5cbiAgXHRiaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLnZpZXdtb2RlbC5yZWdpc3Rlcih0aGlzLmtleXBhdGgsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHRpZiAodGhpcy5yZWZSZXNvbHZlcikge1xuICBcdFx0XHR0aGlzLnJlZlJlc29sdmVyLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0c2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuICBcdFx0dGhpcy5yZXNvbHZlci5idWJibGUoKTtcbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5rZXlwYXRoKSB7XG4gIFx0XHRcdHRoaXMudmlld21vZGVsLnVucmVnaXN0ZXIodGhpcy5rZXlwYXRoLCB0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMucmVmUmVzb2x2ZXIpIHtcbiAgXHRcdFx0dGhpcy5yZWZSZXNvbHZlci51bmJpbmQoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Zm9yY2VSZXNvbHV0aW9uOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5yZWZSZXNvbHZlcikge1xuICBcdFx0XHR0aGlzLnJlZlJlc29sdmVyLmZvcmNlUmVzb2x1dGlvbigpO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX01lbWJlclJlc29sdmVyID0gTWVtYmVyUmVzb2x2ZXI7XG5cbiAgdmFyIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlciA9IGZ1bmN0aW9uIChtdXN0YWNoZSwgdGVtcGxhdGUsIGNhbGxiYWNrKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciByYWN0aXZlLCByZWYsIGtleXBhdGgsIHBhcmVudEZyYWdtZW50O1xuXG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IHBhcmVudEZyYWdtZW50ID0gbXVzdGFjaGUucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy5yb290ID0gcmFjdGl2ZSA9IG11c3RhY2hlLnJvb3Q7XG4gIFx0dGhpcy5tdXN0YWNoZSA9IG11c3RhY2hlO1xuXG4gIFx0dGhpcy5yZWYgPSByZWYgPSB0ZW1wbGF0ZS5yO1xuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICBcdHRoaXMudW5yZXNvbHZlZCA9IFtdO1xuXG4gIFx0Ly8gRmluZCBiYXNlIGtleXBhdGhcbiAgXHRpZiAoa2V5cGF0aCA9IHNoYXJlZF9yZXNvbHZlUmVmKHJhY3RpdmUsIHJlZiwgcGFyZW50RnJhZ21lbnQpKSB7XG4gIFx0XHR0aGlzLmJhc2UgPSBrZXlwYXRoO1xuICBcdH0gZWxzZSB7XG4gIFx0XHR0aGlzLmJhc2VSZXNvbHZlciA9IG5ldyBSZXNvbHZlcnNfUmVmZXJlbmNlUmVzb2x2ZXIodGhpcywgcmVmLCBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRfdGhpcy5iYXNlID0ga2V5cGF0aDtcbiAgXHRcdFx0X3RoaXMuYmFzZVJlc29sdmVyID0gbnVsbDtcbiAgXHRcdFx0X3RoaXMuYnViYmxlKCk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHQvLyBGaW5kIHZhbHVlcyBmb3IgbWVtYmVycywgb3IgbWFyayB0aGVtIGFzIHVucmVzb2x2ZWRcbiAgXHR0aGlzLm1lbWJlcnMgPSB0ZW1wbGF0ZS5tLm1hcChmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgXHRcdHJldHVybiBuZXcgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX01lbWJlclJlc29sdmVyKHRlbXBsYXRlLCBfdGhpcywgcGFyZW50RnJhZ21lbnQpO1xuICBcdH0pO1xuXG4gIFx0dGhpcy5yZWFkeSA9IHRydWU7XG4gIFx0dGhpcy5idWJibGUoKTsgLy8gdHJpZ2dlciBpbml0aWFsIHJlc29sdXRpb24gaWYgcG9zc2libGVcbiAgfTtcblxuICBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIucHJvdG90eXBlID0ge1xuICBcdGdldEtleXBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciB2YWx1ZXMgPSB0aGlzLm1lbWJlcnMubWFwKFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9SZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXJfX2dldFZhbHVlKTtcblxuICBcdFx0aWYgKCF2YWx1ZXMuZXZlcnkoaXNEZWZpbmVkKSB8fCB0aGlzLmJhc2VSZXNvbHZlcikge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXMuYmFzZS5qb2luKHZhbHVlcy5qb2luKFwiLlwiKSk7XG4gIFx0fSxcblxuICBcdGJ1YmJsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLnJlYWR5IHx8IHRoaXMuYmFzZVJlc29sdmVyKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5jYWxsYmFjayh0aGlzLmdldEtleXBhdGgoKSk7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5tZW1iZXJzLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5iaW5kKTtcbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0dmFyIGNoYW5nZWQ7XG5cbiAgXHRcdGlmICh0aGlzLmJhc2UpIHtcbiAgXHRcdFx0dmFyIG5ld0Jhc2UgPSB0aGlzLmJhc2UucmVwbGFjZShvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdFx0aWYgKG5ld0Jhc2UgJiYgbmV3QmFzZSAhPT0gdGhpcy5iYXNlKSB7XG4gIFx0XHRcdFx0dGhpcy5iYXNlID0gbmV3QmFzZTtcbiAgXHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR0aGlzLm1lbWJlcnMuZm9yRWFjaChmdW5jdGlvbiAobWVtYmVycykge1xuICBcdFx0XHRpZiAobWVtYmVycy5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkpIHtcbiAgXHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fSk7XG5cbiAgXHRcdGlmIChjaGFuZ2VkKSB7XG4gIFx0XHRcdHRoaXMuYnViYmxlKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGZvcmNlUmVzb2x1dGlvbjogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuYmFzZVJlc29sdmVyKSB7XG4gIFx0XHRcdHRoaXMuYmFzZSA9IGdldEtleXBhdGgodGhpcy5yZWYpO1xuXG4gIFx0XHRcdHRoaXMuYmFzZVJlc29sdmVyLnVuYmluZCgpO1xuICBcdFx0XHR0aGlzLmJhc2VSZXNvbHZlciA9IG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMubWVtYmVycy5mb3JFYWNoKGZvcmNlUmVzb2x1dGlvbik7XG4gIFx0XHR0aGlzLmJ1YmJsZSgpO1xuICBcdH1cbiAgfTtcblxuICBmdW5jdGlvbiBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXJfUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX19nZXRWYWx1ZShtZW1iZXIpIHtcbiAgXHRyZXR1cm4gbWVtYmVyLnZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gIFx0cmV0dXJuIHZhbHVlICE9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcmNlUmVzb2x1dGlvbihtZW1iZXIpIHtcbiAgXHRtZW1iZXIuZm9yY2VSZXNvbHV0aW9uKCk7XG4gIH1cblxuICB2YXIgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX1JlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlciA9IFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcjtcblxuICB2YXIgTXVzdGFjaGVfaW5pdGlhbGlzZSA9IE11c3RhY2hlJGluaXQ7XG4gIGZ1bmN0aW9uIE11c3RhY2hlJGluaXQobXVzdGFjaGUsIG9wdGlvbnMpIHtcblxuICBcdHZhciByZWYsIHBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZTtcblxuICBcdHBhcmVudEZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcbiAgXHR0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG5cbiAgXHRtdXN0YWNoZS5yb290ID0gcGFyZW50RnJhZ21lbnQucm9vdDtcbiAgXHRtdXN0YWNoZS5wYXJlbnRGcmFnbWVudCA9IHBhcmVudEZyYWdtZW50O1xuICBcdG11c3RhY2hlLnBFbGVtZW50ID0gcGFyZW50RnJhZ21lbnQucEVsZW1lbnQ7XG5cbiAgXHRtdXN0YWNoZS50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gIFx0bXVzdGFjaGUuaW5kZXggPSBvcHRpb25zLmluZGV4IHx8IDA7XG4gIFx0bXVzdGFjaGUuaXNTdGF0aWMgPSBvcHRpb25zLnRlbXBsYXRlLnM7XG5cbiAgXHRtdXN0YWNoZS50eXBlID0gb3B0aW9ucy50ZW1wbGF0ZS50O1xuXG4gIFx0bXVzdGFjaGUucmVnaXN0ZXJlZCA9IGZhbHNlO1xuXG4gIFx0Ly8gaWYgdGhpcyBpcyBhIHNpbXBsZSBtdXN0YWNoZSwgd2l0aCBhIHJlZmVyZW5jZSwgd2UganVzdCBuZWVkIHRvIHJlc29sdmVcbiAgXHQvLyB0aGUgcmVmZXJlbmNlIHRvIGEga2V5cGF0aFxuICBcdGlmIChyZWYgPSB0ZW1wbGF0ZS5yKSB7XG4gIFx0XHRtdXN0YWNoZS5yZXNvbHZlciA9IFJlc29sdmVyc19jcmVhdGVSZWZlcmVuY2VSZXNvbHZlcihtdXN0YWNoZSwgcmVmLCByZXNvbHZlKTtcbiAgXHR9XG5cbiAgXHQvLyBpZiBpdCdzIGFuIGV4cHJlc3Npb24sIHdlIGhhdmUgYSBiaXQgbW9yZSB3b3JrIHRvIGRvXG4gIFx0aWYgKG9wdGlvbnMudGVtcGxhdGUueCkge1xuICBcdFx0bXVzdGFjaGUucmVzb2x2ZXIgPSBuZXcgUmVzb2x2ZXJzX0V4cHJlc3Npb25SZXNvbHZlcihtdXN0YWNoZSwgcGFyZW50RnJhZ21lbnQsIG9wdGlvbnMudGVtcGxhdGUueCwgcmVzb2x2ZUFuZFJlYmluZENoaWxkcmVuKTtcbiAgXHR9XG5cbiAgXHRpZiAob3B0aW9ucy50ZW1wbGF0ZS5yeCkge1xuICBcdFx0bXVzdGFjaGUucmVzb2x2ZXIgPSBuZXcgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX1JlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcihtdXN0YWNoZSwgb3B0aW9ucy50ZW1wbGF0ZS5yeCwgcmVzb2x2ZUFuZFJlYmluZENoaWxkcmVuKTtcbiAgXHR9XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSBpbnZlcnRlZCBzZWN0aW9uc1xuICBcdGlmIChtdXN0YWNoZS50ZW1wbGF0ZS5uID09PSBTRUNUSU9OX1VOTEVTUyAmJiAhbXVzdGFjaGUuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSkge1xuICBcdFx0bXVzdGFjaGUuc2V0VmFsdWUodW5kZWZpbmVkKTtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiByZXNvbHZlKGtleXBhdGgpIHtcbiAgXHRcdG11c3RhY2hlLnJlc29sdmUoa2V5cGF0aCk7XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gcmVzb2x2ZUFuZFJlYmluZENoaWxkcmVuKG5ld0tleXBhdGgpIHtcbiAgXHRcdHZhciBvbGRLZXlwYXRoID0gbXVzdGFjaGUua2V5cGF0aDtcblxuICBcdFx0aWYgKG5ld0tleXBhdGggIT0gb2xkS2V5cGF0aCkge1xuICBcdFx0XHRtdXN0YWNoZS5yZXNvbHZlKG5ld0tleXBhdGgpO1xuXG4gIFx0XHRcdGlmIChvbGRLZXlwYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHRtdXN0YWNoZS5mcmFnbWVudHMgJiYgbXVzdGFjaGUuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgXHRcdFx0XHRcdGYucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0XHRcdH0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIE11c3RhY2hlX3Jlc29sdmUgPSBNdXN0YWNoZSRyZXNvbHZlO1xuXG4gIGZ1bmN0aW9uIE11c3RhY2hlJHJlc29sdmUoa2V5cGF0aCkge1xuICBcdHZhciB3YXNSZXNvbHZlZCwgdmFsdWUsIHR3b3dheUJpbmRpbmc7XG5cbiAgXHQvLyAnU3BlY2lhbCcga2V5cGF0aHMsIGUuZy4gQGZvbyBvciBANywgZW5jb2RlIGEgdmFsdWVcbiAgXHRpZiAoa2V5cGF0aCAmJiBrZXlwYXRoLmlzU3BlY2lhbCkge1xuICBcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcbiAgXHRcdHRoaXMuc2V0VmFsdWUoa2V5cGF0aC52YWx1ZSk7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0Ly8gSWYgd2UgcmVzb2x2ZWQgcHJldmlvdXNseSwgd2UgbmVlZCB0byB1bnJlZ2lzdGVyXG4gIFx0aWYgKHRoaXMucmVnaXN0ZXJlZCkge1xuICBcdFx0Ly8gdW5kZWZpbmVkIG9yIG51bGxcbiAgXHRcdHRoaXMucm9vdC52aWV3bW9kZWwudW5yZWdpc3Rlcih0aGlzLmtleXBhdGgsIHRoaXMpO1xuICBcdFx0dGhpcy5yZWdpc3RlcmVkID0gZmFsc2U7XG5cbiAgXHRcdHdhc1Jlc29sdmVkID0gdHJ1ZTtcbiAgXHR9XG5cbiAgXHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXG4gIFx0Ly8gSWYgdGhlIG5ldyBrZXlwYXRoIGV4aXN0cywgd2UgbmVlZCB0byByZWdpc3RlclxuICBcdC8vIHdpdGggdGhlIHZpZXdtb2RlbFxuICBcdGlmIChrZXlwYXRoICE9IHVuZGVmaW5lZCkge1xuICBcdFx0Ly8gdW5kZWZpbmVkIG9yIG51bGxcbiAgXHRcdHZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG4gIFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnJlZ2lzdGVyKGtleXBhdGgsIHRoaXMpO1xuXG4gIFx0XHR0aGlzLnJlZ2lzdGVyZWQgPSB0cnVlO1xuICBcdH1cblxuICBcdC8vIEVpdGhlciB3YXkgd2UgbmVlZCB0byBxdWV1ZSB1cCBhIHJlbmRlciAoYHZhbHVlYFxuICBcdC8vIHdpbGwgYmUgYHVuZGVmaW5lZGAgaWYgdGhlcmUncyBubyBrZXlwYXRoKVxuICBcdHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuXG4gIFx0Ly8gVHdvLXdheSBiaW5kaW5ncyBuZWVkIHRvIHBvaW50IHRvIHRoZWlyIG5ldyB0YXJnZXQga2V5cGF0aFxuICBcdGlmICh3YXNSZXNvbHZlZCAmJiAodHdvd2F5QmluZGluZyA9IHRoaXMudHdvd2F5QmluZGluZykpIHtcbiAgXHRcdHR3b3dheUJpbmRpbmcucmVib3VuZCgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBNdXN0YWNoZV9yZWJpbmQgPSBNdXN0YWNoZSRyZWJpbmQ7XG5cbiAgZnVuY3Rpb24gTXVzdGFjaGUkcmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHQvLyBDaGlsZHJlbiBmaXJzdFxuICBcdGlmICh0aGlzLmZyYWdtZW50cykge1xuICBcdFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICBcdFx0XHRyZXR1cm4gZi5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHQvLyBFeHByZXNzaW9uIG11c3RhY2hlP1xuICBcdGlmICh0aGlzLnJlc29sdmVyKSB7XG4gIFx0XHR0aGlzLnJlc29sdmVyLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgTXVzdGFjaGUgPSB7XG4gIFx0Z2V0VmFsdWU6IE11c3RhY2hlX2dldFZhbHVlLFxuICBcdGluaXQ6IE11c3RhY2hlX2luaXRpYWxpc2UsXG4gIFx0cmVzb2x2ZTogTXVzdGFjaGVfcmVzb2x2ZSxcbiAgXHRyZWJpbmQ6IE11c3RhY2hlX3JlYmluZFxuICB9O1xuXG4gIHZhciBJbnRlcnBvbGF0b3IgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHRoaXMudHlwZSA9IElOVEVSUE9MQVRPUjtcbiAgXHRNdXN0YWNoZS5pbml0KHRoaXMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIEludGVycG9sYXRvci5wcm90b3R5cGUgPSB7XG4gIFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLm5vZGUuZGF0YSA9IHRoaXMudmFsdWUgPT0gdW5kZWZpbmVkID8gXCJcIiA6IHRoaXMudmFsdWU7XG4gIFx0fSxcbiAgXHRyZXNvbHZlOiBNdXN0YWNoZS5yZXNvbHZlLFxuICBcdHJlYmluZDogTXVzdGFjaGUucmViaW5kLFxuICBcdGRldGFjaDogc2hhcmVkX2RldGFjaCxcblxuICBcdHVuYmluZDogc2hhcmVkX3VuYmluZCxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLm5vZGUpIHtcbiAgXHRcdFx0dGhpcy5ub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc2FmZVRvU3RyaW5nVmFsdWUodGhpcy52YWx1ZSkpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdGlmIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHRcdGRldGFjaE5vZGUodGhpcy5ub2RlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IE11c3RhY2hlLmdldFZhbHVlLFxuXG4gIFx0Ly8gVEVNUFxuICBcdHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdHZhciB3cmFwcGVyO1xuXG4gIFx0XHQvLyBUT0RPIGlzIHRoZXJlIGEgYmV0dGVyIHdheSB0byBhcHByb2FjaCB0aGlzP1xuICBcdFx0aWYgKHRoaXMua2V5cGF0aCAmJiAod3JhcHBlciA9IHRoaXMucm9vdC52aWV3bW9kZWwud3JhcHBlZFt0aGlzLmtleXBhdGguc3RyXSkpIHtcbiAgXHRcdFx0dmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIWlzRXF1YWwodmFsdWUsIHRoaXMudmFsdWUpKSB7XG4gIFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblxuICBcdFx0XHRpZiAodGhpcy5ub2RlKSB7XG4gIFx0XHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVmlldyh0aGlzKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRmaXJzdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLm5vZGU7XG4gIFx0fSxcblxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoZXNjYXBlKSB7XG4gIFx0XHR2YXIgc3RyaW5nID0gXCJcIiArIHNhZmVUb1N0cmluZ1ZhbHVlKHRoaXMudmFsdWUpO1xuICBcdFx0cmV0dXJuIGVzY2FwZSA/IGVzY2FwZUh0bWwoc3RyaW5nKSA6IHN0cmluZztcbiAgXHR9XG4gIH07XG5cbiAgdmFyIGl0ZW1zX0ludGVycG9sYXRvciA9IEludGVycG9sYXRvcjtcblxuICB2YXIgU2VjdGlvbl9wcm90b3R5cGVfYnViYmxlID0gU2VjdGlvbiRidWJibGU7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRidWJibGUoKSB7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcbiAgfVxuXG4gIHZhciBTZWN0aW9uX3Byb3RvdHlwZV9kZXRhY2ggPSBTZWN0aW9uJGRldGFjaDtcblxuICBmdW5jdGlvbiBTZWN0aW9uJGRldGFjaCgpIHtcbiAgXHR2YXIgZG9jRnJhZztcblxuICBcdGlmICh0aGlzLmZyYWdtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50c1swXS5kZXRhY2goKTtcbiAgXHR9XG5cbiAgXHRkb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gIFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0ZG9jRnJhZy5hcHBlbmRDaGlsZChpdGVtLmRldGFjaCgpKTtcbiAgXHR9KTtcblxuICBcdHJldHVybiBkb2NGcmFnO1xuICB9XG5cbiAgdmFyIGZpbmQgPSBTZWN0aW9uJGZpbmQ7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRmaW5kKHNlbGVjdG9yKSB7XG4gIFx0dmFyIGksIGxlbiwgcXVlcnlSZXN1bHQ7XG5cbiAgXHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRpZiAocXVlcnlSZXN1bHQgPSB0aGlzLmZyYWdtZW50c1tpXS5maW5kKHNlbGVjdG9yKSkge1xuICBcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZmluZEFsbCA9IFNlY3Rpb24kZmluZEFsbDtcblxuICBmdW5jdGlvbiBTZWN0aW9uJGZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0dmFyIGksIGxlbjtcblxuICBcdGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnRzW2ldLmZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9XG4gIH1cblxuICB2YXIgZmluZEFsbENvbXBvbmVudHMgPSBTZWN0aW9uJGZpbmRBbGxDb21wb25lbnRzO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0dmFyIGksIGxlbjtcblxuICBcdGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnRzW2ldLmZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGZpbmRDb21wb25lbnQgPSBTZWN0aW9uJGZpbmRDb21wb25lbnQ7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRmaW5kQ29tcG9uZW50KHNlbGVjdG9yKSB7XG4gIFx0dmFyIGksIGxlbiwgcXVlcnlSZXN1bHQ7XG5cbiAgXHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRpZiAocXVlcnlSZXN1bHQgPSB0aGlzLmZyYWdtZW50c1tpXS5maW5kQ29tcG9uZW50KHNlbGVjdG9yKSkge1xuICBcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZmluZE5leHROb2RlID0gU2VjdGlvbiRmaW5kTmV4dE5vZGU7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRmaW5kTmV4dE5vZGUoZnJhZ21lbnQpIHtcbiAgXHRpZiAodGhpcy5mcmFnbWVudHNbZnJhZ21lbnQuaW5kZXggKyAxXSkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnRzW2ZyYWdtZW50LmluZGV4ICsgMV0uZmlyc3ROb2RlKCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICB9XG5cbiAgdmFyIGZpcnN0Tm9kZSA9IFNlY3Rpb24kZmlyc3ROb2RlO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kZmlyc3ROb2RlKCkge1xuICBcdHZhciBsZW4sIGksIG5vZGU7XG5cbiAgXHRpZiAobGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0aWYgKG5vZGUgPSB0aGlzLmZyYWdtZW50c1tpXS5maXJzdE5vZGUoKSkge1xuICBcdFx0XHRcdHJldHVybiBub2RlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICB9XG5cbiAgdmFyIHNodWZmbGUgPSBTZWN0aW9uJHNodWZmbGU7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRzaHVmZmxlKG5ld0luZGljZXMpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIHBhcmVudEZyYWdtZW50LCBmaXJzdENoYW5nZSwgaSwgbmV3TGVuZ3RoLCByZWJvdW5kRnJhZ21lbnRzLCBmcmFnbWVudE9wdGlvbnMsIGZyYWdtZW50O1xuXG4gIFx0Ly8gc2hvcnQgY2lyY3VpdCBhbnkgZG91YmxlLXVwZGF0ZXMsIGFuZCBlbnN1cmUgdGhhdCB0aGlzIGlzbid0IGFwcGxpZWQgdG9cbiAgXHQvLyBub24tbGlzdCBzZWN0aW9uc1xuICBcdGlmICh0aGlzLnNodWZmbGluZyB8fCB0aGlzLnVuYm91bmQgfHwgdGhpcy5jdXJyZW50U3VidHlwZSAhPT0gU0VDVElPTl9FQUNIKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0dGhpcy5zaHVmZmxpbmcgPSB0cnVlO1xuICBcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gX3RoaXMuc2h1ZmZsaW5nID0gZmFsc2U7XG4gIFx0fSk7XG5cbiAgXHRwYXJlbnRGcmFnbWVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQ7XG5cbiAgXHRyZWJvdW5kRnJhZ21lbnRzID0gW107XG5cbiAgXHQvLyBUT0RPOiBuZWVkIHRvIHVwZGF0ZSB0aGlzXG4gIFx0Ly8gZmlyc3QsIHJlYmluZCBleGlzdGluZyBmcmFnbWVudHNcbiAgXHRuZXdJbmRpY2VzLmZvckVhY2goZnVuY3Rpb24gKG5ld0luZGV4LCBvbGRJbmRleCkge1xuICBcdFx0dmFyIGZyYWdtZW50LCBieSwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCwgZGVwcztcblxuICBcdFx0aWYgKG5ld0luZGV4ID09PSBvbGRJbmRleCkge1xuICBcdFx0XHRyZWJvdW5kRnJhZ21lbnRzW25ld0luZGV4XSA9IF90aGlzLmZyYWdtZW50c1tvbGRJbmRleF07XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0ZnJhZ21lbnQgPSBfdGhpcy5mcmFnbWVudHNbb2xkSW5kZXhdO1xuXG4gIFx0XHRpZiAoZmlyc3RDaGFuZ2UgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRmaXJzdENoYW5nZSA9IG9sZEluZGV4O1xuICBcdFx0fVxuXG4gIFx0XHQvLyBkb2VzIHRoaXMgZnJhZ21lbnQgbmVlZCB0byBiZSB0b3JuIGRvd24/XG4gIFx0XHRpZiAobmV3SW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdF90aGlzLmZyYWdtZW50c1RvVW5yZW5kZXIucHVzaChmcmFnbWVudCk7XG4gIFx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdC8vIE90aGVyd2lzZSwgaXQgbmVlZHMgdG8gYmUgcmVib3VuZCB0byBhIG5ldyBpbmRleFxuICBcdFx0YnkgPSBuZXdJbmRleCAtIG9sZEluZGV4O1xuICBcdFx0b2xkS2V5cGF0aCA9IF90aGlzLmtleXBhdGguam9pbihvbGRJbmRleCk7XG4gIFx0XHRuZXdLZXlwYXRoID0gX3RoaXMua2V5cGF0aC5qb2luKG5ld0luZGV4KTtcblxuICBcdFx0ZnJhZ21lbnQuaW5kZXggPSBuZXdJbmRleDtcblxuICBcdFx0Ly8gbm90aWZ5IGFueSByZWdpc3RlcmVkIGluZGV4IHJlZnMgZGlyZWN0bHlcbiAgXHRcdGlmIChkZXBzID0gZnJhZ21lbnQucmVnaXN0ZXJlZEluZGV4UmVmcykge1xuICBcdFx0XHRkZXBzLmZvckVhY2goc2h1ZmZsZV9fYmxpbmRSZWJpbmQpO1xuICBcdFx0fVxuXG4gIFx0XHRmcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHRyZWJvdW5kRnJhZ21lbnRzW25ld0luZGV4XSA9IGZyYWdtZW50O1xuICBcdH0pO1xuXG4gIFx0bmV3TGVuZ3RoID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQodGhpcy5rZXlwYXRoKS5sZW5ndGg7XG5cbiAgXHQvLyBJZiBub3RoaW5nIGNoYW5nZWQgd2l0aCB0aGUgZXhpc3RpbmcgZnJhZ21lbnRzLCB0aGVuIHdlIHN0YXJ0IGFkZGluZ1xuICBcdC8vIG5ldyBmcmFnbWVudHMgYXQgdGhlIGVuZC4uLlxuICBcdGlmIChmaXJzdENoYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHQvLyAuLi51bmxlc3MgdGhlcmUgYXJlIG5vIG5ldyBmcmFnbWVudHMgdG8gYWRkXG4gIFx0XHRpZiAodGhpcy5sZW5ndGggPT09IG5ld0xlbmd0aCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGZpcnN0Q2hhbmdlID0gdGhpcy5sZW5ndGg7XG4gIFx0fVxuXG4gIFx0dGhpcy5sZW5ndGggPSB0aGlzLmZyYWdtZW50cy5sZW5ndGggPSBuZXdMZW5ndGg7XG5cbiAgXHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVmlldyh0aGlzKTtcbiAgXHR9XG5cbiAgXHQvLyBQcmVwYXJlIG5ldyBmcmFnbWVudCBvcHRpb25zXG4gIFx0ZnJhZ21lbnRPcHRpb25zID0ge1xuICBcdFx0dGVtcGxhdGU6IHRoaXMudGVtcGxhdGUuZixcbiAgXHRcdHJvb3Q6IHRoaXMucm9vdCxcbiAgXHRcdG93bmVyOiB0aGlzXG4gIFx0fTtcblxuICBcdC8vIEFkZCBhcyBtYW55IG5ldyBmcmFnbWVudHMgYXMgd2UgbmVlZCB0bywgb3IgYWRkIGJhY2sgZXhpc3RpbmdcbiAgXHQvLyAoZGV0YWNoZWQpIGZyYWdtZW50c1xuICBcdGZvciAoaSA9IGZpcnN0Q2hhbmdlOyBpIDwgbmV3TGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdGZyYWdtZW50ID0gcmVib3VuZEZyYWdtZW50c1tpXTtcblxuICBcdFx0aWYgKCFmcmFnbWVudCkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLnB1c2goaSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZnJhZ21lbnRzW2ldID0gZnJhZ21lbnQ7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gc2h1ZmZsZV9fYmxpbmRSZWJpbmQoZGVwKSB7XG4gIFx0Ly8gdGhlIGtleXBhdGggZG9lc24ndCBhY3R1YWxseSBtYXR0ZXIgaGVyZSBhcyBpdCB3b24ndCBoYXZlIGNoYW5nZWRcbiAgXHRkZXAucmViaW5kKFwiXCIsIFwiXCIpO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9yZWJpbmQgPSBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdE11c3RhY2hlLnJlYmluZC5jYWxsKHRoaXMsIG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICB9O1xuXG4gIHZhciBTZWN0aW9uX3Byb3RvdHlwZV9yZW5kZXIgPSBTZWN0aW9uJHJlbmRlcjtcblxuICBmdW5jdGlvbiBTZWN0aW9uJHJlbmRlcigpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dGhpcy5kb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gIFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICBcdFx0cmV0dXJuIF90aGlzLmRvY0ZyYWcuYXBwZW5kQ2hpbGQoZi5yZW5kZXIoKSk7XG4gIFx0fSk7XG5cbiAgXHR0aGlzLnJlbmRlcmVkRnJhZ21lbnRzID0gdGhpcy5mcmFnbWVudHMuc2xpY2UoKTtcbiAgXHR0aGlzLmZyYWdtZW50c1RvUmVuZGVyID0gW107XG5cbiAgXHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgXHRyZXR1cm4gdGhpcy5kb2NGcmFnO1xuICB9XG5cbiAgdmFyIHNldFZhbHVlID0gU2VjdGlvbiRzZXRWYWx1ZTtcblxuICBmdW5jdGlvbiBTZWN0aW9uJHNldFZhbHVlKHZhbHVlKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciB3cmFwcGVyLCBmcmFnbWVudE9wdGlvbnM7XG5cbiAgXHRpZiAodGhpcy51cGRhdGluZykge1xuICBcdFx0Ly8gSWYgYSBjaGlsZCBvZiB0aGlzIHNlY3Rpb24gY2F1c2VzIGEgcmUtZXZhbHVhdGlvbiAtIGZvciBleGFtcGxlLCBhblxuICBcdFx0Ly8gZXhwcmVzc2lvbiByZWZlcnMgdG8gYSBmdW5jdGlvbiB0aGF0IG11dGF0ZXMgdGhlIGFycmF5IHRoYXQgdGhpc1xuICBcdFx0Ly8gc2VjdGlvbiBkZXBlbmRzIG9uIC0gd2UnbGwgZW5kIHVwIHdpdGggYSBkb3VibGUgcmVuZGVyaW5nIGJ1ZyAoc2VlXG4gIFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzLzc0OCkuIFRoaXMgcHJldmVudHMgaXQuXG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cbiAgXHQvLyB3aXRoIHNlY3Rpb25zLCB3ZSBuZWVkIHRvIGdldCB0aGUgZmFrZSB2YWx1ZSBpZiB3ZSBoYXZlIGEgd3JhcHBlZCBvYmplY3RcbiAgXHRpZiAodGhpcy5rZXlwYXRoICYmICh3cmFwcGVyID0gdGhpcy5yb290LnZpZXdtb2RlbC53cmFwcGVkW3RoaXMua2V5cGF0aC5zdHJdKSkge1xuICBcdFx0dmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuICBcdH1cblxuICBcdC8vIElmIGFueSBmcmFnbWVudHMgYXJlIGF3YWl0aW5nIGNyZWF0aW9uIGFmdGVyIGEgc3BsaWNlLFxuICBcdC8vIHRoaXMgaXMgdGhlIHBsYWNlIHRvIGRvIGl0XG4gIFx0aWYgKHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUubGVuZ3RoKSB7XG4gIFx0XHRmcmFnbWVudE9wdGlvbnMgPSB7XG4gIFx0XHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLmYgfHwgW10sXG4gIFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcbiAgXHRcdFx0cEVsZW1lbnQ6IHRoaXMucEVsZW1lbnQsXG4gIFx0XHRcdG93bmVyOiB0aGlzXG4gIFx0XHR9O1xuXG4gIFx0XHR0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gIFx0XHRcdHZhciBmcmFnbWVudDtcblxuICBcdFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IF90aGlzLmtleXBhdGguam9pbihpbmRleCk7XG4gIFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IGluZGV4O1xuXG4gIFx0XHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoZnJhZ21lbnRPcHRpb25zKTtcbiAgXHRcdFx0X3RoaXMuZnJhZ21lbnRzVG9SZW5kZXIucHVzaChfdGhpcy5mcmFnbWVudHNbaW5kZXhdID0gZnJhZ21lbnQpO1xuICBcdFx0fSk7XG5cbiAgXHRcdHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUubGVuZ3RoID0gMDtcbiAgXHR9IGVsc2UgaWYgKHJlZXZhbHVhdGVTZWN0aW9uKHRoaXMsIHZhbHVlKSkge1xuICBcdFx0dGhpcy5idWJibGUoKTtcblxuICBcdFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVmlldyh0aGlzKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHR0aGlzLnZhbHVlID0gdmFsdWU7XG4gIFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hhbmdlQ3VycmVudFN1YnR5cGUoc2VjdGlvbiwgdmFsdWUsIG9iaikge1xuICBcdGlmICh2YWx1ZSA9PT0gU0VDVElPTl9FQUNIKSB7XG4gIFx0XHQvLyBtYWtlIHN1cmUgcmVmIHR5cGUgaXMgdXAgdG8gZGF0ZSBmb3Iga2V5IG9yIHZhbHVlIGluZGljZXNcbiAgXHRcdGlmIChzZWN0aW9uLmluZGV4UmVmcyAmJiBzZWN0aW9uLmluZGV4UmVmc1swXSkge1xuICBcdFx0XHR2YXIgcmVmID0gc2VjdGlvbi5pbmRleFJlZnNbMF07XG5cbiAgXHRcdFx0Ly8gd2hlbiBzd2l0Y2hpbmcgZmxhdm9ycywgbWFrZSBzdXJlIHRoZSBzZWN0aW9uIGdldHMgdXBkYXRlZFxuICBcdFx0XHRpZiAob2JqICYmIHJlZi50ID09PSBcImlcIiB8fCAhb2JqICYmIHJlZi50ID09PSBcImtcIikge1xuICBcdFx0XHRcdC8vIGlmIHN3aXRjaGluZyBmcm9tIG9iamVjdCB0byBsaXN0LCB1bmJpbmQgYWxsIG9mIHRoZSBvbGQgZnJhZ21lbnRzXG4gIFx0XHRcdFx0aWYgKCFvYmopIHtcbiAgXHRcdFx0XHRcdHNlY3Rpb24ubGVuZ3RoID0gMDtcbiAgXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlciA9IHNlY3Rpb24uZnJhZ21lbnRzLnNsaWNlKDApO1xuICBcdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgXHRcdFx0XHRcdFx0cmV0dXJuIGYudW5iaW5kKCk7XG4gIFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZWYudCA9IG9iaiA/IFwia1wiIDogXCJpXCI7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0c2VjdGlvbi5jdXJyZW50U3VidHlwZSA9IHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVldmFsdWF0ZVNlY3Rpb24oc2VjdGlvbiwgdmFsdWUpIHtcbiAgXHR2YXIgZnJhZ21lbnRPcHRpb25zID0ge1xuICBcdFx0dGVtcGxhdGU6IHNlY3Rpb24udGVtcGxhdGUuZiB8fCBbXSxcbiAgXHRcdHJvb3Q6IHNlY3Rpb24ucm9vdCxcbiAgXHRcdHBFbGVtZW50OiBzZWN0aW9uLnBhcmVudEZyYWdtZW50LnBFbGVtZW50LFxuICBcdFx0b3duZXI6IHNlY3Rpb25cbiAgXHR9O1xuXG4gIFx0c2VjdGlvbi5oYXNDb250ZXh0ID0gdHJ1ZTtcblxuICBcdC8vIElmIHdlIGFscmVhZHkga25vdyB0aGUgc2VjdGlvbiB0eXBlLCBncmVhdFxuICBcdC8vIFRPRE8gY2FuIHRoaXMgYmUgb3B0aW1pc2VkPyBpLmUuIHBpY2sgYW4gcmVldmFsdWF0ZVNlY3Rpb24gZnVuY3Rpb24gZHVyaW5nIGluaXRcbiAgXHQvLyBhbmQgYXZvaWQgZG9pbmcgdGhpcyBlYWNoIHRpbWU/XG4gIFx0aWYgKHNlY3Rpb24uc3VidHlwZSkge1xuICBcdFx0c3dpdGNoIChzZWN0aW9uLnN1YnR5cGUpIHtcbiAgXHRcdFx0Y2FzZSBTRUNUSU9OX0lGOlxuICBcdFx0XHRcdHNlY3Rpb24uaGFzQ29udGV4dCA9IGZhbHNlO1xuICBcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29uZGl0aW9uYWxTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmYWxzZSwgZnJhZ21lbnRPcHRpb25zKTtcblxuICBcdFx0XHRjYXNlIFNFQ1RJT05fVU5MRVNTOlxuICBcdFx0XHRcdHNlY3Rpb24uaGFzQ29udGV4dCA9IGZhbHNlO1xuICBcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29uZGl0aW9uYWxTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCB0cnVlLCBmcmFnbWVudE9wdGlvbnMpO1xuXG4gIFx0XHRcdGNhc2UgU0VDVElPTl9XSVRIOlxuICBcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29udGV4dFNlY3Rpb24oc2VjdGlvbiwgZnJhZ21lbnRPcHRpb25zKTtcblxuICBcdFx0XHRjYXNlIFNFQ1RJT05fSUZfV0lUSDpcbiAgXHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbmRpdGlvbmFsQ29udGV4dFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyk7XG5cbiAgXHRcdFx0Y2FzZSBTRUNUSU9OX0VBQ0g6XG4gIFx0XHRcdFx0aWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICBcdFx0XHRcdFx0Y2hhbmdlQ3VycmVudFN1YnR5cGUoc2VjdGlvbiwgc2VjdGlvbi5zdWJ0eXBlLCB0cnVlKTtcbiAgXHRcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlTGlzdE9iamVjdFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0Ly8gRmFsbHRocm91Z2ggLSBpZiBpdCdzIGEgY29uZGl0aW9uYWwgb3IgYW4gYXJyYXkgd2UgbmVlZCB0byBjb250aW51ZVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIHRvIHdvcmsgb3V0IHdoYXQgc29ydCBvZiBzZWN0aW9uIHdlJ3JlIGRlYWxpbmcgd2l0aFxuICBcdHNlY3Rpb24ub3JkZXJlZCA9ICEhaXNBcnJheUxpa2UodmFsdWUpO1xuXG4gIFx0Ly8gT3JkZXJlZCBsaXN0IHNlY3Rpb25cbiAgXHRpZiAoc2VjdGlvbi5vcmRlcmVkKSB7XG4gIFx0XHRjaGFuZ2VDdXJyZW50U3VidHlwZShzZWN0aW9uLCBTRUNUSU9OX0VBQ0gsIGZhbHNlKTtcbiAgXHRcdHJldHVybiByZWV2YWx1YXRlTGlzdFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyk7XG4gIFx0fVxuXG4gIFx0Ly8gVW5vcmRlcmVkIGxpc3QsIG9yIGNvbnRleHRcbiAgXHRpZiAoaXNPYmplY3QodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHQvLyBJbmRleCByZWZlcmVuY2UgaW5kaWNhdGVzIHNlY3Rpb24gc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSBsaXN0XG4gIFx0XHRpZiAoc2VjdGlvbi50ZW1wbGF0ZS5pKSB7XG4gIFx0XHRcdGNoYW5nZUN1cnJlbnRTdWJ0eXBlKHNlY3Rpb24sIFNFQ1RJT05fRUFDSCwgdHJ1ZSk7XG4gIFx0XHRcdHJldHVybiByZWV2YWx1YXRlTGlzdE9iamVjdFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIE90aGVyd2lzZSwgb2JqZWN0IHByb3ZpZGVzIGNvbnRleHQgZm9yIGNvbnRlbnRzXG4gIFx0XHRjaGFuZ2VDdXJyZW50U3VidHlwZShzZWN0aW9uLCBTRUNUSU9OX1dJVEgsIGZhbHNlKTtcbiAgXHRcdHJldHVybiByZWV2YWx1YXRlQ29udGV4dFNlY3Rpb24oc2VjdGlvbiwgZnJhZ21lbnRPcHRpb25zKTtcbiAgXHR9XG5cbiAgXHQvLyBDb25kaXRpb25hbCBzZWN0aW9uXG4gIFx0Y2hhbmdlQ3VycmVudFN1YnR5cGUoc2VjdGlvbiwgU0VDVElPTl9JRiwgZmFsc2UpO1xuICBcdHNlY3Rpb24uaGFzQ29udGV4dCA9IGZhbHNlO1xuICBcdHJldHVybiByZWV2YWx1YXRlQ29uZGl0aW9uYWxTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmYWxzZSwgZnJhZ21lbnRPcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZXZhbHVhdGVMaXN0U2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zKSB7XG4gIFx0dmFyIGksIGxlbmd0aCwgZnJhZ21lbnQ7XG5cbiAgXHRsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cbiAgXHRpZiAobGVuZ3RoID09PSBzZWN0aW9uLmxlbmd0aCkge1xuICBcdFx0Ly8gTm90aGluZyB0byBkb1xuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH1cblxuICBcdC8vIGlmIHRoZSBhcnJheSBpcyBzaG9ydGVyIHRoYW4gaXQgd2FzIHByZXZpb3VzbHksIHJlbW92ZSBpdGVtc1xuICBcdGlmIChsZW5ndGggPCBzZWN0aW9uLmxlbmd0aCkge1xuICBcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyID0gc2VjdGlvbi5mcmFnbWVudHMuc3BsaWNlKGxlbmd0aCwgc2VjdGlvbi5sZW5ndGggLSBsZW5ndGgpO1xuICBcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5iaW5kKTtcbiAgXHR9XG5cbiAgXHQvLyBvdGhlcndpc2UuLi5cbiAgXHRlbHNlIHtcbiAgXHRcdGlmIChsZW5ndGggPiBzZWN0aW9uLmxlbmd0aCkge1xuICBcdFx0XHQvLyBhZGQgYW55IG5ldyBvbmVzXG4gIFx0XHRcdGZvciAoaSA9IHNlY3Rpb24ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdFx0XHQvLyBhcHBlbmQgbGlzdCBpdGVtIHRvIGNvbnRleHQgc3RhY2tcbiAgXHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IHNlY3Rpb24ua2V5cGF0aC5qb2luKGkpO1xuICBcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IGk7XG5cbiAgXHRcdFx0XHRmcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KGZyYWdtZW50T3B0aW9ucyk7XG4gIFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5wdXNoKHNlY3Rpb24uZnJhZ21lbnRzW2ldID0gZnJhZ21lbnQpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0c2VjdGlvbi5sZW5ndGggPSBsZW5ndGg7XG4gIFx0cmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiByZWV2YWx1YXRlTGlzdE9iamVjdFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucykge1xuICBcdHZhciBpZCwgaSwgaGFzS2V5LCBmcmFnbWVudCwgY2hhbmdlZCwgZGVwcztcblxuICBcdGhhc0tleSA9IHNlY3Rpb24uaGFzS2V5IHx8IChzZWN0aW9uLmhhc0tleSA9IHt9KTtcblxuICBcdC8vIHJlbW92ZSBhbnkgZnJhZ21lbnRzIHRoYXQgc2hvdWxkIG5vIGxvbmdlciBleGlzdFxuICBcdGkgPSBzZWN0aW9uLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0ZnJhZ21lbnQgPSBzZWN0aW9uLmZyYWdtZW50c1tpXTtcblxuICBcdFx0aWYgKCEoZnJhZ21lbnQua2V5IGluIHZhbHVlKSkge1xuICBcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblxuICBcdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcbiAgXHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyLnB1c2goZnJhZ21lbnQpO1xuICBcdFx0XHRzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoaSwgMSk7XG5cbiAgXHRcdFx0aGFzS2V5W2ZyYWdtZW50LmtleV0gPSBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBub3RpZnkgYW55IGRlcGVuZGVudHMgYWJvdXQgY2hhbmdlZCBpbmRpY2VzXG4gIFx0aSA9IHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRmcmFnbWVudCA9IHNlY3Rpb24uZnJhZ21lbnRzW2ldO1xuXG4gIFx0XHRpZiAoZnJhZ21lbnQuaW5kZXggIT09IGkpIHtcbiAgXHRcdFx0ZnJhZ21lbnQuaW5kZXggPSBpO1xuICBcdFx0XHRpZiAoZGVwcyA9IGZyYWdtZW50LnJlZ2lzdGVyZWRJbmRleFJlZnMpIHtcbiAgXHRcdFx0XHRkZXBzLmZvckVhY2goc2V0VmFsdWVfX2JsaW5kUmViaW5kKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIGFkZCBhbnkgdGhhdCBoYXZlbid0IGJlZW4gY3JlYXRlZCB5ZXRcbiAgXHRpID0gc2VjdGlvbi5mcmFnbWVudHMubGVuZ3RoO1xuICBcdGZvciAoaWQgaW4gdmFsdWUpIHtcbiAgXHRcdGlmICghaGFzS2V5W2lkXSkge1xuICBcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblxuICBcdFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IHNlY3Rpb24ua2V5cGF0aC5qb2luKGlkKTtcbiAgXHRcdFx0ZnJhZ21lbnRPcHRpb25zLmtleSA9IGlkO1xuICBcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSBpKys7XG5cbiAgXHRcdFx0ZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudChmcmFnbWVudE9wdGlvbnMpO1xuXG4gIFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9SZW5kZXIucHVzaChmcmFnbWVudCk7XG4gIFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzLnB1c2goZnJhZ21lbnQpO1xuICBcdFx0XHRoYXNLZXlbaWRdID0gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRzZWN0aW9uLmxlbmd0aCA9IHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHRyZXR1cm4gY2hhbmdlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZXZhbHVhdGVDb25kaXRpb25hbENvbnRleHRTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMpIHtcbiAgXHRpZiAodmFsdWUpIHtcbiAgXHRcdHJldHVybiByZWV2YWx1YXRlQ29udGV4dFNlY3Rpb24oc2VjdGlvbiwgZnJhZ21lbnRPcHRpb25zKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cmV0dXJuIHJlbW92ZVNlY3Rpb25GcmFnbWVudHMoc2VjdGlvbik7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVldmFsdWF0ZUNvbnRleHRTZWN0aW9uKHNlY3Rpb24sIGZyYWdtZW50T3B0aW9ucykge1xuICBcdHZhciBmcmFnbWVudDtcblxuICBcdC8vIC4uLnRoZW4gaWYgaXQgaXNuJ3QgcmVuZGVyZWQsIHJlbmRlciBpdCwgYWRkaW5nIHNlY3Rpb24ua2V5cGF0aCB0byB0aGUgY29udGV4dCBzdGFja1xuICBcdC8vIChpZiBpdCBpcyBhbHJlYWR5IHJlbmRlcmVkLCB0aGVuIGFueSBjaGlsZHJlbiBkZXBlbmRlbnQgb24gdGhlIGNvbnRleHQgc3RhY2tcbiAgXHQvLyB3aWxsIHVwZGF0ZSB0aGVtc2VsdmVzIHdpdGhvdXQgYW55IHByb21wdGluZylcbiAgXHRpZiAoIXNlY3Rpb24ubGVuZ3RoKSB7XG4gIFx0XHQvLyBhcHBlbmQgdGhpcyBzZWN0aW9uIHRvIHRoZSBjb250ZXh0IHN0YWNrXG4gIFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IHNlY3Rpb24ua2V5cGF0aDtcbiAgXHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IDA7XG5cbiAgXHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoZnJhZ21lbnRPcHRpb25zKTtcblxuICBcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5wdXNoKHNlY3Rpb24uZnJhZ21lbnRzWzBdID0gZnJhZ21lbnQpO1xuICBcdFx0c2VjdGlvbi5sZW5ndGggPSAxO1xuXG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiByZWV2YWx1YXRlQ29uZGl0aW9uYWxTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBpbnZlcnRlZCwgZnJhZ21lbnRPcHRpb25zKSB7XG4gIFx0dmFyIGRvUmVuZGVyLCBlbXB0eUFycmF5LCBlbXB0eU9iamVjdCwgZnJhZ21lbnQsIG5hbWU7XG5cbiAgXHRlbXB0eUFycmF5ID0gaXNBcnJheUxpa2UodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgXHRlbXB0eU9iamVjdCA9IGZhbHNlO1xuICBcdGlmICghaXNBcnJheUxpa2UodmFsdWUpICYmIGlzT2JqZWN0KHZhbHVlKSkge1xuICBcdFx0ZW1wdHlPYmplY3QgPSB0cnVlO1xuICBcdFx0Zm9yIChuYW1lIGluIHZhbHVlKSB7XG4gIFx0XHRcdGVtcHR5T2JqZWN0ID0gZmFsc2U7XG4gIFx0XHRcdGJyZWFrO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChpbnZlcnRlZCkge1xuICBcdFx0ZG9SZW5kZXIgPSBlbXB0eUFycmF5IHx8IGVtcHR5T2JqZWN0IHx8ICF2YWx1ZTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0ZG9SZW5kZXIgPSB2YWx1ZSAmJiAhZW1wdHlBcnJheSAmJiAhZW1wdHlPYmplY3Q7XG4gIFx0fVxuXG4gIFx0aWYgKGRvUmVuZGVyKSB7XG4gIFx0XHRpZiAoIXNlY3Rpb24ubGVuZ3RoKSB7XG4gIFx0XHRcdC8vIG5vIGNoYW5nZSB0byBjb250ZXh0IHN0YWNrXG4gIFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IDA7XG5cbiAgXHRcdFx0ZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudChmcmFnbWVudE9wdGlvbnMpO1xuICBcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goc2VjdGlvbi5mcmFnbWVudHNbMF0gPSBmcmFnbWVudCk7XG4gIFx0XHRcdHNlY3Rpb24ubGVuZ3RoID0gMTtcblxuICBcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHNlY3Rpb24ubGVuZ3RoID4gMSkge1xuICBcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoMSk7XG4gIFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG5cbiAgXHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJldHVybiByZW1vdmVTZWN0aW9uRnJhZ21lbnRzKHNlY3Rpb24pO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVNlY3Rpb25GcmFnbWVudHMoc2VjdGlvbikge1xuICBcdGlmIChzZWN0aW9uLmxlbmd0aCkge1xuICBcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyID0gc2VjdGlvbi5mcmFnbWVudHMuc3BsaWNlKDAsIHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aCkuZmlsdGVyKGlzUmVuZGVyZWQpO1xuICBcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5iaW5kKTtcbiAgXHRcdHNlY3Rpb24ubGVuZ3RoID0gc2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5sZW5ndGggPSAwO1xuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gaXNSZW5kZXJlZChmcmFnbWVudCkge1xuICBcdHJldHVybiBmcmFnbWVudC5yZW5kZXJlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFZhbHVlX19ibGluZFJlYmluZChkZXApIHtcbiAgXHQvLyB0aGUga2V5cGF0aCBkb2Vzbid0IGFjdHVhbGx5IG1hdHRlciBoZXJlIGFzIGl0IHdvbid0IGhhdmUgY2hhbmdlZFxuICBcdGRlcC5yZWJpbmQoXCJcIiwgXCJcIik7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3RvU3RyaW5nID0gU2VjdGlvbiR0b1N0cmluZztcblxuICBmdW5jdGlvbiBTZWN0aW9uJHRvU3RyaW5nKGVzY2FwZSkge1xuICBcdHZhciBzdHIsIGksIGxlbjtcblxuICBcdHN0ciA9IFwiXCI7XG5cbiAgXHRpID0gMDtcbiAgXHRsZW4gPSB0aGlzLmxlbmd0aDtcblxuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0c3RyICs9IHRoaXMuZnJhZ21lbnRzW2ldLnRvU3RyaW5nKGVzY2FwZSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfdW5iaW5kID0gU2VjdGlvbiR1bmJpbmQ7XG4gIGZ1bmN0aW9uIFNlY3Rpb24kdW5iaW5kKCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR0aGlzLmZyYWdtZW50cy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIFx0dGhpcy5mcmFnbWVudHNUb1JlbmRlci5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gIFx0XHRyZXR1cm4gcmVtb3ZlRnJvbUFycmF5KF90aGlzLmZyYWdtZW50cywgZik7XG4gIFx0fSk7XG4gIFx0dGhpcy5mcmFnbWVudHNUb1JlbmRlciA9IFtdO1xuICBcdHNoYXJlZF91bmJpbmQuY2FsbCh0aGlzKTtcblxuICBcdHRoaXMubGVuZ3RoID0gMDtcbiAgXHR0aGlzLnVuYm91bmQgPSB0cnVlO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV91bnJlbmRlciA9IFNlY3Rpb24kdW5yZW5kZXI7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiR1bnJlbmRlcihzaG91bGREZXN0cm95KSB7XG4gIFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaChzaG91bGREZXN0cm95ID8gdW5yZW5kZXJBbmREZXN0cm95IDogcHJvdG90eXBlX3VucmVuZGVyX191bnJlbmRlcik7XG4gIFx0dGhpcy5yZW5kZXJlZEZyYWdtZW50cyA9IFtdO1xuICBcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVucmVuZGVyQW5kRGVzdHJveShmcmFnbWVudCkge1xuICBcdGZyYWdtZW50LnVucmVuZGVyKHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvdG90eXBlX3VucmVuZGVyX191bnJlbmRlcihmcmFnbWVudCkge1xuICBcdGZyYWdtZW50LnVucmVuZGVyKGZhbHNlKTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfdXBkYXRlID0gU2VjdGlvbiR1cGRhdGU7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiR1cGRhdGUoKSB7XG4gIFx0dmFyIGZyYWdtZW50LCByZW5kZXJJbmRleCwgcmVuZGVyZWRGcmFnbWVudHMsIGFuY2hvciwgdGFyZ2V0LCBpLCBsZW47XG5cbiAgXHQvLyBgdGhpcy5yZW5kZXJlZEZyYWdtZW50c2AgaXMgaW4gdGhlIG9yZGVyIG9mIHRoZSBwcmV2aW91cyByZW5kZXIuXG4gIFx0Ly8gSWYgZnJhZ21lbnRzIGhhdmUgc2h1ZmZsZWQgYWJvdXQsIHRoaXMgYWxsb3dzIHVzIHRvIHF1aWNrbHlcbiAgXHQvLyByZWluc2VydCB0aGVtIGluIHRoZSBjb3JyZWN0IHBsYWNlXG4gIFx0cmVuZGVyZWRGcmFnbWVudHMgPSB0aGlzLnJlbmRlcmVkRnJhZ21lbnRzO1xuXG4gIFx0Ly8gUmVtb3ZlIGZyYWdtZW50cyB0aGF0IGhhdmUgYmVlbiBtYXJrZWQgZm9yIGRlc3RydWN0aW9uXG4gIFx0d2hpbGUgKGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudHNUb1VucmVuZGVyLnBvcCgpKSB7XG4gIFx0XHRmcmFnbWVudC51bnJlbmRlcih0cnVlKTtcbiAgXHRcdHJlbmRlcmVkRnJhZ21lbnRzLnNwbGljZShyZW5kZXJlZEZyYWdtZW50cy5pbmRleE9mKGZyYWdtZW50KSwgMSk7XG4gIFx0fVxuXG4gIFx0Ly8gUmVuZGVyIG5ldyBmcmFnbWVudHMgKGJ1dCBkb24ndCBpbnNlcnQgdGhlbSB5ZXQpXG4gIFx0d2hpbGUgKGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudHNUb1JlbmRlci5zaGlmdCgpKSB7XG4gIFx0XHRmcmFnbWVudC5yZW5kZXIoKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0dGFyZ2V0ID0gdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCk7XG4gIFx0fVxuXG4gIFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0ZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50c1tpXTtcbiAgXHRcdHJlbmRlckluZGV4ID0gcmVuZGVyZWRGcmFnbWVudHMuaW5kZXhPZihmcmFnbWVudCwgaSk7IC8vIHNlYXJjaCBmcm9tIGN1cnJlbnQgaW5kZXggLSBpdCdzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIHNhbWUgb3IgaGlnaGVyXG5cbiAgXHRcdGlmIChyZW5kZXJJbmRleCA9PT0gaSkge1xuICBcdFx0XHQvLyBhbHJlYWR5IGluIHRoZSByaWdodCBwbGFjZS4gaW5zZXJ0IGFjY3VtdWxhdGVkIG5vZGVzIChpZiBhbnkpIGFuZCBjYXJyeSBvblxuICBcdFx0XHRpZiAodGhpcy5kb2NGcmFnLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0YW5jaG9yID0gZnJhZ21lbnQuZmlyc3ROb2RlKCk7XG4gIFx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSh0aGlzLmRvY0ZyYWcsIGFuY2hvcik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjb250aW51ZTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5kb2NGcmFnLmFwcGVuZENoaWxkKGZyYWdtZW50LmRldGFjaCgpKTtcblxuICBcdFx0Ly8gdXBkYXRlIHJlbmRlcmVkRnJhZ21lbnRzXG4gIFx0XHRpZiAocmVuZGVySW5kZXggIT09IC0xKSB7XG4gIFx0XHRcdHJlbmRlcmVkRnJhZ21lbnRzLnNwbGljZShyZW5kZXJJbmRleCwgMSk7XG4gIFx0XHR9XG4gIFx0XHRyZW5kZXJlZEZyYWdtZW50cy5zcGxpY2UoaSwgMCwgZnJhZ21lbnQpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLnJlbmRlcmVkICYmIHRoaXMuZG9jRnJhZy5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICBcdFx0YW5jaG9yID0gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUodGhpcyk7XG4gIFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHRoaXMuZG9jRnJhZywgYW5jaG9yKTtcbiAgXHR9XG5cbiAgXHQvLyBTYXZlIHRoZSByZW5kZXJpbmcgb3JkZXIgZm9yIG5leHQgdGltZVxuICBcdHRoaXMucmVuZGVyZWRGcmFnbWVudHMgPSB0aGlzLmZyYWdtZW50cy5zbGljZSgpO1xuICB9XG5cbiAgdmFyIFNlY3Rpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHRoaXMudHlwZSA9IFNFQ1RJT047XG4gIFx0dGhpcy5zdWJ0eXBlID0gdGhpcy5jdXJyZW50U3VidHlwZSA9IG9wdGlvbnMudGVtcGxhdGUubjtcbiAgXHR0aGlzLmludmVydGVkID0gdGhpcy5zdWJ0eXBlID09PSBTRUNUSU9OX1VOTEVTUztcblxuICBcdHRoaXMucEVsZW1lbnQgPSBvcHRpb25zLnBFbGVtZW50O1xuXG4gIFx0dGhpcy5mcmFnbWVudHMgPSBbXTtcbiAgXHR0aGlzLmZyYWdtZW50c1RvQ3JlYXRlID0gW107XG4gIFx0dGhpcy5mcmFnbWVudHNUb1JlbmRlciA9IFtdO1xuICBcdHRoaXMuZnJhZ21lbnRzVG9VbnJlbmRlciA9IFtdO1xuXG4gIFx0aWYgKG9wdGlvbnMudGVtcGxhdGUuaSkge1xuICBcdFx0dGhpcy5pbmRleFJlZnMgPSBvcHRpb25zLnRlbXBsYXRlLmkuc3BsaXQoXCIsXCIpLm1hcChmdW5jdGlvbiAoaywgaSkge1xuICBcdFx0XHRyZXR1cm4geyBuOiBrLCB0OiBpID09PSAwID8gXCJrXCIgOiBcImlcIiB9O1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0dGhpcy5yZW5kZXJlZEZyYWdtZW50cyA9IFtdO1xuXG4gIFx0dGhpcy5sZW5ndGggPSAwOyAvLyBudW1iZXIgb2YgdGltZXMgdGhpcyBzZWN0aW9uIGlzIHJlbmRlcmVkXG5cbiAgXHRNdXN0YWNoZS5pbml0KHRoaXMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIFNlY3Rpb24ucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogU2VjdGlvbl9wcm90b3R5cGVfYnViYmxlLFxuICBcdGRldGFjaDogU2VjdGlvbl9wcm90b3R5cGVfZGV0YWNoLFxuICBcdGZpbmQ6IGZpbmQsXG4gIFx0ZmluZEFsbDogZmluZEFsbCxcbiAgXHRmaW5kQWxsQ29tcG9uZW50czogZmluZEFsbENvbXBvbmVudHMsXG4gIFx0ZmluZENvbXBvbmVudDogZmluZENvbXBvbmVudCxcbiAgXHRmaW5kTmV4dE5vZGU6IGZpbmROZXh0Tm9kZSxcbiAgXHRmaXJzdE5vZGU6IGZpcnN0Tm9kZSxcbiAgXHRnZXRJbmRleFJlZjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgXHRcdGlmICh0aGlzLmluZGV4UmVmcykge1xuICBcdFx0XHR2YXIgaSA9IHRoaXMuaW5kZXhSZWZzLmxlbmd0aDtcbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdHZhciByZWYgPSB0aGlzLmluZGV4UmVmc1tpXTtcbiAgXHRcdFx0XHRpZiAocmVmLm4gPT09IG5hbWUpIHtcbiAgXHRcdFx0XHRcdHJldHVybiByZWY7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcbiAgXHRnZXRWYWx1ZTogTXVzdGFjaGUuZ2V0VmFsdWUsXG4gIFx0c2h1ZmZsZTogc2h1ZmZsZSxcbiAgXHRyZWJpbmQ6IHByb3RvdHlwZV9yZWJpbmQsXG4gIFx0cmVuZGVyOiBTZWN0aW9uX3Byb3RvdHlwZV9yZW5kZXIsXG4gIFx0cmVzb2x2ZTogTXVzdGFjaGUucmVzb2x2ZSxcbiAgXHRzZXRWYWx1ZTogc2V0VmFsdWUsXG4gIFx0dG9TdHJpbmc6IHByb3RvdHlwZV90b1N0cmluZyxcbiAgXHR1bmJpbmQ6IHByb3RvdHlwZV91bmJpbmQsXG4gIFx0dW5yZW5kZXI6IHByb3RvdHlwZV91bnJlbmRlcixcbiAgXHR1cGRhdGU6IHByb3RvdHlwZV91cGRhdGVcbiAgfTtcblxuICB2YXIgX1NlY3Rpb24gPSBTZWN0aW9uO1xuXG4gIHZhciBUcmlwbGVfcHJvdG90eXBlX2RldGFjaCA9IFRyaXBsZSRkZXRhY2g7XG5cbiAgZnVuY3Rpb24gVHJpcGxlJGRldGFjaCgpIHtcbiAgXHR2YXIgbGVuLCBpO1xuXG4gIFx0aWYgKHRoaXMuZG9jRnJhZykge1xuICBcdFx0bGVuID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0dGhpcy5kb2NGcmFnLmFwcGVuZENoaWxkKHRoaXMubm9kZXNbaV0pO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdGhpcy5kb2NGcmFnO1xuICBcdH1cbiAgfVxuXG4gIHZhciBUcmlwbGVfcHJvdG90eXBlX2ZpbmQgPSBUcmlwbGUkZmluZDtcbiAgZnVuY3Rpb24gVHJpcGxlJGZpbmQoc2VsZWN0b3IpIHtcbiAgXHR2YXIgaSwgbGVuLCBub2RlLCBxdWVyeVJlc3VsdDtcblxuICBcdGxlbiA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0bm9kZSA9IHRoaXMubm9kZXNbaV07XG5cbiAgXHRcdGlmIChub2RlLm5vZGVUeXBlICE9PSAxKSB7XG4gIFx0XHRcdGNvbnRpbnVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAobWF0Y2hlcyhub2RlLCBzZWxlY3RvcikpIHtcbiAgXHRcdFx0cmV0dXJuIG5vZGU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChxdWVyeVJlc3VsdCA9IG5vZGUucXVlcnlTZWxlY3RvcihzZWxlY3RvcikpIHtcbiAgXHRcdFx0cmV0dXJuIHF1ZXJ5UmVzdWx0O1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIFRyaXBsZV9wcm90b3R5cGVfZmluZEFsbCA9IFRyaXBsZSRmaW5kQWxsO1xuICBmdW5jdGlvbiBUcmlwbGUkZmluZEFsbChzZWxlY3RvciwgcXVlcnlSZXN1bHQpIHtcbiAgXHR2YXIgaSwgbGVuLCBub2RlLCBxdWVyeUFsbFJlc3VsdCwgbnVtTm9kZXMsIGo7XG5cbiAgXHRsZW4gPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdG5vZGUgPSB0aGlzLm5vZGVzW2ldO1xuXG4gIFx0XHRpZiAobm9kZS5ub2RlVHlwZSAhPT0gMSkge1xuICBcdFx0XHRjb250aW51ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKG1hdGNoZXMobm9kZSwgc2VsZWN0b3IpKSB7XG4gIFx0XHRcdHF1ZXJ5UmVzdWx0LnB1c2gobm9kZSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChxdWVyeUFsbFJlc3VsdCA9IG5vZGUucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpIHtcbiAgXHRcdFx0bnVtTm9kZXMgPSBxdWVyeUFsbFJlc3VsdC5sZW5ndGg7XG4gIFx0XHRcdGZvciAoaiA9IDA7IGogPCBudW1Ob2RlczsgaiArPSAxKSB7XG4gIFx0XHRcdFx0cXVlcnlSZXN1bHQucHVzaChxdWVyeUFsbFJlc3VsdFtqXSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgVHJpcGxlX3Byb3RvdHlwZV9maXJzdE5vZGUgPSBUcmlwbGUkZmlyc3ROb2RlO1xuXG4gIGZ1bmN0aW9uIFRyaXBsZSRmaXJzdE5vZGUoKSB7XG4gIFx0aWYgKHRoaXMucmVuZGVyZWQgJiYgdGhpcy5ub2Rlc1swXSkge1xuICBcdFx0cmV0dXJuIHRoaXMubm9kZXNbMF07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICB9XG5cbiAgdmFyIGVsZW1lbnRDYWNoZSA9IHt9LFxuICAgICAgaWVCdWcsXG4gICAgICBpZUJsYWNrbGlzdDtcblxuICB0cnkge1xuICBcdGNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiKS5pbm5lckhUTUwgPSBcImZvb1wiO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgXHRpZUJ1ZyA9IHRydWU7XG5cbiAgXHRpZUJsYWNrbGlzdCA9IHtcbiAgXHRcdFRBQkxFOiBbXCI8dGFibGUgY2xhc3M9XFxcInhcXFwiPlwiLCBcIjwvdGFibGU+XCJdLFxuICBcdFx0VEhFQUQ6IFtcIjx0YWJsZT48dGhlYWQgY2xhc3M9XFxcInhcXFwiPlwiLCBcIjwvdGhlYWQ+PC90YWJsZT5cIl0sXG4gIFx0XHRUQk9EWTogW1wiPHRhYmxlPjx0Ym9keSBjbGFzcz1cXFwieFxcXCI+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiXSxcbiAgXHRcdFRSOiBbXCI8dGFibGU+PHRyIGNsYXNzPVxcXCJ4XFxcIj5cIiwgXCI8L3RyPjwvdGFibGU+XCJdLFxuICBcdFx0U0VMRUNUOiBbXCI8c2VsZWN0IGNsYXNzPVxcXCJ4XFxcIj5cIiwgXCI8L3NlbGVjdD5cIl1cbiAgXHR9O1xuICB9XG5cbiAgdmFyIGluc2VydEh0bWwgPSBmdW5jdGlvbiAoaHRtbCwgbm9kZSwgZG9jRnJhZykge1xuICBcdHZhciBjb250YWluZXIsXG4gIFx0ICAgIG5vZGVzID0gW10sXG4gIFx0ICAgIHdyYXBwZXIsXG4gIFx0ICAgIHNlbGVjdGVkT3B0aW9uLFxuICBcdCAgICBjaGlsZCxcbiAgXHQgICAgaTtcblxuICBcdC8vIHJlbmRlciAwIGFuZCBmYWxzZVxuICBcdGlmIChodG1sICE9IG51bGwgJiYgaHRtbCAhPT0gXCJcIikge1xuICBcdFx0aWYgKGllQnVnICYmICh3cmFwcGVyID0gaWVCbGFja2xpc3Rbbm9kZS50YWdOYW1lXSkpIHtcbiAgXHRcdFx0Y29udGFpbmVyID0gZWxlbWVudChcIkRJVlwiKTtcbiAgXHRcdFx0Y29udGFpbmVyLmlubmVySFRNTCA9IHdyYXBwZXJbMF0gKyBodG1sICsgd3JhcHBlclsxXTtcbiAgXHRcdFx0Y29udGFpbmVyID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIueFwiKTtcblxuICBcdFx0XHRpZiAoY29udGFpbmVyLnRhZ05hbWUgPT09IFwiU0VMRUNUXCIpIHtcbiAgXHRcdFx0XHRzZWxlY3RlZE9wdGlvbiA9IGNvbnRhaW5lci5vcHRpb25zW2NvbnRhaW5lci5zZWxlY3RlZEluZGV4XTtcbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5zdmcpIHtcbiAgXHRcdFx0Y29udGFpbmVyID0gZWxlbWVudChcIkRJVlwiKTtcbiAgXHRcdFx0Y29udGFpbmVyLmlubmVySFRNTCA9IFwiPHN2ZyBjbGFzcz1cXFwieFxcXCI+XCIgKyBodG1sICsgXCI8L3N2Zz5cIjtcbiAgXHRcdFx0Y29udGFpbmVyID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIueFwiKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGNvbnRhaW5lciA9IGVsZW1lbnQobm9kZS50YWdOYW1lKTtcbiAgXHRcdFx0Y29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG5cbiAgXHRcdFx0aWYgKGNvbnRhaW5lci50YWdOYW1lID09PSBcIlNFTEVDVFwiKSB7XG4gIFx0XHRcdFx0c2VsZWN0ZWRPcHRpb24gPSBjb250YWluZXIub3B0aW9uc1tjb250YWluZXIuc2VsZWN0ZWRJbmRleF07XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0d2hpbGUgKGNoaWxkID0gY29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcbiAgXHRcdFx0bm9kZXMucHVzaChjaGlsZCk7XG4gIFx0XHRcdGRvY0ZyYWcuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBUaGlzIGlzIHJlYWxseSBhbm5veWluZy4gRXh0cmFjdGluZyA8b3B0aW9uPiBub2RlcyBmcm9tIHRoZVxuICBcdFx0Ly8gdGVtcG9yYXJ5IGNvbnRhaW5lciA8c2VsZWN0PiBjYXVzZXMgdGhlIHJlbWFpbmluZyBvbmVzIHRvXG4gIFx0XHQvLyBiZWNvbWUgc2VsZWN0ZWQuIFNvIG5vdyB3ZSBoYXZlIHRvIGRlc2VsZWN0IHRoZW0uIElFOCwgeW91XG4gIFx0XHQvLyBhbWF6ZSBtZS4gWW91IHJlYWxseSBkb1xuICBcdFx0Ly8gLi4uYW5kIG5vdyBDaHJvbWUgdG9vXG4gIFx0XHRpZiAobm9kZS50YWdOYW1lID09PSBcIlNFTEVDVFwiKSB7XG4gIFx0XHRcdGkgPSBub2Rlcy5sZW5ndGg7XG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRpZiAobm9kZXNbaV0gIT09IHNlbGVjdGVkT3B0aW9uKSB7XG4gIFx0XHRcdFx0XHRub2Rlc1tpXS5zZWxlY3RlZCA9IGZhbHNlO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBub2RlcztcbiAgfTtcblxuICBmdW5jdGlvbiBlbGVtZW50KHRhZ05hbWUpIHtcbiAgXHRyZXR1cm4gZWxlbWVudENhY2hlW3RhZ05hbWVdIHx8IChlbGVtZW50Q2FjaGVbdGFnTmFtZV0gPSBjcmVhdGVFbGVtZW50KHRhZ05hbWUpKTtcbiAgfVxuXG4gIHZhciBoZWxwZXJzX3VwZGF0ZVNlbGVjdCA9IHVwZGF0ZVNlbGVjdDtcblxuICBmdW5jdGlvbiB1cGRhdGVTZWxlY3QocGFyZW50RWxlbWVudCkge1xuICBcdHZhciBzZWxlY3RlZE9wdGlvbnMsIG9wdGlvbiwgdmFsdWU7XG5cbiAgXHRpZiAoIXBhcmVudEVsZW1lbnQgfHwgcGFyZW50RWxlbWVudC5uYW1lICE9PSBcInNlbGVjdFwiIHx8ICFwYXJlbnRFbGVtZW50LmJpbmRpbmcpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRzZWxlY3RlZE9wdGlvbnMgPSB0b0FycmF5KHBhcmVudEVsZW1lbnQubm9kZS5vcHRpb25zKS5maWx0ZXIoaXNTZWxlY3RlZCk7XG5cbiAgXHQvLyBJZiBvbmUgb2YgdGhlbSBoYWQgYSBgc2VsZWN0ZWRgIGF0dHJpYnV0ZSwgd2UgbmVlZCB0byBzeW5jXG4gIFx0Ly8gdGhlIG1vZGVsIHRvIHRoZSB2aWV3XG4gIFx0aWYgKHBhcmVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIikpIHtcbiAgXHRcdHZhbHVlID0gc2VsZWN0ZWRPcHRpb25zLm1hcChmdW5jdGlvbiAobykge1xuICBcdFx0XHRyZXR1cm4gby52YWx1ZTtcbiAgXHRcdH0pO1xuICBcdH0gZWxzZSBpZiAob3B0aW9uID0gc2VsZWN0ZWRPcHRpb25zWzBdKSB7XG4gIFx0XHR2YWx1ZSA9IG9wdGlvbi52YWx1ZTtcbiAgXHR9XG5cbiAgXHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0cGFyZW50RWxlbWVudC5iaW5kaW5nLnNldFZhbHVlKHZhbHVlKTtcbiAgXHR9XG5cbiAgXHRwYXJlbnRFbGVtZW50LmJ1YmJsZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTZWxlY3RlZChvcHRpb24pIHtcbiAgXHRyZXR1cm4gb3B0aW9uLnNlbGVjdGVkO1xuICB9XG5cbiAgdmFyIFRyaXBsZV9wcm90b3R5cGVfcmVuZGVyID0gVHJpcGxlJHJlbmRlcjtcbiAgZnVuY3Rpb24gVHJpcGxlJHJlbmRlcigpIHtcbiAgXHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIHJlbmRlciBhbiBpdGVtIHRoYXQgd2FzIGFscmVhZHkgcmVuZGVyZWRcIik7XG4gIFx0fVxuXG4gIFx0dGhpcy5kb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBcdHRoaXMubm9kZXMgPSBpbnNlcnRIdG1sKHRoaXMudmFsdWUsIHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpLCB0aGlzLmRvY0ZyYWcpO1xuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gd2UncmUgaW5zZXJ0aW5nIHRoZSBjb250ZW50cyBvZiBhIDxzZWxlY3Q+XG4gIFx0aGVscGVyc191cGRhdGVTZWxlY3QodGhpcy5wRWxlbWVudCk7XG5cbiAgXHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgXHRyZXR1cm4gdGhpcy5kb2NGcmFnO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9zZXRWYWx1ZSA9IFRyaXBsZSRzZXRWYWx1ZTtcbiAgZnVuY3Rpb24gVHJpcGxlJHNldFZhbHVlKHZhbHVlKSB7XG4gIFx0dmFyIHdyYXBwZXI7XG5cbiAgXHQvLyBUT0RPIGlzIHRoZXJlIGEgYmV0dGVyIHdheSB0byBhcHByb2FjaCB0aGlzP1xuICBcdGlmICh3cmFwcGVyID0gdGhpcy5yb290LnZpZXdtb2RlbC53cmFwcGVkW3RoaXMua2V5cGF0aC5zdHJdKSB7XG4gIFx0XHR2YWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG4gIFx0fVxuXG4gIFx0aWYgKHZhbHVlICE9PSB0aGlzLnZhbHVlKSB7XG4gIFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG4gIFx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuXG4gIFx0XHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRWaWV3KHRoaXMpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBUcmlwbGVfcHJvdG90eXBlX3RvU3RyaW5nID0gVHJpcGxlJHRvU3RyaW5nO1xuICBmdW5jdGlvbiBUcmlwbGUkdG9TdHJpbmcoKSB7XG4gIFx0cmV0dXJuIHRoaXMudmFsdWUgIT0gdW5kZWZpbmVkID8gZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyhcIlwiICsgdGhpcy52YWx1ZSkgOiBcIlwiO1xuICB9XG5cbiAgdmFyIFRyaXBsZV9wcm90b3R5cGVfdW5yZW5kZXIgPSBUcmlwbGUkdW5yZW5kZXI7XG4gIGZ1bmN0aW9uIFRyaXBsZSR1bnJlbmRlcihzaG91bGREZXN0cm95KSB7XG4gIFx0aWYgKHRoaXMucmVuZGVyZWQgJiYgc2hvdWxkRGVzdHJveSkge1xuICBcdFx0dGhpcy5ub2Rlcy5mb3JFYWNoKGRldGFjaE5vZGUpO1xuICBcdFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuICBcdH1cblxuICBcdC8vIFRPRE8gdXBkYXRlIGxpdmUgcXVlcmllc1xuICB9XG5cbiAgdmFyIFRyaXBsZV9wcm90b3R5cGVfdXBkYXRlID0gVHJpcGxlJHVwZGF0ZTtcbiAgZnVuY3Rpb24gVHJpcGxlJHVwZGF0ZSgpIHtcbiAgXHR2YXIgbm9kZSwgcGFyZW50Tm9kZTtcblxuICBcdGlmICghdGhpcy5yZW5kZXJlZCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIFJlbW92ZSBleGlzdGluZyBub2Rlc1xuICBcdHdoaWxlICh0aGlzLm5vZGVzICYmIHRoaXMubm9kZXMubGVuZ3RoKSB7XG4gIFx0XHRub2RlID0gdGhpcy5ub2Rlcy5wb3AoKTtcbiAgXHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgXHR9XG5cbiAgXHQvLyBJbnNlcnQgbmV3IG5vZGVzXG4gIFx0cGFyZW50Tm9kZSA9IHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpO1xuXG4gIFx0dGhpcy5ub2RlcyA9IGluc2VydEh0bWwodGhpcy52YWx1ZSwgcGFyZW50Tm9kZSwgdGhpcy5kb2NGcmFnKTtcbiAgXHRwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmRvY0ZyYWcsIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpKTtcblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHdlJ3JlIGluc2VydGluZyB0aGUgY29udGVudHMgb2YgYSA8c2VsZWN0PlxuICBcdGhlbHBlcnNfdXBkYXRlU2VsZWN0KHRoaXMucEVsZW1lbnQpO1xuICB9XG5cbiAgdmFyIFRyaXBsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy50eXBlID0gVFJJUExFO1xuICBcdE11c3RhY2hlLmluaXQodGhpcywgb3B0aW9ucyk7XG4gIH07XG5cbiAgVHJpcGxlLnByb3RvdHlwZSA9IHtcbiAgXHRkZXRhY2g6IFRyaXBsZV9wcm90b3R5cGVfZGV0YWNoLFxuICBcdGZpbmQ6IFRyaXBsZV9wcm90b3R5cGVfZmluZCxcbiAgXHRmaW5kQWxsOiBUcmlwbGVfcHJvdG90eXBlX2ZpbmRBbGwsXG4gIFx0Zmlyc3ROb2RlOiBUcmlwbGVfcHJvdG90eXBlX2ZpcnN0Tm9kZSxcbiAgXHRnZXRWYWx1ZTogTXVzdGFjaGUuZ2V0VmFsdWUsXG4gIFx0cmViaW5kOiBNdXN0YWNoZS5yZWJpbmQsXG4gIFx0cmVuZGVyOiBUcmlwbGVfcHJvdG90eXBlX3JlbmRlcixcbiAgXHRyZXNvbHZlOiBNdXN0YWNoZS5yZXNvbHZlLFxuICBcdHNldFZhbHVlOiBwcm90b3R5cGVfc2V0VmFsdWUsXG4gIFx0dG9TdHJpbmc6IFRyaXBsZV9wcm90b3R5cGVfdG9TdHJpbmcsXG4gIFx0dW5iaW5kOiBzaGFyZWRfdW5iaW5kLFxuICBcdHVucmVuZGVyOiBUcmlwbGVfcHJvdG90eXBlX3VucmVuZGVyLFxuICBcdHVwZGF0ZTogVHJpcGxlX3Byb3RvdHlwZV91cGRhdGVcbiAgfTtcblxuICB2YXIgX1RyaXBsZSA9IFRyaXBsZTtcblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfYnViYmxlID0gZnVuY3Rpb24gKCkge1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG4gIH07XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2RldGFjaCA9IEVsZW1lbnQkZGV0YWNoO1xuXG4gIGZ1bmN0aW9uIEVsZW1lbnQkZGV0YWNoKCkge1xuICBcdHZhciBub2RlID0gdGhpcy5ub2RlLFxuICBcdCAgICBwYXJlbnROb2RlO1xuXG4gIFx0aWYgKG5vZGUpIHtcbiAgXHRcdC8vIG5lZWQgdG8gY2hlY2sgZm9yIHBhcmVudCBub2RlIC0gRE9NIG1heSBoYXZlIGJlZW4gYWx0ZXJlZFxuICBcdFx0Ly8gYnkgc29tZXRoaW5nIG90aGVyIHRoYW4gUmFjdGl2ZSEgZS5nLiBqUXVlcnkgVUkuLi5cbiAgXHRcdGlmIChwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlKSB7XG4gIFx0XHRcdHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBub2RlO1xuICBcdH1cbiAgfVxuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9maW5kID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIFx0aWYgKCF0aGlzLm5vZGUpIHtcbiAgXHRcdC8vIHRoaXMgZWxlbWVudCBoYXNuJ3QgYmVlbiByZW5kZXJlZCB5ZXRcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmIChtYXRjaGVzKHRoaXMubm9kZSwgc2VsZWN0b3IpKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmZyYWdtZW50ICYmIHRoaXMuZnJhZ21lbnQuZmluZCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZChzZWxlY3Rvcik7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9maW5kQWxsID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdC8vIEFkZCB0aGlzIG5vZGUgdG8gdGhlIHF1ZXJ5LCBpZiBhcHBsaWNhYmxlLCBhbmQgcmVnaXN0ZXIgdGhlXG4gIFx0Ly8gcXVlcnkgb24gdGhpcyBlbGVtZW50XG4gIFx0aWYgKHF1ZXJ5Ll90ZXN0KHRoaXMsIHRydWUpICYmIHF1ZXJ5LmxpdmUpIHtcbiAgXHRcdCh0aGlzLmxpdmVRdWVyaWVzIHx8ICh0aGlzLmxpdmVRdWVyaWVzID0gW10pKS5wdXNoKHF1ZXJ5KTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC5maW5kQWxsKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9maW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uIChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQ29tcG9uZW50KHNlbGVjdG9yKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2ZpbmROZXh0Tm9kZSA9IEVsZW1lbnQkZmluZE5leHROb2RlO1xuXG4gIGZ1bmN0aW9uIEVsZW1lbnQkZmluZE5leHROb2RlKCkge1xuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2ZpcnN0Tm9kZSA9IEVsZW1lbnQkZmlyc3ROb2RlO1xuXG4gIGZ1bmN0aW9uIEVsZW1lbnQkZmlyc3ROb2RlKCkge1xuICBcdHJldHVybiB0aGlzLm5vZGU7XG4gIH1cblxuICB2YXIgZ2V0QXR0cmlidXRlID0gRWxlbWVudCRnZXRBdHRyaWJ1dGU7XG5cbiAgZnVuY3Rpb24gRWxlbWVudCRnZXRBdHRyaWJ1dGUobmFtZSkge1xuICBcdGlmICghdGhpcy5hdHRyaWJ1dGVzIHx8ICF0aGlzLmF0dHJpYnV0ZXNbbmFtZV0pIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW25hbWVdLnZhbHVlO1xuICB9XG5cbiAgdmFyIHRydXRoeSA9IC9edHJ1ZXxvbnx5ZXN8MSQvaTtcbiAgdmFyIHByb2Nlc3NCaW5kaW5nQXR0cmlidXRlc19faXNOdW1lcmljID0gL15bMC05XSskLztcblxuICB2YXIgcHJvY2Vzc0JpbmRpbmdBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGVsZW1lbnQsIHRlbXBsYXRlKSB7XG4gIFx0dmFyIHZhbCwgYXR0cnMsIGF0dHJpYnV0ZXM7XG5cbiAgXHRhdHRyaWJ1dGVzID0gdGVtcGxhdGUuYSB8fCB7fTtcbiAgXHRhdHRycyA9IHt9O1xuXG4gIFx0Ly8gYXR0cmlidXRlcyB0aGF0IGFyZSBwcmVzZW50IGJ1dCBkb24ndCBoYXZlIGEgdmFsdWUgKD0pXG4gIFx0Ly8gd2lsbCBiZSBzZXQgdG8gdGhlIG51bWJlciAwLCB3aGljaCB3ZSBjb25kaWRlciB0byBiZSB0cnVlXG4gIFx0Ly8gdGhlIHN0cmluZyAnMCcsIGhvd2V2ZXIgaXMgZmFsc2VcblxuICBcdHZhbCA9IGF0dHJpYnV0ZXMudHdvd2F5O1xuICBcdGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0YXR0cnMudHdvd2F5ID0gdmFsID09PSAwIHx8IHRydXRoeS50ZXN0KHZhbCk7XG4gIFx0fVxuXG4gIFx0dmFsID0gYXR0cmlidXRlcy5sYXp5O1xuICBcdGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0Ly8gY2hlY2sgZm9yIHRpbWVvdXQgdmFsdWVcbiAgXHRcdGlmICh2YWwgIT09IDAgJiYgcHJvY2Vzc0JpbmRpbmdBdHRyaWJ1dGVzX19pc051bWVyaWMudGVzdCh2YWwpKSB7XG4gIFx0XHRcdGF0dHJzLmxhenkgPSBwYXJzZUludCh2YWwpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0YXR0cnMubGF6eSA9IHZhbCA9PT0gMCB8fCB0cnV0aHkudGVzdCh2YWwpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBhdHRycztcbiAgfTtcblxuICB2YXIgQXR0cmlidXRlX3Byb3RvdHlwZV9idWJibGUgPSBBdHRyaWJ1dGUkYnViYmxlO1xuICBmdW5jdGlvbiBBdHRyaWJ1dGUkYnViYmxlKCkge1xuICBcdHZhciB2YWx1ZSA9IHRoaXMudXNlUHJvcGVydHkgfHwgIXRoaXMucmVuZGVyZWQgPyB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCkgOiB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCk7XG5cbiAgXHQvLyBUT0RPIHRoaXMgY2FuIHJlZ2lzdGVyIHRoZSBhdHRyaWJ1dGUgbXVsdGlwbGUgdGltZXMgKHNlZSByZW5kZXIgdGVzdFxuICBcdC8vICdBdHRyaWJ1dGUgd2l0aCBuZXN0ZWQgbXVzdGFjaGVzJylcbiAgXHRpZiAoIWlzRXF1YWwodmFsdWUsIHRoaXMudmFsdWUpKSB7XG5cbiAgXHRcdC8vIE5lZWQgdG8gY2xlYXIgb2xkIGlkIGZyb20gcmFjdGl2ZS5ub2Rlc1xuICBcdFx0aWYgKHRoaXMubmFtZSA9PT0gXCJpZFwiICYmIHRoaXMudmFsdWUpIHtcbiAgXHRcdFx0ZGVsZXRlIHRoaXMucm9vdC5ub2Rlc1t0aGlzLnZhbHVlXTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXG4gIFx0XHRpZiAodGhpcy5uYW1lID09PSBcInZhbHVlXCIgJiYgdGhpcy5ub2RlKSB7XG4gIFx0XHRcdC8vIFdlIG5lZWQgdG8gc3RvcmUgdGhlIHZhbHVlIG9uIHRoZSBET00gbGlrZSB0aGlzIHNvIHdlXG4gIFx0XHRcdC8vIGNhbiByZXRyaWV2ZSBpdCBsYXRlciB3aXRob3V0IGl0IGJlaW5nIGNvZXJjZWQgdG8gYSBzdHJpbmdcbiAgXHRcdFx0dGhpcy5ub2RlLl9yYWN0aXZlLnZhbHVlID0gdmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFZpZXcodGhpcyk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIHN2Z0NhbWVsQ2FzZUVsZW1lbnRzLCBzdmdDYW1lbENhc2VBdHRyaWJ1dGVzLCBjcmVhdGVNYXAsIG1hcDtcbiAgc3ZnQ2FtZWxDYXNlRWxlbWVudHMgPSBcImFsdEdseXBoIGFsdEdseXBoRGVmIGFsdEdseXBoSXRlbSBhbmltYXRlQ29sb3IgYW5pbWF0ZU1vdGlvbiBhbmltYXRlVHJhbnNmb3JtIGNsaXBQYXRoIGZlQmxlbmQgZmVDb2xvck1hdHJpeCBmZUNvbXBvbmVudFRyYW5zZmVyIGZlQ29tcG9zaXRlIGZlQ29udm9sdmVNYXRyaXggZmVEaWZmdXNlTGlnaHRpbmcgZmVEaXNwbGFjZW1lbnRNYXAgZmVEaXN0YW50TGlnaHQgZmVGbG9vZCBmZUZ1bmNBIGZlRnVuY0IgZmVGdW5jRyBmZUZ1bmNSIGZlR2F1c3NpYW5CbHVyIGZlSW1hZ2UgZmVNZXJnZSBmZU1lcmdlTm9kZSBmZU1vcnBob2xvZ3kgZmVPZmZzZXQgZmVQb2ludExpZ2h0IGZlU3BlY3VsYXJMaWdodGluZyBmZVNwb3RMaWdodCBmZVRpbGUgZmVUdXJidWxlbmNlIGZvcmVpZ25PYmplY3QgZ2x5cGhSZWYgbGluZWFyR3JhZGllbnQgcmFkaWFsR3JhZGllbnQgdGV4dFBhdGggdmtlcm5cIi5zcGxpdChcIiBcIik7XG4gIHN2Z0NhbWVsQ2FzZUF0dHJpYnV0ZXMgPSBcImF0dHJpYnV0ZU5hbWUgYXR0cmlidXRlVHlwZSBiYXNlRnJlcXVlbmN5IGJhc2VQcm9maWxlIGNhbGNNb2RlIGNsaXBQYXRoVW5pdHMgY29udGVudFNjcmlwdFR5cGUgY29udGVudFN0eWxlVHlwZSBkaWZmdXNlQ29uc3RhbnQgZWRnZU1vZGUgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCBmaWx0ZXJSZXMgZmlsdGVyVW5pdHMgZ2x5cGhSZWYgZ3JhZGllbnRUcmFuc2Zvcm0gZ3JhZGllbnRVbml0cyBrZXJuZWxNYXRyaXgga2VybmVsVW5pdExlbmd0aCBrZXlQb2ludHMga2V5U3BsaW5lcyBrZXlUaW1lcyBsZW5ndGhBZGp1c3QgbGltaXRpbmdDb25lQW5nbGUgbWFya2VySGVpZ2h0IG1hcmtlclVuaXRzIG1hcmtlcldpZHRoIG1hc2tDb250ZW50VW5pdHMgbWFza1VuaXRzIG51bU9jdGF2ZXMgcGF0aExlbmd0aCBwYXR0ZXJuQ29udGVudFVuaXRzIHBhdHRlcm5UcmFuc2Zvcm0gcGF0dGVyblVuaXRzIHBvaW50c0F0WCBwb2ludHNBdFkgcG9pbnRzQXRaIHByZXNlcnZlQWxwaGEgcHJlc2VydmVBc3BlY3RSYXRpbyBwcmltaXRpdmVVbml0cyByZWZYIHJlZlkgcmVwZWF0Q291bnQgcmVwZWF0RHVyIHJlcXVpcmVkRXh0ZW5zaW9ucyByZXF1aXJlZEZlYXR1cmVzIHNwZWN1bGFyQ29uc3RhbnQgc3BlY3VsYXJFeHBvbmVudCBzcHJlYWRNZXRob2Qgc3RhcnRPZmZzZXQgc3RkRGV2aWF0aW9uIHN0aXRjaFRpbGVzIHN1cmZhY2VTY2FsZSBzeXN0ZW1MYW5ndWFnZSB0YWJsZVZhbHVlcyB0YXJnZXRYIHRhcmdldFkgdGV4dExlbmd0aCB2aWV3Qm94IHZpZXdUYXJnZXQgeENoYW5uZWxTZWxlY3RvciB5Q2hhbm5lbFNlbGVjdG9yIHpvb21BbmRQYW5cIi5zcGxpdChcIiBcIik7XG5cbiAgY3JlYXRlTWFwID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gIFx0dmFyIG1hcCA9IHt9LFxuICBcdCAgICBpID0gaXRlbXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdG1hcFtpdGVtc1tpXS50b0xvd2VyQ2FzZSgpXSA9IGl0ZW1zW2ldO1xuICBcdH1cbiAgXHRyZXR1cm4gbWFwO1xuICB9O1xuXG4gIG1hcCA9IGNyZWF0ZU1hcChzdmdDYW1lbENhc2VFbGVtZW50cy5jb25jYXQoc3ZnQ2FtZWxDYXNlQXR0cmlidXRlcykpO1xuXG4gIHZhciBlbmZvcmNlQ2FzZSA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSkge1xuICBcdHZhciBsb3dlckNhc2VFbGVtZW50TmFtZSA9IGVsZW1lbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIFx0cmV0dXJuIG1hcFtsb3dlckNhc2VFbGVtZW50TmFtZV0gfHwgbG93ZXJDYXNlRWxlbWVudE5hbWU7XG4gIH07XG5cbiAgdmFyIGRldGVybWluZU5hbWVBbmROYW1lc3BhY2UgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBuYW1lKSB7XG4gIFx0dmFyIGNvbG9uSW5kZXgsIG5hbWVzcGFjZVByZWZpeDtcblxuICBcdC8vIGFyZSB3ZSBkZWFsaW5nIHdpdGggYSBuYW1lc3BhY2VkIGF0dHJpYnV0ZSwgZS5nLiB4bGluazpocmVmP1xuICBcdGNvbG9uSW5kZXggPSBuYW1lLmluZGV4T2YoXCI6XCIpO1xuICBcdGlmIChjb2xvbkluZGV4ICE9PSAtMSkge1xuXG4gIFx0XHQvLyBsb29rcyBsaWtlIHdlIGFyZSwgeWVzLi4uXG4gIFx0XHRuYW1lc3BhY2VQcmVmaXggPSBuYW1lLnN1YnN0cigwLCBjb2xvbkluZGV4KTtcblxuICBcdFx0Ly8gLi4udW5sZXNzIGl0J3MgYSBuYW1lc3BhY2UgKmRlY2xhcmF0aW9uKiwgd2hpY2ggd2UgaWdub3JlIChvbiB0aGUgYXNzdW1wdGlvblxuICBcdFx0Ly8gdGhhdCBvbmx5IHZhbGlkIG5hbWVzcGFjZXMgd2lsbCBiZSB1c2VkKVxuICBcdFx0aWYgKG5hbWVzcGFjZVByZWZpeCAhPT0gXCJ4bWxuc1wiKSB7XG4gIFx0XHRcdG5hbWUgPSBuYW1lLnN1YnN0cmluZyhjb2xvbkluZGV4ICsgMSk7XG5cbiAgXHRcdFx0YXR0cmlidXRlLm5hbWUgPSBlbmZvcmNlQ2FzZShuYW1lKTtcbiAgXHRcdFx0YXR0cmlidXRlLm5hbWVzcGFjZSA9IG5hbWVzcGFjZXNbbmFtZXNwYWNlUHJlZml4LnRvTG93ZXJDYXNlKCldO1xuICBcdFx0XHRhdHRyaWJ1dGUubmFtZXNwYWNlUHJlZml4ID0gbmFtZXNwYWNlUHJlZml4O1xuXG4gIFx0XHRcdGlmICghYXR0cmlidXRlLm5hbWVzcGFjZSkge1xuICBcdFx0XHRcdHRocm93IFwiVW5rbm93biBuYW1lc3BhY2UgKFxcXCJcIiArIG5hbWVzcGFjZVByZWZpeCArIFwiXFxcIilcIjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBTVkcgYXR0cmlidXRlIG5hbWVzIGFyZSBjYXNlIHNlbnNpdGl2ZVxuICBcdGF0dHJpYnV0ZS5uYW1lID0gYXR0cmlidXRlLmVsZW1lbnQubmFtZXNwYWNlICE9PSBuYW1lc3BhY2VzLmh0bWwgPyBlbmZvcmNlQ2FzZShuYW1lKSA6IG5hbWU7XG4gIH07XG5cbiAgdmFyIGhlbHBlcnNfZ2V0SW50ZXJwb2xhdG9yID0gZ2V0SW50ZXJwb2xhdG9yO1xuICBmdW5jdGlvbiBnZXRJbnRlcnBvbGF0b3IoYXR0cmlidXRlKSB7XG4gIFx0dmFyIGl0ZW1zID0gYXR0cmlidXRlLmZyYWdtZW50Lml0ZW1zO1xuXG4gIFx0aWYgKGl0ZW1zLmxlbmd0aCAhPT0gMSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGlmIChpdGVtc1swXS50eXBlID09PSBJTlRFUlBPTEFUT1IpIHtcbiAgXHRcdHJldHVybiBpdGVtc1swXTtcbiAgXHR9XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2luaXQgPSBBdHRyaWJ1dGUkaW5pdDtcbiAgZnVuY3Rpb24gQXR0cmlidXRlJGluaXQob3B0aW9ucykge1xuICBcdHRoaXMudHlwZSA9IEFUVFJJQlVURTtcbiAgXHR0aGlzLmVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQ7XG4gIFx0dGhpcy5yb290ID0gb3B0aW9ucy5yb290O1xuXG4gIFx0ZGV0ZXJtaW5lTmFtZUFuZE5hbWVzcGFjZSh0aGlzLCBvcHRpb25zLm5hbWUpO1xuICBcdHRoaXMuaXNCb29sZWFuID0gYm9vbGVhbkF0dHJpYnV0ZXMudGVzdCh0aGlzLm5hbWUpO1xuXG4gIFx0Ly8gaWYgaXQncyBhbiBlbXB0eSBhdHRyaWJ1dGUsIG9yIGp1c3QgYSBzdHJhaWdodCBrZXktdmFsdWUgcGFpciwgd2l0aCBub1xuICBcdC8vIG11c3RhY2hlIHNoZW5hbmlnYW5zLCBzZXQgdGhlIGF0dHJpYnV0ZSBhY2NvcmRpbmdseSBhbmQgZ28gaG9tZVxuICBcdGlmICghb3B0aW9ucy52YWx1ZSB8fCB0eXBlb2Ygb3B0aW9ucy52YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0dGhpcy52YWx1ZSA9IHRoaXMuaXNCb29sZWFuID8gdHJ1ZSA6IG9wdGlvbnMudmFsdWUgfHwgXCJcIjtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHQvLyBvdGhlcndpc2Ugd2UgbmVlZCB0byBkbyBzb21lIHdvcmtcblxuICBcdC8vIHNoYXJlIHBhcmVudEZyYWdtZW50IHdpdGggcGFyZW50IGVsZW1lbnRcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gdGhpcy5lbGVtZW50LnBhcmVudEZyYWdtZW50O1xuXG4gIFx0dGhpcy5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdHRlbXBsYXRlOiBvcHRpb25zLnZhbHVlLFxuICBcdFx0cm9vdDogdGhpcy5yb290LFxuICBcdFx0b3duZXI6IHRoaXNcbiAgXHR9KTtcblxuICBcdC8vIFRPRE8gY2FuIHdlIHVzZSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCkgaW4gc29tZSBjYXNlcz8gSXQncyBxdWlja2VyXG4gIFx0dGhpcy52YWx1ZSA9IHRoaXMuZnJhZ21lbnQuZ2V0VmFsdWUoKTtcblxuICBcdC8vIFN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoaXMgYXR0cmlidXRlJ3MgaW50ZXJwb2xhdG9yLCBpZiBpdHMgZnJhZ21lbnRcbiAgXHQvLyB0YWtlcyB0aGUgZm9ybSBge3tmb299fWAuIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciB0d28td2F5IGJpbmRpbmcgYW5kXG4gIFx0Ly8gZm9yIGNvcnJlY3RseSByZW5kZXJpbmcgSFRNTCBsYXRlclxuICBcdHRoaXMuaW50ZXJwb2xhdG9yID0gaGVscGVyc19nZXRJbnRlcnBvbGF0b3IodGhpcyk7XG4gIFx0dGhpcy5pc0JpbmRhYmxlID0gISF0aGlzLmludGVycG9sYXRvciAmJiAhdGhpcy5pbnRlcnBvbGF0b3IuaXNTdGF0aWM7XG5cbiAgXHQvLyBtYXJrIGFzIHJlYWR5XG4gIFx0dGhpcy5yZWFkeSA9IHRydWU7XG4gIH1cblxuICB2YXIgQXR0cmlidXRlX3Byb3RvdHlwZV9yZWJpbmQgPSBBdHRyaWJ1dGUkcmViaW5kO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSRyZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgQXR0cmlidXRlX3Byb3RvdHlwZV9yZW5kZXIgPSBBdHRyaWJ1dGUkcmVuZGVyO1xuICB2YXIgcHJvcGVydHlOYW1lcyA9IHtcbiAgXHRcImFjY2VwdC1jaGFyc2V0XCI6IFwiYWNjZXB0Q2hhcnNldFwiLFxuICBcdGFjY2Vzc2tleTogXCJhY2Nlc3NLZXlcIixcbiAgXHRiZ2NvbG9yOiBcImJnQ29sb3JcIixcbiAgXHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCIsXG4gIFx0Y29kZWJhc2U6IFwiY29kZUJhc2VcIixcbiAgXHRjb2xzcGFuOiBcImNvbFNwYW5cIixcbiAgXHRjb250ZW50ZWRpdGFibGU6IFwiY29udGVudEVkaXRhYmxlXCIsXG4gIFx0ZGF0ZXRpbWU6IFwiZGF0ZVRpbWVcIixcbiAgXHRkaXJuYW1lOiBcImRpck5hbWVcIixcbiAgXHRcImZvclwiOiBcImh0bWxGb3JcIixcbiAgXHRcImh0dHAtZXF1aXZcIjogXCJodHRwRXF1aXZcIixcbiAgXHRpc21hcDogXCJpc01hcFwiLFxuICBcdG1heGxlbmd0aDogXCJtYXhMZW5ndGhcIixcbiAgXHRub3ZhbGlkYXRlOiBcIm5vVmFsaWRhdGVcIixcbiAgXHRwdWJkYXRlOiBcInB1YkRhdGVcIixcbiAgXHRyZWFkb25seTogXCJyZWFkT25seVwiLFxuICBcdHJvd3NwYW46IFwicm93U3BhblwiLFxuICBcdHRhYmluZGV4OiBcInRhYkluZGV4XCIsXG4gIFx0dXNlbWFwOiBcInVzZU1hcFwiXG4gIH07XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSRyZW5kZXIobm9kZSkge1xuICBcdHZhciBwcm9wZXJ0eU5hbWU7XG5cbiAgXHR0aGlzLm5vZGUgPSBub2RlO1xuXG4gIFx0Ly8gc2hvdWxkIHdlIHVzZSBkaXJlY3QgcHJvcGVydHkgYWNjZXNzLCBvciBzZXRBdHRyaWJ1dGU/XG4gIFx0aWYgKCFub2RlLm5hbWVzcGFjZVVSSSB8fCBub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5odG1sKSB7XG4gIFx0XHRwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWVzW3RoaXMubmFtZV0gfHwgdGhpcy5uYW1lO1xuXG4gIFx0XHRpZiAobm9kZVtwcm9wZXJ0eU5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGlzIGF0dHJpYnV0ZSBhIGJvb2xlYW4gYXR0cmlidXRlIG9yICd2YWx1ZSc/IElmIHNvIHdlJ3JlIGJldHRlciBvZmYgZG9pbmcgZS5nLlxuICBcdFx0Ly8gbm9kZS5zZWxlY3RlZCA9IHRydWUgcmF0aGVyIHRoYW4gbm9kZS5zZXRBdHRyaWJ1dGUoICdzZWxlY3RlZCcsICcnIClcbiAgXHRcdGlmICh0aGlzLmlzQm9vbGVhbiB8fCB0aGlzLmlzVHdvd2F5KSB7XG4gIFx0XHRcdHRoaXMudXNlUHJvcGVydHkgPSB0cnVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAocHJvcGVydHlOYW1lID09PSBcInZhbHVlXCIpIHtcbiAgXHRcdFx0bm9kZS5fcmFjdGl2ZS52YWx1ZSA9IHRoaXMudmFsdWU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gIFx0dGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIHZhciBBdHRyaWJ1dGVfcHJvdG90eXBlX3RvU3RyaW5nID0gQXR0cmlidXRlJHRvU3RyaW5nO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR0b1N0cmluZygpIHtcbiAgXHR2YXIgX3JlZiA9IHRoaXM7XG5cbiAgXHR2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgXHR2YXIgbmFtZXNwYWNlUHJlZml4ID0gX3JlZi5uYW1lc3BhY2VQcmVmaXg7XG4gIFx0dmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcbiAgXHR2YXIgaW50ZXJwb2xhdG9yID0gX3JlZi5pbnRlcnBvbGF0b3I7XG4gIFx0dmFyIGZyYWdtZW50ID0gX3JlZi5mcmFnbWVudDtcblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHNlbGVjdCBhbmQgdGV4dGFyZWEgdmFsdWVzIChzaG91bGQgbm90IGJlIHN0cmluZ2lmaWVkKVxuICBcdGlmIChuYW1lID09PSBcInZhbHVlXCIgJiYgKHRoaXMuZWxlbWVudC5uYW1lID09PSBcInNlbGVjdFwiIHx8IHRoaXMuZWxlbWVudC5uYW1lID09PSBcInRleHRhcmVhXCIpKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gY29udGVudCBlZGl0YWJsZVxuICBcdGlmIChuYW1lID09PSBcInZhbHVlXCIgJiYgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gcmFkaW8gbmFtZXNcbiAgXHRpZiAobmFtZSA9PT0gXCJuYW1lXCIgJiYgdGhpcy5lbGVtZW50Lm5hbWUgPT09IFwiaW5wdXRcIiAmJiBpbnRlcnBvbGF0b3IpIHtcbiAgXHRcdHJldHVybiBcIm5hbWU9e3tcIiArIChpbnRlcnBvbGF0b3Iua2V5cGF0aC5zdHIgfHwgaW50ZXJwb2xhdG9yLnJlZikgKyBcIn19XCI7XG4gIFx0fVxuXG4gIFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzXG4gIFx0aWYgKHRoaXMuaXNCb29sZWFuKSB7XG4gIFx0XHRyZXR1cm4gdmFsdWUgPyBuYW1lIDogXCJcIjtcbiAgXHR9XG5cbiAgXHRpZiAoZnJhZ21lbnQpIHtcbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIHRoaXMgY2F0Y2hlcyB1bmRlZmluZWQvbnVsbCB2YWx1ZXMgKCMxMjExKVxuICBcdFx0aWYgKGZyYWdtZW50Lml0ZW1zLmxlbmd0aCA9PT0gMSAmJiBmcmFnbWVudC5pdGVtc1swXS52YWx1ZSA9PSBudWxsKSB7XG4gIFx0XHRcdHJldHVybiBcIlwiO1xuICBcdFx0fVxuXG4gIFx0XHR2YWx1ZSA9IGZyYWdtZW50LnRvU3RyaW5nKCk7XG4gIFx0fVxuXG4gIFx0aWYgKG5hbWVzcGFjZVByZWZpeCkge1xuICBcdFx0bmFtZSA9IG5hbWVzcGFjZVByZWZpeCArIFwiOlwiICsgbmFtZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdmFsdWUgPyBuYW1lICsgXCI9XFxcIlwiICsgQXR0cmlidXRlX3Byb3RvdHlwZV90b1N0cmluZ19fZXNjYXBlKHZhbHVlKSArIFwiXFxcIlwiIDogbmFtZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZV9wcm90b3R5cGVfdG9TdHJpbmdfX2VzY2FwZSh2YWx1ZSkge1xuICBcdHJldHVybiB2YWx1ZS5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIikucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIikucmVwbGFjZSgvJy9nLCBcIiYjMzk7XCIpO1xuICB9XG5cbiAgdmFyIEF0dHJpYnV0ZV9wcm90b3R5cGVfdW5iaW5kID0gQXR0cmlidXRlJHVuYmluZDtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdW5iaW5kKCkge1xuICBcdC8vIGlnbm9yZSBub24tZHluYW1pYyBhdHRyaWJ1dGVzXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJpZFwiKSB7XG4gIFx0XHRkZWxldGUgdGhpcy5yb290Lm5vZGVzW3RoaXMudmFsdWVdO1xuICBcdH1cbiAgfVxuXG4gIHZhciB1cGRhdGVTZWxlY3RWYWx1ZSA9IEF0dHJpYnV0ZSR1cGRhdGVTZWxlY3Q7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZVNlbGVjdCgpIHtcbiAgXHR2YXIgdmFsdWUgPSB0aGlzLnZhbHVlLFxuICBcdCAgICBvcHRpb25zLFxuICBcdCAgICBvcHRpb24sXG4gIFx0ICAgIG9wdGlvblZhbHVlLFxuICBcdCAgICBpO1xuXG4gIFx0aWYgKCF0aGlzLmxvY2tlZCkge1xuICBcdFx0dGhpcy5ub2RlLl9yYWN0aXZlLnZhbHVlID0gdmFsdWU7XG5cbiAgXHRcdG9wdGlvbnMgPSB0aGlzLm5vZGUub3B0aW9ucztcbiAgXHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRvcHRpb24gPSBvcHRpb25zW2ldO1xuICBcdFx0XHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5fcmFjdGl2ZSA/IG9wdGlvbi5fcmFjdGl2ZS52YWx1ZSA6IG9wdGlvbi52YWx1ZTsgLy8gb3B0aW9ucyBpbnNlcnRlZCB2aWEgYSB0cmlwbGUgZG9uJ3QgaGF2ZSBfcmFjdGl2ZVxuXG4gIFx0XHRcdGlmIChvcHRpb25WYWx1ZSA9PSB2YWx1ZSkge1xuICBcdFx0XHRcdC8vIGRvdWJsZSBlcXVhbHMgYXMgd2UgbWF5IGJlIGNvbXBhcmluZyBudW1iZXJzIHdpdGggc3RyaW5nc1xuICBcdFx0XHRcdG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG4gIFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBpZiB3ZSdyZSBzdGlsbCBoZXJlLCBpdCBtZWFucyB0aGUgbmV3IHZhbHVlIGRpZG4ndCBtYXRjaCBhbnkgb2YgdGhlIG9wdGlvbnMuLi5cbiAgXHQvLyBUT0RPIGZpZ3VyZSBvdXQgd2hhdCB0byBkbyBpbiB0aGlzIHNpdHVhdGlvblxuICB9XG5cbiAgdmFyIHVwZGF0ZU11bHRpcGxlU2VsZWN0VmFsdWUgPSBBdHRyaWJ1dGUkdXBkYXRlTXVsdGlwbGVTZWxlY3Q7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVNdWx0aXBsZVNlbGVjdCgpIHtcbiAgXHR2YXIgdmFsdWUgPSB0aGlzLnZhbHVlLFxuICBcdCAgICBvcHRpb25zLFxuICBcdCAgICBpLFxuICBcdCAgICBvcHRpb24sXG4gIFx0ICAgIG9wdGlvblZhbHVlO1xuXG4gIFx0aWYgKCFpc0FycmF5KHZhbHVlKSkge1xuICBcdFx0dmFsdWUgPSBbdmFsdWVdO1xuICBcdH1cblxuICBcdG9wdGlvbnMgPSB0aGlzLm5vZGUub3B0aW9ucztcbiAgXHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRvcHRpb24gPSBvcHRpb25zW2ldO1xuICBcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7IC8vIG9wdGlvbnMgaW5zZXJ0ZWQgdmlhIGEgdHJpcGxlIGRvbid0IGhhdmUgX3JhY3RpdmVcbiAgXHRcdG9wdGlvbi5zZWxlY3RlZCA9IGFycmF5Q29udGFpbnModmFsdWUsIG9wdGlvblZhbHVlKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgdXBkYXRlUmFkaW9OYW1lID0gQXR0cmlidXRlJHVwZGF0ZVJhZGlvTmFtZTtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlUmFkaW9OYW1lKCkge1xuICBcdHZhciBfcmVmID0gdGhpcztcblxuICBcdHZhciBub2RlID0gX3JlZi5ub2RlO1xuICBcdHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG5cbiAgXHRub2RlLmNoZWNrZWQgPSB2YWx1ZSA9PSBub2RlLl9yYWN0aXZlLnZhbHVlO1xuICB9XG5cbiAgdmFyIHVwZGF0ZVJhZGlvVmFsdWUgPSBBdHRyaWJ1dGUkdXBkYXRlUmFkaW9WYWx1ZTtcbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZVJhZGlvVmFsdWUoKSB7XG4gIFx0dmFyIHdhc0NoZWNrZWQsXG4gIFx0ICAgIG5vZGUgPSB0aGlzLm5vZGUsXG4gIFx0ICAgIGJpbmRpbmcsXG4gIFx0ICAgIGJpbmRpbmdzLFxuICBcdCAgICBpO1xuXG4gIFx0d2FzQ2hlY2tlZCA9IG5vZGUuY2hlY2tlZDtcblxuICBcdG5vZGUudmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIFx0bm9kZS5jaGVja2VkID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID09PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibmFtZVwiKTtcblxuICBcdC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgLSBpZiB0aGUgaW5wdXQgd2FzIGNoZWNrZWQsIGFuZCB0aGUgdmFsdWVcbiAgXHQvLyBjaGFuZ2VkIHNvIHRoYXQgaXQncyBubyBsb25nZXIgY2hlY2tlZCwgdGhlIHR3b3dheSBiaW5kaW5nIGlzXG4gIFx0Ly8gbW9zdCBsaWtlbHkgb3V0IG9mIGRhdGUuIFRvIGZpeCBpdCB3ZSBoYXZlIHRvIGp1bXAgdGhyb3VnaCBzb21lXG4gIFx0Ly8gaG9vcHMuLi4gdGhpcyBpcyBhIGxpdHRsZSBrbHVkZ3kgYnV0IGl0IHdvcmtzXG4gIFx0aWYgKHdhc0NoZWNrZWQgJiYgIW5vZGUuY2hlY2tlZCAmJiB0aGlzLmVsZW1lbnQuYmluZGluZykge1xuICBcdFx0YmluZGluZ3MgPSB0aGlzLmVsZW1lbnQuYmluZGluZy5zaWJsaW5ncztcblxuICBcdFx0aWYgKGkgPSBiaW5kaW5ncy5sZW5ndGgpIHtcbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcblxuICBcdFx0XHRcdGlmICghYmluZGluZy5lbGVtZW50Lm5vZGUpIHtcbiAgXHRcdFx0XHRcdC8vIHRoaXMgaXMgdGhlIGluaXRpYWwgcmVuZGVyLCBzaWJsaW5ncyBhcmUgc3RpbGwgcmVuZGVyaW5nIVxuICBcdFx0XHRcdFx0Ly8gd2UnbGwgY29tZSBiYWNrIGxhdGVyLi4uXG4gIFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0aWYgKGJpbmRpbmcuZWxlbWVudC5ub2RlLmNoZWNrZWQpIHtcbiAgXHRcdFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFJhY3RpdmUoYmluZGluZy5yb290KTtcbiAgXHRcdFx0XHRcdHJldHVybiBiaW5kaW5nLmhhbmRsZUNoYW5nZSgpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KGJpbmRpbmcua2V5cGF0aCwgdW5kZWZpbmVkKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgdXBkYXRlQ2hlY2tib3hOYW1lID0gQXR0cmlidXRlJHVwZGF0ZUNoZWNrYm94TmFtZTtcbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUNoZWNrYm94TmFtZSgpIHtcbiAgXHR2YXIgX3JlZiA9IHRoaXM7XG5cbiAgXHR2YXIgZWxlbWVudCA9IF9yZWYuZWxlbWVudDtcbiAgXHR2YXIgbm9kZSA9IF9yZWYubm9kZTtcbiAgXHR2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO3ZhciBiaW5kaW5nID0gZWxlbWVudC5iaW5kaW5nO3ZhciB2YWx1ZUF0dHJpYnV0ZTt2YXIgaTtcblxuICBcdHZhbHVlQXR0cmlidXRlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcblxuICBcdGlmICghaXNBcnJheSh2YWx1ZSkpIHtcbiAgXHRcdGJpbmRpbmcuaXNDaGVja2VkID0gbm9kZS5jaGVja2VkID0gdmFsdWUgPT0gdmFsdWVBdHRyaWJ1dGU7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGkgPSB2YWx1ZS5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGlmICh2YWx1ZUF0dHJpYnV0ZSA9PSB2YWx1ZVtpXSkge1xuICBcdFx0XHRcdGJpbmRpbmcuaXNDaGVja2VkID0gbm9kZS5jaGVja2VkID0gdHJ1ZTtcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdGJpbmRpbmcuaXNDaGVja2VkID0gbm9kZS5jaGVja2VkID0gZmFsc2U7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHVwZGF0ZUNsYXNzTmFtZSA9IEF0dHJpYnV0ZSR1cGRhdGVDbGFzc05hbWU7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVDbGFzc05hbWUoKSB7XG4gIFx0dGhpcy5ub2RlLmNsYXNzTmFtZSA9IHNhZmVUb1N0cmluZ1ZhbHVlKHRoaXMudmFsdWUpO1xuICB9XG5cbiAgdmFyIHVwZGF0ZUlkQXR0cmlidXRlID0gQXR0cmlidXRlJHVwZGF0ZUlkQXR0cmlidXRlO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVJZEF0dHJpYnV0ZSgpIHtcbiAgXHR2YXIgX3JlZiA9IHRoaXM7XG5cbiAgXHR2YXIgbm9kZSA9IF9yZWYubm9kZTtcbiAgXHR2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuXG4gIFx0dGhpcy5yb290Lm5vZGVzW3ZhbHVlXSA9IG5vZGU7XG4gIFx0bm9kZS5pZCA9IHZhbHVlO1xuICB9XG5cbiAgdmFyIHVwZGF0ZUlFU3R5bGVBdHRyaWJ1dGUgPSBBdHRyaWJ1dGUkdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZTtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZSgpIHtcbiAgXHR2YXIgbm9kZSwgdmFsdWU7XG5cbiAgXHRub2RlID0gdGhpcy5ub2RlO1xuICBcdHZhbHVlID0gdGhpcy52YWx1ZTtcblxuICBcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHR2YWx1ZSA9IFwiXCI7XG4gIFx0fVxuXG4gIFx0bm9kZS5zdHlsZS5zZXRBdHRyaWJ1dGUoXCJjc3NUZXh0XCIsIHZhbHVlKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZSA9IEF0dHJpYnV0ZSR1cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZTtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWUoKSB7XG4gIFx0dmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcblxuICBcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHR2YWx1ZSA9IFwiXCI7XG4gIFx0fVxuXG4gIFx0aWYgKCF0aGlzLmxvY2tlZCkge1xuICBcdFx0dGhpcy5ub2RlLmlubmVySFRNTCA9IHZhbHVlO1xuICBcdH1cbiAgfVxuXG4gIHZhciB1cGRhdGVWYWx1ZSA9IEF0dHJpYnV0ZSR1cGRhdGVWYWx1ZTtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlVmFsdWUoKSB7XG4gIFx0dmFyIF9yZWYgPSB0aGlzO1xuXG4gIFx0dmFyIG5vZGUgPSBfcmVmLm5vZGU7XG4gIFx0dmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcblxuICBcdC8vIHN0b3JlIGFjdHVhbCB2YWx1ZSwgc28gaXQgZG9lc24ndCBnZXQgY29lcmNlZCB0byBhIHN0cmluZ1xuICBcdG5vZGUuX3JhY3RpdmUudmFsdWUgPSB2YWx1ZTtcblxuICBcdC8vIHdpdGggdHdvLXdheSBiaW5kaW5nLCBvbmx5IHVwZGF0ZSBpZiB0aGUgY2hhbmdlIHdhc24ndCBpbml0aWF0ZWQgYnkgdGhlIHVzZXJcbiAgXHQvLyBvdGhlcndpc2UgdGhlIGN1cnNvciB3aWxsIG9mdGVuIGJlIHNlbnQgdG8gdGhlIHdyb25nIHBsYWNlXG4gIFx0aWYgKCF0aGlzLmxvY2tlZCkge1xuICBcdFx0bm9kZS52YWx1ZSA9IHZhbHVlID09IHVuZGVmaW5lZCA/IFwiXCIgOiB2YWx1ZTtcbiAgXHR9XG4gIH1cblxuICB2YXIgdXBkYXRlQm9vbGVhbiA9IEF0dHJpYnV0ZSR1cGRhdGVCb29sZWFuQXR0cmlidXRlO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVCb29sZWFuQXR0cmlidXRlKCkge1xuICBcdC8vIHdpdGggdHdvLXdheSBiaW5kaW5nLCBvbmx5IHVwZGF0ZSBpZiB0aGUgY2hhbmdlIHdhc24ndCBpbml0aWF0ZWQgYnkgdGhlIHVzZXJcbiAgXHQvLyBvdGhlcndpc2UgdGhlIGN1cnNvciB3aWxsIG9mdGVuIGJlIHNlbnQgdG8gdGhlIHdyb25nIHBsYWNlXG4gIFx0aWYgKCF0aGlzLmxvY2tlZCkge1xuICBcdFx0dGhpcy5ub2RlW3RoaXMucHJvcGVydHlOYW1lXSA9IHRoaXMudmFsdWU7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHVwZGF0ZUV2ZXJ5dGhpbmdFbHNlID0gQXR0cmlidXRlJHVwZGF0ZUV2ZXJ5dGhpbmdFbHNlO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVFdmVyeXRoaW5nRWxzZSgpIHtcbiAgXHR2YXIgX3JlZiA9IHRoaXM7XG5cbiAgXHR2YXIgbm9kZSA9IF9yZWYubm9kZTtcbiAgXHR2YXIgbmFtZXNwYWNlID0gX3JlZi5uYW1lc3BhY2U7XG4gIFx0dmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gIFx0dmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcbiAgXHR2YXIgZnJhZ21lbnQgPSBfcmVmLmZyYWdtZW50O1xuXG4gIFx0aWYgKG5hbWVzcGFjZSkge1xuICBcdFx0bm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUsIChmcmFnbWVudCB8fCB2YWx1ZSkudG9TdHJpbmcoKSk7XG4gIFx0fSBlbHNlIGlmICghdGhpcy5pc0Jvb2xlYW4pIHtcbiAgXHRcdGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gIFx0XHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgKGZyYWdtZW50IHx8IHZhbHVlKS50b1N0cmluZygpKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgLSB0cnV0aHkgYmVjb21lcyAnJywgZmFsc3kgbWVhbnMgJ3JlbW92ZSBhdHRyaWJ1dGUnXG4gIFx0ZWxzZSB7XG4gIFx0XHRpZiAodmFsdWUpIHtcbiAgXHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgXCJcIik7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICAvLyBUaGVyZSBhcmUgYSBmZXcgc3BlY2lhbCBjYXNlcyB3aGVuIGl0IGNvbWVzIHRvIHVwZGF0aW5nIGF0dHJpYnV0ZXMuIEZvciB0aGlzIHJlYXNvbixcbiAgLy8gdGhlIHByb3RvdHlwZSAudXBkYXRlKCkgbWV0aG9kIHBvaW50cyB0byB0aGlzIG1ldGhvZCwgd2hpY2ggd2FpdHMgdW50aWwgdGhlXG4gIC8vIGF0dHJpYnV0ZSBoYXMgZmluaXNoZWQgaW5pdGlhbGlzaW5nLCB0aGVuIHJlcGxhY2VzIHRoZSBwcm90b3R5cGUgbWV0aG9kIHdpdGggYSBtb3JlXG4gIC8vIHN1aXRhYmxlIG9uZS4gVGhhdCB3YXksIHdlIHNhdmUgb3Vyc2VsdmVzIGRvaW5nIGEgYnVuY2ggb2YgdGVzdHMgb24gZWFjaCBjYWxsXG4gIHZhciBBdHRyaWJ1dGVfcHJvdG90eXBlX3VwZGF0ZSA9IEF0dHJpYnV0ZSR1cGRhdGU7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGUoKSB7XG4gIFx0dmFyIF9yZWYgPSB0aGlzO1xuXG4gIFx0dmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gIFx0dmFyIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQ7XG4gIFx0dmFyIG5vZGUgPSBfcmVmLm5vZGU7dmFyIHR5cGU7dmFyIHVwZGF0ZU1ldGhvZDtcblxuICBcdGlmIChuYW1lID09PSBcImlkXCIpIHtcbiAgXHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUlkQXR0cmlidXRlO1xuICBcdH0gZWxzZSBpZiAobmFtZSA9PT0gXCJ2YWx1ZVwiKSB7XG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBzZWxlY3RzXG4gIFx0XHRpZiAoZWxlbWVudC5uYW1lID09PSBcInNlbGVjdFwiICYmIG5hbWUgPT09IFwidmFsdWVcIikge1xuICBcdFx0XHR1cGRhdGVNZXRob2QgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIpID8gdXBkYXRlTXVsdGlwbGVTZWxlY3RWYWx1ZSA6IHVwZGF0ZVNlbGVjdFZhbHVlO1xuICBcdFx0fSBlbHNlIGlmIChlbGVtZW50Lm5hbWUgPT09IFwidGV4dGFyZWFcIikge1xuICBcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVWYWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gY29udGVudGVkaXRhYmxlXG4gIFx0XHRlbHNlIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSAhPSBudWxsKSB7XG4gIFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSA8aW5wdXQ+XG4gIFx0XHRlbHNlIGlmIChlbGVtZW50Lm5hbWUgPT09IFwiaW5wdXRcIikge1xuICBcdFx0XHR0eXBlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuXG4gIFx0XHRcdC8vIHR5cGU9J2ZpbGUnIHZhbHVlPSd7e2ZpbGVMaXN0fX0nPlxuICBcdFx0XHRpZiAodHlwZSA9PT0gXCJmaWxlXCIpIHtcbiAgXHRcdFx0XHR1cGRhdGVNZXRob2QgPSBub29wOyAvLyByZWFkLW9ubHlcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIHR5cGU9J3JhZGlvJyBuYW1lPSd7e3R3b3dheX19J1xuICBcdFx0XHRlbHNlIGlmICh0eXBlID09PSBcInJhZGlvXCIgJiYgZWxlbWVudC5iaW5kaW5nICYmIGVsZW1lbnQuYmluZGluZy5uYW1lID09PSBcIm5hbWVcIikge1xuICBcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZVJhZGlvVmFsdWU7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlVmFsdWU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBzcGVjaWFsIGNhc2UgLSA8aW5wdXQgdHlwZT0ncmFkaW8nIG5hbWU9J3t7dHdvd2F5fX0nIHZhbHVlPSdmb28nPlxuICBcdGVsc2UgaWYgKHRoaXMuaXNUd293YXkgJiYgbmFtZSA9PT0gXCJuYW1lXCIpIHtcbiAgXHRcdGlmIChub2RlLnR5cGUgPT09IFwicmFkaW9cIikge1xuICBcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVSYWRpb05hbWU7XG4gIFx0XHR9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJjaGVja2JveFwiKSB7XG4gIFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUNoZWNrYm94TmFtZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBzcGVjaWFsIGNhc2UgLSBzdHlsZSBhdHRyaWJ1dGVzIGluIEludGVybmV0IEV4cGxvZGVyXG4gIFx0ZWxzZSBpZiAobmFtZSA9PT0gXCJzdHlsZVwiICYmIG5vZGUuc3R5bGUuc2V0QXR0cmlidXRlKSB7XG4gIFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVJRVN0eWxlQXR0cmlidXRlO1xuICBcdH1cblxuICBcdC8vIHNwZWNpYWwgY2FzZSAtIGNsYXNzIG5hbWVzLiBJRSBmdWNrcyB0aGluZ3MgdXAsIGFnYWluXG4gIFx0ZWxzZSBpZiAobmFtZSA9PT0gXCJjbGFzc1wiICYmICghbm9kZS5uYW1lc3BhY2VVUkkgfHwgbm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuaHRtbCkpIHtcbiAgXHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUNsYXNzTmFtZTtcbiAgXHR9IGVsc2UgaWYgKHRoaXMudXNlUHJvcGVydHkpIHtcbiAgXHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUJvb2xlYW47XG4gIFx0fVxuXG4gIFx0aWYgKCF1cGRhdGVNZXRob2QpIHtcbiAgXHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUV2ZXJ5dGhpbmdFbHNlO1xuICBcdH1cblxuICBcdHRoaXMudXBkYXRlID0gdXBkYXRlTWV0aG9kO1xuICBcdHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICB2YXIgQXR0cmlidXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLmluaXQob3B0aW9ucyk7XG4gIH07XG5cbiAgQXR0cmlidXRlLnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IEF0dHJpYnV0ZV9wcm90b3R5cGVfYnViYmxlLFxuICBcdGluaXQ6IHByb3RvdHlwZV9pbml0LFxuICBcdHJlYmluZDogQXR0cmlidXRlX3Byb3RvdHlwZV9yZWJpbmQsXG4gIFx0cmVuZGVyOiBBdHRyaWJ1dGVfcHJvdG90eXBlX3JlbmRlcixcbiAgXHR0b1N0cmluZzogQXR0cmlidXRlX3Byb3RvdHlwZV90b1N0cmluZyxcbiAgXHR1bmJpbmQ6IEF0dHJpYnV0ZV9wcm90b3R5cGVfdW5iaW5kLFxuICBcdHVwZGF0ZTogQXR0cmlidXRlX3Byb3RvdHlwZV91cGRhdGVcbiAgfTtcblxuICB2YXIgX0F0dHJpYnV0ZSA9IEF0dHJpYnV0ZTtcblxuICB2YXIgY3JlYXRlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gIFx0dmFyIG5hbWUsXG4gIFx0ICAgIGF0dHJpYnV0ZSxcbiAgXHQgICAgcmVzdWx0ID0gW107XG5cbiAgXHRmb3IgKG5hbWUgaW4gYXR0cmlidXRlcykge1xuICBcdFx0Ly8gc2tpcCBiaW5kaW5nIGF0dHJpYnV0ZXNcbiAgXHRcdGlmIChuYW1lID09PSBcInR3b3dheVwiIHx8IG5hbWUgPT09IFwibGF6eVwiKSB7XG4gIFx0XHRcdGNvbnRpbnVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICBcdFx0XHRhdHRyaWJ1dGUgPSBuZXcgX0F0dHJpYnV0ZSh7XG4gIFx0XHRcdFx0ZWxlbWVudDogZWxlbWVudCxcbiAgXHRcdFx0XHRuYW1lOiBuYW1lLFxuICBcdFx0XHRcdHZhbHVlOiBhdHRyaWJ1dGVzW25hbWVdLFxuICBcdFx0XHRcdHJvb3Q6IGVsZW1lbnQucm9vdFxuICBcdFx0XHR9KTtcblxuICBcdFx0XHRyZXN1bHRbbmFtZV0gPSBhdHRyaWJ1dGU7XG5cbiAgXHRcdFx0aWYgKG5hbWUgIT09IFwidmFsdWVcIikge1xuICBcdFx0XHRcdHJlc3VsdC5wdXNoKGF0dHJpYnV0ZSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyB2YWx1ZSBhdHRyaWJ1dGUgZ29lcyBsYXN0LiBUaGlzIGlzIGJlY2F1c2UgaXRcbiAgXHQvLyBtYXkgZ2V0IGNsYW1wZWQgb24gcmVuZGVyIG90aGVyd2lzZSwgZS5nLiBpblxuICBcdC8vIGA8aW5wdXQgdHlwZT0ncmFuZ2UnIHZhbHVlPSc5OTknIG1pbj0nMCcgbWF4PScxMDAwJz5gXG4gIFx0Ly8gc2luY2UgZGVmYXVsdCBtYXggaXMgMTAwXG4gIFx0aWYgKGF0dHJpYnV0ZSA9IHJlc3VsdC52YWx1ZSkge1xuICBcdFx0cmVzdWx0LnB1c2goYXR0cmlidXRlKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBfQ29uZGl0aW9uYWxBdHRyaWJ1dGVfX2RpdjtcblxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIFx0X0NvbmRpdGlvbmFsQXR0cmlidXRlX19kaXYgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICB9XG5cbiAgdmFyIENvbmRpdGlvbmFsQXR0cmlidXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHRlbXBsYXRlKSB7XG4gIFx0dGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgXHR0aGlzLnJvb3QgPSBlbGVtZW50LnJvb3Q7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGVsZW1lbnQucGFyZW50RnJhZ21lbnQ7XG5cbiAgXHR0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcblxuICBcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRyb290OiBlbGVtZW50LnJvb3QsXG4gIFx0XHRvd25lcjogdGhpcyxcbiAgXHRcdHRlbXBsYXRlOiBbdGVtcGxhdGVdXG4gIFx0fSk7XG4gIH07XG5cbiAgQ29uZGl0aW9uYWxBdHRyaWJ1dGUucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMubm9kZSkge1xuICBcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmVsZW1lbnQuYnViYmxlKCk7XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gIFx0XHR0aGlzLm5vZGUgPSBub2RlO1xuICBcdFx0dGhpcy5pc1N2ZyA9IG5vZGUubmFtZXNwYWNlVVJJID09PSBuYW1lc3BhY2VzLnN2ZztcblxuICBcdFx0dGhpcy51cGRhdGUoKTtcbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdH0sXG5cbiAgXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdHZhciBzdHIsIGF0dHJzO1xuXG4gIFx0XHRzdHIgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCk7XG4gIFx0XHRhdHRycyA9IHBhcnNlQXR0cmlidXRlcyhzdHIsIHRoaXMuaXNTdmcpO1xuXG4gIFx0XHQvLyBhbnkgYXR0cmlidXRlcyB0aGF0IHByZXZpb3VzbHkgZXhpc3RlZCBidXQgbm8gbG9uZ2VyIGRvXG4gIFx0XHQvLyBtdXN0IGJlIHJlbW92ZWRcbiAgXHRcdHRoaXMuYXR0cmlidXRlcy5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcbiAgXHRcdFx0cmV0dXJuIG5vdEluKGF0dHJzLCBhKTtcbiAgXHRcdH0pLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgXHRcdFx0X3RoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoYS5uYW1lKTtcbiAgXHRcdH0pO1xuXG4gIFx0XHRhdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gIFx0XHRcdF90aGlzLm5vZGUuc2V0QXR0cmlidXRlKGEubmFtZSwgYS52YWx1ZSk7XG4gIFx0XHR9KTtcblxuICBcdFx0dGhpcy5hdHRyaWJ1dGVzID0gYXR0cnM7XG4gIFx0fSxcblxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC50b1N0cmluZygpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgX0NvbmRpdGlvbmFsQXR0cmlidXRlID0gQ29uZGl0aW9uYWxBdHRyaWJ1dGU7XG5cbiAgZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVzKHN0ciwgaXNTdmcpIHtcbiAgXHR2YXIgdGFnID0gaXNTdmcgPyBcInN2Z1wiIDogXCJkaXZcIjtcbiAgXHRfQ29uZGl0aW9uYWxBdHRyaWJ1dGVfX2Rpdi5pbm5lckhUTUwgPSBcIjxcIiArIHRhZyArIFwiIFwiICsgc3RyICsgXCI+PC9cIiArIHRhZyArIFwiPlwiO1xuXG4gIFx0cmV0dXJuIHRvQXJyYXkoX0NvbmRpdGlvbmFsQXR0cmlidXRlX19kaXYuY2hpbGROb2Rlc1swXS5hdHRyaWJ1dGVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdEluKGhheXN0YWNrLCBuZWVkbGUpIHtcbiAgXHR2YXIgaSA9IGhheXN0YWNrLmxlbmd0aDtcblxuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGlmIChoYXlzdGFja1tpXS5uYW1lID09PSBuZWVkbGUubmFtZSkge1xuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgY3JlYXRlQ29uZGl0aW9uYWxBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgXHRpZiAoIWF0dHJpYnV0ZXMpIHtcbiAgXHRcdHJldHVybiBbXTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gYXR0cmlidXRlcy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgXHRcdHJldHVybiBuZXcgX0NvbmRpdGlvbmFsQXR0cmlidXRlKGVsZW1lbnQsIGEpO1xuICBcdH0pO1xuICB9O1xuXG4gIHZhciBCaW5kaW5nID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgXHR2YXIgaW50ZXJwb2xhdG9yLCBrZXlwYXRoLCB2YWx1ZSwgcGFyZW50Rm9ybTtcblxuICBcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIFx0dGhpcy5yb290ID0gZWxlbWVudC5yb290O1xuICBcdHRoaXMuYXR0cmlidXRlID0gZWxlbWVudC5hdHRyaWJ1dGVzW3RoaXMubmFtZSB8fCBcInZhbHVlXCJdO1xuXG4gIFx0aW50ZXJwb2xhdG9yID0gdGhpcy5hdHRyaWJ1dGUuaW50ZXJwb2xhdG9yO1xuICBcdGludGVycG9sYXRvci50d293YXlCaW5kaW5nID0gdGhpcztcblxuICBcdGlmIChrZXlwYXRoID0gaW50ZXJwb2xhdG9yLmtleXBhdGgpIHtcbiAgXHRcdGlmIChrZXlwYXRoLnN0ci5zbGljZSgtMSkgPT09IFwifVwiKSB7XG4gIFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyhcIlR3by13YXkgYmluZGluZyBkb2VzIG5vdCB3b3JrIHdpdGggZXhwcmVzc2lvbnMgKGAlc2Agb24gPCVzPilcIiwgaW50ZXJwb2xhdG9yLnJlc29sdmVyLnVuaXF1ZVN0cmluZywgZWxlbWVudC5uYW1lLCB7IHJhY3RpdmU6IHRoaXMucm9vdCB9KTtcbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoa2V5cGF0aC5pc1NwZWNpYWwpIHtcbiAgXHRcdFx0d2Fybk9uY2VJZkRlYnVnKFwiVHdvLXdheSBiaW5kaW5nIGRvZXMgbm90IHdvcmsgd2l0aCAlc1wiLCBpbnRlcnBvbGF0b3IucmVzb2x2ZXIucmVmLCB7IHJhY3RpdmU6IHRoaXMucm9vdCB9KTtcbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHQvLyBBIG11c3RhY2hlIG1heSBiZSAqYW1iaWd1b3VzKi4gTGV0J3Mgc2F5IHdlIHdlcmUgZ2l2ZW5cbiAgXHRcdC8vIGB2YWx1ZT1cInt7YmFyfX1cImAuIElmIHRoZSBjb250ZXh0IHdhcyBgZm9vYCwgYW5kIGBmb28uYmFyYFxuICBcdFx0Ly8gKndhc24ndCogYHVuZGVmaW5lZGAsIHRoZSBrZXlwYXRoIHdvdWxkIGJlIGBmb28uYmFyYC5cbiAgXHRcdC8vIFRoZW4sIGFueSB1c2VyIGlucHV0IHdvdWxkIHJlc3VsdCBpbiBgZm9vLmJhcmAgYmVpbmcgdXBkYXRlZC5cbiAgXHRcdC8vXG4gIFx0XHQvLyBJZiwgaG93ZXZlciwgYGZvby5iYXJgICp3YXMqIHVuZGVmaW5lZCwgYW5kIHNvIHdhcyBgYmFyYCwgd2Ugd291bGQgYmVcbiAgXHRcdC8vIGxlZnQgd2l0aCBhbiB1bnJlc29sdmVkIHBhcnRpYWwga2V5cGF0aCAtIHNvIHdlIGFyZSBmb3JjZWQgdG8gbWFrZSBhblxuICBcdFx0Ly8gYXNzdW1wdGlvbi4gVGhhdCBhc3N1bXB0aW9uIGlzIHRoYXQgdGhlIGlucHV0IGluIHF1ZXN0aW9uIHNob3VsZFxuICBcdFx0Ly8gYmUgZm9yY2VkIHRvIHJlc29sdmUgdG8gYGJhcmAsIGFuZCBhbnkgdXNlciBpbnB1dCB3b3VsZCBhZmZlY3QgYGJhcmBcbiAgXHRcdC8vIGFuZCBub3QgYGZvby5iYXJgLlxuICBcdFx0Ly9cbiAgXHRcdC8vIERpZCB0aGF0IG1ha2UgYW55IHNlbnNlPyBObz8gT2guIFNvcnJ5LiBXZWxsIHRoZSBtb3JhbCBvZiB0aGUgc3RvcnkgaXNcbiAgXHRcdC8vIGJlIGV4cGxpY2l0IHdoZW4gdXNpbmcgdHdvLXdheSBkYXRhLWJpbmRpbmcgYWJvdXQgd2hhdCBrZXlwYXRoIHlvdSdyZVxuICBcdFx0Ly8gdXBkYXRpbmcuIFVzaW5nIGl0IGluIGxpc3RzIGlzIHByb2JhYmx5IGEgcmVjaXBlIGZvciBjb25mdXNpb24uLi5cbiAgXHRcdHZhciByZWYgPSBpbnRlcnBvbGF0b3IudGVtcGxhdGUuciA/IFwiJ1wiICsgaW50ZXJwb2xhdG9yLnRlbXBsYXRlLnIgKyBcIicgcmVmZXJlbmNlXCIgOiBcImV4cHJlc3Npb25cIjtcbiAgXHRcdHdhcm5JZkRlYnVnKFwiVGhlICVzIGJlaW5nIHVzZWQgZm9yIHR3by13YXkgYmluZGluZyBpcyBhbWJpZ3VvdXMsIGFuZCBtYXkgY2F1c2UgdW5leHBlY3RlZCByZXN1bHRzLiBDb25zaWRlciBpbml0aWFsaXNpbmcgeW91ciBkYXRhIHRvIGVsaW1pbmF0ZSB0aGUgYW1iaWd1aXR5XCIsIHJlZiwgeyByYWN0aXZlOiB0aGlzLnJvb3QgfSk7XG4gIFx0XHRpbnRlcnBvbGF0b3IucmVzb2x2ZXIuZm9yY2VSZXNvbHV0aW9uKCk7XG4gIFx0XHRrZXlwYXRoID0gaW50ZXJwb2xhdG9yLmtleXBhdGg7XG4gIFx0fVxuXG4gIFx0dGhpcy5hdHRyaWJ1dGUuaXNUd293YXkgPSB0cnVlO1xuICBcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cbiAgXHQvLyBpbml0aWFsaXNlIHZhbHVlLCBpZiBpdCdzIHVuZGVmaW5lZFxuICBcdHZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLmdldEluaXRpYWxWYWx1ZSkge1xuICBcdFx0dmFsdWUgPSB0aGlzLmdldEluaXRpYWxWYWx1ZSgpO1xuXG4gIFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldChrZXlwYXRoLCB2YWx1ZSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKHBhcmVudEZvcm0gPSBmaW5kUGFyZW50Rm9ybShlbGVtZW50KSkge1xuICBcdFx0dGhpcy5yZXNldFZhbHVlID0gdmFsdWU7XG4gIFx0XHRwYXJlbnRGb3JtLmZvcm1CaW5kaW5ncy5wdXNoKHRoaXMpO1xuICBcdH1cbiAgfTtcblxuICBCaW5kaW5nLnByb3RvdHlwZSA9IHtcbiAgXHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMucm9vdCk7XG4gIFx0XHR0aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSB0cnVlO1xuICBcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQodGhpcy5rZXlwYXRoLCB0aGlzLmdldFZhbHVlKCkpO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuIF90aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSBmYWxzZTtcbiAgXHRcdH0pO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIFx0fSxcblxuICBcdHJlYm91bmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBiaW5kaW5ncywgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aDtcblxuICBcdFx0b2xkS2V5cGF0aCA9IHRoaXMua2V5cGF0aDtcbiAgXHRcdG5ld0tleXBhdGggPSB0aGlzLmF0dHJpYnV0ZS5pbnRlcnBvbGF0b3Iua2V5cGF0aDtcblxuICBcdFx0Ly8gVGhlIGF0dHJpYnV0ZSB0aGlzIGJpbmRpbmcgaXMgbGlua2VkIHRvIGhhcyBhbHJlYWR5IGRvbmUgdGhlIHdvcmtcbiAgXHRcdGlmIChvbGRLZXlwYXRoID09PSBuZXdLZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3Nbb2xkS2V5cGF0aC5zdHJdLCB0aGlzKTtcblxuICBcdFx0dGhpcy5rZXlwYXRoID0gbmV3S2V5cGF0aDtcblxuICBcdFx0YmluZGluZ3MgPSB0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzW25ld0tleXBhdGguc3RyXSB8fCAodGhpcy5yb290Ll90d293YXlCaW5kaW5nc1tuZXdLZXlwYXRoLnN0cl0gPSBbXSk7XG4gIFx0XHRiaW5kaW5ncy5wdXNoKHRoaXMpO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHt9XG4gIH07XG5cbiAgQmluZGluZy5leHRlbmQgPSBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICBcdHZhciBQYXJlbnQgPSB0aGlzLFxuICBcdCAgICBTcGVjaWFsaXNlZEJpbmRpbmc7XG5cbiAgXHRTcGVjaWFsaXNlZEJpbmRpbmcgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICBcdFx0QmluZGluZy5jYWxsKHRoaXMsIGVsZW1lbnQpO1xuXG4gIFx0XHRpZiAodGhpcy5pbml0KSB7XG4gIFx0XHRcdHRoaXMuaW5pdCgpO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRTcGVjaWFsaXNlZEJpbmRpbmcucHJvdG90eXBlID0gY3JlYXRlKFBhcmVudC5wcm90b3R5cGUpO1xuICBcdHV0aWxzX29iamVjdF9fZXh0ZW5kKFNwZWNpYWxpc2VkQmluZGluZy5wcm90b3R5cGUsIHByb3BlcnRpZXMpO1xuXG4gIFx0U3BlY2lhbGlzZWRCaW5kaW5nLmV4dGVuZCA9IEJpbmRpbmcuZXh0ZW5kO1xuXG4gIFx0cmV0dXJuIFNwZWNpYWxpc2VkQmluZGluZztcbiAgfTtcblxuICB2YXIgQmluZGluZ19CaW5kaW5nID0gQmluZGluZztcblxuICBmdW5jdGlvbiBmaW5kUGFyZW50Rm9ybShlbGVtZW50KSB7XG4gIFx0d2hpbGUgKGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudCkge1xuICBcdFx0aWYgKGVsZW1lbnQubmFtZSA9PT0gXCJmb3JtXCIpIHtcbiAgXHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgLy8gdGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgZWxlbWVudCBpcyB1bmJvdW5kLlxuICAvLyBTcGVjaWFsaXNlZCBiaW5kaW5ncyBjYW4gb3ZlcnJpZGUgaXRcblxuICAvLyBUaGlzIGlzIHRoZSBoYW5kbGVyIGZvciBET00gZXZlbnRzIHRoYXQgd291bGQgbGVhZCB0byBhIGNoYW5nZSBpbiB0aGUgbW9kZWxcbiAgLy8gKGkuZS4gY2hhbmdlLCBzb21ldGltZXMsIGlucHV0LCBhbmQgb2NjYXNpb25hbGx5IGNsaWNrIGFuZCBrZXl1cClcbiAgdmFyIGhhbmRsZURvbUV2ZW50ID0gaGFuZGxlQ2hhbmdlO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUNoYW5nZSgpIHtcbiAgXHR0aGlzLl9yYWN0aXZlLmJpbmRpbmcuaGFuZGxlQ2hhbmdlKCk7XG4gIH1cblxuICB2YXIgR2VuZXJpY0JpbmRpbmc7XG5cbiAgR2VuZXJpY0JpbmRpbmcgPSBCaW5kaW5nX0JpbmRpbmcuZXh0ZW5kKHtcbiAgXHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBcIlwiO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLnZhbHVlO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGUsXG4gIFx0XHQgICAgbGF6eSxcbiAgXHRcdCAgICB0aW1lb3V0ID0gZmFsc2U7XG4gIFx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcblxuICBcdFx0Ly8gYW55IGxhenkgc2V0dGluZyBmb3IgdGhpcyBlbGVtZW50IG92ZXJyaWRlcyB0aGUgcm9vdFxuICBcdFx0Ly8gaWYgdGhlIHZhbHVlIGlzIGEgbnVtYmVyLCBpdCdzIGEgdGltZW91dFxuICBcdFx0bGF6eSA9IHRoaXMucm9vdC5sYXp5O1xuICBcdFx0aWYgKHRoaXMuZWxlbWVudC5sYXp5ID09PSB0cnVlKSB7XG4gIFx0XHRcdGxhenkgPSB0cnVlO1xuICBcdFx0fSBlbHNlIGlmICh0aGlzLmVsZW1lbnQubGF6eSA9PT0gZmFsc2UpIHtcbiAgXHRcdFx0bGF6eSA9IGZhbHNlO1xuICBcdFx0fSBlbHNlIGlmIChpc19faXNOdW1lcmljKHRoaXMuZWxlbWVudC5sYXp5KSkge1xuICBcdFx0XHRsYXp5ID0gZmFsc2U7XG4gIFx0XHRcdHRpbWVvdXQgPSArdGhpcy5lbGVtZW50Lmxhenk7XG4gIFx0XHR9IGVsc2UgaWYgKGlzX19pc051bWVyaWMobGF6eSB8fCBcIlwiKSkge1xuICBcdFx0XHR0aW1lb3V0ID0gK2xhenk7XG4gIFx0XHRcdGxhenkgPSBmYWxzZTtcblxuICBcdFx0XHQvLyBtYWtlIHN1cmUgdGhlIHRpbWVvdXQgaXMgYXZhaWxhYmxlIHRvIHRoZSBoYW5kbGVyXG4gIFx0XHRcdHRoaXMuZWxlbWVudC5sYXp5ID0gdGltZW91dDtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5oYW5kbGVyID0gdGltZW91dCA/IGhhbmRsZURlbGF5IDogaGFuZGxlRG9tRXZlbnQ7XG5cbiAgXHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuXG4gIFx0XHRpZiAoIWxhenkpIHtcbiAgXHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy5oYW5kbGVyLCBmYWxzZSk7XG5cbiAgXHRcdFx0aWYgKG5vZGUuYXR0YWNoRXZlbnQpIHtcbiAgXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLmhhbmRsZXIsIGZhbHNlKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGhhbmRsZUJsdXIsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG4gIFx0XHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG5cbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy5oYW5kbGVyLCBmYWxzZSk7XG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLmhhbmRsZXIsIGZhbHNlKTtcbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgaGFuZGxlQmx1ciwgZmFsc2UpO1xuICBcdH1cbiAgfSk7XG5cbiAgdmFyIEJpbmRpbmdfR2VuZXJpY0JpbmRpbmcgPSBHZW5lcmljQmluZGluZztcblxuICBmdW5jdGlvbiBoYW5kbGVCbHVyKCkge1xuICBcdHZhciB2YWx1ZTtcblxuICBcdGhhbmRsZURvbUV2ZW50LmNhbGwodGhpcyk7XG5cbiAgXHR2YWx1ZSA9IHRoaXMuX3JhY3RpdmUucm9vdC52aWV3bW9kZWwuZ2V0KHRoaXMuX3JhY3RpdmUuYmluZGluZy5rZXlwYXRoKTtcbiAgXHR0aGlzLnZhbHVlID0gdmFsdWUgPT0gdW5kZWZpbmVkID8gXCJcIiA6IHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRGVsYXkoKSB7XG4gIFx0dmFyIGJpbmRpbmcgPSB0aGlzLl9yYWN0aXZlLmJpbmRpbmcsXG4gIFx0ICAgIGVsID0gdGhpcztcblxuICBcdGlmICghIWJpbmRpbmcuX3RpbWVvdXQpIGNsZWFyVGltZW91dChiaW5kaW5nLl90aW1lb3V0KTtcblxuICBcdGJpbmRpbmcuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmIChiaW5kaW5nLnJlbmRlcmVkKSBoYW5kbGVEb21FdmVudC5jYWxsKGVsKTtcbiAgXHRcdGJpbmRpbmcuX3RpbWVvdXQgPSB1bmRlZmluZWQ7XG4gIFx0fSwgYmluZGluZy5lbGVtZW50LmxhenkpO1xuICB9XG5cbiAgdmFyIENvbnRlbnRFZGl0YWJsZUJpbmRpbmcgPSBCaW5kaW5nX0dlbmVyaWNCaW5kaW5nLmV4dGVuZCh7XG4gIFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50LmZyYWdtZW50ID8gdGhpcy5lbGVtZW50LmZyYWdtZW50LnRvU3RyaW5nKCkgOiBcIlwiO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmlubmVySFRNTDtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBCaW5kaW5nX0NvbnRlbnRFZGl0YWJsZUJpbmRpbmcgPSBDb250ZW50RWRpdGFibGVCaW5kaW5nO1xuXG4gIHZhciBzaGFyZWRfZ2V0U2libGluZ3MgPSBnZXRTaWJsaW5ncztcbiAgdmFyIHNldHMgPSB7fTtcbiAgZnVuY3Rpb24gZ2V0U2libGluZ3MoaWQsIGdyb3VwLCBrZXlwYXRoKSB7XG4gIFx0dmFyIGhhc2ggPSBpZCArIGdyb3VwICsga2V5cGF0aDtcbiAgXHRyZXR1cm4gc2V0c1toYXNoXSB8fCAoc2V0c1toYXNoXSA9IFtdKTtcbiAgfVxuXG4gIHZhciBSYWRpb0JpbmRpbmcgPSBCaW5kaW5nX0JpbmRpbmcuZXh0ZW5kKHtcbiAgXHRuYW1lOiBcImNoZWNrZWRcIixcblxuICBcdGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuc2libGluZ3MgPSBzaGFyZWRfZ2V0U2libGluZ3ModGhpcy5yb290Ll9ndWlkLCBcInJhZGlvXCIsIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpKTtcbiAgXHRcdHRoaXMuc2libGluZ3MucHVzaCh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcblxuICBcdFx0aWYgKG5vZGUuYXR0YWNoRXZlbnQpIHtcbiAgXHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLnJvb3QpO1xuXG4gIFx0XHR0aGlzLnNpYmxpbmdzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgXHRcdFx0YmluZGluZy5yb290LnZpZXdtb2RlbC5zZXQoYmluZGluZy5rZXlwYXRoLCBiaW5kaW5nLmdldFZhbHVlKCkpO1xuICBcdFx0fSk7XG5cbiAgXHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMuc2libGluZ3MsIHRoaXMpO1xuICBcdH1cbiAgfSk7XG5cbiAgdmFyIEJpbmRpbmdfUmFkaW9CaW5kaW5nID0gUmFkaW9CaW5kaW5nO1xuXG4gIHZhciBSYWRpb05hbWVCaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0bmFtZTogXCJuYW1lXCIsXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLnNpYmxpbmdzID0gc2hhcmVkX2dldFNpYmxpbmdzKHRoaXMucm9vdC5fZ3VpZCwgXCJyYWRpb25hbWVcIiwgdGhpcy5rZXlwYXRoLnN0cik7XG4gIFx0XHR0aGlzLnNpYmxpbmdzLnB1c2godGhpcyk7XG5cbiAgXHRcdHRoaXMucmFkaW9OYW1lID0gdHJ1ZTsgLy8gc28gdGhhdCByYWN0aXZlLnVwZGF0ZU1vZGVsKCkga25vd3Mgd2hhdCB0byBkbyB3aXRoIHRoaXNcbiAgXHR9LFxuXG4gIFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImNoZWNrZWRcIikpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRub2RlLm5hbWUgPSBcInt7XCIgKyB0aGlzLmtleXBhdGguc3RyICsgXCJ9fVwiO1xuICBcdFx0bm9kZS5jaGVja2VkID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQodGhpcy5rZXlwYXRoKSA9PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cbiAgXHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuXG4gIFx0XHRpZiAobm9kZS5hdHRhY2hFdmVudCkge1xuICBcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblxuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcbiAgXHRcdHJldHVybiBub2RlLl9yYWN0aXZlID8gbm9kZS5fcmFjdGl2ZS52YWx1ZSA6IG5vZGUudmFsdWU7XG4gIFx0fSxcblxuICBcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gSWYgdGhpcyA8aW5wdXQ+IGlzIHRoZSBvbmUgdGhhdCdzIGNoZWNrZWQsIHRoZW4gdGhlIHZhbHVlIG9mIGl0c1xuICBcdFx0Ly8gYG5hbWVgIGtleXBhdGggZ2V0cyBzZXQgdG8gaXRzIHZhbHVlXG4gIFx0XHRpZiAodGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZCkge1xuICBcdFx0XHRCaW5kaW5nX0JpbmRpbmcucHJvdG90eXBlLmhhbmRsZUNoYW5nZS5jYWxsKHRoaXMpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZWJvdW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0dmFyIG5vZGU7XG5cbiAgXHRcdEJpbmRpbmdfQmluZGluZy5wcm90b3R5cGUucmVib3VuZC5jYWxsKHRoaXMsIG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuXG4gIFx0XHRpZiAobm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlKSB7XG4gIFx0XHRcdG5vZGUubmFtZSA9IFwie3tcIiArIHRoaXMua2V5cGF0aC5zdHIgKyBcIn19XCI7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMuc2libGluZ3MsIHRoaXMpO1xuICBcdH1cbiAgfSk7XG5cbiAgdmFyIEJpbmRpbmdfUmFkaW9OYW1lQmluZGluZyA9IFJhZGlvTmFtZUJpbmRpbmc7XG5cbiAgdmFyIENoZWNrYm94TmFtZUJpbmRpbmcgPSBCaW5kaW5nX0JpbmRpbmcuZXh0ZW5kKHtcbiAgXHRuYW1lOiBcIm5hbWVcIixcblxuICBcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gVGhpcyBvbmx5IGdldHMgY2FsbGVkIG9uY2UgcGVyIGdyb3VwIChvZiBpbnB1dHMgdGhhdFxuICBcdFx0Ly8gc2hhcmUgYSBuYW1lKSwgYmVjYXVzZSBpdCBvbmx5IGdldHMgY2FsbGVkIGlmIHRoZXJlXG4gIFx0XHQvLyBpc24ndCBhbiBpbml0aWFsIHZhbHVlLiBCeSB0aGUgc2FtZSB0b2tlbiwgd2UgY2FuIG1ha2VcbiAgXHRcdC8vIGEgbm90ZSBvZiB0aGF0IGZhY3QgdGhhdCB0aGVyZSB3YXMgbm8gaW5pdGlhbCB2YWx1ZSxcbiAgXHRcdC8vIGFuZCBwb3B1bGF0ZSBpdCB1c2luZyBhbnkgYGNoZWNrZWRgIGF0dHJpYnV0ZXMgdGhhdFxuICBcdFx0Ly8gZXhpc3QgKHdoaWNoIHVzZXJzIHNob3VsZCBhdm9pZCwgYnV0IHdoaWNoIHdlIHNob3VsZFxuICBcdFx0Ly8gc3VwcG9ydCBhbnl3YXkgdG8gYXZvaWQgYnJlYWtpbmcgZXhwZWN0YXRpb25zKVxuICBcdFx0dGhpcy5ub0luaXRpYWxWYWx1ZSA9IHRydWU7XG4gIFx0XHRyZXR1cm4gW107XG4gIFx0fSxcblxuICBcdGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBleGlzdGluZ1ZhbHVlLCBiaW5kaW5nVmFsdWU7XG5cbiAgXHRcdHRoaXMuY2hlY2tib3hOYW1lID0gdHJ1ZTsgLy8gc28gdGhhdCByYWN0aXZlLnVwZGF0ZU1vZGVsKCkga25vd3Mgd2hhdCB0byBkbyB3aXRoIHRoaXNcblxuICBcdFx0Ly8gRWFjaCBpbnB1dCBoYXMgYSByZWZlcmVuY2UgdG8gYW4gYXJyYXkgY29udGFpbmluZyBpdCBhbmQgaXRzXG4gIFx0XHQvLyBzaWJsaW5ncywgYXMgdHdvLXdheSBiaW5kaW5nIGRlcGVuZHMgb24gYmVpbmcgYWJsZSB0byBhc2NlcnRhaW5cbiAgXHRcdC8vIHRoZSBzdGF0dXMgb2YgYWxsIGlucHV0cyB3aXRoaW4gdGhlIGdyb3VwXG4gIFx0XHR0aGlzLnNpYmxpbmdzID0gc2hhcmVkX2dldFNpYmxpbmdzKHRoaXMucm9vdC5fZ3VpZCwgXCJjaGVja2JveGVzXCIsIHRoaXMua2V5cGF0aC5zdHIpO1xuICBcdFx0dGhpcy5zaWJsaW5ncy5wdXNoKHRoaXMpO1xuXG4gIFx0XHRpZiAodGhpcy5ub0luaXRpYWxWYWx1ZSkge1xuICBcdFx0XHR0aGlzLnNpYmxpbmdzLm5vSW5pdGlhbFZhbHVlID0gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gSWYgbm8gaW5pdGlhbCB2YWx1ZSB3YXMgc2V0LCBhbmQgdGhpcyBpbnB1dCBpcyBjaGVja2VkLCB3ZVxuICBcdFx0Ly8gdXBkYXRlIHRoZSBtb2RlbFxuICBcdFx0aWYgKHRoaXMuc2libGluZ3Mubm9Jbml0aWFsVmFsdWUgJiYgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImNoZWNrZWRcIikpIHtcbiAgXHRcdFx0ZXhpc3RpbmdWYWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KHRoaXMua2V5cGF0aCk7XG4gIFx0XHRcdGJpbmRpbmdWYWx1ZSA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcblxuICBcdFx0XHRleGlzdGluZ1ZhbHVlLnB1c2goYmluZGluZ1ZhbHVlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkodGhpcy5zaWJsaW5ncywgdGhpcyk7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZSxcbiAgXHRcdCAgICBleGlzdGluZ1ZhbHVlLFxuICBcdFx0ICAgIGJpbmRpbmdWYWx1ZTtcblxuICBcdFx0ZXhpc3RpbmdWYWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KHRoaXMua2V5cGF0aCk7XG4gIFx0XHRiaW5kaW5nVmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cbiAgXHRcdGlmIChpc0FycmF5KGV4aXN0aW5nVmFsdWUpKSB7XG4gIFx0XHRcdHRoaXMuaXNDaGVja2VkID0gYXJyYXlDb250YWlucyhleGlzdGluZ1ZhbHVlLCBiaW5kaW5nVmFsdWUpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5pc0NoZWNrZWQgPSBleGlzdGluZ1ZhbHVlID09IGJpbmRpbmdWYWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0bm9kZS5uYW1lID0gXCJ7e1wiICsgdGhpcy5rZXlwYXRoLnN0ciArIFwifX1cIjtcbiAgXHRcdG5vZGUuY2hlY2tlZCA9IHRoaXMuaXNDaGVja2VkO1xuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcblxuICBcdFx0Ly8gaW4gY2FzZSBvZiBJRSBlbWVyZ2VuY3ksIGJpbmQgdG8gY2xpY2sgZXZlbnQgYXMgd2VsbFxuICBcdFx0aWYgKG5vZGUuYXR0YWNoRXZlbnQpIHtcbiAgXHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0Y2hhbmdlZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHdhc0NoZWNrZWQgPSAhIXRoaXMuaXNDaGVja2VkO1xuICBcdFx0dGhpcy5pc0NoZWNrZWQgPSB0aGlzLmVsZW1lbnQubm9kZS5jaGVja2VkO1xuICBcdFx0cmV0dXJuIHRoaXMuaXNDaGVja2VkID09PSB3YXNDaGVja2VkO1xuICBcdH0sXG5cbiAgXHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuaXNDaGVja2VkID0gdGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZDtcbiAgXHRcdEJpbmRpbmdfQmluZGluZy5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlLmNhbGwodGhpcyk7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5zaWJsaW5ncy5maWx0ZXIoaXNDaGVja2VkKS5tYXAoQmluZGluZ19DaGVja2JveE5hbWVCaW5kaW5nX19nZXRWYWx1ZSk7XG4gIFx0fVxuICB9KTtcblxuICBmdW5jdGlvbiBpc0NoZWNrZWQoYmluZGluZykge1xuICBcdHJldHVybiBiaW5kaW5nLmlzQ2hlY2tlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIEJpbmRpbmdfQ2hlY2tib3hOYW1lQmluZGluZ19fZ2V0VmFsdWUoYmluZGluZykge1xuICBcdHJldHVybiBiaW5kaW5nLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIH1cblxuICB2YXIgQmluZGluZ19DaGVja2JveE5hbWVCaW5kaW5nID0gQ2hlY2tib3hOYW1lQmluZGluZztcblxuICB2YXIgQ2hlY2tib3hCaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0bmFtZTogXCJjaGVja2VkXCIsXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuXG4gIFx0XHRpZiAobm9kZS5hdHRhY2hFdmVudCkge1xuICBcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblxuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG4gIFx0fVxuICB9KTtcblxuICB2YXIgQmluZGluZ19DaGVja2JveEJpbmRpbmcgPSBDaGVja2JveEJpbmRpbmc7XG5cbiAgdmFyIFNlbGVjdEJpbmRpbmcgPSBCaW5kaW5nX0JpbmRpbmcuZXh0ZW5kKHtcbiAgXHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBvcHRpb25zID0gdGhpcy5lbGVtZW50Lm9wdGlvbnMsXG4gIFx0XHQgICAgbGVuLFxuICBcdFx0ICAgIGksXG4gIFx0XHQgICAgdmFsdWUsXG4gIFx0XHQgICAgb3B0aW9uV2FzU2VsZWN0ZWQ7XG5cbiAgXHRcdGlmICh0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGkgPSBsZW4gPSBvcHRpb25zLmxlbmd0aDtcblxuICBcdFx0aWYgKCFsZW4pIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHQvLyB0YWtlIHRoZSBmaW5hbCBzZWxlY3RlZCBvcHRpb24uLi5cbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0aWYgKG9wdGlvbnNbaV0uZ2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIikpIHtcbiAgXHRcdFx0XHR2YWx1ZSA9IG9wdGlvbnNbaV0uZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIFx0XHRcdFx0b3B0aW9uV2FzU2VsZWN0ZWQgPSB0cnVlO1xuICBcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIG9yIHRoZSBmaXJzdCBub24tZGlzYWJsZWQgb3B0aW9uLCBpZiBub25lIGFyZSBzZWxlY3RlZFxuICBcdFx0aWYgKCFvcHRpb25XYXNTZWxlY3RlZCkge1xuICBcdFx0XHR3aGlsZSAoKytpIDwgbGVuKSB7XG4gIFx0XHRcdFx0aWYgKCFvcHRpb25zW2ldLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpKSB7XG4gIFx0XHRcdFx0XHR2YWx1ZSA9IG9wdGlvbnNbaV0uZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIFx0XHRcdFx0XHRicmVhaztcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gVGhpcyBpcyBhbiBvcHRpbWlzYXRpb24gKGFrYSBoYWNrKSB0aGF0IGFsbG93cyB1cyB0byBmb3JnbyBzb21lXG4gIFx0XHQvLyBvdGhlciBtb3JlIGV4cGVuc2l2ZSB3b3JrXG4gIFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0aGlzLmVsZW1lbnQuYXR0cmlidXRlcy52YWx1ZS52YWx1ZSA9IHZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5lbGVtZW50Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5lbGVtZW50Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHQvLyBUT0RPIHRoaXMgbWV0aG9kIGlzIGFuIGFub21hbHkuLi4gaXMgaXQgbmVjZXNzYXJ5P1xuICBcdHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KHRoaXMua2V5cGF0aCwgdmFsdWUpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG9wdGlvbnMsIGksIGxlbiwgb3B0aW9uLCBvcHRpb25WYWx1ZTtcblxuICBcdFx0b3B0aW9ucyA9IHRoaXMuZWxlbWVudC5ub2RlLm9wdGlvbnM7XG4gIFx0XHRsZW4gPSBvcHRpb25zLmxlbmd0aDtcblxuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbaV07XG5cbiAgXHRcdFx0aWYgKG9wdGlvbnNbaV0uc2VsZWN0ZWQpIHtcbiAgXHRcdFx0XHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5fcmFjdGl2ZSA/IG9wdGlvbi5fcmFjdGl2ZS52YWx1ZSA6IG9wdGlvbi52YWx1ZTtcbiAgXHRcdFx0XHRyZXR1cm4gb3B0aW9uVmFsdWU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Zm9yY2VVcGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuICBcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy5hdHRyaWJ1dGUubG9ja2VkID0gdHJ1ZTtcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRyZXR1cm4gX3RoaXMuYXR0cmlidXRlLmxvY2tlZCA9IGZhbHNlO1xuICBcdFx0XHR9KTtcbiAgXHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQodGhpcy5rZXlwYXRoLCB2YWx1ZSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9KTtcblxuICB2YXIgQmluZGluZ19TZWxlY3RCaW5kaW5nID0gU2VsZWN0QmluZGluZztcblxuICB2YXIgTXVsdGlwbGVTZWxlY3RCaW5kaW5nID0gQmluZGluZ19TZWxlY3RCaW5kaW5nLmV4dGVuZCh7XG4gIFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm9wdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgXHRcdFx0cmV0dXJuIG9wdGlvbi5nZXRBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiKTtcbiAgXHRcdH0pLm1hcChmdW5jdGlvbiAob3B0aW9uKSB7XG4gIFx0XHRcdHJldHVybiBvcHRpb24uZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIFx0XHR9KTtcbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgdmFsdWVGcm9tTW9kZWw7XG5cbiAgXHRcdHRoaXMuZWxlbWVudC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcblxuICBcdFx0dmFsdWVGcm9tTW9kZWwgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCh0aGlzLmtleXBhdGgpO1xuXG4gIFx0XHRpZiAodmFsdWVGcm9tTW9kZWwgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHQvLyBnZXQgdmFsdWUgZnJvbSBET00sIGlmIHBvc3NpYmxlXG4gIFx0XHRcdHRoaXMuaGFuZGxlQ2hhbmdlKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmVsZW1lbnQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdHNldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUT0RPIG5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgc2VsZWN0ZWRWYWx1ZXMsIG9wdGlvbnMsIGksIGxlbiwgb3B0aW9uLCBvcHRpb25WYWx1ZTtcblxuICBcdFx0c2VsZWN0ZWRWYWx1ZXMgPSBbXTtcbiAgXHRcdG9wdGlvbnMgPSB0aGlzLmVsZW1lbnQubm9kZS5vcHRpb25zO1xuICBcdFx0bGVuID0gb3B0aW9ucy5sZW5ndGg7XG5cbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRvcHRpb24gPSBvcHRpb25zW2ldO1xuXG4gIFx0XHRcdGlmIChvcHRpb24uc2VsZWN0ZWQpIHtcbiAgXHRcdFx0XHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5fcmFjdGl2ZSA/IG9wdGlvbi5fcmFjdGl2ZS52YWx1ZSA6IG9wdGlvbi52YWx1ZTtcbiAgXHRcdFx0XHRzZWxlY3RlZFZhbHVlcy5wdXNoKG9wdGlvblZhbHVlKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gc2VsZWN0ZWRWYWx1ZXM7XG4gIFx0fSxcblxuICBcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGF0dHJpYnV0ZSwgcHJldmlvdXNWYWx1ZSwgdmFsdWU7XG5cbiAgXHRcdGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlO1xuICBcdFx0cHJldmlvdXNWYWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZTtcblxuICBcdFx0dmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cbiAgXHRcdGlmIChwcmV2aW91c1ZhbHVlID09PSB1bmRlZmluZWQgfHwgIWFycmF5Q29udGVudHNNYXRjaCh2YWx1ZSwgcHJldmlvdXNWYWx1ZSkpIHtcbiAgXHRcdFx0QmluZGluZ19TZWxlY3RCaW5kaW5nLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UuY2FsbCh0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdGZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cbiAgXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHRoaXMuYXR0cmlidXRlLmxvY2tlZCA9IHRydWU7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIF90aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSBmYWxzZTtcbiAgXHRcdFx0fSk7XG4gIFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KHRoaXMua2V5cGF0aCwgdmFsdWUpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1cGRhdGVNb2RlbDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuYXR0cmlidXRlLnZhbHVlID09PSB1bmRlZmluZWQgfHwgIXRoaXMuYXR0cmlidXRlLnZhbHVlLmxlbmd0aCkge1xuICBcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCh0aGlzLmtleXBhdGgsIHRoaXMuaW5pdGlhbFZhbHVlKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBCaW5kaW5nX011bHRpcGxlU2VsZWN0QmluZGluZyA9IE11bHRpcGxlU2VsZWN0QmluZGluZztcblxuICB2YXIgRmlsZUxpc3RCaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmVsZW1lbnQubm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmVsZW1lbnQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm5vZGUuZmlsZXM7XG4gIFx0fVxuICB9KTtcblxuICB2YXIgQmluZGluZ19GaWxlTGlzdEJpbmRpbmcgPSBGaWxlTGlzdEJpbmRpbmc7XG5cbiAgdmFyIE51bWVyaWNCaW5kaW5nID0gQmluZGluZ19HZW5lcmljQmluZGluZy5leHRlbmQoe1xuICBcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHVuZGVmaW5lZDtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciB2YWx1ZSA9IHBhcnNlRmxvYXQodGhpcy5lbGVtZW50Lm5vZGUudmFsdWUpO1xuICBcdFx0cmV0dXJuIGlzTmFOKHZhbHVlKSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xuICBcdH1cbiAgfSk7XG5cbiAgdmFyIGluaXRfY3JlYXRlVHdvd2F5QmluZGluZyA9IGNyZWF0ZVR3b3dheUJpbmRpbmc7XG5cbiAgZnVuY3Rpb24gY3JlYXRlVHdvd2F5QmluZGluZyhlbGVtZW50KSB7XG4gIFx0dmFyIGF0dHJpYnV0ZXMgPSBlbGVtZW50LmF0dHJpYnV0ZXMsXG4gIFx0ICAgIHR5cGUsXG4gIFx0ICAgIEJpbmRpbmcsXG4gIFx0ICAgIGJpbmROYW1lLFxuICBcdCAgICBiaW5kQ2hlY2tlZCxcbiAgXHQgICAgYmluZGluZztcblxuICBcdC8vIGlmIHRoaXMgaXMgYSBsYXRlIGJpbmRpbmcsIGFuZCB0aGVyZSdzIGFscmVhZHkgb25lLCBpdFxuICBcdC8vIG5lZWRzIHRvIGJlIHRvcm4gZG93blxuICBcdGlmIChlbGVtZW50LmJpbmRpbmcpIHtcbiAgXHRcdGVsZW1lbnQuYmluZGluZy50ZWFyZG93bigpO1xuICBcdFx0ZWxlbWVudC5iaW5kaW5nID0gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBjb250ZW50ZWRpdGFibGVcbiAgXHRpZiAoXG4gIFx0Ly8gaWYgdGhlIGNvbnRlbnRlZGl0YWJsZSBhdHRyaWJ1dGUgaXMgdHJ1ZSBvciBpcyBiaW5kYWJsZSBhbmQgbWF5IHRodXMgYmVjb21lIHRydWVcbiAgXHQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikgfHwgISFhdHRyaWJ1dGVzLmNvbnRlbnRlZGl0YWJsZSAmJiBpc0JpbmRhYmxlKGF0dHJpYnV0ZXMuY29udGVudGVkaXRhYmxlKSkgJiYgaXNCaW5kYWJsZShhdHRyaWJ1dGVzLnZhbHVlKSkge1xuICBcdFx0QmluZGluZyA9IEJpbmRpbmdfQ29udGVudEVkaXRhYmxlQmluZGluZztcbiAgXHR9XG5cbiAgXHQvLyA8aW5wdXQ+XG4gIFx0ZWxzZSBpZiAoZWxlbWVudC5uYW1lID09PSBcImlucHV0XCIpIHtcbiAgXHRcdHR5cGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInR5cGVcIik7XG5cbiAgXHRcdGlmICh0eXBlID09PSBcInJhZGlvXCIgfHwgdHlwZSA9PT0gXCJjaGVja2JveFwiKSB7XG4gIFx0XHRcdGJpbmROYW1lID0gaXNCaW5kYWJsZShhdHRyaWJ1dGVzLm5hbWUpO1xuICBcdFx0XHRiaW5kQ2hlY2tlZCA9IGlzQmluZGFibGUoYXR0cmlidXRlcy5jaGVja2VkKTtcblxuICBcdFx0XHQvLyB3ZSBjYW4gZWl0aGVyIGJpbmQgdGhlIG5hbWUgYXR0cmlidXRlLCBvciB0aGUgY2hlY2tlZCBhdHRyaWJ1dGUgLSBub3QgYm90aFxuICBcdFx0XHRpZiAoYmluZE5hbWUgJiYgYmluZENoZWNrZWQpIHtcbiAgXHRcdFx0XHR3YXJuSWZEZWJ1ZyhcIkEgcmFkaW8gaW5wdXQgY2FuIGhhdmUgdHdvLXdheSBiaW5kaW5nIG9uIGl0cyBuYW1lIGF0dHJpYnV0ZSwgb3IgaXRzIGNoZWNrZWQgYXR0cmlidXRlIC0gbm90IGJvdGhcIiwgeyByYWN0aXZlOiBlbGVtZW50LnJvb3QgfSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoYmluZE5hbWUpIHtcbiAgXHRcdFx0XHRCaW5kaW5nID0gdHlwZSA9PT0gXCJyYWRpb1wiID8gQmluZGluZ19SYWRpb05hbWVCaW5kaW5nIDogQmluZGluZ19DaGVja2JveE5hbWVCaW5kaW5nO1xuICBcdFx0XHR9IGVsc2UgaWYgKGJpbmRDaGVja2VkKSB7XG4gIFx0XHRcdFx0QmluZGluZyA9IHR5cGUgPT09IFwicmFkaW9cIiA/IEJpbmRpbmdfUmFkaW9CaW5kaW5nIDogQmluZGluZ19DaGVja2JveEJpbmRpbmc7XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gXCJmaWxlXCIgJiYgaXNCaW5kYWJsZShhdHRyaWJ1dGVzLnZhbHVlKSkge1xuICBcdFx0XHRCaW5kaW5nID0gQmluZGluZ19GaWxlTGlzdEJpbmRpbmc7XG4gIFx0XHR9IGVsc2UgaWYgKGlzQmluZGFibGUoYXR0cmlidXRlcy52YWx1ZSkpIHtcbiAgXHRcdFx0QmluZGluZyA9IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJyYW5nZVwiID8gTnVtZXJpY0JpbmRpbmcgOiBCaW5kaW5nX0dlbmVyaWNCaW5kaW5nO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIDxzZWxlY3Q+XG4gIFx0ZWxzZSBpZiAoZWxlbWVudC5uYW1lID09PSBcInNlbGVjdFwiICYmIGlzQmluZGFibGUoYXR0cmlidXRlcy52YWx1ZSkpIHtcbiAgXHRcdEJpbmRpbmcgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIpID8gQmluZGluZ19NdWx0aXBsZVNlbGVjdEJpbmRpbmcgOiBCaW5kaW5nX1NlbGVjdEJpbmRpbmc7XG4gIFx0fVxuXG4gIFx0Ly8gPHRleHRhcmVhPlxuICBcdGVsc2UgaWYgKGVsZW1lbnQubmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICYmIGlzQmluZGFibGUoYXR0cmlidXRlcy52YWx1ZSkpIHtcbiAgXHRcdEJpbmRpbmcgPSBCaW5kaW5nX0dlbmVyaWNCaW5kaW5nO1xuICBcdH1cblxuICBcdGlmIChCaW5kaW5nICYmIChiaW5kaW5nID0gbmV3IEJpbmRpbmcoZWxlbWVudCkpICYmIGJpbmRpbmcua2V5cGF0aCkge1xuICBcdFx0cmV0dXJuIGJpbmRpbmc7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gaXNCaW5kYWJsZShhdHRyaWJ1dGUpIHtcbiAgXHRyZXR1cm4gYXR0cmlidXRlICYmIGF0dHJpYnV0ZS5pc0JpbmRhYmxlO1xuICB9XG5cbiAgLy8gYW5kIHRoaXMgZWxlbWVudCBhbHNvIGhhcyBhIHZhbHVlIGF0dHJpYnV0ZSB0byBiaW5kXG5cbiAgdmFyIEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfYnViYmxlID0gRXZlbnRIYW5kbGVyJGJ1YmJsZTtcblxuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkYnViYmxlKCkge1xuICBcdHZhciBoYXNBY3Rpb24gPSB0aGlzLmdldEFjdGlvbigpO1xuXG4gIFx0aWYgKGhhc0FjdGlvbiAmJiAhdGhpcy5oYXNMaXN0ZW5lcikge1xuICBcdFx0dGhpcy5saXN0ZW4oKTtcbiAgXHR9IGVsc2UgaWYgKCFoYXNBY3Rpb24gJiYgdGhpcy5oYXNMaXN0ZW5lcikge1xuICBcdFx0dGhpcy51bnJlbmRlcigpO1xuICBcdH1cbiAgfVxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gbWF5IGJlIG92ZXJ3cml0dGVuLCBpZiB0aGUgZXZlbnQgZGlyZWN0aXZlXG4gIC8vIGluY2x1ZGVzIHBhcmFtZXRlcnNcbiAgdmFyIEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfZmlyZSA9IEV2ZW50SGFuZGxlciRmaXJlO1xuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkZmlyZShldmVudCkge1xuICBcdHNoYXJlZF9maXJlRXZlbnQodGhpcy5yb290LCB0aGlzLmdldEFjdGlvbigpLCB7IGV2ZW50OiBldmVudCB9KTtcbiAgfVxuXG4gIHZhciBnZXRBY3Rpb24gPSBFdmVudEhhbmRsZXIkZ2V0QWN0aW9uO1xuXG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRnZXRBY3Rpb24oKSB7XG4gIFx0cmV0dXJuIHRoaXMuYWN0aW9uLnRvU3RyaW5nKCkudHJpbSgpO1xuICB9XG5cbiAgdmFyIEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfaW5pdCA9IEV2ZW50SGFuZGxlciRpbml0O1xuXG4gIHZhciBldmVudFBhdHRlcm4gPSAvXmV2ZW50KD86XFwuKC4rKSk/LztcbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGluaXQoZWxlbWVudCwgbmFtZSwgdGVtcGxhdGUpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIGFjdGlvbiwgcmVmcywgcmFjdGl2ZTtcblxuICBcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIFx0dGhpcy5yb290ID0gZWxlbWVudC5yb290O1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBlbGVtZW50LnBhcmVudEZyYWdtZW50O1xuICBcdHRoaXMubmFtZSA9IG5hbWU7XG5cbiAgXHRpZiAobmFtZS5pbmRleE9mKFwiKlwiKSAhPT0gLTEpIHtcbiAgXHRcdGZhdGFsKFwiT25seSBjb21wb25lbnQgcHJveHktZXZlbnRzIG1heSBjb250YWluIFxcXCIqXFxcIiB3aWxkY2FyZHMsIDwlcyBvbi0lcz1cXFwiLi4uXFxcIi8+IGlzIG5vdCB2YWxpZFwiLCBlbGVtZW50Lm5hbWUsIG5hbWUpO1xuICBcdFx0dGhpcy5pbnZhbGlkID0gdHJ1ZTtcbiAgXHR9XG5cbiAgXHRpZiAodGVtcGxhdGUubSkge1xuICBcdFx0cmVmcyA9IHRlbXBsYXRlLmEucjtcblxuICBcdFx0Ly8gVGhpcyBpcyBhIG1ldGhvZCBjYWxsXG4gIFx0XHR0aGlzLm1ldGhvZCA9IHRlbXBsYXRlLm07XG4gIFx0XHR0aGlzLmtleXBhdGhzID0gW107XG4gIFx0XHR0aGlzLmZuID0gc2hhcmVkX2dldEZ1bmN0aW9uRnJvbVN0cmluZyh0ZW1wbGF0ZS5hLnMsIHJlZnMubGVuZ3RoKTtcblxuICBcdFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGVsZW1lbnQucGFyZW50RnJhZ21lbnQ7XG4gIFx0XHRyYWN0aXZlID0gdGhpcy5yb290O1xuXG4gIFx0XHQvLyBDcmVhdGUgcmVzb2x2ZXJzIGZvciBlYWNoIHJlZmVyZW5jZVxuICBcdFx0dGhpcy5yZWZSZXNvbHZlcnMgPSBbXTtcbiAgXHRcdHJlZnMuZm9yRWFjaChmdW5jdGlvbiAocmVmLCBpKSB7XG4gIFx0XHRcdHZhciBtYXRjaCA9IHVuZGVmaW5lZDtcblxuICBcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSB0aGUgYGV2ZW50YCBvYmplY3RcbiAgXHRcdFx0aWYgKG1hdGNoID0gZXZlbnRQYXR0ZXJuLmV4ZWMocmVmKSkge1xuICBcdFx0XHRcdF90aGlzLmtleXBhdGhzW2ldID0ge1xuICBcdFx0XHRcdFx0ZXZlbnRPYmplY3Q6IHRydWUsXG4gIFx0XHRcdFx0XHRyZWZpbmVtZW50czogbWF0Y2hbMV0gPyBtYXRjaFsxXS5zcGxpdChcIi5cIikgOiBbXVxuICBcdFx0XHRcdH07XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0X3RoaXMucmVmUmVzb2x2ZXJzLnB1c2goUmVzb2x2ZXJzX2NyZWF0ZVJlZmVyZW5jZVJlc29sdmVyKF90aGlzLCByZWYsIGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gX3RoaXMucmVzb2x2ZShpLCBrZXlwYXRoKTtcbiAgXHRcdFx0XHR9KSk7XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuXG4gIFx0XHR0aGlzLmZpcmUgPSBmaXJlTWV0aG9kQ2FsbDtcbiAgXHR9IGVsc2Uge1xuICBcdFx0Ly8gR2V0IGFjdGlvbiAoJ2ZvbycgaW4gJ29uLWNsaWNrPSdmb28nKVxuICBcdFx0YWN0aW9uID0gdGVtcGxhdGUubiB8fCB0ZW1wbGF0ZTtcbiAgXHRcdGlmICh0eXBlb2YgYWN0aW9uICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdGFjdGlvbiA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0XHR0ZW1wbGF0ZTogYWN0aW9uLFxuICBcdFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcbiAgXHRcdFx0XHRvd25lcjogdGhpc1xuICBcdFx0XHR9KTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5hY3Rpb24gPSBhY3Rpb247XG5cbiAgXHRcdC8vIEdldCBwYXJhbWV0ZXJzXG4gIFx0XHRpZiAodGVtcGxhdGUuZCkge1xuICBcdFx0XHR0aGlzLmR5bmFtaWNQYXJhbXMgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLmQsXG4gIFx0XHRcdFx0cm9vdDogdGhpcy5yb290LFxuICBcdFx0XHRcdG93bmVyOiB0aGlzLmVsZW1lbnRcbiAgXHRcdFx0fSk7XG5cbiAgXHRcdFx0dGhpcy5maXJlID0gZmlyZUV2ZW50V2l0aER5bmFtaWNQYXJhbXM7XG4gIFx0XHR9IGVsc2UgaWYgKHRlbXBsYXRlLmEpIHtcbiAgXHRcdFx0dGhpcy5wYXJhbXMgPSB0ZW1wbGF0ZS5hO1xuICBcdFx0XHR0aGlzLmZpcmUgPSBmaXJlRXZlbnRXaXRoUGFyYW1zO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmVNZXRob2RDYWxsKGV2ZW50KSB7XG4gIFx0dmFyIHJhY3RpdmUsIHZhbHVlcywgYXJncztcblxuICBcdHJhY3RpdmUgPSB0aGlzLnJvb3Q7XG5cbiAgXHRpZiAodHlwZW9mIHJhY3RpdmVbdGhpcy5tZXRob2RdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byBjYWxsIGEgbm9uLWV4aXN0ZW50IG1ldGhvZCAoXFxcIlwiICsgdGhpcy5tZXRob2QgKyBcIlxcXCIpXCIpO1xuICBcdH1cblxuICBcdHZhbHVlcyA9IHRoaXMua2V5cGF0aHMubWFwKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHR2YXIgdmFsdWUsIGxlbiwgaTtcblxuICBcdFx0aWYgKGtleXBhdGggPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHQvLyBub3QgeWV0IHJlc29sdmVkXG4gIFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIFRPRE8gdGhlIHJlZmluZW1lbnRzIHN0dWZmIHdvdWxkIGJlIGJldHRlciBoYW5kbGVkIGF0IHBhcnNlIHRpbWVcbiAgXHRcdGlmIChrZXlwYXRoLmV2ZW50T2JqZWN0KSB7XG4gIFx0XHRcdHZhbHVlID0gZXZlbnQ7XG5cbiAgXHRcdFx0aWYgKGxlbiA9IGtleXBhdGgucmVmaW5lbWVudHMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlW2tleXBhdGgucmVmaW5lbWVudHNbaV1dO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dmFsdWUgPSByYWN0aXZlLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB2YWx1ZTtcbiAgXHR9KTtcblxuICBcdHNoYXJlZF9ldmVudFN0YWNrLmVucXVldWUocmFjdGl2ZSwgZXZlbnQpO1xuXG4gIFx0YXJncyA9IHRoaXMuZm4uYXBwbHkobnVsbCwgdmFsdWVzKTtcbiAgXHRyYWN0aXZlW3RoaXMubWV0aG9kXS5hcHBseShyYWN0aXZlLCBhcmdzKTtcblxuICBcdHNoYXJlZF9ldmVudFN0YWNrLmRlcXVldWUocmFjdGl2ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlRXZlbnRXaXRoUGFyYW1zKGV2ZW50KSB7XG4gIFx0c2hhcmVkX2ZpcmVFdmVudCh0aGlzLnJvb3QsIHRoaXMuZ2V0QWN0aW9uKCksIHsgZXZlbnQ6IGV2ZW50LCBhcmdzOiB0aGlzLnBhcmFtcyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmVFdmVudFdpdGhEeW5hbWljUGFyYW1zKGV2ZW50KSB7XG4gIFx0dmFyIGFyZ3MgPSB0aGlzLmR5bmFtaWNQYXJhbXMuZ2V0QXJnc0xpc3QoKTtcblxuICBcdC8vIG5lZWQgdG8gc3RyaXAgW10gZnJvbSBlbmRzIGlmIGEgc3RyaW5nIVxuICBcdGlmICh0eXBlb2YgYXJncyA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0YXJncyA9IGFyZ3Muc3Vic3RyKDEsIGFyZ3MubGVuZ3RoIC0gMik7XG4gIFx0fVxuXG4gIFx0c2hhcmVkX2ZpcmVFdmVudCh0aGlzLnJvb3QsIHRoaXMuZ2V0QWN0aW9uKCksIHsgZXZlbnQ6IGV2ZW50LCBhcmdzOiBhcmdzIH0pO1xuICB9XG5cbiAgdmFyIHNoYXJlZF9nZW5lcmljSGFuZGxlciA9IGdlbmVyaWNIYW5kbGVyO1xuICBmdW5jdGlvbiBnZW5lcmljSGFuZGxlcihldmVudCkge1xuICBcdHZhciBzdG9yYWdlLFxuICBcdCAgICBoYW5kbGVyLFxuICBcdCAgICBpbmRpY2VzLFxuICBcdCAgICBpbmRleCA9IHt9O1xuXG4gIFx0c3RvcmFnZSA9IHRoaXMuX3JhY3RpdmU7XG4gIFx0aGFuZGxlciA9IHN0b3JhZ2UuZXZlbnRzW2V2ZW50LnR5cGVdO1xuXG4gIFx0aWYgKGluZGljZXMgPSBSZXNvbHZlcnNfZmluZEluZGV4UmVmcyhoYW5kbGVyLmVsZW1lbnQucGFyZW50RnJhZ21lbnQpKSB7XG4gIFx0XHRpbmRleCA9IFJlc29sdmVyc19maW5kSW5kZXhSZWZzLnJlc29sdmUoaW5kaWNlcyk7XG4gIFx0fVxuXG4gIFx0aGFuZGxlci5maXJlKHtcbiAgXHRcdG5vZGU6IHRoaXMsXG4gIFx0XHRvcmlnaW5hbDogZXZlbnQsXG4gIFx0XHRpbmRleDogaW5kZXgsXG4gIFx0XHRrZXlwYXRoOiBzdG9yYWdlLmtleXBhdGguc3RyLFxuICBcdFx0Y29udGV4dDogc3RvcmFnZS5yb290LnZpZXdtb2RlbC5nZXQoc3RvcmFnZS5rZXlwYXRoKVxuICBcdH0pO1xuICB9XG5cbiAgdmFyIGxpc3RlbiA9IEV2ZW50SGFuZGxlciRsaXN0ZW47XG5cbiAgdmFyIGN1c3RvbUhhbmRsZXJzID0ge30sXG4gICAgICB0b3VjaEV2ZW50cyA9IHtcbiAgXHR0b3VjaHN0YXJ0OiB0cnVlLFxuICBcdHRvdWNobW92ZTogdHJ1ZSxcbiAgXHR0b3VjaGVuZDogdHJ1ZSxcbiAgXHR0b3VjaGNhbmNlbDogdHJ1ZSxcbiAgXHQvL25vdCB3M2MsIGJ1dCBzdXBwb3J0ZWQgaW4gc29tZSBicm93c2Vyc1xuICBcdHRvdWNobGVhdmU6IHRydWVcbiAgfTtcbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGxpc3RlbigpIHtcbiAgXHR2YXIgZGVmaW5pdGlvbixcbiAgXHQgICAgbmFtZSA9IHRoaXMubmFtZTtcblxuICBcdGlmICh0aGlzLmludmFsaWQpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRpZiAoZGVmaW5pdGlvbiA9IGZpbmRJblZpZXdIaWVyYXJjaHkoXCJldmVudHNcIiwgdGhpcy5yb290LCBuYW1lKSkge1xuICBcdFx0dGhpcy5jdXN0b20gPSBkZWZpbml0aW9uKHRoaXMubm9kZSwgZ2V0Q3VzdG9tSGFuZGxlcihuYW1lKSk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdC8vIExvb2tzIGxpa2Ugd2UncmUgZGVhbGluZyB3aXRoIGEgc3RhbmRhcmQgRE9NIGV2ZW50Li4uIGJ1dCBsZXQncyBjaGVja1xuICBcdFx0aWYgKCEoXCJvblwiICsgbmFtZSBpbiB0aGlzLm5vZGUpICYmICEod2luZG93ICYmIFwib25cIiArIG5hbWUgaW4gd2luZG93KSAmJiAhaXNKc2RvbSkge1xuXG4gIFx0XHRcdC8vIG9rYXkgdG8gdXNlIHRvdWNoIGV2ZW50cyBpZiB0aGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZW1cbiAgXHRcdFx0aWYgKCF0b3VjaEV2ZW50c1tuYW1lXSkge1xuICBcdFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyhtaXNzaW5nUGx1Z2luKG5hbWUsIFwiZXZlbnRcIiksIHsgbm9kZTogdGhpcy5ub2RlIH0pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBzaGFyZWRfZ2VuZXJpY0hhbmRsZXIsIGZhbHNlKTtcbiAgXHR9XG5cbiAgXHR0aGlzLmhhc0xpc3RlbmVyID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEN1c3RvbUhhbmRsZXIobmFtZSkge1xuICBcdGlmICghY3VzdG9tSGFuZGxlcnNbbmFtZV0pIHtcbiAgXHRcdGN1c3RvbUhhbmRsZXJzW25hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIFx0XHRcdHZhciBzdG9yYWdlID0gZXZlbnQubm9kZS5fcmFjdGl2ZTtcblxuICBcdFx0XHRldmVudC5pbmRleCA9IHN0b3JhZ2UuaW5kZXg7XG4gIFx0XHRcdGV2ZW50LmtleXBhdGggPSBzdG9yYWdlLmtleXBhdGguc3RyO1xuICBcdFx0XHRldmVudC5jb250ZXh0ID0gc3RvcmFnZS5yb290LnZpZXdtb2RlbC5nZXQoc3RvcmFnZS5rZXlwYXRoKTtcblxuICBcdFx0XHRzdG9yYWdlLmV2ZW50c1tuYW1lXS5maXJlKGV2ZW50KTtcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGN1c3RvbUhhbmRsZXJzW25hbWVdO1xuICB9XG5cbiAgdmFyIEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfcmViaW5kID0gRXZlbnRIYW5kbGVyJHJlYmluZDtcblxuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkcmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHR2YXIgZnJhZ21lbnQ7XG4gIFx0aWYgKHRoaXMubWV0aG9kKSB7XG4gIFx0XHRmcmFnbWVudCA9IHRoaXMuZWxlbWVudC5wYXJlbnRGcmFnbWVudDtcbiAgXHRcdHRoaXMucmVmUmVzb2x2ZXJzLmZvckVhY2gocmViaW5kKTtcblxuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGlmICh0eXBlb2YgdGhpcy5hY3Rpb24gIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHJlYmluZCh0aGlzLmFjdGlvbik7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZHluYW1pY1BhcmFtcykge1xuICBcdFx0cmViaW5kKHRoaXMuZHluYW1pY1BhcmFtcyk7XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gcmViaW5kKHRoaW5nKSB7XG4gIFx0XHR0aGluZyAmJiB0aGluZy5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfcmVuZGVyID0gRXZlbnRIYW5kbGVyJHJlbmRlcjtcblxuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkcmVuZGVyKCkge1xuICBcdHRoaXMubm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuICBcdC8vIHN0b3JlIHRoaXMgb24gdGhlIG5vZGUgaXRzZWxmLCBzbyBpdCBjYW4gYmUgcmV0cmlldmVkIGJ5IGFcbiAgXHQvLyB1bml2ZXJzYWwgaGFuZGxlclxuICBcdHRoaXMubm9kZS5fcmFjdGl2ZS5ldmVudHNbdGhpcy5uYW1lXSA9IHRoaXM7XG5cbiAgXHRpZiAodGhpcy5tZXRob2QgfHwgdGhpcy5nZXRBY3Rpb24oKSkge1xuICBcdFx0dGhpcy5saXN0ZW4oKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3Jlc29sdmUgPSBFdmVudEhhbmRsZXIkcmVzb2x2ZTtcblxuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkcmVzb2x2ZShpbmRleCwga2V5cGF0aCkge1xuICBcdHRoaXMua2V5cGF0aHNbaW5kZXhdID0ga2V5cGF0aDtcbiAgfVxuXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3VuYmluZCA9IEV2ZW50SGFuZGxlciR1bmJpbmQ7XG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciR1bmJpbmQoKSB7XG4gIFx0aWYgKHRoaXMubWV0aG9kKSB7XG4gIFx0XHR0aGlzLnJlZlJlc29sdmVycy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0Ly8gVGVhciBkb3duIGR5bmFtaWMgbmFtZVxuICBcdGlmICh0eXBlb2YgdGhpcy5hY3Rpb24gIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHRoaXMuYWN0aW9uLnVuYmluZCgpO1xuICBcdH1cblxuICBcdC8vIFRlYXIgZG93biBkeW5hbWljIHBhcmFtZXRlcnNcbiAgXHRpZiAodGhpcy5keW5hbWljUGFyYW1zKSB7XG4gIFx0XHR0aGlzLmR5bmFtaWNQYXJhbXMudW5iaW5kKCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfdW5yZW5kZXIgPSBFdmVudEhhbmRsZXIkdW5yZW5kZXI7XG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciR1bnJlbmRlcigpIHtcblxuICBcdGlmICh0aGlzLmN1c3RvbSkge1xuICBcdFx0dGhpcy5jdXN0b20udGVhcmRvd24oKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0dGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5uYW1lLCBzaGFyZWRfZ2VuZXJpY0hhbmRsZXIsIGZhbHNlKTtcbiAgXHR9XG5cbiAgXHR0aGlzLmhhc0xpc3RlbmVyID0gZmFsc2U7XG4gIH1cblxuICB2YXIgRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUsIHRlbXBsYXRlKSB7XG4gIFx0dGhpcy5pbml0KGVsZW1lbnQsIG5hbWUsIHRlbXBsYXRlKTtcbiAgfTtcblxuICBFdmVudEhhbmRsZXIucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV9idWJibGUsXG4gIFx0ZmlyZTogRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV9maXJlLFxuICBcdGdldEFjdGlvbjogZ2V0QWN0aW9uLFxuICBcdGluaXQ6IEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfaW5pdCxcbiAgXHRsaXN0ZW46IGxpc3RlbixcbiAgXHRyZWJpbmQ6IEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfcmViaW5kLFxuICBcdHJlbmRlcjogRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV9yZW5kZXIsXG4gIFx0cmVzb2x2ZTogcHJvdG90eXBlX3Jlc29sdmUsXG4gIFx0dW5iaW5kOiBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3VuYmluZCxcbiAgXHR1bnJlbmRlcjogRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV91bnJlbmRlclxuICB9O1xuXG4gIHZhciBfRXZlbnRIYW5kbGVyID0gRXZlbnRIYW5kbGVyO1xuXG4gIHZhciBjcmVhdGVFdmVudEhhbmRsZXJzID0gZnVuY3Rpb24gKGVsZW1lbnQsIHRlbXBsYXRlKSB7XG4gIFx0dmFyIGksXG4gIFx0ICAgIG5hbWUsXG4gIFx0ICAgIG5hbWVzLFxuICBcdCAgICBoYW5kbGVyLFxuICBcdCAgICByZXN1bHQgPSBbXTtcblxuICBcdGZvciAobmFtZSBpbiB0ZW1wbGF0ZSkge1xuICBcdFx0aWYgKHRlbXBsYXRlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gIFx0XHRcdG5hbWVzID0gbmFtZS5zcGxpdChcIi1cIik7XG4gIFx0XHRcdGkgPSBuYW1lcy5sZW5ndGg7XG5cbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdGhhbmRsZXIgPSBuZXcgX0V2ZW50SGFuZGxlcihlbGVtZW50LCBuYW1lc1tpXSwgdGVtcGxhdGVbbmFtZV0pO1xuICBcdFx0XHRcdHJlc3VsdC5wdXNoKGhhbmRsZXIpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgRGVjb3JhdG9yID0gZnVuY3Rpb24gKGVsZW1lbnQsIHRlbXBsYXRlKSB7XG4gIFx0dmFyIHNlbGYgPSB0aGlzLFxuICBcdCAgICByYWN0aXZlLFxuICBcdCAgICBuYW1lLFxuICBcdCAgICBmcmFnbWVudDtcblxuICBcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIFx0dGhpcy5yb290ID0gcmFjdGl2ZSA9IGVsZW1lbnQucm9vdDtcblxuICBcdG5hbWUgPSB0ZW1wbGF0ZS5uIHx8IHRlbXBsYXRlO1xuXG4gIFx0aWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRmcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0dGVtcGxhdGU6IG5hbWUsXG4gIFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG4gIFx0XHRcdG93bmVyOiBlbGVtZW50XG4gIFx0XHR9KTtcblxuICBcdFx0bmFtZSA9IGZyYWdtZW50LnRvU3RyaW5nKCk7XG4gIFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblxuICBcdFx0aWYgKG5hbWUgPT09IFwiXCIpIHtcbiAgXHRcdFx0Ly8gZW1wdHkgc3RyaW5nIG9rYXksIGp1c3Qgbm8gZGVjb3JhdG9yXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAodGVtcGxhdGUuYSkge1xuICBcdFx0dGhpcy5wYXJhbXMgPSB0ZW1wbGF0ZS5hO1xuICBcdH0gZWxzZSBpZiAodGVtcGxhdGUuZCkge1xuICBcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLmQsXG4gIFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG4gIFx0XHRcdG93bmVyOiBlbGVtZW50XG4gIFx0XHR9KTtcblxuICBcdFx0dGhpcy5wYXJhbXMgPSB0aGlzLmZyYWdtZW50LmdldEFyZ3NMaXN0KCk7XG5cbiAgXHRcdHRoaXMuZnJhZ21lbnQuYnViYmxlID0gZnVuY3Rpb24gKCkge1xuICBcdFx0XHR0aGlzLmRpcnR5QXJncyA9IHRoaXMuZGlydHlWYWx1ZSA9IHRydWU7XG4gIFx0XHRcdHNlbGYucGFyYW1zID0gdGhpcy5nZXRBcmdzTGlzdCgpO1xuXG4gIFx0XHRcdGlmIChzZWxmLnJlYWR5KSB7XG4gIFx0XHRcdFx0c2VsZi51cGRhdGUoKTtcbiAgXHRcdFx0fVxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHR0aGlzLmZuID0gZmluZEluVmlld0hpZXJhcmNoeShcImRlY29yYXRvcnNcIiwgcmFjdGl2ZSwgbmFtZSk7XG5cbiAgXHRpZiAoIXRoaXMuZm4pIHtcbiAgXHRcdGZhdGFsKG1pc3NpbmdQbHVnaW4obmFtZSwgXCJkZWNvcmF0b3JcIikpO1xuICBcdH1cbiAgfTtcblxuICBEZWNvcmF0b3IucHJvdG90eXBlID0ge1xuICBcdGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlLCByZXN1bHQsIGFyZ3M7XG5cbiAgXHRcdG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblxuICBcdFx0aWYgKHRoaXMucGFyYW1zKSB7XG4gIFx0XHRcdGFyZ3MgPSBbbm9kZV0uY29uY2F0KHRoaXMucGFyYW1zKTtcbiAgXHRcdFx0cmVzdWx0ID0gdGhpcy5mbi5hcHBseSh0aGlzLnJvb3QsIGFyZ3MpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cmVzdWx0ID0gdGhpcy5mbi5jYWxsKHRoaXMucm9vdCwgbm9kZSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghcmVzdWx0IHx8ICFyZXN1bHQudGVhcmRvd24pIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiRGVjb3JhdG9yIGRlZmluaXRpb24gbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdpdGggYSB0ZWFyZG93biBtZXRob2RcIik7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIFRPRE8gZG9lcyB0aGlzIG1ha2Ugc2Vuc2U/XG4gIFx0XHR0aGlzLmFjdHVhbCA9IHJlc3VsdDtcbiAgXHRcdHRoaXMucmVhZHkgPSB0cnVlO1xuICBcdH0sXG5cbiAgXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLmFjdHVhbC51cGRhdGUpIHtcbiAgXHRcdFx0dGhpcy5hY3R1YWwudXBkYXRlLmFwcGx5KHRoaXMucm9vdCwgdGhpcy5wYXJhbXMpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5hY3R1YWwudGVhcmRvd24odHJ1ZSk7XG4gIFx0XHRcdHRoaXMuaW5pdCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dGVhcmRvd246IGZ1bmN0aW9uICh1cGRhdGluZykge1xuICBcdFx0dGhpcy50b3JuZG93biA9IHRydWU7XG4gIFx0XHRpZiAodGhpcy5yZWFkeSkge1xuICBcdFx0XHR0aGlzLmFjdHVhbC50ZWFyZG93bigpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXVwZGF0aW5nICYmIHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIF9EZWNvcmF0b3IgPSBEZWNvcmF0b3I7XG5cbiAgZnVuY3Rpb24gc2VsZWN0X19idWJibGUoKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdGlmICghdGhpcy5kaXJ0eSkge1xuICBcdFx0dGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgXHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHN5bmMoX3RoaXMpO1xuICBcdFx0XHRfdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTsgLy8gZGVmYXVsdCBiZWhhdmlvdXJcbiAgfVxuXG4gIGZ1bmN0aW9uIHN5bmMoc2VsZWN0RWxlbWVudCkge1xuICBcdHZhciBzZWxlY3ROb2RlLCBzZWxlY3RWYWx1ZSwgaXNNdWx0aXBsZSwgb3B0aW9ucywgb3B0aW9uV2FzU2VsZWN0ZWQ7XG5cbiAgXHRzZWxlY3ROb2RlID0gc2VsZWN0RWxlbWVudC5ub2RlO1xuXG4gIFx0aWYgKCFzZWxlY3ROb2RlKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0b3B0aW9ucyA9IHRvQXJyYXkoc2VsZWN0Tm9kZS5vcHRpb25zKTtcblxuICBcdHNlbGVjdFZhbHVlID0gc2VsZWN0RWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcbiAgXHRpc011bHRpcGxlID0gc2VsZWN0RWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKTtcblxuICBcdC8vIElmIHRoZSA8c2VsZWN0PiBoYXMgYSBzcGVjaWZpZWQgdmFsdWUsIHRoYXQgc2hvdWxkIG92ZXJyaWRlXG4gIFx0Ly8gdGhlc2Ugb3B0aW9uc1xuICBcdGlmIChzZWxlY3RWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRvcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKG8pIHtcbiAgXHRcdFx0dmFyIG9wdGlvblZhbHVlLCBzaG91bGRTZWxlY3Q7XG5cbiAgXHRcdFx0b3B0aW9uVmFsdWUgPSBvLl9yYWN0aXZlID8gby5fcmFjdGl2ZS52YWx1ZSA6IG8udmFsdWU7XG4gIFx0XHRcdHNob3VsZFNlbGVjdCA9IGlzTXVsdGlwbGUgPyB2YWx1ZUNvbnRhaW5zKHNlbGVjdFZhbHVlLCBvcHRpb25WYWx1ZSkgOiBzZWxlY3RWYWx1ZSA9PSBvcHRpb25WYWx1ZTtcblxuICBcdFx0XHRpZiAoc2hvdWxkU2VsZWN0KSB7XG4gIFx0XHRcdFx0b3B0aW9uV2FzU2VsZWN0ZWQgPSB0cnVlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0by5zZWxlY3RlZCA9IHNob3VsZFNlbGVjdDtcbiAgXHRcdH0pO1xuXG4gIFx0XHRpZiAoIW9wdGlvbldhc1NlbGVjdGVkKSB7XG4gIFx0XHRcdGlmIChvcHRpb25zWzBdKSB7XG4gIFx0XHRcdFx0b3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoc2VsZWN0RWxlbWVudC5iaW5kaW5nKSB7XG4gIFx0XHRcdFx0c2VsZWN0RWxlbWVudC5iaW5kaW5nLmZvcmNlVXBkYXRlKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBPdGhlcndpc2UgdGhlIHZhbHVlIHNob3VsZCBiZSBpbml0aWFsaXNlZCBhY2NvcmRpbmcgdG8gd2hpY2hcbiAgXHQvLyA8b3B0aW9uPiBlbGVtZW50IGlzIHNlbGVjdGVkLCBpZiB0d293YXkgYmluZGluZyBpcyBpbiBlZmZlY3RcbiAgXHRlbHNlIGlmIChzZWxlY3RFbGVtZW50LmJpbmRpbmcpIHtcbiAgXHRcdHNlbGVjdEVsZW1lbnQuYmluZGluZy5mb3JjZVVwZGF0ZSgpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbHVlQ29udGFpbnMoc2VsZWN0VmFsdWUsIG9wdGlvblZhbHVlKSB7XG4gIFx0dmFyIGkgPSBzZWxlY3RWYWx1ZS5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aWYgKHNlbGVjdFZhbHVlW2ldID09IG9wdGlvblZhbHVlKSB7XG4gIFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNwZWNpYWxfb3B0aW9uX19pbml0KG9wdGlvbiwgdGVtcGxhdGUpIHtcbiAgXHRvcHRpb24uc2VsZWN0ID0gZmluZFBhcmVudFNlbGVjdChvcHRpb24ucGFyZW50KTtcblxuICBcdC8vIHdlIG1pZ2h0IGJlIGluc2lkZSBhIDxkYXRhbGlzdD4gZWxlbWVudFxuICBcdGlmICghb3B0aW9uLnNlbGVjdCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdG9wdGlvbi5zZWxlY3Qub3B0aW9ucy5wdXNoKG9wdGlvbik7XG5cbiAgXHQvLyBJZiB0aGUgdmFsdWUgYXR0cmlidXRlIGlzIG1pc3NpbmcsIHVzZSB0aGUgZWxlbWVudCdzIGNvbnRlbnRcbiAgXHRpZiAoIXRlbXBsYXRlLmEpIHtcbiAgXHRcdHRlbXBsYXRlLmEgPSB7fTtcbiAgXHR9XG5cbiAgXHQvLyAuLi5hcyBsb25nIGFzIGl0IGlzbid0IGRpc2FibGVkXG4gIFx0aWYgKHRlbXBsYXRlLmEudmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhdGVtcGxhdGUuYS5oYXNPd25Qcm9wZXJ0eShcImRpc2FibGVkXCIpKSB7XG4gIFx0XHR0ZW1wbGF0ZS5hLnZhbHVlID0gdGVtcGxhdGUuZjtcbiAgXHR9XG5cbiAgXHQvLyBJZiB0aGVyZSBpcyBhIGBzZWxlY3RlZGAgYXR0cmlidXRlLCBidXQgdGhlIDxzZWxlY3Q+XG4gIFx0Ly8gYWxyZWFkeSBoYXMgYSB2YWx1ZSwgZGVsZXRlIGl0XG4gIFx0aWYgKFwic2VsZWN0ZWRcIiBpbiB0ZW1wbGF0ZS5hICYmIG9wdGlvbi5zZWxlY3QuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0ZGVsZXRlIHRlbXBsYXRlLmEuc2VsZWN0ZWQ7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gc3BlY2lhbF9vcHRpb25fX3VuYmluZChvcHRpb24pIHtcbiAgXHRpZiAob3B0aW9uLnNlbGVjdCkge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KG9wdGlvbi5zZWxlY3Qub3B0aW9ucywgb3B0aW9uKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kUGFyZW50U2VsZWN0KGVsZW1lbnQpIHtcbiAgXHRpZiAoIWVsZW1lbnQpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRkbyB7XG4gIFx0XHRpZiAoZWxlbWVudC5uYW1lID09PSBcInNlbGVjdFwiKSB7XG4gIFx0XHRcdHJldHVybiBlbGVtZW50O1xuICBcdFx0fVxuICBcdH0gd2hpbGUgKGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudCk7XG4gIH1cblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfaW5pdCA9IEVsZW1lbnQkaW5pdDtcbiAgZnVuY3Rpb24gRWxlbWVudCRpbml0KG9wdGlvbnMpIHtcbiAgXHR2YXIgcGFyZW50RnJhZ21lbnQsIHRlbXBsYXRlLCByYWN0aXZlLCBiaW5kaW5nLCBiaW5kaW5ncywgdHdvd2F5LCBiaW5kaW5nQXR0cnM7XG5cbiAgXHR0aGlzLnR5cGUgPSBFTEVNRU5UO1xuXG4gIFx0Ly8gc3R1ZmYgd2UnbGwgbmVlZCBsYXRlclxuICBcdHBhcmVudEZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcblxuICBcdHRoaXMucGFyZW50ID0gb3B0aW9ucy5wRWxlbWVudCB8fCBwYXJlbnRGcmFnbWVudC5wRWxlbWVudDtcblxuICBcdHRoaXMucm9vdCA9IHJhY3RpdmUgPSBwYXJlbnRGcmFnbWVudC5yb290O1xuICBcdHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuICBcdHRoaXMua2V5ID0gb3B0aW9ucy5rZXk7XG5cbiAgXHR0aGlzLm5hbWUgPSBlbmZvcmNlQ2FzZSh0ZW1wbGF0ZS5lKTtcblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIDxvcHRpb24+IGVsZW1lbnRzXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJvcHRpb25cIikge1xuICBcdFx0c3BlY2lhbF9vcHRpb25fX2luaXQodGhpcywgdGVtcGxhdGUpO1xuICBcdH1cblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIDxzZWxlY3Q+IGVsZW1lbnRzXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJzZWxlY3RcIikge1xuICBcdFx0dGhpcy5vcHRpb25zID0gW107XG4gIFx0XHR0aGlzLmJ1YmJsZSA9IHNlbGVjdF9fYnViYmxlOyAvLyBUT0RPIHRoaXMgaXMgYSBrbHVkZ2VcbiAgXHR9XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSA8Zm9ybT4gZWxlbWVudHNcbiAgXHRpZiAodGhpcy5uYW1lID09PSBcImZvcm1cIikge1xuICBcdFx0dGhpcy5mb3JtQmluZGluZ3MgPSBbXTtcbiAgXHR9XG5cbiAgXHQvLyBoYW5kbGUgYmluZGluZyBhdHRyaWJ1dGVzIGZpcnN0ICh0d293YXksIGxhenkpXG4gIFx0YmluZGluZ0F0dHJzID0gcHJvY2Vzc0JpbmRpbmdBdHRyaWJ1dGVzKHRoaXMsIHRlbXBsYXRlKTtcblxuICBcdC8vIGNyZWF0ZSBhdHRyaWJ1dGVzXG4gIFx0dGhpcy5hdHRyaWJ1dGVzID0gY3JlYXRlQXR0cmlidXRlcyh0aGlzLCB0ZW1wbGF0ZS5hKTtcbiAgXHR0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcyA9IGNyZWF0ZUNvbmRpdGlvbmFsQXR0cmlidXRlcyh0aGlzLCB0ZW1wbGF0ZS5tKTtcblxuICBcdC8vIGFwcGVuZCBjaGlsZHJlbiwgaWYgdGhlcmUgYXJlIGFueVxuICBcdGlmICh0ZW1wbGF0ZS5mKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUuZixcbiAgXHRcdFx0cm9vdDogcmFjdGl2ZSxcbiAgXHRcdFx0b3duZXI6IHRoaXMsXG4gIFx0XHRcdHBFbGVtZW50OiB0aGlzLFxuICBcdFx0XHRjc3NJZHM6IG51bGxcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdC8vIHRoZSBlbGVtZW50IHNldHRpbmcgc2hvdWxkIG92ZXJyaWRlIHRoZSByYWN0aXZlIHNldHRpbmdcbiAgXHR0d293YXkgPSByYWN0aXZlLnR3b3dheTtcbiAgXHRpZiAoYmluZGluZ0F0dHJzLnR3b3dheSA9PT0gZmFsc2UpIHR3b3dheSA9IGZhbHNlO2Vsc2UgaWYgKGJpbmRpbmdBdHRycy50d293YXkgPT09IHRydWUpIHR3b3dheSA9IHRydWU7XG5cbiAgXHR0aGlzLnR3b3dheSA9IHR3b3dheTtcbiAgXHR0aGlzLmxhenkgPSBiaW5kaW5nQXR0cnMubGF6eTtcblxuICBcdC8vIGNyZWF0ZSB0d293YXkgYmluZGluZ1xuICBcdGlmICh0d293YXkgJiYgKGJpbmRpbmcgPSBpbml0X2NyZWF0ZVR3b3dheUJpbmRpbmcodGhpcywgdGVtcGxhdGUuYSkpKSB7XG4gIFx0XHR0aGlzLmJpbmRpbmcgPSBiaW5kaW5nO1xuXG4gIFx0XHQvLyByZWdpc3RlciB0aGlzIHdpdGggdGhlIHJvb3QsIHNvIHRoYXQgd2UgY2FuIGRvIHJhY3RpdmUudXBkYXRlTW9kZWwoKVxuICBcdFx0YmluZGluZ3MgPSB0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzW2JpbmRpbmcua2V5cGF0aC5zdHJdIHx8ICh0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzW2JpbmRpbmcua2V5cGF0aC5zdHJdID0gW10pO1xuICBcdFx0YmluZGluZ3MucHVzaChiaW5kaW5nKTtcbiAgXHR9XG5cbiAgXHQvLyBjcmVhdGUgZXZlbnQgcHJveGllc1xuICBcdGlmICh0ZW1wbGF0ZS52KSB7XG4gIFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMgPSBjcmVhdGVFdmVudEhhbmRsZXJzKHRoaXMsIHRlbXBsYXRlLnYpO1xuICBcdH1cblxuICBcdC8vIGNyZWF0ZSBkZWNvcmF0b3JcbiAgXHRpZiAodGVtcGxhdGUubykge1xuICBcdFx0dGhpcy5kZWNvcmF0b3IgPSBuZXcgX0RlY29yYXRvcih0aGlzLCB0ZW1wbGF0ZS5vKTtcbiAgXHR9XG5cbiAgXHQvLyBjcmVhdGUgdHJhbnNpdGlvbnNcbiAgXHR0aGlzLmludHJvID0gdGVtcGxhdGUudDAgfHwgdGVtcGxhdGUudDE7XG4gIFx0dGhpcy5vdXRybyA9IHRlbXBsYXRlLnQwIHx8IHRlbXBsYXRlLnQyO1xuICB9XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX3JlYmluZCA9IEVsZW1lbnQkcmViaW5kO1xuICBmdW5jdGlvbiBFbGVtZW50JHJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0dmFyIGksIHN0b3JhZ2UsIGxpdmVRdWVyaWVzLCByYWN0aXZlO1xuXG4gIFx0aWYgKHRoaXMuYXR0cmlidXRlcykge1xuICBcdFx0dGhpcy5hdHRyaWJ1dGVzLmZvckVhY2gocmViaW5kKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMpIHtcbiAgXHRcdHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzLmZvckVhY2gocmViaW5kKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5ldmVudEhhbmRsZXJzKSB7XG4gIFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaChyZWJpbmQpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmRlY29yYXRvcikge1xuICBcdFx0cmViaW5kKHRoaXMuZGVjb3JhdG9yKTtcbiAgXHR9XG5cbiAgXHQvLyByZWJpbmQgY2hpbGRyZW5cbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0cmViaW5kKHRoaXMuZnJhZ21lbnQpO1xuICBcdH1cblxuICBcdC8vIFVwZGF0ZSBsaXZlIHF1ZXJpZXMsIGlmIG5lY2Vzc2FyeVxuICBcdGlmIChsaXZlUXVlcmllcyA9IHRoaXMubGl2ZVF1ZXJpZXMpIHtcbiAgXHRcdHJhY3RpdmUgPSB0aGlzLnJvb3Q7XG5cbiAgXHRcdGkgPSBsaXZlUXVlcmllcy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGxpdmVRdWVyaWVzW2ldLl9tYWtlRGlydHkoKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5ub2RlICYmIChzdG9yYWdlID0gdGhpcy5ub2RlLl9yYWN0aXZlKSkge1xuXG4gIFx0XHQvLyBhZGp1c3Qga2V5cGF0aCBpZiBuZWVkZWRcbiAgXHRcdGFzc2lnbk5ld0tleXBhdGgoc3RvcmFnZSwgXCJrZXlwYXRoXCIsIG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH1cblxuICBcdGZ1bmN0aW9uIHJlYmluZCh0aGluZykge1xuICBcdFx0dGhpbmcucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNwZWNpYWxfaW1nX19yZW5kZXIoaW1nKSB7XG4gIFx0dmFyIGxvYWRIYW5kbGVyO1xuXG4gIFx0Ly8gaWYgdGhpcyBpcyBhbiA8aW1nPiwgYW5kIHdlJ3JlIGluIGEgY3JhcCBicm93c2VyLCB3ZSBtYXkgbmVlZCB0byBwcmV2ZW50IGl0XG4gIFx0Ly8gZnJvbSBvdmVycmlkaW5nIHdpZHRoIGFuZCBoZWlnaHQgd2hlbiBpdCBsb2FkcyB0aGUgc3JjXG4gIFx0aWYgKGltZy5hdHRyaWJ1dGVzLndpZHRoIHx8IGltZy5hdHRyaWJ1dGVzLmhlaWdodCkge1xuICBcdFx0aW1nLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgbG9hZEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHZhciB3aWR0aCA9IGltZy5nZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKSxcbiAgXHRcdFx0ICAgIGhlaWdodCA9IGltZy5nZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIik7XG5cbiAgXHRcdFx0aWYgKHdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHRpbWcubm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3aWR0aCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHRpbWcubm9kZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGltZy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGxvYWRIYW5kbGVyLCBmYWxzZSk7XG4gIFx0XHR9LCBmYWxzZSk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZm9ybV9fcmVuZGVyKGVsZW1lbnQpIHtcbiAgXHRlbGVtZW50Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0XCIsIGhhbmRsZVJlc2V0LCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtX191bnJlbmRlcihlbGVtZW50KSB7XG4gIFx0ZWxlbWVudC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNldFwiLCBoYW5kbGVSZXNldCwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUmVzZXQoKSB7XG4gIFx0dmFyIGVsZW1lbnQgPSB0aGlzLl9yYWN0aXZlLnByb3h5O1xuXG4gIFx0Z2xvYmFsX3J1bmxvb3Auc3RhcnQoKTtcbiAgXHRlbGVtZW50LmZvcm1CaW5kaW5ncy5mb3JFYWNoKHVwZGF0ZU1vZGVsKTtcbiAgXHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZU1vZGVsKGJpbmRpbmcpIHtcbiAgXHRiaW5kaW5nLnJvb3Qudmlld21vZGVsLnNldChiaW5kaW5nLmtleXBhdGgsIGJpbmRpbmcucmVzZXRWYWx1ZSk7XG4gIH1cblxuICB2YXIgVHJhbnNpdGlvbl9wcm90b3R5cGVfaW5pdCA9IFRyYW5zaXRpb24kaW5pdDtcbiAgZnVuY3Rpb24gVHJhbnNpdGlvbiRpbml0KGVsZW1lbnQsIHRlbXBsYXRlLCBpc0ludHJvKSB7XG4gIFx0dmFyIHJhY3RpdmUsIG5hbWUsIGZyYWdtZW50O1xuXG4gIFx0dGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgXHR0aGlzLnJvb3QgPSByYWN0aXZlID0gZWxlbWVudC5yb290O1xuICBcdHRoaXMuaXNJbnRybyA9IGlzSW50cm87XG5cbiAgXHRuYW1lID0gdGVtcGxhdGUubiB8fCB0ZW1wbGF0ZTtcblxuICBcdGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0ZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdHRlbXBsYXRlOiBuYW1lLFxuICBcdFx0XHRyb290OiByYWN0aXZlLFxuICBcdFx0XHRvd25lcjogZWxlbWVudFxuICBcdFx0fSk7XG5cbiAgXHRcdG5hbWUgPSBmcmFnbWVudC50b1N0cmluZygpO1xuICBcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cbiAgXHRcdGlmIChuYW1lID09PSBcIlwiKSB7XG4gIFx0XHRcdC8vIGVtcHR5IHN0cmluZyBva2F5LCBqdXN0IG5vIHRyYW5zaXRpb25cbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHRoaXMubmFtZSA9IG5hbWU7XG5cbiAgXHRpZiAodGVtcGxhdGUuYSkge1xuICBcdFx0dGhpcy5wYXJhbXMgPSB0ZW1wbGF0ZS5hO1xuICBcdH0gZWxzZSBpZiAodGVtcGxhdGUuZCkge1xuICBcdFx0Ly8gVE9ETyBpcyB0aGVyZSBhIHdheSB0byBpbnRlcnByZXQgZHluYW1pYyBhcmd1bWVudHMgd2l0aG91dCBhbGwgdGhlXG4gIFx0XHQvLyAnZGVwZW5kZW5jeSB0aHJhc2hpbmcnP1xuICBcdFx0ZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5kLFxuICBcdFx0XHRyb290OiByYWN0aXZlLFxuICBcdFx0XHRvd25lcjogZWxlbWVudFxuICBcdFx0fSk7XG5cbiAgXHRcdHRoaXMucGFyYW1zID0gZnJhZ21lbnQuZ2V0QXJnc0xpc3QoKTtcbiAgXHRcdGZyYWdtZW50LnVuYmluZCgpO1xuICBcdH1cblxuICBcdHRoaXMuX2ZuID0gZmluZEluVmlld0hpZXJhcmNoeShcInRyYW5zaXRpb25zXCIsIHJhY3RpdmUsIG5hbWUpO1xuXG4gIFx0aWYgKCF0aGlzLl9mbikge1xuICBcdFx0d2Fybk9uY2VJZkRlYnVnKG1pc3NpbmdQbHVnaW4obmFtZSwgXCJ0cmFuc2l0aW9uXCIpLCB7IHJhY3RpdmU6IHRoaXMucm9vdCB9KTtcbiAgXHR9XG4gIH1cblxuICB2YXIgY2FtZWxDYXNlID0gZnVuY3Rpb24gKGh5cGhlbmF0ZWRTdHIpIHtcbiAgXHRyZXR1cm4gaHlwaGVuYXRlZFN0ci5yZXBsYWNlKC8tKFthLXpBLVpdKS9nLCBmdW5jdGlvbiAobWF0Y2gsICQxKSB7XG4gIFx0XHRyZXR1cm4gJDEudG9VcHBlckNhc2UoKTtcbiAgXHR9KTtcbiAgfTtcblxuICB2YXIgaGVscGVyc19wcmVmaXhfX3ByZWZpeCwgcHJlZml4Q2FjaGUsIGhlbHBlcnNfcHJlZml4X190ZXN0U3R5bGU7XG5cbiAgaWYgKCFpc0NsaWVudCkge1xuICBcdGhlbHBlcnNfcHJlZml4X19wcmVmaXggPSBudWxsO1xuICB9IGVsc2Uge1xuICBcdHByZWZpeENhY2hlID0ge307XG4gIFx0aGVscGVyc19wcmVmaXhfX3Rlc3RTdHlsZSA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGU7XG5cbiAgXHRoZWxwZXJzX3ByZWZpeF9fcHJlZml4ID0gZnVuY3Rpb24gKHByb3ApIHtcbiAgXHRcdHZhciBpLCB2ZW5kb3IsIGNhcHBlZDtcblxuICBcdFx0cHJvcCA9IGNhbWVsQ2FzZShwcm9wKTtcblxuICBcdFx0aWYgKCFwcmVmaXhDYWNoZVtwcm9wXSkge1xuICBcdFx0XHRpZiAoaGVscGVyc19wcmVmaXhfX3Rlc3RTdHlsZVtwcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0cHJlZml4Q2FjaGVbcHJvcF0gPSBwcm9wO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdC8vIHRlc3QgdmVuZG9ycy4uLlxuICBcdFx0XHRcdGNhcHBlZCA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnN1YnN0cmluZygxKTtcblxuICBcdFx0XHRcdGkgPSB2ZW5kb3JzLmxlbmd0aDtcbiAgXHRcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0XHR2ZW5kb3IgPSB2ZW5kb3JzW2ldO1xuICBcdFx0XHRcdFx0aWYgKGhlbHBlcnNfcHJlZml4X190ZXN0U3R5bGVbdmVuZG9yICsgY2FwcGVkXSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0XHRcdHByZWZpeENhY2hlW3Byb3BdID0gdmVuZG9yICsgY2FwcGVkO1xuICBcdFx0XHRcdFx0XHRicmVhaztcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHByZWZpeENhY2hlW3Byb3BdO1xuICBcdH07XG4gIH1cblxuICB2YXIgaGVscGVyc19wcmVmaXggPSBoZWxwZXJzX3ByZWZpeF9fcHJlZml4O1xuXG4gIHZhciBnZXRTdHlsZSwgcHJvdG90eXBlX2dldFN0eWxlX19nZXRDb21wdXRlZFN0eWxlO1xuXG4gIGlmICghaXNDbGllbnQpIHtcbiAgXHRnZXRTdHlsZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gIFx0cHJvdG90eXBlX2dldFN0eWxlX19nZXRDb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgfHwgbGVnYWN5LmdldENvbXB1dGVkU3R5bGU7XG5cbiAgXHRnZXRTdHlsZSA9IGZ1bmN0aW9uIChwcm9wcykge1xuICBcdFx0dmFyIGNvbXB1dGVkU3R5bGUsIHN0eWxlcywgaSwgcHJvcCwgdmFsdWU7XG5cbiAgXHRcdGNvbXB1dGVkU3R5bGUgPSBwcm90b3R5cGVfZ2V0U3R5bGVfX2dldENvbXB1dGVkU3R5bGUodGhpcy5ub2RlKTtcblxuICBcdFx0aWYgKHR5cGVvZiBwcm9wcyA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHR2YWx1ZSA9IGNvbXB1dGVkU3R5bGVbaGVscGVyc19wcmVmaXgocHJvcHMpXTtcbiAgXHRcdFx0aWYgKHZhbHVlID09PSBcIjBweFwiKSB7XG4gIFx0XHRcdFx0dmFsdWUgPSAwO1xuICBcdFx0XHR9XG4gIFx0XHRcdHJldHVybiB2YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFpc0FycmF5KHByb3BzKSkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2l0aW9uJGdldFN0eWxlIG11c3QgYmUgcGFzc2VkIGEgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyBDU1MgcHJvcGVydGllc1wiKTtcbiAgXHRcdH1cblxuICBcdFx0c3R5bGVzID0ge307XG5cbiAgXHRcdGkgPSBwcm9wcy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdHByb3AgPSBwcm9wc1tpXTtcbiAgXHRcdFx0dmFsdWUgPSBjb21wdXRlZFN0eWxlW2hlbHBlcnNfcHJlZml4KHByb3ApXTtcbiAgXHRcdFx0aWYgKHZhbHVlID09PSBcIjBweFwiKSB7XG4gIFx0XHRcdFx0dmFsdWUgPSAwO1xuICBcdFx0XHR9XG4gIFx0XHRcdHN0eWxlc1twcm9wXSA9IHZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gc3R5bGVzO1xuICBcdH07XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2dldFN0eWxlID0gZ2V0U3R5bGU7XG5cbiAgdmFyIHNldFN0eWxlID0gZnVuY3Rpb24gKHN0eWxlLCB2YWx1ZSkge1xuICBcdHZhciBwcm9wO1xuXG4gIFx0aWYgKHR5cGVvZiBzdHlsZSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0dGhpcy5ub2RlLnN0eWxlW2hlbHBlcnNfcHJlZml4KHN0eWxlKV0gPSB2YWx1ZTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0Zm9yIChwcm9wIGluIHN0eWxlKSB7XG4gIFx0XHRcdGlmIChzdHlsZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICBcdFx0XHRcdHRoaXMubm9kZS5zdHlsZVtoZWxwZXJzX3ByZWZpeChwcm9wKV0gPSBzdHlsZVtwcm9wXTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBUaWNrZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHZhciBlYXNpbmc7XG5cbiAgXHR0aGlzLmR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcbiAgXHR0aGlzLnN0ZXAgPSBvcHRpb25zLnN0ZXA7XG4gIFx0dGhpcy5jb21wbGV0ZSA9IG9wdGlvbnMuY29tcGxldGU7XG5cbiAgXHQvLyBlYXNpbmdcbiAgXHRpZiAodHlwZW9mIG9wdGlvbnMuZWFzaW5nID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRlYXNpbmcgPSBvcHRpb25zLnJvb3QuZWFzaW5nW29wdGlvbnMuZWFzaW5nXTtcblxuICBcdFx0aWYgKCFlYXNpbmcpIHtcbiAgXHRcdFx0d2Fybk9uY2VJZkRlYnVnKG1pc3NpbmdQbHVnaW4ob3B0aW9ucy5lYXNpbmcsIFwiZWFzaW5nXCIpKTtcbiAgXHRcdFx0ZWFzaW5nID0gbGluZWFyO1xuICBcdFx0fVxuICBcdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuZWFzaW5nID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRlYXNpbmcgPSBsaW5lYXI7XG4gIFx0fVxuXG4gIFx0dGhpcy5lYXNpbmcgPSBlYXNpbmc7XG5cbiAgXHR0aGlzLnN0YXJ0ID0gdXRpbHNfZ2V0VGltZSgpO1xuICBcdHRoaXMuZW5kID0gdGhpcy5zdGFydCArIHRoaXMuZHVyYXRpb247XG5cbiAgXHR0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICBcdHNoYXJlZF9hbmltYXRpb25zLmFkZCh0aGlzKTtcbiAgfTtcblxuICBUaWNrZXIucHJvdG90eXBlID0ge1xuICBcdHRpY2s6IGZ1bmN0aW9uIChub3cpIHtcbiAgXHRcdHZhciBlbGFwc2VkLCBlYXNlZDtcblxuICBcdFx0aWYgKCF0aGlzLnJ1bm5pbmcpIHtcbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAobm93ID4gdGhpcy5lbmQpIHtcbiAgXHRcdFx0aWYgKHRoaXMuc3RlcCkge1xuICBcdFx0XHRcdHRoaXMuc3RlcCgxKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICh0aGlzLmNvbXBsZXRlKSB7XG4gIFx0XHRcdFx0dGhpcy5jb21wbGV0ZSgxKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cblxuICBcdFx0ZWxhcHNlZCA9IG5vdyAtIHRoaXMuc3RhcnQ7XG4gIFx0XHRlYXNlZCA9IHRoaXMuZWFzaW5nKGVsYXBzZWQgLyB0aGlzLmR1cmF0aW9uKTtcblxuICBcdFx0aWYgKHRoaXMuc3RlcCkge1xuICBcdFx0XHR0aGlzLnN0ZXAoZWFzZWQpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9LFxuXG4gIFx0c3RvcDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuYWJvcnQpIHtcbiAgXHRcdFx0dGhpcy5hYm9ydCgpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIHNoYXJlZF9UaWNrZXIgPSBUaWNrZXI7XG4gIGZ1bmN0aW9uIGxpbmVhcih0KSB7XG4gIFx0cmV0dXJuIHQ7XG4gIH1cblxuICB2YXIgdW5wcmVmaXhQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIl4tKD86XCIgKyB2ZW5kb3JzLmpvaW4oXCJ8XCIpICsgXCIpLVwiKTtcblxuICB2YXIgdW5wcmVmaXggPSBmdW5jdGlvbiAocHJvcCkge1xuICBcdHJldHVybiBwcm9wLnJlcGxhY2UodW5wcmVmaXhQYXR0ZXJuLCBcIlwiKTtcbiAgfTtcblxuICB2YXIgdmVuZG9yUGF0dGVybiA9IG5ldyBSZWdFeHAoXCJeKD86XCIgKyB2ZW5kb3JzLmpvaW4oXCJ8XCIpICsgXCIpKFtBLVpdKVwiKTtcblxuICB2YXIgaHlwaGVuYXRlID0gZnVuY3Rpb24gKHN0cikge1xuICBcdHZhciBoeXBoZW5hdGVkO1xuXG4gIFx0aWYgKCFzdHIpIHtcbiAgXHRcdHJldHVybiBcIlwiOyAvLyBlZGdlIGNhc2VcbiAgXHR9XG5cbiAgXHRpZiAodmVuZG9yUGF0dGVybi50ZXN0KHN0cikpIHtcbiAgXHRcdHN0ciA9IFwiLVwiICsgc3RyO1xuICBcdH1cblxuICBcdGh5cGhlbmF0ZWQgPSBzdHIucmVwbGFjZSgvW0EtWl0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gIFx0XHRyZXR1cm4gXCItXCIgKyBtYXRjaC50b0xvd2VyQ2FzZSgpO1xuICBcdH0pO1xuXG4gIFx0cmV0dXJuIGh5cGhlbmF0ZWQ7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVRyYW5zaXRpb25zLFxuICAgICAgYW5pbWF0ZVN0eWxlX2NyZWF0ZVRyYW5zaXRpb25zX190ZXN0U3R5bGUsXG4gICAgICBUUkFOU0lUSU9OLFxuICAgICAgVFJBTlNJVElPTkVORCxcbiAgICAgIENTU19UUkFOU0lUSU9OU19FTkFCTEVELFxuICAgICAgVFJBTlNJVElPTl9EVVJBVElPTixcbiAgICAgIFRSQU5TSVRJT05fUFJPUEVSVFksXG4gICAgICBUUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTixcbiAgICAgIGNhblVzZUNzc1RyYW5zaXRpb25zID0ge30sXG4gICAgICBjYW5ub3RVc2VDc3NUcmFuc2l0aW9ucyA9IHt9O1xuXG4gIGlmICghaXNDbGllbnQpIHtcbiAgXHRjcmVhdGVUcmFuc2l0aW9ucyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gIFx0YW5pbWF0ZVN0eWxlX2NyZWF0ZVRyYW5zaXRpb25zX190ZXN0U3R5bGUgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlO1xuXG4gIFx0Ly8gZGV0ZXJtaW5lIHNvbWUgZmFjdHMgYWJvdXQgb3VyIGVudmlyb25tZW50XG4gIFx0KGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmIChhbmltYXRlU3R5bGVfY3JlYXRlVHJhbnNpdGlvbnNfX3Rlc3RTdHlsZS50cmFuc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0VFJBTlNJVElPTiA9IFwidHJhbnNpdGlvblwiO1xuICBcdFx0XHRUUkFOU0lUSU9ORU5EID0gXCJ0cmFuc2l0aW9uZW5kXCI7XG4gIFx0XHRcdENTU19UUkFOU0lUSU9OU19FTkFCTEVEID0gdHJ1ZTtcbiAgXHRcdH0gZWxzZSBpZiAoYW5pbWF0ZVN0eWxlX2NyZWF0ZVRyYW5zaXRpb25zX190ZXN0U3R5bGUud2Via2l0VHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFRSQU5TSVRJT04gPSBcIndlYmtpdFRyYW5zaXRpb25cIjtcbiAgXHRcdFx0VFJBTlNJVElPTkVORCA9IFwid2Via2l0VHJhbnNpdGlvbkVuZFwiO1xuICBcdFx0XHRDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCA9IHRydWU7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCA9IGZhbHNlO1xuICBcdFx0fVxuICBcdH0pKCk7XG5cbiAgXHRpZiAoVFJBTlNJVElPTikge1xuICBcdFx0VFJBTlNJVElPTl9EVVJBVElPTiA9IFRSQU5TSVRJT04gKyBcIkR1cmF0aW9uXCI7XG4gIFx0XHRUUkFOU0lUSU9OX1BST1BFUlRZID0gVFJBTlNJVElPTiArIFwiUHJvcGVydHlcIjtcbiAgXHRcdFRSQU5TSVRJT05fVElNSU5HX0ZVTkNUSU9OID0gVFJBTlNJVElPTiArIFwiVGltaW5nRnVuY3Rpb25cIjtcbiAgXHR9XG5cbiAgXHRjcmVhdGVUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uICh0LCB0bywgb3B0aW9ucywgY2hhbmdlZFByb3BlcnRpZXMsIHJlc29sdmUpIHtcblxuICBcdFx0Ly8gV2FpdCBhIGJlYXQgKG90aGVyd2lzZSB0aGUgdGFyZ2V0IHN0eWxlcyB3aWxsIGJlIGFwcGxpZWQgaW1tZWRpYXRlbHkpXG4gIFx0XHQvLyBUT0RPIHVzZSBhIGZhc3Rkb20tc3R5bGUgbWVjaGFuaXNtP1xuICBcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cbiAgXHRcdFx0dmFyIGhhc2hQcmVmaXgsIGpzVHJhbnNpdGlvbnNDb21wbGV0ZSwgY3NzVHJhbnNpdGlvbnNDb21wbGV0ZSwgY2hlY2tDb21wbGV0ZSwgdHJhbnNpdGlvbkVuZEhhbmRsZXI7XG5cbiAgXHRcdFx0Y2hlY2tDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRpZiAoanNUcmFuc2l0aW9uc0NvbXBsZXRlICYmIGNzc1RyYW5zaXRpb25zQ29tcGxldGUpIHtcbiAgXHRcdFx0XHRcdC8vIHdpbGwgY2hhbmdlcyB0byBldmVudHMgYW5kIGZpcmUgaGF2ZSBhbiB1bmV4cGVjdGVkIGNvbnNlcXVlbmNlIGhlcmU/XG4gIFx0XHRcdFx0XHR0LnJvb3QuZmlyZSh0Lm5hbWUgKyBcIjplbmRcIiwgdC5ub2RlLCB0LmlzSW50cm8pO1xuICBcdFx0XHRcdFx0cmVzb2x2ZSgpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fTtcblxuICBcdFx0XHQvLyB0aGlzIGlzIHVzZWQgdG8ga2VlcCB0cmFjayBvZiB3aGljaCBlbGVtZW50cyBjYW4gdXNlIENTUyB0byBhbmltYXRlXG4gIFx0XHRcdC8vIHdoaWNoIHByb3BlcnRpZXNcbiAgXHRcdFx0aGFzaFByZWZpeCA9ICh0Lm5vZGUubmFtZXNwYWNlVVJJIHx8IFwiXCIpICsgdC5ub2RlLnRhZ05hbWU7XG5cbiAgXHRcdFx0dC5ub2RlLnN0eWxlW1RSQU5TSVRJT05fUFJPUEVSVFldID0gY2hhbmdlZFByb3BlcnRpZXMubWFwKGhlbHBlcnNfcHJlZml4KS5tYXAoaHlwaGVuYXRlKS5qb2luKFwiLFwiKTtcbiAgXHRcdFx0dC5ub2RlLnN0eWxlW1RSQU5TSVRJT05fVElNSU5HX0ZVTkNUSU9OXSA9IGh5cGhlbmF0ZShvcHRpb25zLmVhc2luZyB8fCBcImxpbmVhclwiKTtcbiAgXHRcdFx0dC5ub2RlLnN0eWxlW1RSQU5TSVRJT05fRFVSQVRJT05dID0gb3B0aW9ucy5kdXJhdGlvbiAvIDEwMDAgKyBcInNcIjtcblxuICBcdFx0XHR0cmFuc2l0aW9uRW5kSGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBcdFx0XHRcdHZhciBpbmRleDtcblxuICBcdFx0XHRcdGluZGV4ID0gY2hhbmdlZFByb3BlcnRpZXMuaW5kZXhPZihjYW1lbENhc2UodW5wcmVmaXgoZXZlbnQucHJvcGVydHlOYW1lKSkpO1xuICBcdFx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcbiAgXHRcdFx0XHRcdGNoYW5nZWRQcm9wZXJ0aWVzLnNwbGljZShpbmRleCwgMSk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0aWYgKGNoYW5nZWRQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICBcdFx0XHRcdFx0Ly8gc3RpbGwgdHJhbnNpdGlvbmluZy4uLlxuICBcdFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdHQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFRSQU5TSVRJT05FTkQsIHRyYW5zaXRpb25FbmRIYW5kbGVyLCBmYWxzZSk7XG5cbiAgXHRcdFx0XHRjc3NUcmFuc2l0aW9uc0NvbXBsZXRlID0gdHJ1ZTtcbiAgXHRcdFx0XHRjaGVja0NvbXBsZXRlKCk7XG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0dC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoVFJBTlNJVElPTkVORCwgdHJhbnNpdGlvbkVuZEhhbmRsZXIsIGZhbHNlKTtcblxuICBcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHR2YXIgaSA9IGNoYW5nZWRQcm9wZXJ0aWVzLmxlbmd0aCxcbiAgXHRcdFx0XHQgICAgaGFzaCxcbiAgXHRcdFx0XHQgICAgb3JpZ2luYWxWYWx1ZSxcbiAgXHRcdFx0XHQgICAgaW5kZXgsXG4gIFx0XHRcdFx0ICAgIHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzID0gW10sXG4gIFx0XHRcdFx0ICAgIHByb3AsXG4gIFx0XHRcdFx0ICAgIHN1ZmZpeDtcblxuICBcdFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRcdHByb3AgPSBjaGFuZ2VkUHJvcGVydGllc1tpXTtcbiAgXHRcdFx0XHRcdGhhc2ggPSBoYXNoUHJlZml4ICsgcHJvcDtcblxuICBcdFx0XHRcdFx0aWYgKENTU19UUkFOU0lUSU9OU19FTkFCTEVEICYmICFjYW5ub3RVc2VDc3NUcmFuc2l0aW9uc1toYXNoXSkge1xuICBcdFx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbaGVscGVyc19wcmVmaXgocHJvcCldID0gdG9bcHJvcF07XG5cbiAgXHRcdFx0XHRcdFx0Ly8gSWYgd2UncmUgbm90IHN1cmUgaWYgQ1NTIHRyYW5zaXRpb25zIGFyZSBzdXBwb3J0ZWQgZm9yXG4gIFx0XHRcdFx0XHRcdC8vIHRoaXMgdGFnL3Byb3BlcnR5IGNvbWJvLCBmaW5kIG91dCBub3dcbiAgXHRcdFx0XHRcdFx0aWYgKCFjYW5Vc2VDc3NUcmFuc2l0aW9uc1toYXNoXSkge1xuICBcdFx0XHRcdFx0XHRcdG9yaWdpbmFsVmFsdWUgPSB0LmdldFN0eWxlKHByb3ApO1xuXG4gIFx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhpcyBwcm9wZXJ0eSBpcyB0cmFuc2l0aW9uYWJsZSBpbiB0aGlzIGJyb3dzZXIsXG4gIFx0XHRcdFx0XHRcdFx0Ly8gdGhlIGN1cnJlbnQgc3R5bGUgd2lsbCBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgdGFyZ2V0IHN0eWxlXG4gIFx0XHRcdFx0XHRcdFx0Y2FuVXNlQ3NzVHJhbnNpdGlvbnNbaGFzaF0gPSB0LmdldFN0eWxlKHByb3ApICE9IHRvW3Byb3BdO1xuICBcdFx0XHRcdFx0XHRcdGNhbm5vdFVzZUNzc1RyYW5zaXRpb25zW2hhc2hdID0gIWNhblVzZUNzc1RyYW5zaXRpb25zW2hhc2hdO1xuXG4gIFx0XHRcdFx0XHRcdFx0Ly8gUmVzZXQsIGlmIHdlJ3JlIGdvaW5nIHRvIHVzZSB0aW1lcnMgYWZ0ZXIgYWxsXG4gIFx0XHRcdFx0XHRcdFx0aWYgKGNhbm5vdFVzZUNzc1RyYW5zaXRpb25zW2hhc2hdKSB7XG4gIFx0XHRcdFx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbaGVscGVyc19wcmVmaXgocHJvcCldID0gb3JpZ2luYWxWYWx1ZTtcbiAgXHRcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0aWYgKCFDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCB8fCBjYW5ub3RVc2VDc3NUcmFuc2l0aW9uc1toYXNoXSkge1xuICBcdFx0XHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGZhbGwgYmFjayB0byB0aW1lci1iYXNlZCBzdHVmZlxuICBcdFx0XHRcdFx0XHRpZiAob3JpZ2luYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxWYWx1ZSA9IHQuZ2V0U3R5bGUocHJvcCk7XG4gIFx0XHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0XHQvLyBuZWVkIHRvIHJlbW92ZSB0aGlzIGZyb20gY2hhbmdlZFByb3BlcnRpZXMsIG90aGVyd2lzZSB0cmFuc2l0aW9uRW5kSGFuZGxlclxuICBcdFx0XHRcdFx0XHQvLyB3aWxsIGdldCBjb25mdXNlZFxuICBcdFx0XHRcdFx0XHRpbmRleCA9IGNoYW5nZWRQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCk7XG4gIFx0XHRcdFx0XHRcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0XHRcdFx0XHR3YXJuSWZEZWJ1ZyhcIlNvbWV0aGluZyB2ZXJ5IHN0cmFuZ2UgaGFwcGVuZWQgd2l0aCB0cmFuc2l0aW9ucy4gUGxlYXNlIHJhaXNlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9pc3N1ZXMgLSB0aGFua3MhXCIsIHsgbm9kZTogdC5ub2RlIH0pO1xuICBcdFx0XHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0XHRcdGNoYW5nZWRQcm9wZXJ0aWVzLnNwbGljZShpbmRleCwgMSk7XG4gIFx0XHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0XHQvLyBUT0RPIERldGVybWluZSB3aGV0aGVyIHRoaXMgcHJvcGVydHkgaXMgYW5pbWF0YWJsZSBhdCBhbGxcblxuICBcdFx0XHRcdFx0XHRzdWZmaXggPSAvW15cXGRdKiQvLmV4ZWModG9bcHJvcF0pWzBdO1xuXG4gIFx0XHRcdFx0XHRcdC8vIC4uLnRoZW4ga2ljayBvZmYgYSB0aW1lci1iYXNlZCB0cmFuc2l0aW9uXG4gIFx0XHRcdFx0XHRcdHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzLnB1c2goe1xuICBcdFx0XHRcdFx0XHRcdG5hbWU6IGhlbHBlcnNfcHJlZml4KHByb3ApLFxuICBcdFx0XHRcdFx0XHRcdGludGVycG9sYXRvcjogc2hhcmVkX2ludGVycG9sYXRlKHBhcnNlRmxvYXQob3JpZ2luYWxWYWx1ZSksIHBhcnNlRmxvYXQodG9bcHJvcF0pKSxcbiAgXHRcdFx0XHRcdFx0XHRzdWZmaXg6IHN1ZmZpeFxuICBcdFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHQvLyBqYXZhc2NyaXB0IHRyYW5zaXRpb25zXG4gIFx0XHRcdFx0aWYgKHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzLmxlbmd0aCkge1xuICBcdFx0XHRcdFx0bmV3IHNoYXJlZF9UaWNrZXIoe1xuICBcdFx0XHRcdFx0XHRyb290OiB0LnJvb3QsXG4gIFx0XHRcdFx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICBcdFx0XHRcdFx0XHRlYXNpbmc6IGNhbWVsQ2FzZShvcHRpb25zLmVhc2luZyB8fCBcIlwiKSxcbiAgXHRcdFx0XHRcdFx0c3RlcDogZnVuY3Rpb24gKHBvcykge1xuICBcdFx0XHRcdFx0XHRcdHZhciBwcm9wLCBpO1xuXG4gIFx0XHRcdFx0XHRcdFx0aSA9IHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzLmxlbmd0aDtcbiAgXHRcdFx0XHRcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0XHRcdFx0XHRwcm9wID0gcHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnNbaV07XG4gIFx0XHRcdFx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbcHJvcC5uYW1lXSA9IHByb3AuaW50ZXJwb2xhdG9yKHBvcykgKyBwcm9wLnN1ZmZpeDtcbiAgXHRcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHRcdH0sXG4gIFx0XHRcdFx0XHRcdGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHRcdFx0anNUcmFuc2l0aW9uc0NvbXBsZXRlID0gdHJ1ZTtcbiAgXHRcdFx0XHRcdFx0XHRjaGVja0NvbXBsZXRlKCk7XG4gIFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdH0pO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRqc1RyYW5zaXRpb25zQ29tcGxldGUgPSB0cnVlO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGlmICghY2hhbmdlZFByb3BlcnRpZXMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0XHQvLyBXZSBuZWVkIHRvIGNhbmNlbCB0aGUgdHJhbnNpdGlvbkVuZEhhbmRsZXIsIGFuZCBkZWFsIHdpdGhcbiAgXHRcdFx0XHRcdC8vIHRoZSBmYWN0IHRoYXQgaXQgd2lsbCBuZXZlciBmaXJlXG4gIFx0XHRcdFx0XHR0Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9ORU5ELCB0cmFuc2l0aW9uRW5kSGFuZGxlciwgZmFsc2UpO1xuICBcdFx0XHRcdFx0Y3NzVHJhbnNpdGlvbnNDb21wbGV0ZSA9IHRydWU7XG4gIFx0XHRcdFx0XHRjaGVja0NvbXBsZXRlKCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9LCAwKTtcbiAgXHRcdH0sIG9wdGlvbnMuZGVsYXkgfHwgMCk7XG4gIFx0fTtcbiAgfVxuXG4gIHZhciBhbmltYXRlU3R5bGVfY3JlYXRlVHJhbnNpdGlvbnMgPSBjcmVhdGVUcmFuc2l0aW9ucztcblxuICB2YXIgaGlkZGVuLCB2ZW5kb3IsIGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19wcmVmaXgsIGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19pLCB2aXNpYmlsaXR5O1xuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgXHRoaWRkZW4gPSBcImhpZGRlblwiO1xuXG4gIFx0dmlzaWJpbGl0eSA9IHt9O1xuXG4gIFx0aWYgKGhpZGRlbiBpbiBkb2N1bWVudCkge1xuICBcdFx0YW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHlfX3ByZWZpeCA9IFwiXCI7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19pID0gdmVuZG9ycy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHlfX2ktLSkge1xuICBcdFx0XHR2ZW5kb3IgPSB2ZW5kb3JzW2FuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19pXTtcbiAgXHRcdFx0aGlkZGVuID0gdmVuZG9yICsgXCJIaWRkZW5cIjtcblxuICBcdFx0XHRpZiAoaGlkZGVuIGluIGRvY3VtZW50KSB7XG4gIFx0XHRcdFx0YW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHlfX3ByZWZpeCA9IHZlbmRvcjtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChhbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9fcHJlZml4ICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHlfX3ByZWZpeCArIFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvbkNoYW5nZSk7XG5cbiAgXHRcdC8vIGluaXRpYWxpc2VcbiAgXHRcdG9uQ2hhbmdlKCk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdC8vIGdhaCwgd2UncmUgaW4gYW4gb2xkIGJyb3dzZXJcbiAgXHRcdGlmIChcIm9uZm9jdXNvdXRcIiBpbiBkb2N1bWVudCkge1xuICBcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgb25IaWRlKTtcbiAgXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgb25TaG93KTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgb25IaWRlKTtcbiAgXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIG9uSGlkZSk7XG5cbiAgXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlc2hvd1wiLCBvblNob3cpO1xuICBcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIG9uU2hvdyk7XG4gIFx0XHR9XG5cbiAgXHRcdHZpc2liaWxpdHkuaGlkZGVuID0gZmFsc2U7IC8vIHVudGlsIHByb3ZlbiBvdGhlcndpc2UuIE5vdCBpZGVhbCBidXQgaGV5XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gIFx0dmlzaWJpbGl0eS5oaWRkZW4gPSBkb2N1bWVudFtoaWRkZW5dO1xuICB9XG5cbiAgZnVuY3Rpb24gb25IaWRlKCkge1xuICBcdHZpc2liaWxpdHkuaGlkZGVuID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU2hvdygpIHtcbiAgXHR2aXNpYmlsaXR5LmhpZGRlbiA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5ID0gdmlzaWJpbGl0eTtcblxuICB2YXIgYW5pbWF0ZVN0eWxlLCBfYW5pbWF0ZVN0eWxlX19nZXRDb21wdXRlZFN0eWxlLCByZXNvbHZlZDtcblxuICBpZiAoIWlzQ2xpZW50KSB7XG4gIFx0YW5pbWF0ZVN0eWxlID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgXHRfYW5pbWF0ZVN0eWxlX19nZXRDb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgfHwgbGVnYWN5LmdldENvbXB1dGVkU3R5bGU7XG5cbiAgXHRhbmltYXRlU3R5bGUgPSBmdW5jdGlvbiAoc3R5bGUsIHZhbHVlLCBvcHRpb25zKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgdG87XG5cbiAgXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcInQuYW5pbWF0ZVN0eWxlKCkgcmV0dXJucyBhIHByb21pc2UgLSB1c2UgLnRoZW4oKSBpbnN0ZWFkIG9mIHBhc3NpbmcgYSBjYWxsYmFja1wiKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gcGFnZSBpc24ndCB2aXNpYmxlLiBEb24ndCBhbmltYXRlIGFueXRoaW5nLCBiZWNhdXNlXG4gIFx0XHQvLyB0aGF0IHdheSB5b3UnbGwgbmV2ZXIgZ2V0IENTUyB0cmFuc2l0aW9uZW5kIGV2ZW50c1xuICBcdFx0aWYgKGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5LmhpZGRlbikge1xuICBcdFx0XHR0aGlzLnNldFN0eWxlKHN0eWxlLCB2YWx1ZSk7XG4gIFx0XHRcdHJldHVybiByZXNvbHZlZCB8fCAocmVzb2x2ZWQgPSB1dGlsc19Qcm9taXNlLnJlc29sdmUoKSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0eXBlb2Ygc3R5bGUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0dG8gPSB7fTtcbiAgXHRcdFx0dG9bc3R5bGVdID0gdmFsdWU7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0byA9IHN0eWxlO1xuXG4gIFx0XHRcdC8vIHNodWZmbGUgYXJndW1lbnRzXG4gIFx0XHRcdG9wdGlvbnMgPSB2YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gQXMgb2YgMC4zLjksIHRyYW5zaXRpb24gYXV0aG9ycyBzaG91bGQgc3VwcGx5IGFuIGBvcHRpb25gIG9iamVjdCB3aXRoXG4gIFx0XHQvLyBgZHVyYXRpb25gIGFuZCBgZWFzaW5nYCBwcm9wZXJ0aWVzIChhbmQgb3B0aW9uYWwgYGRlbGF5YCksIHBsdXMgYVxuICBcdFx0Ly8gY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGNvbXBsZXRlc1xuXG4gIFx0XHQvLyBUT0RPIHJlbW92ZSB0aGlzIGNoZWNrIGluIGEgZnV0dXJlIHZlcnNpb25cbiAgXHRcdGlmICghb3B0aW9ucykge1xuICBcdFx0XHR3YXJuT25jZUlmRGVidWcoXCJUaGUgXFxcIiVzXFxcIiB0cmFuc2l0aW9uIGRvZXMgbm90IHN1cHBseSBhbiBvcHRpb25zIG9iamVjdCB0byBgdC5hbmltYXRlU3R5bGUoKWAuIFRoaXMgd2lsbCBicmVhayBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIFJhY3RpdmUuIEZvciBtb3JlIGluZm8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SYWN0aXZlSlMvUmFjdGl2ZS9pc3N1ZXMvMzQwXCIsIHRoaXMubmFtZSk7XG4gIFx0XHRcdG9wdGlvbnMgPSB0aGlzO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgcHJvbWlzZSA9IG5ldyB1dGlsc19Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gIFx0XHRcdHZhciBwcm9wZXJ0eU5hbWVzLCBjaGFuZ2VkUHJvcGVydGllcywgY29tcHV0ZWRTdHlsZSwgY3VycmVudCwgZnJvbSwgaSwgcHJvcDtcblxuICBcdFx0XHQvLyBFZGdlIGNhc2UgLSBpZiBkdXJhdGlvbiBpcyB6ZXJvLCBzZXQgc3R5bGUgc3luY2hyb25vdXNseSBhbmQgY29tcGxldGVcbiAgXHRcdFx0aWYgKCFvcHRpb25zLmR1cmF0aW9uKSB7XG4gIFx0XHRcdFx0X3RoaXMuc2V0U3R5bGUodG8pO1xuICBcdFx0XHRcdHJlc29sdmUoKTtcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBHZXQgYSBsaXN0IG9mIHRoZSBwcm9wZXJ0aWVzIHdlJ3JlIGFuaW1hdGluZ1xuICBcdFx0XHRwcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmtleXModG8pO1xuICBcdFx0XHRjaGFuZ2VkUHJvcGVydGllcyA9IFtdO1xuXG4gIFx0XHRcdC8vIFN0b3JlIHRoZSBjdXJyZW50IHN0eWxlc1xuICBcdFx0XHRjb21wdXRlZFN0eWxlID0gX2FuaW1hdGVTdHlsZV9fZ2V0Q29tcHV0ZWRTdHlsZShfdGhpcy5ub2RlKTtcblxuICBcdFx0XHRmcm9tID0ge307XG4gIFx0XHRcdGkgPSBwcm9wZXJ0eU5hbWVzLmxlbmd0aDtcbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdHByb3AgPSBwcm9wZXJ0eU5hbWVzW2ldO1xuICBcdFx0XHRcdGN1cnJlbnQgPSBjb21wdXRlZFN0eWxlW2hlbHBlcnNfcHJlZml4KHByb3ApXTtcblxuICBcdFx0XHRcdGlmIChjdXJyZW50ID09PSBcIjBweFwiKSB7XG4gIFx0XHRcdFx0XHRjdXJyZW50ID0gMDtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGtub3cgaWYgd2UncmUgYWN0dWFsbHkgY2hhbmdpbmcgYW55dGhpbmdcbiAgXHRcdFx0XHRpZiAoY3VycmVudCAhPSB0b1twcm9wXSkge1xuICBcdFx0XHRcdFx0Ly8gdXNlICE9IGluc3RlYWQgb2YgIT09LCBzbyB3ZSBjYW4gY29tcGFyZSBzdHJpbmdzIHdpdGggbnVtYmVyc1xuICBcdFx0XHRcdFx0Y2hhbmdlZFByb3BlcnRpZXMucHVzaChwcm9wKTtcblxuICBcdFx0XHRcdFx0Ly8gbWFrZSB0aGUgY29tcHV0ZWQgc3R5bGUgZXhwbGljaXQsIHNvIHdlIGNhbiBhbmltYXRlIHdoZXJlXG4gIFx0XHRcdFx0XHQvLyBlLmcuIGhlaWdodD0nYXV0bydcbiAgXHRcdFx0XHRcdF90aGlzLm5vZGUuc3R5bGVbaGVscGVyc19wcmVmaXgocHJvcCldID0gY3VycmVudDtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBJZiB3ZSdyZSBub3QgYWN0dWFsbHkgY2hhbmdpbmcgYW55dGhpbmcsIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50XG4gIFx0XHRcdC8vIHdpbGwgbmV2ZXIgZmlyZSEgU28gd2UgY29tcGxldGUgZWFybHlcbiAgXHRcdFx0aWYgKCFjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRyZXNvbHZlKCk7XG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0YW5pbWF0ZVN0eWxlX2NyZWF0ZVRyYW5zaXRpb25zKF90aGlzLCB0bywgb3B0aW9ucywgY2hhbmdlZFByb3BlcnRpZXMsIHJlc29sdmUpO1xuICBcdFx0fSk7XG5cbiAgXHRcdHJldHVybiBwcm9taXNlO1xuICBcdH07XG4gIH1cblxuICB2YXIgX2FuaW1hdGVTdHlsZSA9IGFuaW1hdGVTdHlsZTtcblxuICB2YXIgcHJvY2Vzc1BhcmFtcyA9IGZ1bmN0aW9uIChwYXJhbXMsIGRlZmF1bHRzKSB7XG4gIFx0aWYgKHR5cGVvZiBwYXJhbXMgPT09IFwibnVtYmVyXCIpIHtcbiAgXHRcdHBhcmFtcyA9IHsgZHVyYXRpb246IHBhcmFtcyB9O1xuICBcdH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcyA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0aWYgKHBhcmFtcyA9PT0gXCJzbG93XCIpIHtcbiAgXHRcdFx0cGFyYW1zID0geyBkdXJhdGlvbjogNjAwIH07XG4gIFx0XHR9IGVsc2UgaWYgKHBhcmFtcyA9PT0gXCJmYXN0XCIpIHtcbiAgXHRcdFx0cGFyYW1zID0geyBkdXJhdGlvbjogMjAwIH07XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRwYXJhbXMgPSB7IGR1cmF0aW9uOiA0MDAgfTtcbiAgXHRcdH1cbiAgXHR9IGVsc2UgaWYgKCFwYXJhbXMpIHtcbiAgXHRcdHBhcmFtcyA9IHt9O1xuICBcdH1cblxuICBcdHJldHVybiBmaWxsR2Fwcyh7fSwgcGFyYW1zLCBkZWZhdWx0cyk7XG4gIH07XG5cbiAgdmFyIHByb3RvdHlwZV9zdGFydCA9IFRyYW5zaXRpb24kc3RhcnQ7XG5cbiAgZnVuY3Rpb24gVHJhbnNpdGlvbiRzdGFydCgpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIG5vZGUsIG9yaWdpbmFsU3R5bGUsIGNvbXBsZXRlZDtcblxuICBcdG5vZGUgPSB0aGlzLm5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcbiAgXHRvcmlnaW5hbFN0eWxlID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcblxuICBcdC8vIGNyZWF0ZSB0LmNvbXBsZXRlKCkgLSB3ZSBkb24ndCB3YW50IHRoaXMgb24gdGhlIHByb3RvdHlwZSxcbiAgXHQvLyBiZWNhdXNlIHdlIGRvbid0IHdhbnQgYHRoaXNgIHNpbGxpbmVzcyB3aGVuIHBhc3NpbmcgaXQgYXNcbiAgXHQvLyBhbiBhcmd1bWVudFxuICBcdHRoaXMuY29tcGxldGUgPSBmdW5jdGlvbiAobm9SZXNldCkge1xuICBcdFx0aWYgKGNvbXBsZXRlZCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghbm9SZXNldCAmJiBfdGhpcy5pc0ludHJvKSB7XG4gIFx0XHRcdHJlc2V0U3R5bGUobm9kZSwgb3JpZ2luYWxTdHlsZSk7XG4gIFx0XHR9XG5cbiAgXHRcdG5vZGUuX3JhY3RpdmUudHJhbnNpdGlvbiA9IG51bGw7XG4gIFx0XHRfdGhpcy5fbWFuYWdlci5yZW1vdmUoX3RoaXMpO1xuXG4gIFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuICBcdH07XG5cbiAgXHQvLyBJZiB0aGUgdHJhbnNpdGlvbiBmdW5jdGlvbiBkb2Vzbid0IGV4aXN0LCBhYm9ydFxuICBcdGlmICghdGhpcy5fZm4pIHtcbiAgXHRcdHRoaXMuY29tcGxldGUoKTtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHR0aGlzLl9mbi5hcHBseSh0aGlzLnJvb3QsIFt0aGlzXS5jb25jYXQodGhpcy5wYXJhbXMpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0U3R5bGUobm9kZSwgc3R5bGUpIHtcbiAgXHRpZiAoc3R5bGUpIHtcbiAgXHRcdG5vZGUuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgc3R5bGUpO1xuICBcdH0gZWxzZSB7XG5cbiAgXHRcdC8vIE5leHQgbGluZSBpcyBuZWNlc3NhcnksIHRvIHJlbW92ZSBlbXB0eSBzdHlsZSBhdHRyaWJ1dGUhXG4gIFx0XHQvLyBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNzE2NzU1M1xuICBcdFx0bm9kZS5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgXHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XG4gIFx0fVxuICB9XG5cbiAgdmFyIFRyYW5zaXRpb24gPSBmdW5jdGlvbiAob3duZXIsIHRlbXBsYXRlLCBpc0ludHJvKSB7XG4gIFx0dGhpcy5pbml0KG93bmVyLCB0ZW1wbGF0ZSwgaXNJbnRybyk7XG4gIH07XG5cbiAgVHJhbnNpdGlvbi5wcm90b3R5cGUgPSB7XG4gIFx0aW5pdDogVHJhbnNpdGlvbl9wcm90b3R5cGVfaW5pdCxcbiAgXHRzdGFydDogcHJvdG90eXBlX3N0YXJ0LFxuICBcdGdldFN0eWxlOiBwcm90b3R5cGVfZ2V0U3R5bGUsXG4gIFx0c2V0U3R5bGU6IHNldFN0eWxlLFxuICBcdGFuaW1hdGVTdHlsZTogX2FuaW1hdGVTdHlsZSxcbiAgXHRwcm9jZXNzUGFyYW1zOiBwcm9jZXNzUGFyYW1zXG4gIH07XG5cbiAgdmFyIF9UcmFuc2l0aW9uID0gVHJhbnNpdGlvbjtcblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfcmVuZGVyID0gRWxlbWVudCRyZW5kZXI7XG5cbiAgdmFyIHVwZGF0ZUNzcywgdXBkYXRlU2NyaXB0O1xuXG4gIHVwZGF0ZUNzcyA9IGZ1bmN0aW9uICgpIHtcbiAgXHR2YXIgbm9kZSA9IHRoaXMubm9kZSxcbiAgXHQgICAgY29udGVudCA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoZmFsc2UpO1xuXG4gIFx0Ly8gSUU4IGhhcyBubyBzdHlsZVNoZWV0IHVubGVzcyB0aGVyZSdzIGEgdHlwZSB0ZXh0L2Nzc1xuICBcdGlmICh3aW5kb3cgJiYgd2luZG93LmFwcGVhcnNUb0JlSUVMZXNzRXF1YWw4KSB7XG4gIFx0XHRub2RlLnR5cGUgPSBcInRleHQvY3NzXCI7XG4gIFx0fVxuXG4gIFx0aWYgKG5vZGUuc3R5bGVTaGVldCkge1xuICBcdFx0bm9kZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjb250ZW50O1xuICBcdH0gZWxzZSB7XG5cbiAgXHRcdHdoaWxlIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICBcdFx0XHRub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gIFx0XHR9XG5cbiAgXHRcdG5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY29udGVudCkpO1xuICBcdH1cbiAgfTtcblxuICB1cGRhdGVTY3JpcHQgPSBmdW5jdGlvbiAoKSB7XG4gIFx0aWYgKCF0aGlzLm5vZGUudHlwZSB8fCB0aGlzLm5vZGUudHlwZSA9PT0gXCJ0ZXh0L2phdmFzY3JpcHRcIikge1xuICBcdFx0d2FybklmRGVidWcoXCJTY3JpcHQgdGFnIHdhcyB1cGRhdGVkLiBUaGlzIGRvZXMgbm90IGNhdXNlIHRoZSBjb2RlIHRvIGJlIHJlLWV2YWx1YXRlZCFcIiwgeyByYWN0aXZlOiB0aGlzLnJvb3QgfSk7XG4gIFx0XHQvLyBBcyBpdCBoYXBwZW5zLCB3ZSBBUkUgaW4gYSBwb3NpdGlvbiB0byByZS1ldmFsdWF0ZSB0aGUgY29kZSBpZiB3ZSB3YW50ZWRcbiAgXHRcdC8vIHRvIC0gd2UgY291bGQgZXZhbCgpIGl0LCBvciBpbnNlcnQgaXQgaW50byBhIGZyZXNoICh0ZW1wb3JhcnkpIHNjcmlwdCB0YWcuXG4gIFx0XHQvLyBCdXQgdGhpcyB3b3VsZCBiZSBhIHRlcnJpYmxlIGlkZWEgd2l0aCB1bnByZWRpY3RhYmxlIHJlc3VsdHMsIHNvIGxldCdzIG5vdC5cbiAgXHR9XG5cbiAgXHR0aGlzLm5vZGUudGV4dCA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoZmFsc2UpO1xuICB9O1xuICBmdW5jdGlvbiBFbGVtZW50JHJlbmRlcigpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIHJvb3QgPSB0aGlzLnJvb3QsXG4gIFx0ICAgIG5hbWVzcGFjZSxcbiAgXHQgICAgbm9kZSxcbiAgXHQgICAgdHJhbnNpdGlvbjtcblxuICBcdG5hbWVzcGFjZSA9IGdldE5hbWVzcGFjZSh0aGlzKTtcbiAgXHRub2RlID0gdGhpcy5ub2RlID0gY3JlYXRlRWxlbWVudCh0aGlzLm5hbWUsIG5hbWVzcGFjZSk7XG5cbiAgXHQvLyBJcyB0aGlzIGEgdG9wLWxldmVsIG5vZGUgb2YgYSBjb21wb25lbnQ/IElmIHNvLCB3ZSBtYXkgbmVlZCB0byBhZGRcbiAgXHQvLyBhIGRhdGEtcmFjdGl2ZS1jc3MgYXR0cmlidXRlLCBmb3IgQ1NTIGVuY2Fwc3VsYXRpb25cbiAgXHRpZiAodGhpcy5wYXJlbnRGcmFnbWVudC5jc3NJZHMpIHtcbiAgXHRcdHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXJhY3RpdmUtY3NzXCIsIHRoaXMucGFyZW50RnJhZ21lbnQuY3NzSWRzLm1hcChmdW5jdGlvbiAoeCkge1xuICBcdFx0XHRyZXR1cm4gXCJ7XCIgKyB4ICsgXCJ9XCI7XG4gIFx0XHR9KS5qb2luKFwiIFwiKSk7XG4gIFx0fVxuXG4gIFx0Ly8gQWRkIF9yYWN0aXZlIHByb3BlcnR5IHRvIHRoZSBub2RlIC0gd2UgdXNlIHRoaXMgb2JqZWN0IHRvIHN0b3JlIHN0dWZmXG4gIFx0Ly8gcmVsYXRlZCB0byBwcm94eSBldmVudHMsIHR3by13YXkgYmluZGluZ3MgZXRjXG4gIFx0ZGVmaW5lUHJvcGVydHkodGhpcy5ub2RlLCBcIl9yYWN0aXZlXCIsIHtcbiAgXHRcdHZhbHVlOiB7XG4gIFx0XHRcdHByb3h5OiB0aGlzLFxuICBcdFx0XHRrZXlwYXRoOiBnZXRJbm5lckNvbnRleHQodGhpcy5wYXJlbnRGcmFnbWVudCksXG4gIFx0XHRcdGV2ZW50czogY3JlYXRlKG51bGwpLFxuICBcdFx0XHRyb290OiByb290XG4gIFx0XHR9XG4gIFx0fSk7XG5cbiAgXHQvLyBSZW5kZXIgYXR0cmlidXRlc1xuICBcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gIFx0XHRyZXR1cm4gYS5yZW5kZXIobm9kZSk7XG4gIFx0fSk7XG4gIFx0dGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICBcdFx0cmV0dXJuIGEucmVuZGVyKG5vZGUpO1xuICBcdH0pO1xuXG4gIFx0Ly8gUmVuZGVyIGNoaWxkcmVuXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdC8vIFNwZWNpYWwgY2FzZSAtIDxzY3JpcHQ+IGVsZW1lbnRcbiAgXHRcdGlmICh0aGlzLm5hbWUgPT09IFwic2NyaXB0XCIpIHtcbiAgXHRcdFx0dGhpcy5idWJibGUgPSB1cGRhdGVTY3JpcHQ7XG4gIFx0XHRcdHRoaXMubm9kZS50ZXh0ID0gdGhpcy5mcmFnbWVudC50b1N0cmluZyhmYWxzZSk7IC8vIGJ5cGFzcyB3YXJuaW5nIGluaXRpYWxseVxuICBcdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyID0gbm9vcDsgLy8gVE9ETyB0aGlzIGlzIGEga2x1ZGdlXG4gIFx0XHR9XG5cbiAgXHRcdC8vIFNwZWNpYWwgY2FzZSAtIDxzdHlsZT4gZWxlbWVudFxuICBcdFx0ZWxzZSBpZiAodGhpcy5uYW1lID09PSBcInN0eWxlXCIpIHtcbiAgXHRcdFx0dGhpcy5idWJibGUgPSB1cGRhdGVDc3M7XG4gIFx0XHRcdHRoaXMuYnViYmxlKCk7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIgPSBub29wO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBjb250ZW50ZWRpdGFibGVcbiAgXHRcdGVsc2UgaWYgKHRoaXMuYmluZGluZyAmJiB0aGlzLmdldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyID0gbm9vcDtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLmZyYWdtZW50LnJlbmRlcigpKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBkZWFsIHdpdGggdHdvLXdheSBiaW5kaW5nc1xuICBcdGlmICh0aGlzLmJpbmRpbmcpIHtcbiAgXHRcdHRoaXMuYmluZGluZy5yZW5kZXIoKTtcbiAgXHRcdHRoaXMubm9kZS5fcmFjdGl2ZS5iaW5kaW5nID0gdGhpcy5iaW5kaW5nO1xuICBcdH1cblxuICBcdC8vIEFkZCBwcm94eSBldmVudCBoYW5kbGVyc1xuICBcdGlmICh0aGlzLmV2ZW50SGFuZGxlcnMpIHtcbiAgXHRcdHRoaXMuZXZlbnRIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoKSB7XG4gIFx0XHRcdHJldHVybiBoLnJlbmRlcigpO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJvcHRpb25cIikge1xuICBcdFx0cHJvY2Vzc09wdGlvbih0aGlzKTtcbiAgXHR9XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2VzXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJpbWdcIikge1xuICBcdFx0Ly8gaWYgdGhpcyBpcyBhbiA8aW1nPiwgYW5kIHdlJ3JlIGluIGEgY3JhcCBicm93c2VyLCB3ZSBtYXlcbiAgXHRcdC8vIG5lZWQgdG8gcHJldmVudCBpdCBmcm9tIG92ZXJyaWRpbmcgd2lkdGggYW5kIGhlaWdodCB3aGVuXG4gIFx0XHQvLyBpdCBsb2FkcyB0aGUgc3JjXG4gIFx0XHRzcGVjaWFsX2ltZ19fcmVuZGVyKHRoaXMpO1xuICBcdH0gZWxzZSBpZiAodGhpcy5uYW1lID09PSBcImZvcm1cIikge1xuICBcdFx0Ly8gZm9ybXMgbmVlZCB0byBrZWVwIHRyYWNrIG9mIHRoZWlyIGJpbmRpbmdzLCBpbiBjYXNlIG9mIHJlc2V0XG4gIFx0XHRmb3JtX19yZW5kZXIodGhpcyk7XG4gIFx0fSBlbHNlIGlmICh0aGlzLm5hbWUgPT09IFwiaW5wdXRcIiB8fCB0aGlzLm5hbWUgPT09IFwidGV4dGFyZWFcIikge1xuICBcdFx0Ly8gaW5wdXRzIGFuZCB0ZXh0YXJlYXMgc2hvdWxkIHN0b3JlIHRoZWlyIGluaXRpYWwgdmFsdWUgYXNcbiAgXHRcdC8vIGBkZWZhdWx0VmFsdWVgIGluIGNhc2Ugb2YgcmVzZXRcbiAgXHRcdHRoaXMubm9kZS5kZWZhdWx0VmFsdWUgPSB0aGlzLm5vZGUudmFsdWU7XG4gIFx0fSBlbHNlIGlmICh0aGlzLm5hbWUgPT09IFwib3B0aW9uXCIpIHtcbiAgXHRcdC8vIHNpbWlsYXJseSBmb3Igb3B0aW9uIG5vZGVzXG4gIFx0XHR0aGlzLm5vZGUuZGVmYXVsdFNlbGVjdGVkID0gdGhpcy5ub2RlLnNlbGVjdGVkO1xuICBcdH1cblxuICBcdC8vIGFwcGx5IGRlY29yYXRvcihzKVxuICBcdGlmICh0aGlzLmRlY29yYXRvciAmJiB0aGlzLmRlY29yYXRvci5mbikge1xuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0aWYgKCFfdGhpcy5kZWNvcmF0b3IudG9ybmRvd24pIHtcbiAgXHRcdFx0XHRfdGhpcy5kZWNvcmF0b3IuaW5pdCgpO1xuICBcdFx0XHR9XG4gIFx0XHR9LCB0cnVlKTtcbiAgXHR9XG5cbiAgXHQvLyB0cmlnZ2VyIGludHJvIHRyYW5zaXRpb25cbiAgXHRpZiAocm9vdC50cmFuc2l0aW9uc0VuYWJsZWQgJiYgdGhpcy5pbnRybykge1xuICBcdFx0dHJhbnNpdGlvbiA9IG5ldyBfVHJhbnNpdGlvbih0aGlzLCB0aGlzLmludHJvLCB0cnVlKTtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnJlZ2lzdGVyVHJhbnNpdGlvbih0cmFuc2l0aW9uKTtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHJldHVybiB0cmFuc2l0aW9uLnN0YXJ0KCk7XG4gIFx0XHR9LCB0cnVlKTtcblxuICBcdFx0dGhpcy50cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5ub2RlLmF1dG9mb2N1cykge1xuICBcdFx0Ly8gU3BlY2lhbCBjYXNlLiBTb21lIGJyb3dzZXJzICgqY291Z2gqIEZpcmVmaXggKmNvdWdoKikgaGF2ZSBhIHByb2JsZW1cbiAgXHRcdC8vIHdpdGggZHluYW1pY2FsbHktZ2VuZXJhdGVkIGVsZW1lbnRzIGhhdmluZyBhdXRvZm9jdXMsIGFuZCB0aGV5IHdvbid0XG4gIFx0XHQvLyBhbGxvdyB5b3UgdG8gcHJvZ3JhbW1hdGljYWxseSBmb2N1cyB0aGUgZWxlbWVudCB1bnRpbCBpdCdzIGluIHRoZSBET01cbiAgXHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHJldHVybiBfdGhpcy5ub2RlLmZvY3VzKCk7XG4gIFx0XHR9LCB0cnVlKTtcbiAgXHR9XG5cbiAgXHR1cGRhdGVMaXZlUXVlcmllcyh0aGlzKTtcbiAgXHRyZXR1cm4gdGhpcy5ub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TmFtZXNwYWNlKGVsZW1lbnQpIHtcbiAgXHR2YXIgbmFtZXNwYWNlLCB4bWxucywgcGFyZW50O1xuXG4gIFx0Ly8gVXNlIHNwZWNpZmllZCBuYW1lc3BhY2UuLi5cbiAgXHRpZiAoeG1sbnMgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInhtbG5zXCIpKSB7XG4gIFx0XHRuYW1lc3BhY2UgPSB4bWxucztcbiAgXHR9XG5cbiAgXHQvLyAuLi5vciBTVkcgbmFtZXNwYWNlLCBpZiB0aGlzIGlzIGFuIDxzdmc+IGVsZW1lbnRcbiAgXHRlbHNlIGlmIChlbGVtZW50Lm5hbWUgPT09IFwic3ZnXCIpIHtcbiAgXHRcdG5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuc3ZnO1xuICBcdH0gZWxzZSBpZiAocGFyZW50ID0gZWxlbWVudC5wYXJlbnQpIHtcbiAgXHRcdC8vIC4uLm9yIEhUTUwsIGlmIHRoZSBwYXJlbnQgaXMgYSA8Zm9yZWlnbk9iamVjdD5cbiAgXHRcdGlmIChwYXJlbnQubmFtZSA9PT0gXCJmb3JlaWduT2JqZWN0XCIpIHtcbiAgXHRcdFx0bmFtZXNwYWNlID0gbmFtZXNwYWNlcy5odG1sO1xuICBcdFx0fVxuXG4gIFx0XHQvLyAuLi5vciBpbmhlcml0IGZyb20gdGhlIHBhcmVudCBub2RlXG4gIFx0XHRlbHNlIHtcbiAgXHRcdFx0bmFtZXNwYWNlID0gcGFyZW50Lm5vZGUubmFtZXNwYWNlVVJJO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHRuYW1lc3BhY2UgPSBlbGVtZW50LnJvb3QuZWwubmFtZXNwYWNlVVJJO1xuICBcdH1cblxuICBcdHJldHVybiBuYW1lc3BhY2U7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzT3B0aW9uKG9wdGlvbikge1xuICBcdHZhciBvcHRpb25WYWx1ZSwgc2VsZWN0VmFsdWUsIGk7XG5cbiAgXHRpZiAoIW9wdGlvbi5zZWxlY3QpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRzZWxlY3RWYWx1ZSA9IG9wdGlvbi5zZWxlY3QuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIFx0aWYgKHNlbGVjdFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcblxuICBcdGlmIChvcHRpb24uc2VsZWN0Lm5vZGUubXVsdGlwbGUgJiYgaXNBcnJheShzZWxlY3RWYWx1ZSkpIHtcbiAgXHRcdGkgPSBzZWxlY3RWYWx1ZS5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGlmIChvcHRpb25WYWx1ZSA9PSBzZWxlY3RWYWx1ZVtpXSkge1xuICBcdFx0XHRcdG9wdGlvbi5ub2RlLnNlbGVjdGVkID0gdHJ1ZTtcbiAgXHRcdFx0XHRicmVhaztcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHRvcHRpb24ubm9kZS5zZWxlY3RlZCA9IG9wdGlvblZhbHVlID09IHNlbGVjdFZhbHVlO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpdmVRdWVyaWVzKGVsZW1lbnQpIHtcbiAgXHR2YXIgaW5zdGFuY2UsIGxpdmVRdWVyaWVzLCBpLCBzZWxlY3RvciwgcXVlcnk7XG5cbiAgXHQvLyBEb2VzIHRoaXMgbmVlZCB0byBiZSBhZGRlZCB0byBhbnkgbGl2ZSBxdWVyaWVzP1xuICBcdGluc3RhbmNlID0gZWxlbWVudC5yb290O1xuXG4gIFx0ZG8ge1xuICBcdFx0bGl2ZVF1ZXJpZXMgPSBpbnN0YW5jZS5fbGl2ZVF1ZXJpZXM7XG5cbiAgXHRcdGkgPSBsaXZlUXVlcmllcy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdHNlbGVjdG9yID0gbGl2ZVF1ZXJpZXNbaV07XG4gIFx0XHRcdHF1ZXJ5ID0gbGl2ZVF1ZXJpZXNbXCJfXCIgKyBzZWxlY3Rvcl07XG5cbiAgXHRcdFx0aWYgKHF1ZXJ5Ll90ZXN0KGVsZW1lbnQpKSB7XG4gIFx0XHRcdFx0Ly8ga2VlcCByZWdpc3RlciBvZiBhcHBsaWNhYmxlIHNlbGVjdG9ycywgZm9yIHdoZW4gd2UgdGVhcmRvd25cbiAgXHRcdFx0XHQoZWxlbWVudC5saXZlUXVlcmllcyB8fCAoZWxlbWVudC5saXZlUXVlcmllcyA9IFtdKSkucHVzaChxdWVyeSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9IHdoaWxlIChpbnN0YW5jZSA9IGluc3RhbmNlLnBhcmVudCk7XG4gIH1cblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfdG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIFx0dmFyIHN0ciwgZXNjYXBlO1xuXG4gIFx0aWYgKHRoaXMudGVtcGxhdGUueSkge1xuICBcdFx0Ly8gRE9DVFlQRSBkZWNsYXJhdGlvblxuICBcdFx0cmV0dXJuIFwiPCFET0NUWVBFXCIgKyB0aGlzLnRlbXBsYXRlLmRkICsgXCI+XCI7XG4gIFx0fVxuXG4gIFx0c3RyID0gXCI8XCIgKyB0aGlzLnRlbXBsYXRlLmU7XG5cbiAgXHRzdHIgKz0gdGhpcy5hdHRyaWJ1dGVzLm1hcChzdHJpbmdpZnlBdHRyaWJ1dGUpLmpvaW4oXCJcIikgKyB0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcy5tYXAoc3RyaW5naWZ5QXR0cmlidXRlKS5qb2luKFwiXCIpO1xuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gc2VsZWN0ZWQgb3B0aW9uc1xuICBcdGlmICh0aGlzLm5hbWUgPT09IFwib3B0aW9uXCIgJiYgb3B0aW9uSXNTZWxlY3RlZCh0aGlzKSkge1xuICBcdFx0c3RyICs9IFwiIHNlbGVjdGVkXCI7XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gdHdvLXdheSByYWRpbyBuYW1lIGJpbmRpbmdzXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJpbnB1dFwiICYmIGlucHV0SXNDaGVja2VkUmFkaW8odGhpcykpIHtcbiAgXHRcdHN0ciArPSBcIiBjaGVja2VkXCI7XG4gIFx0fVxuXG4gIFx0c3RyICs9IFwiPlwiO1xuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gdGV4dGFyZWFcbiAgXHRpZiAodGhpcy5uYW1lID09PSBcInRleHRhcmVhXCIgJiYgdGhpcy5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRzdHIgKz0gZXNjYXBlSHRtbCh0aGlzLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpKTtcbiAgXHR9XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSBjb250ZW50ZWRpdGFibGVcbiAgXHRlbHNlIGlmICh0aGlzLmdldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRzdHIgKz0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSB8fCBcIlwiO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHRlc2NhcGUgPSB0aGlzLm5hbWUgIT09IFwic2NyaXB0XCIgJiYgdGhpcy5uYW1lICE9PSBcInN0eWxlXCI7XG4gIFx0XHRzdHIgKz0gdGhpcy5mcmFnbWVudC50b1N0cmluZyhlc2NhcGUpO1xuICBcdH1cblxuICBcdC8vIGFkZCBhIGNsb3NpbmcgdGFnIGlmIHRoaXMgaXNuJ3QgYSB2b2lkIGVsZW1lbnRcbiAgXHRpZiAoIXZvaWRFbGVtZW50TmFtZXMudGVzdCh0aGlzLnRlbXBsYXRlLmUpKSB7XG4gIFx0XHRzdHIgKz0gXCI8L1wiICsgdGhpcy50ZW1wbGF0ZS5lICsgXCI+XCI7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHN0cjtcbiAgfTtcblxuICBmdW5jdGlvbiBvcHRpb25Jc1NlbGVjdGVkKGVsZW1lbnQpIHtcbiAgXHR2YXIgb3B0aW9uVmFsdWUsIHNlbGVjdFZhbHVlLCBpO1xuXG4gIFx0b3B0aW9uVmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuXG4gIFx0aWYgKG9wdGlvblZhbHVlID09PSB1bmRlZmluZWQgfHwgIWVsZW1lbnQuc2VsZWN0KSB7XG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fVxuXG4gIFx0c2VsZWN0VmFsdWUgPSBlbGVtZW50LnNlbGVjdC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcblxuICBcdGlmIChzZWxlY3RWYWx1ZSA9PSBvcHRpb25WYWx1ZSkge1xuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuXG4gIFx0aWYgKGVsZW1lbnQuc2VsZWN0LmdldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIpICYmIGlzQXJyYXkoc2VsZWN0VmFsdWUpKSB7XG4gIFx0XHRpID0gc2VsZWN0VmFsdWUubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRpZiAoc2VsZWN0VmFsdWVbaV0gPT0gb3B0aW9uVmFsdWUpIHtcbiAgXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlucHV0SXNDaGVja2VkUmFkaW8oZWxlbWVudCkge1xuICBcdHZhciBhdHRyaWJ1dGVzLCB0eXBlQXR0cmlidXRlLCB2YWx1ZUF0dHJpYnV0ZSwgbmFtZUF0dHJpYnV0ZTtcblxuICBcdGF0dHJpYnV0ZXMgPSBlbGVtZW50LmF0dHJpYnV0ZXM7XG5cbiAgXHR0eXBlQXR0cmlidXRlID0gYXR0cmlidXRlcy50eXBlO1xuICBcdHZhbHVlQXR0cmlidXRlID0gYXR0cmlidXRlcy52YWx1ZTtcbiAgXHRuYW1lQXR0cmlidXRlID0gYXR0cmlidXRlcy5uYW1lO1xuXG4gIFx0aWYgKCF0eXBlQXR0cmlidXRlIHx8IHR5cGVBdHRyaWJ1dGUudmFsdWUgIT09IFwicmFkaW9cIiB8fCAhdmFsdWVBdHRyaWJ1dGUgfHwgIW5hbWVBdHRyaWJ1dGUuaW50ZXJwb2xhdG9yKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKHZhbHVlQXR0cmlidXRlLnZhbHVlID09PSBuYW1lQXR0cmlidXRlLmludGVycG9sYXRvci52YWx1ZSkge1xuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5QXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuICBcdHZhciBzdHIgPSBhdHRyaWJ1dGUudG9TdHJpbmcoKTtcbiAgXHRyZXR1cm4gc3RyID8gXCIgXCIgKyBzdHIgOiBcIlwiO1xuICB9XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX3VuYmluZCA9IEVsZW1lbnQkdW5iaW5kO1xuICBmdW5jdGlvbiBFbGVtZW50JHVuYmluZCgpIHtcbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5iaW5kaW5nKSB7XG4gIFx0XHR0aGlzLmJpbmRpbmcudW5iaW5kKCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZXZlbnRIYW5kbGVycykge1xuICBcdFx0dGhpcy5ldmVudEhhbmRsZXJzLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5iaW5kKTtcbiAgXHR9XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSA8b3B0aW9uPlxuICBcdGlmICh0aGlzLm5hbWUgPT09IFwib3B0aW9uXCIpIHtcbiAgXHRcdHNwZWNpYWxfb3B0aW9uX191bmJpbmQodGhpcyk7XG4gIFx0fVxuXG4gIFx0dGhpcy5hdHRyaWJ1dGVzLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5iaW5kKTtcbiAgXHR0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIH1cblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfdW5yZW5kZXIgPSBFbGVtZW50JHVucmVuZGVyO1xuXG4gIGZ1bmN0aW9uIEVsZW1lbnQkdW5yZW5kZXIoc2hvdWxkRGVzdHJveSkge1xuICBcdHZhciBiaW5kaW5nLCBiaW5kaW5ncywgdHJhbnNpdGlvbjtcblxuICBcdGlmICh0cmFuc2l0aW9uID0gdGhpcy50cmFuc2l0aW9uKSB7XG4gIFx0XHR0cmFuc2l0aW9uLmNvbXBsZXRlKCk7XG4gIFx0fVxuXG4gIFx0Ly8gRGV0YWNoIGFzIHNvb24gYXMgd2UgY2FuXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJvcHRpb25cIikge1xuICBcdFx0Ly8gPG9wdGlvbj4gZWxlbWVudHMgZGV0YWNoIGltbWVkaWF0ZWx5LCBzbyB0aGF0XG4gIFx0XHQvLyB0aGVpciBwYXJlbnQgPHNlbGVjdD4gZWxlbWVudCBzeW5jcyBjb3JyZWN0bHksIGFuZFxuICBcdFx0Ly8gc2luY2Ugb3B0aW9uIGVsZW1lbnRzIGNhbid0IGhhdmUgdHJhbnNpdGlvbnMgYW55d2F5XG4gIFx0XHR0aGlzLmRldGFjaCgpO1xuICBcdH0gZWxzZSBpZiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0Z2xvYmFsX3J1bmxvb3AuZGV0YWNoV2hlblJlYWR5KHRoaXMpO1xuICBcdH1cblxuICBcdC8vIENoaWxkcmVuIGZpcnN0LiB0aGF0IHdheSwgYW55IHRyYW5zaXRpb25zIG9uIGNoaWxkIGVsZW1lbnRzIHdpbGwgYmVcbiAgXHQvLyBoYW5kbGVkIGJ5IHRoZSBjdXJyZW50IHRyYW5zaXRpb25NYW5hZ2VyXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIoZmFsc2UpO1xuICBcdH1cblxuICBcdGlmIChiaW5kaW5nID0gdGhpcy5iaW5kaW5nKSB7XG4gIFx0XHR0aGlzLmJpbmRpbmcudW5yZW5kZXIoKTtcblxuICBcdFx0dGhpcy5ub2RlLl9yYWN0aXZlLmJpbmRpbmcgPSBudWxsO1xuICBcdFx0YmluZGluZ3MgPSB0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzW2JpbmRpbmcua2V5cGF0aC5zdHJdO1xuICBcdFx0YmluZGluZ3Muc3BsaWNlKGJpbmRpbmdzLmluZGV4T2YoYmluZGluZyksIDEpO1xuICBcdH1cblxuICBcdC8vIFJlbW92ZSBldmVudCBoYW5kbGVyc1xuICBcdGlmICh0aGlzLmV2ZW50SGFuZGxlcnMpIHtcbiAgXHRcdHRoaXMuZXZlbnRIYW5kbGVycy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VucmVuZGVyKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5kZWNvcmF0b3IpIHtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnJlZ2lzdGVyRGVjb3JhdG9yKHRoaXMuZGVjb3JhdG9yKTtcbiAgXHR9XG5cbiAgXHQvLyB0cmlnZ2VyIG91dHJvIHRyYW5zaXRpb24gaWYgbmVjZXNzYXJ5XG4gIFx0aWYgKHRoaXMucm9vdC50cmFuc2l0aW9uc0VuYWJsZWQgJiYgdGhpcy5vdXRybykge1xuICBcdFx0dHJhbnNpdGlvbiA9IG5ldyBfVHJhbnNpdGlvbih0aGlzLCB0aGlzLm91dHJvLCBmYWxzZSk7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5yZWdpc3RlclRyYW5zaXRpb24odHJhbnNpdGlvbik7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gdHJhbnNpdGlvbi5zdGFydCgpO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0Ly8gUmVtb3ZlIHRoaXMgbm9kZSBmcm9tIGFueSBsaXZlIHF1ZXJpZXNcbiAgXHRpZiAodGhpcy5saXZlUXVlcmllcykge1xuICBcdFx0cmVtb3ZlRnJvbUxpdmVRdWVyaWVzKHRoaXMpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLm5hbWUgPT09IFwiZm9ybVwiKSB7XG4gIFx0XHRmb3JtX191bnJlbmRlcih0aGlzKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVGcm9tTGl2ZVF1ZXJpZXMoZWxlbWVudCkge1xuICBcdHZhciBxdWVyeSwgc2VsZWN0b3IsIGk7XG5cbiAgXHRpID0gZWxlbWVudC5saXZlUXVlcmllcy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0cXVlcnkgPSBlbGVtZW50LmxpdmVRdWVyaWVzW2ldO1xuICBcdFx0c2VsZWN0b3IgPSBxdWVyeS5zZWxlY3RvcjtcblxuICBcdFx0cXVlcnkuX3JlbW92ZShlbGVtZW50Lm5vZGUpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBFbGVtZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLmluaXQob3B0aW9ucyk7XG4gIH07XG5cbiAgRWxlbWVudC5wcm90b3R5cGUgPSB7XG4gIFx0YnViYmxlOiBFbGVtZW50X3Byb3RvdHlwZV9idWJibGUsXG4gIFx0ZGV0YWNoOiBFbGVtZW50X3Byb3RvdHlwZV9kZXRhY2gsXG4gIFx0ZmluZDogRWxlbWVudF9wcm90b3R5cGVfZmluZCxcbiAgXHRmaW5kQWxsOiBFbGVtZW50X3Byb3RvdHlwZV9maW5kQWxsLFxuICBcdGZpbmRBbGxDb21wb25lbnRzOiBFbGVtZW50X3Byb3RvdHlwZV9maW5kQWxsQ29tcG9uZW50cyxcbiAgXHRmaW5kQ29tcG9uZW50OiBFbGVtZW50X3Byb3RvdHlwZV9maW5kQ29tcG9uZW50LFxuICBcdGZpbmROZXh0Tm9kZTogRWxlbWVudF9wcm90b3R5cGVfZmluZE5leHROb2RlLFxuICBcdGZpcnN0Tm9kZTogRWxlbWVudF9wcm90b3R5cGVfZmlyc3ROb2RlLFxuICBcdGdldEF0dHJpYnV0ZTogZ2V0QXR0cmlidXRlLFxuICBcdGluaXQ6IEVsZW1lbnRfcHJvdG90eXBlX2luaXQsXG4gIFx0cmViaW5kOiBFbGVtZW50X3Byb3RvdHlwZV9yZWJpbmQsXG4gIFx0cmVuZGVyOiBFbGVtZW50X3Byb3RvdHlwZV9yZW5kZXIsXG4gIFx0dG9TdHJpbmc6IEVsZW1lbnRfcHJvdG90eXBlX3RvU3RyaW5nLFxuICBcdHVuYmluZDogRWxlbWVudF9wcm90b3R5cGVfdW5iaW5kLFxuICBcdHVucmVuZGVyOiBFbGVtZW50X3Byb3RvdHlwZV91bnJlbmRlclxuICB9O1xuXG4gIHZhciBfRWxlbWVudCA9IEVsZW1lbnQ7XG5cbiAgdmFyIGRlSW5kZW50X19lbXB0eSA9IC9eXFxzKiQvLFxuICAgICAgZGVJbmRlbnRfX2xlYWRpbmdXaGl0ZXNwYWNlID0gL15cXHMqLztcblxuICB2YXIgZGVJbmRlbnQgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIFx0dmFyIGxpbmVzLCBmaXJzdExpbmUsIGxhc3RMaW5lLCBtaW5JbmRlbnQ7XG5cbiAgXHRsaW5lcyA9IHN0ci5zcGxpdChcIlxcblwiKTtcblxuICBcdC8vIHJlbW92ZSBmaXJzdCBhbmQgbGFzdCBsaW5lLCBpZiB0aGV5IG9ubHkgY29udGFpbiB3aGl0ZXNwYWNlXG4gIFx0Zmlyc3RMaW5lID0gbGluZXNbMF07XG4gIFx0aWYgKGZpcnN0TGluZSAhPT0gdW5kZWZpbmVkICYmIGRlSW5kZW50X19lbXB0eS50ZXN0KGZpcnN0TGluZSkpIHtcbiAgXHRcdGxpbmVzLnNoaWZ0KCk7XG4gIFx0fVxuXG4gIFx0bGFzdExpbmUgPSBsYXN0SXRlbShsaW5lcyk7XG4gIFx0aWYgKGxhc3RMaW5lICE9PSB1bmRlZmluZWQgJiYgZGVJbmRlbnRfX2VtcHR5LnRlc3QobGFzdExpbmUpKSB7XG4gIFx0XHRsaW5lcy5wb3AoKTtcbiAgXHR9XG5cbiAgXHRtaW5JbmRlbnQgPSBsaW5lcy5yZWR1Y2UocmVkdWNlciwgbnVsbCk7XG5cbiAgXHRpZiAobWluSW5kZW50KSB7XG4gIFx0XHRzdHIgPSBsaW5lcy5tYXAoZnVuY3Rpb24gKGxpbmUpIHtcbiAgXHRcdFx0cmV0dXJuIGxpbmUucmVwbGFjZShtaW5JbmRlbnQsIFwiXCIpO1xuICBcdFx0fSkuam9pbihcIlxcblwiKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc3RyO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlZHVjZXIocHJldmlvdXMsIGxpbmUpIHtcbiAgXHR2YXIgbGluZUluZGVudCA9IGRlSW5kZW50X19sZWFkaW5nV2hpdGVzcGFjZS5leGVjKGxpbmUpWzBdO1xuXG4gIFx0aWYgKHByZXZpb3VzID09PSBudWxsIHx8IGxpbmVJbmRlbnQubGVuZ3RoIDwgcHJldmlvdXMubGVuZ3RoKSB7XG4gIFx0XHRyZXR1cm4gbGluZUluZGVudDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcHJldmlvdXM7XG4gIH1cblxuICB2YXIgUGFydGlhbF9nZXRQYXJ0aWFsVGVtcGxhdGUgPSBnZXRQYXJ0aWFsVGVtcGxhdGU7XG5cbiAgZnVuY3Rpb24gZ2V0UGFydGlhbFRlbXBsYXRlKHJhY3RpdmUsIG5hbWUsIHBhcmVudEZyYWdtZW50KSB7XG4gIFx0dmFyIHBhcnRpYWw7XG5cbiAgXHQvLyBJZiB0aGUgcGFydGlhbCBpbiBpbnN0YW5jZSBvciB2aWV3IGhlaXJhcmNoeSBpbnN0YW5jZXMsIGdyZWF0XG4gIFx0aWYgKHBhcnRpYWwgPSBnZXRQYXJ0aWFsRnJvbVJlZ2lzdHJ5KHJhY3RpdmUsIG5hbWUsIHBhcmVudEZyYWdtZW50IHx8IHt9KSkge1xuICBcdFx0cmV0dXJuIHBhcnRpYWw7XG4gIFx0fVxuXG4gIFx0Ly8gRG9lcyBpdCBleGlzdCBvbiB0aGUgcGFnZSBhcyBhIHNjcmlwdCB0YWc/XG4gIFx0cGFydGlhbCA9IHRlbXBsYXRlX3BhcnNlci5mcm9tSWQobmFtZSwgeyBub1Rocm93OiB0cnVlIH0pO1xuXG4gIFx0aWYgKHBhcnRpYWwpIHtcbiAgXHRcdC8vIGlzIHRoaXMgbmVjZXNzYXJ5P1xuICBcdFx0cGFydGlhbCA9IGRlSW5kZW50KHBhcnRpYWwpO1xuXG4gIFx0XHQvLyBwYXJzZSBhbmQgcmVnaXN0ZXIgdG8gdGhpcyByYWN0aXZlIGluc3RhbmNlXG4gIFx0XHR2YXIgcGFyc2VkID0gdGVtcGxhdGVfcGFyc2VyLnBhcnNlKHBhcnRpYWwsIHRlbXBsYXRlX3BhcnNlci5nZXRQYXJzZU9wdGlvbnMocmFjdGl2ZSkpO1xuXG4gIFx0XHQvLyByZWdpc3RlciAoYW5kIHJldHVybiBtYWluIHBhcnRpYWwgaWYgdGhlcmUgYXJlIG90aGVycyBpbiB0aGUgdGVtcGxhdGUpXG4gIFx0XHRyZXR1cm4gcmFjdGl2ZS5wYXJ0aWFsc1tuYW1lXSA9IHBhcnNlZC50O1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBhcnRpYWxGcm9tUmVnaXN0cnkocmFjdGl2ZSwgbmFtZSwgcGFyZW50RnJhZ21lbnQpIHtcbiAgXHR2YXIgZm4gPSB1bmRlZmluZWQsXG4gIFx0ICAgIHBhcnRpYWwgPSBmaW5kUGFyZW50UGFydGlhbChuYW1lLCBwYXJlbnRGcmFnbWVudC5vd25lcik7XG5cbiAgXHQvLyBpZiB0aGVyZSB3YXMgYW4gaW5zdGFuY2UgdXAtaGllcmFyY2h5LCBjb29sXG4gIFx0aWYgKHBhcnRpYWwpIHJldHVybiBwYXJ0aWFsO1xuXG4gIFx0Ly8gZmluZCBmaXJzdCBpbnN0YW5jZSBpbiB0aGUgcmFjdGl2ZSBvciB2aWV3IGhpZXJhcmNoeSB0aGF0IGhhcyB0aGlzIHBhcnRpYWxcbiAgXHR2YXIgaW5zdGFuY2UgPSBmaW5kSW5zdGFuY2UoXCJwYXJ0aWFsc1wiLCByYWN0aXZlLCBuYW1lKTtcblxuICBcdGlmICghaW5zdGFuY2UpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRwYXJ0aWFsID0gaW5zdGFuY2UucGFydGlhbHNbbmFtZV07XG5cbiAgXHQvLyBwYXJ0aWFsIGlzIGEgZnVuY3Rpb24/XG4gIFx0aWYgKHR5cGVvZiBwYXJ0aWFsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdGZuID0gcGFydGlhbC5iaW5kKGluc3RhbmNlKTtcbiAgXHRcdGZuLmlzT3duZXIgPSBpbnN0YW5jZS5wYXJ0aWFscy5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgXHRcdHBhcnRpYWwgPSBmbi5jYWxsKHJhY3RpdmUsIHRlbXBsYXRlX3BhcnNlcik7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJ0aWFsICYmIHBhcnRpYWwgIT09IFwiXCIpIHtcbiAgXHRcdHdhcm5JZkRlYnVnKG5vUmVnaXN0cnlGdW5jdGlvblJldHVybiwgbmFtZSwgXCJwYXJ0aWFsXCIsIFwicGFydGlhbFwiLCB7IHJhY3RpdmU6IHJhY3RpdmUgfSk7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0Ly8gSWYgdGhpcyB3YXMgYWRkZWQgbWFudWFsbHkgdG8gdGhlIHJlZ2lzdHJ5LFxuICBcdC8vIGJ1dCBoYXNuJ3QgYmVlbiBwYXJzZWQsIHBhcnNlIGl0IG5vd1xuICBcdGlmICghdGVtcGxhdGVfcGFyc2VyLmlzUGFyc2VkKHBhcnRpYWwpKSB7XG5cbiAgXHRcdC8vIHVzZSB0aGUgcGFyc2VPcHRpb25zIG9mIHRoZSByYWN0aXZlIGluc3RhbmNlIG9uIHdoaWNoIGl0IHdhcyBmb3VuZFxuICBcdFx0dmFyIHBhcnNlZCA9IHRlbXBsYXRlX3BhcnNlci5wYXJzZShwYXJ0aWFsLCB0ZW1wbGF0ZV9wYXJzZXIuZ2V0UGFyc2VPcHRpb25zKGluc3RhbmNlKSk7XG5cbiAgXHRcdC8vIFBhcnRpYWxzIGNhbm5vdCBjb250YWluIG5lc3RlZCBwYXJ0aWFscyFcbiAgXHRcdC8vIFRPRE8gYWRkIGEgdGVzdCBmb3IgdGhpc1xuICBcdFx0aWYgKHBhcnNlZC5wKSB7XG4gIFx0XHRcdHdhcm5JZkRlYnVnKFwiUGFydGlhbHMgKHt7PiVzfX0pIGNhbm5vdCBjb250YWluIG5lc3RlZCBpbmxpbmUgcGFydGlhbHNcIiwgbmFtZSwgeyByYWN0aXZlOiByYWN0aXZlIH0pO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBpZiBmbiwgdXNlIGluc3RhbmNlIHRvIHN0b3JlIHJlc3VsdCwgb3RoZXJ3aXNlIG5lZWRzIHRvIGdvXG4gIFx0XHQvLyBpbiB0aGUgY29ycmVjdCBwb2ludCBpbiBwcm90b3R5cGUgY2hhaW4gb24gaW5zdGFuY2Ugb3IgY29uc3RydWN0b3JcbiAgXHRcdHZhciB0YXJnZXQgPSBmbiA/IGluc3RhbmNlIDogZmluZE93bmVyKGluc3RhbmNlLCBuYW1lKTtcblxuICBcdFx0Ly8gbWF5IGJlIGEgdGVtcGxhdGUgd2l0aCBwYXJ0aWFscywgd2hpY2ggbmVlZCB0byBiZSByZWdpc3RlcmVkIGFuZCBtYWluIHRlbXBsYXRlIGV4dHJhY3RlZFxuICBcdFx0dGFyZ2V0LnBhcnRpYWxzW25hbWVdID0gcGFydGlhbCA9IHBhcnNlZC50O1xuICBcdH1cblxuICBcdC8vIHN0b3JlIGZvciByZXNldFxuICBcdGlmIChmbikge1xuICBcdFx0cGFydGlhbC5fZm4gPSBmbjtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcGFydGlhbC52ID8gcGFydGlhbC50IDogcGFydGlhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRPd25lcihyYWN0aXZlLCBrZXkpIHtcbiAgXHRyZXR1cm4gcmFjdGl2ZS5wYXJ0aWFscy5oYXNPd25Qcm9wZXJ0eShrZXkpID8gcmFjdGl2ZSA6IGZpbmRDb25zdHJ1Y3RvcihyYWN0aXZlLmNvbnN0cnVjdG9yLCBrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZENvbnN0cnVjdG9yKGNvbnN0cnVjdG9yLCBrZXkpIHtcbiAgXHRpZiAoIWNvbnN0cnVjdG9yKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuICBcdHJldHVybiBjb25zdHJ1Y3Rvci5wYXJ0aWFscy5oYXNPd25Qcm9wZXJ0eShrZXkpID8gY29uc3RydWN0b3IgOiBmaW5kQ29uc3RydWN0b3IoY29uc3RydWN0b3IuX1BhcmVudCwga2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRQYXJlbnRQYXJ0aWFsKG5hbWUsIHBhcmVudCkge1xuICBcdGlmIChwYXJlbnQpIHtcbiAgXHRcdGlmIChwYXJlbnQudGVtcGxhdGUgJiYgcGFyZW50LnRlbXBsYXRlLnAgJiYgcGFyZW50LnRlbXBsYXRlLnBbbmFtZV0pIHtcbiAgXHRcdFx0cmV0dXJuIHBhcmVudC50ZW1wbGF0ZS5wW25hbWVdO1xuICBcdFx0fSBlbHNlIGlmIChwYXJlbnQucGFyZW50RnJhZ21lbnQgJiYgcGFyZW50LnBhcmVudEZyYWdtZW50Lm93bmVyKSB7XG4gIFx0XHRcdHJldHVybiBmaW5kUGFyZW50UGFydGlhbChuYW1lLCBwYXJlbnQucGFyZW50RnJhZ21lbnQub3duZXIpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBhcHBseUluZGVudCA9IGZ1bmN0aW9uIChzdHJpbmcsIGluZGVudCkge1xuICBcdHZhciBpbmRlbnRlZDtcblxuICBcdGlmICghaW5kZW50KSB7XG4gIFx0XHRyZXR1cm4gc3RyaW5nO1xuICBcdH1cblxuICBcdGluZGVudGVkID0gc3RyaW5nLnNwbGl0KFwiXFxuXCIpLm1hcChmdW5jdGlvbiAobGluZSwgbm90Rmlyc3RMaW5lKSB7XG4gIFx0XHRyZXR1cm4gbm90Rmlyc3RMaW5lID8gaW5kZW50ICsgbGluZSA6IGxpbmU7XG4gIFx0fSkuam9pbihcIlxcblwiKTtcblxuICBcdHJldHVybiBpbmRlbnRlZDtcbiAgfTtcblxuICB2YXIgbWlzc2luZ1BhcnRpYWxNZXNzYWdlID0gXCJDb3VsZCBub3QgZmluZCB0ZW1wbGF0ZSBmb3IgcGFydGlhbCBcXFwiJXNcXFwiXCI7XG5cbiAgdmFyIFBhcnRpYWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHZhciBwYXJlbnRGcmFnbWVudCwgdGVtcGxhdGU7XG5cbiAgXHRwYXJlbnRGcmFnbWVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuXG4gIFx0dGhpcy5yb290ID0gcGFyZW50RnJhZ21lbnQucm9vdDtcbiAgXHR0aGlzLnR5cGUgPSBQQVJUSUFMO1xuICBcdHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuICBcdHRoaXMubmFtZSA9IG9wdGlvbnMudGVtcGxhdGUucjtcbiAgXHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG5cbiAgXHR0aGlzLmZyYWdtZW50ID0gdGhpcy5mcmFnbWVudFRvUmVuZGVyID0gdGhpcy5mcmFnbWVudFRvVW5yZW5kZXIgPSBudWxsO1xuXG4gIFx0TXVzdGFjaGUuaW5pdCh0aGlzLCBvcHRpb25zKTtcblxuICBcdC8vIElmIHRoaXMgZGlkbid0IHJlc29sdmUsIGl0IG1vc3QgbGlrZWx5IG1lYW5zIHdlIGhhdmUgYSBuYW1lZCBwYXJ0aWFsXG4gIFx0Ly8gKGkuZS4gYHt7PmZvb319YCBtZWFucyAndXNlIHRoZSBmb28gcGFydGlhbCcsIG5vdCAndXNlIHRoZSBwYXJ0aWFsXG4gIFx0Ly8gd2hvc2UgbmFtZSBpcyB0aGUgdmFsdWUgb2YgYGZvb2AnKVxuICBcdGlmICghdGhpcy5rZXlwYXRoKSB7XG4gIFx0XHRpZiAodGVtcGxhdGUgPSBQYXJ0aWFsX2dldFBhcnRpYWxUZW1wbGF0ZSh0aGlzLnJvb3QsIHRoaXMubmFtZSwgcGFyZW50RnJhZ21lbnQpKSB7XG4gIFx0XHRcdHNoYXJlZF91bmJpbmQuY2FsbCh0aGlzKTsgLy8gcHJldmVudCBhbnkgZnVydGhlciBjaGFuZ2VzXG4gIFx0XHRcdHRoaXMuaXNOYW1lZCA9IHRydWU7XG4gIFx0XHRcdHRoaXMuc2V0VGVtcGxhdGUodGVtcGxhdGUpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0d2Fybk9uY2VJZkRlYnVnKG1pc3NpbmdQYXJ0aWFsTWVzc2FnZSwgdGhpcy5uYW1lKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgUGFydGlhbC5wcm90b3R5cGUgPSB7XG4gIFx0YnViYmxlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuICBcdH0sXG5cbiAgXHRkZXRhY2g6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmRldGFjaCgpO1xuICBcdH0sXG5cbiAgXHRmaW5kOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoc2VsZWN0b3IpO1xuICBcdH0sXG5cbiAgXHRmaW5kQWxsOiBmdW5jdGlvbiAoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQWxsKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0fSxcblxuICBcdGZpbmRDb21wb25lbnQ6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudChzZWxlY3Rvcik7XG4gIFx0fSxcblxuICBcdGZpbmRBbGxDb21wb25lbnRzOiBmdW5jdGlvbiAoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpO1xuICBcdH0sXG5cbiAgXHRmaXJzdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpcnN0Tm9kZSgpO1xuICBcdH0sXG5cbiAgXHRmaW5kTmV4dE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0Z2V0UGFydGlhbE5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLmlzTmFtZWQgJiYgdGhpcy5uYW1lKSByZXR1cm4gdGhpcy5uYW1lO2Vsc2UgaWYgKHRoaXMudmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMubmFtZTtlbHNlIHJldHVybiB0aGlzLnZhbHVlO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZ2V0VmFsdWUoKTtcbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0Ly8gbmFtZWQgcGFydGlhbHMgYXJlbid0IGJvdW5kLCBzbyBkb24ndCByZWJpbmRcbiAgXHRcdGlmICghdGhpcy5pc05hbWVkKSB7XG4gIFx0XHRcdE11c3RhY2hlX3JlYmluZC5jYWxsKHRoaXMsIG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG4gIFx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgXHRcdHJldHVybiB0aGlzLmRvY0ZyYWc7XG4gIFx0fSxcblxuICBcdHJlc29sdmU6IE11c3RhY2hlLnJlc29sdmUsXG5cbiAgXHRzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHR2YXIgdGVtcGxhdGU7XG5cbiAgXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlID09PSB0aGlzLnZhbHVlKSB7XG4gIFx0XHRcdC8vIG5vdGhpbmcgaGFzIGNoYW5nZWQsIHNvIG5vIHdvcmsgdG8gYmUgZG9uZVxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHRlbXBsYXRlID0gUGFydGlhbF9nZXRQYXJ0aWFsVGVtcGxhdGUodGhpcy5yb290LCBcIlwiICsgdmFsdWUsIHRoaXMucGFyZW50RnJhZ21lbnQpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyB3ZSBtYXkgYmUgaGVyZSBpZiB3ZSBoYXZlIGEgcGFydGlhbCBsaWtlIGB7ez5mb299fWAgYW5kIGBmb29gIGlzIHRoZVxuICBcdFx0Ly8gbmFtZSBvZiBib3RoIGEgZGF0YSBwcm9wZXJ0eSAod2hvc2UgdmFsdWUgSVNOJ1QgdGhlIG5hbWUgb2YgYSBwYXJ0aWFsKVxuICBcdFx0Ly8gYW5kIGEgcGFydGlhbC4gSW4gdGhvc2UgY2FzZXMsIHRoaXMgYmVjb21lcyBhIG5hbWVkIHBhcnRpYWxcbiAgXHRcdGlmICghdGVtcGxhdGUgJiYgdGhpcy5uYW1lICYmICh0ZW1wbGF0ZSA9IFBhcnRpYWxfZ2V0UGFydGlhbFRlbXBsYXRlKHRoaXMucm9vdCwgdGhpcy5uYW1lLCB0aGlzLnBhcmVudEZyYWdtZW50KSkpIHtcbiAgXHRcdFx0c2hhcmVkX3VuYmluZC5jYWxsKHRoaXMpO1xuICBcdFx0XHR0aGlzLmlzTmFtZWQgPSB0cnVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXRlbXBsYXRlKSB7XG4gIFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyhtaXNzaW5nUGFydGlhbE1lc3NhZ2UsIHRoaXMubmFtZSwgeyByYWN0aXZlOiB0aGlzLnJvb3QgfSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICBcdFx0dGhpcy5zZXRUZW1wbGF0ZSh0ZW1wbGF0ZSB8fCBbXSk7XG5cbiAgXHRcdHRoaXMuYnViYmxlKCk7XG5cbiAgXHRcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFZpZXcodGhpcyk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHNldFRlbXBsYXRlOiBmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgXHRcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0XHRcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRcdFx0dGhpcy5mcmFnbWVudFRvVW5yZW5kZXIgPSB0aGlzLmZyYWdtZW50O1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgXHRcdFx0cm9vdDogdGhpcy5yb290LFxuICBcdFx0XHRvd25lcjogdGhpcyxcbiAgXHRcdFx0cEVsZW1lbnQ6IHRoaXMucGFyZW50RnJhZ21lbnQucEVsZW1lbnRcbiAgXHRcdH0pO1xuXG4gIFx0XHR0aGlzLmZyYWdtZW50VG9SZW5kZXIgPSB0aGlzLmZyYWdtZW50O1xuICBcdH0sXG5cbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKHRvU3RyaW5nKSB7XG4gIFx0XHR2YXIgc3RyaW5nLCBwcmV2aW91c0l0ZW0sIGxhc3RMaW5lLCBtYXRjaDtcblxuICBcdFx0c3RyaW5nID0gdGhpcy5mcmFnbWVudC50b1N0cmluZyh0b1N0cmluZyk7XG5cbiAgXHRcdHByZXZpb3VzSXRlbSA9IHRoaXMucGFyZW50RnJhZ21lbnQuaXRlbXNbdGhpcy5pbmRleCAtIDFdO1xuXG4gIFx0XHRpZiAoIXByZXZpb3VzSXRlbSB8fCBwcmV2aW91c0l0ZW0udHlwZSAhPT0gVEVYVCkge1xuICBcdFx0XHRyZXR1cm4gc3RyaW5nO1xuICBcdFx0fVxuXG4gIFx0XHRsYXN0TGluZSA9IHByZXZpb3VzSXRlbS50ZXh0LnNwbGl0KFwiXFxuXCIpLnBvcCgpO1xuXG4gIFx0XHRpZiAobWF0Y2ggPSAvXlxccyskLy5leGVjKGxhc3RMaW5lKSkge1xuICBcdFx0XHRyZXR1cm4gYXBwbHlJbmRlbnQoc3RyaW5nLCBtYXRjaFswXSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBzdHJpbmc7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLmlzTmFtZWQpIHtcbiAgXHRcdFx0Ly8gZHluYW1pYyBwYXJ0aWFsIC0gbmVlZCB0byB1bmJpbmQgc2VsZlxuICBcdFx0XHRzaGFyZWRfdW5iaW5kLmNhbGwodGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyKHNob3VsZERlc3Ryb3kpO1xuICBcdFx0XHR9XG4gIFx0XHRcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgdGFyZ2V0LCBhbmNob3I7XG5cbiAgXHRcdGlmICh0aGlzLmZyYWdtZW50VG9VbnJlbmRlcikge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50VG9VbnJlbmRlci51bnJlbmRlcih0cnVlKTtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudFRvVW5yZW5kZXIgPSBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5mcmFnbWVudFRvUmVuZGVyKSB7XG4gIFx0XHRcdHRoaXMuZG9jRnJhZy5hcHBlbmRDaGlsZCh0aGlzLmZyYWdtZW50VG9SZW5kZXIucmVuZGVyKCkpO1xuICBcdFx0XHR0aGlzLmZyYWdtZW50VG9SZW5kZXIgPSBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0XHR0YXJnZXQgPSB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKTtcbiAgXHRcdFx0YW5jaG9yID0gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUodGhpcyk7XG4gIFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUodGhpcy5kb2NGcmFnLCBhbmNob3IpO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgX1BhcnRpYWwgPSBQYXJ0aWFsO1xuXG4gIC8vIGZpbmRzIHRoZSBjb21wb25lbnQgY29uc3RydWN0b3IgaW4gdGhlIHJlZ2lzdHJ5IG9yIHZpZXcgaGllcmFyY2h5IHJlZ2lzdHJpZXNcblxuICB2YXIgQ29tcG9uZW50X2dldENvbXBvbmVudCA9IGdldENvbXBvbmVudDtcbiAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50KHJhY3RpdmUsIG5hbWUpIHtcblxuICBcdHZhciBDb21wb25lbnQsXG4gIFx0ICAgIGluc3RhbmNlID0gZmluZEluc3RhbmNlKFwiY29tcG9uZW50c1wiLCByYWN0aXZlLCBuYW1lKTtcblxuICBcdGlmIChpbnN0YW5jZSkge1xuICBcdFx0Q29tcG9uZW50ID0gaW5zdGFuY2UuY29tcG9uZW50c1tuYW1lXTtcblxuICBcdFx0Ly8gYmVzdCB0ZXN0IHdlIGhhdmUgZm9yIG5vdCBSYWN0aXZlLmV4dGVuZFxuICBcdFx0aWYgKCFDb21wb25lbnQuX1BhcmVudCkge1xuICBcdFx0XHQvLyBmdW5jdGlvbiBvcHRpb24sIGV4ZWN1dGUgYW5kIHN0b3JlIGZvciByZXNldFxuICBcdFx0XHR2YXIgZm4gPSBDb21wb25lbnQuYmluZChpbnN0YW5jZSk7XG4gIFx0XHRcdGZuLmlzT3duZXIgPSBpbnN0YW5jZS5jb21wb25lbnRzLmhhc093blByb3BlcnR5KG5hbWUpO1xuICBcdFx0XHRDb21wb25lbnQgPSBmbigpO1xuXG4gIFx0XHRcdGlmICghQ29tcG9uZW50KSB7XG4gIFx0XHRcdFx0d2FybklmRGVidWcobm9SZWdpc3RyeUZ1bmN0aW9uUmV0dXJuLCBuYW1lLCBcImNvbXBvbmVudFwiLCBcImNvbXBvbmVudFwiLCB7IHJhY3RpdmU6IHJhY3RpdmUgfSk7XG5cbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAodHlwZW9mIENvbXBvbmVudCA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRcdC8vIGFsbG93IHN0cmluZyBsb29rdXBcbiAgXHRcdFx0XHRDb21wb25lbnQgPSBnZXRDb21wb25lbnQocmFjdGl2ZSwgQ29tcG9uZW50KTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdENvbXBvbmVudC5fZm4gPSBmbjtcbiAgXHRcdFx0aW5zdGFuY2UuY29tcG9uZW50c1tuYW1lXSA9IENvbXBvbmVudDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gQ29tcG9uZW50O1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfZGV0YWNoID0gQ29tcG9uZW50JGRldGFjaDtcbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfZGV0YWNoX19kZXRhY2hIb29rID0gbmV3IGhvb2tzX0hvb2soXCJkZXRhY2hcIik7XG4gIGZ1bmN0aW9uIENvbXBvbmVudCRkZXRhY2goKSB7XG4gIFx0dmFyIGRldGFjaGVkID0gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5kZXRhY2goKTtcbiAgXHRDb21wb25lbnRfcHJvdG90eXBlX2RldGFjaF9fZGV0YWNoSG9vay5maXJlKHRoaXMuaW5zdGFuY2UpO1xuICBcdHJldHVybiBkZXRhY2hlZDtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmQgPSBDb21wb25lbnQkZmluZDtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkZmluZChzZWxlY3Rvcikge1xuICBcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpbmQoc2VsZWN0b3IpO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfZmluZEFsbCA9IENvbXBvbmVudCRmaW5kQWxsO1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kQWxsKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmRBbGxDb21wb25lbnRzID0gQ29tcG9uZW50JGZpbmRBbGxDb21wb25lbnRzO1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHRxdWVyeS5fdGVzdCh0aGlzLCB0cnVlKTtcblxuICBcdGlmICh0aGlzLmluc3RhbmNlLmZyYWdtZW50KSB7XG4gIFx0XHR0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfZmluZENvbXBvbmVudCA9IENvbXBvbmVudCRmaW5kQ29tcG9uZW50O1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kQ29tcG9uZW50KHNlbGVjdG9yKSB7XG4gIFx0aWYgKCFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gdGhpcy5uYW1lKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5pbnN0YW5jZS5mcmFnbWVudCkge1xuICBcdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmluZENvbXBvbmVudChzZWxlY3Rvcik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kTmV4dE5vZGUgPSBDb21wb25lbnQkZmluZE5leHROb2RlO1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kTmV4dE5vZGUoKSB7XG4gIFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfZmlyc3ROb2RlID0gQ29tcG9uZW50JGZpcnN0Tm9kZTtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkZmlyc3ROb2RlKCkge1xuICBcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maXJzdE5vZGUoKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwcm9jZXNzV3JhcHBlciA9IGZ1bmN0aW9uICh3cmFwcGVyLCBhcnJheSwgbWV0aG9kTmFtZSwgbmV3SW5kaWNlcykge1xuICBcdHZhciByb290ID0gd3JhcHBlci5yb290O1xuICBcdHZhciBrZXlwYXRoID0gd3JhcHBlci5rZXlwYXRoO1xuXG4gIFx0aWYgKCEhbmV3SW5kaWNlcykge1xuICBcdFx0cm9vdC52aWV3bW9kZWwuc21hcnRVcGRhdGUoa2V5cGF0aCwgYXJyYXksIG5ld0luZGljZXMpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHQvLyBJZiB0aGlzIGlzIGEgc29ydCBvciByZXZlcnNlLCB3ZSBqdXN0IGRvIHJvb3Quc2V0KCkuLi5cbiAgXHRcdC8vIFRPRE8gdXNlIG1lcmdlIGxvZ2ljP1xuICBcdFx0cm9vdC52aWV3bW9kZWwubWFyayhrZXlwYXRoKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIHBhdGNoZWRBcnJheVByb3RvID0gW10sXG4gICAgICBtdXRhdG9yTWV0aG9kcyA9IFtcInBvcFwiLCBcInB1c2hcIiwgXCJyZXZlcnNlXCIsIFwic2hpZnRcIiwgXCJzb3J0XCIsIFwic3BsaWNlXCIsIFwidW5zaGlmdFwiXSxcbiAgICAgIHRlc3RPYmosXG4gICAgICBwYXRjaEFycmF5TWV0aG9kcyxcbiAgICAgIHVucGF0Y2hBcnJheU1ldGhvZHM7XG5cbiAgbXV0YXRvck1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICBcdHZhciBtZXRob2QgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICBcdFx0XHRhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgbmV3SW5kaWNlcywgcmVzdWx0LCB3cmFwcGVyLCBpO1xuXG4gIFx0XHRuZXdJbmRpY2VzID0gc2hhcmVkX2dldE5ld0luZGljZXModGhpcywgbWV0aG9kTmFtZSwgYXJncyk7XG5cbiAgXHRcdC8vIGFwcGx5IHRoZSB1bmRlcmx5aW5nIG1ldGhvZFxuICBcdFx0cmVzdWx0ID0gQXJyYXkucHJvdG90eXBlW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgXHRcdC8vIHRyaWdnZXIgY2hhbmdlc1xuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc3RhcnQoKTtcblxuICBcdFx0dGhpcy5fcmFjdGl2ZS5zZXR0aW5nID0gdHJ1ZTtcbiAgXHRcdGkgPSB0aGlzLl9yYWN0aXZlLndyYXBwZXJzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0d3JhcHBlciA9IHRoaXMuX3JhY3RpdmUud3JhcHBlcnNbaV07XG5cbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkUmFjdGl2ZSh3cmFwcGVyLnJvb3QpO1xuICBcdFx0XHRwcm9jZXNzV3JhcHBlcih3cmFwcGVyLCB0aGlzLCBtZXRob2ROYW1lLCBuZXdJbmRpY2VzKTtcbiAgXHRcdH1cblxuICBcdFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG5cbiAgXHRcdHRoaXMuX3JhY3RpdmUuc2V0dGluZyA9IGZhbHNlO1xuICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHR9O1xuXG4gIFx0ZGVmaW5lUHJvcGVydHkocGF0Y2hlZEFycmF5UHJvdG8sIG1ldGhvZE5hbWUsIHtcbiAgXHRcdHZhbHVlOiBtZXRob2RcbiAgXHR9KTtcbiAgfSk7XG5cbiAgLy8gY2FuIHdlIHVzZSBwcm90b3R5cGUgY2hhaW4gaW5qZWN0aW9uP1xuICAvLyBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS9ob3ctZWNtYXNjcmlwdC01LXN0aWxsLWRvZXMtbm90LWFsbG93LXRvLXN1YmNsYXNzLWFuLWFycmF5LyN3cmFwcGVyc19wcm90b3R5cGVfY2hhaW5faW5qZWN0aW9uXG4gIHRlc3RPYmogPSB7fTtcblxuICBpZiAodGVzdE9iai5fX3Byb3RvX18pIHtcbiAgXHQvLyB5ZXMsIHdlIGNhblxuICBcdHBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gIFx0XHRhcnJheS5fX3Byb3RvX18gPSBwYXRjaGVkQXJyYXlQcm90bztcbiAgXHR9O1xuXG4gIFx0dW5wYXRjaEFycmF5TWV0aG9kcyA9IGZ1bmN0aW9uIChhcnJheSkge1xuICBcdFx0YXJyYXkuX19wcm90b19fID0gQXJyYXkucHJvdG90eXBlO1xuICBcdH07XG4gIH0gZWxzZSB7XG4gIFx0Ly8gbm8sIHdlIGNhbid0XG4gIFx0cGF0Y2hBcnJheU1ldGhvZHMgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgXHRcdHZhciBpLCBtZXRob2ROYW1lO1xuXG4gIFx0XHRpID0gbXV0YXRvck1ldGhvZHMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRtZXRob2ROYW1lID0gbXV0YXRvck1ldGhvZHNbaV07XG4gIFx0XHRcdGRlZmluZVByb3BlcnR5KGFycmF5LCBtZXRob2ROYW1lLCB7XG4gIFx0XHRcdFx0dmFsdWU6IHBhdGNoZWRBcnJheVByb3RvW21ldGhvZE5hbWVdLFxuICBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICBcdFx0XHR9KTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0dW5wYXRjaEFycmF5TWV0aG9kcyA9IGZ1bmN0aW9uIChhcnJheSkge1xuICBcdFx0dmFyIGk7XG5cbiAgXHRcdGkgPSBtdXRhdG9yTWV0aG9kcy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGRlbGV0ZSBhcnJheVttdXRhdG9yTWV0aG9kc1tpXV07XG4gIFx0XHR9XG4gIFx0fTtcbiAgfVxuXG4gIHBhdGNoQXJyYXlNZXRob2RzLnVucGF0Y2ggPSB1bnBhdGNoQXJyYXlNZXRob2RzO1xuICB2YXIgcGF0Y2ggPSBwYXRjaEFycmF5TWV0aG9kcztcblxuICB2YXIgYXJyYXlBZGFwdG9yLFxuXG4gIC8vIGhlbHBlcnNcbiAgQXJyYXlXcmFwcGVyLCBhcnJheV9pbmRleF9fZXJyb3JNZXNzYWdlO1xuXG4gIGFycmF5QWRhcHRvciA9IHtcbiAgXHRmaWx0ZXI6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgXHRcdC8vIHdyYXAgdGhlIGFycmF5IGlmIGEpIGIpIGl0J3MgYW4gYXJyYXksIGFuZCBiKSBlaXRoZXIgaXQgaGFzbid0IGJlZW4gd3JhcHBlZCBhbHJlYWR5LFxuICBcdFx0Ly8gb3IgdGhlIGFycmF5IGRpZG4ndCB0cmlnZ2VyIHRoZSBnZXQoKSBpdHNlbGZcbiAgXHRcdHJldHVybiBpc0FycmF5KG9iamVjdCkgJiYgKCFvYmplY3QuX3JhY3RpdmUgfHwgIW9iamVjdC5fcmFjdGl2ZS5zZXR0aW5nKTtcbiAgXHR9LFxuICBcdHdyYXA6IGZ1bmN0aW9uIChyYWN0aXZlLCBhcnJheSwga2V5cGF0aCkge1xuICBcdFx0cmV0dXJuIG5ldyBBcnJheVdyYXBwZXIocmFjdGl2ZSwgYXJyYXksIGtleXBhdGgpO1xuICBcdH1cbiAgfTtcblxuICBBcnJheVdyYXBwZXIgPSBmdW5jdGlvbiAocmFjdGl2ZSwgYXJyYXksIGtleXBhdGgpIHtcbiAgXHR0aGlzLnJvb3QgPSByYWN0aXZlO1xuICBcdHRoaXMudmFsdWUgPSBhcnJheTtcbiAgXHR0aGlzLmtleXBhdGggPSBnZXRLZXlwYXRoKGtleXBhdGgpO1xuXG4gIFx0Ly8gaWYgdGhpcyBhcnJheSBoYXNuJ3QgYWxyZWFkeSBiZWVuIHJhY3RpZmllZCwgcmFjdGlmeSBpdFxuICBcdGlmICghYXJyYXkuX3JhY3RpdmUpIHtcblxuICBcdFx0Ly8gZGVmaW5lIGEgbm9uLWVudW1lcmFibGUgX3JhY3RpdmUgcHJvcGVydHkgdG8gc3RvcmUgdGhlIHdyYXBwZXJzXG4gIFx0XHRkZWZpbmVQcm9wZXJ0eShhcnJheSwgXCJfcmFjdGl2ZVwiLCB7XG4gIFx0XHRcdHZhbHVlOiB7XG4gIFx0XHRcdFx0d3JhcHBlcnM6IFtdLFxuICBcdFx0XHRcdGluc3RhbmNlczogW10sXG4gIFx0XHRcdFx0c2V0dGluZzogZmFsc2VcbiAgXHRcdFx0fSxcbiAgXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG4gIFx0XHR9KTtcblxuICBcdFx0cGF0Y2goYXJyYXkpO1xuICBcdH1cblxuICBcdC8vIHN0b3JlIHRoZSByYWN0aXZlIGluc3RhbmNlLCBzbyB3ZSBjYW4gaGFuZGxlIHRyYW5zaXRpb25zIGxhdGVyXG4gIFx0aWYgKCFhcnJheS5fcmFjdGl2ZS5pbnN0YW5jZXNbcmFjdGl2ZS5fZ3VpZF0pIHtcbiAgXHRcdGFycmF5Ll9yYWN0aXZlLmluc3RhbmNlc1tyYWN0aXZlLl9ndWlkXSA9IDA7XG4gIFx0XHRhcnJheS5fcmFjdGl2ZS5pbnN0YW5jZXMucHVzaChyYWN0aXZlKTtcbiAgXHR9XG5cbiAgXHRhcnJheS5fcmFjdGl2ZS5pbnN0YW5jZXNbcmFjdGl2ZS5fZ3VpZF0gKz0gMTtcbiAgXHRhcnJheS5fcmFjdGl2ZS53cmFwcGVycy5wdXNoKHRoaXMpO1xuICB9O1xuXG4gIEFycmF5V3JhcHBlci5wcm90b3R5cGUgPSB7XG4gIFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcbiAgXHR9LFxuICBcdHRlYXJkb3duOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgYXJyYXksIHN0b3JhZ2UsIHdyYXBwZXJzLCBpbnN0YW5jZXMsIGluZGV4O1xuXG4gIFx0XHRhcnJheSA9IHRoaXMudmFsdWU7XG4gIFx0XHRzdG9yYWdlID0gYXJyYXkuX3JhY3RpdmU7XG4gIFx0XHR3cmFwcGVycyA9IHN0b3JhZ2Uud3JhcHBlcnM7XG4gIFx0XHRpbnN0YW5jZXMgPSBzdG9yYWdlLmluc3RhbmNlcztcblxuICBcdFx0Ly8gaWYgdGVhcmRvd24oKSB3YXMgaW52b2tlZCBiZWNhdXNlIHdlJ3JlIGNsZWFyaW5nIHRoZSBjYWNoZSBhcyBhIHJlc3VsdCBvZlxuICBcdFx0Ly8gYSBjaGFuZ2UgdGhhdCB0aGUgYXJyYXkgaXRzZWxmIHRyaWdnZXJlZCwgd2UgY2FuIHNhdmUgb3Vyc2VsdmVzIHRoZSB0ZWFyZG93blxuICBcdFx0Ly8gYW5kIGltbWVkaWF0ZSBzZXR1cFxuICBcdFx0aWYgKHN0b3JhZ2Uuc2V0dGluZykge1xuICBcdFx0XHRyZXR1cm4gZmFsc2U7IC8vIHNvIHRoYXQgd2UgZG9uJ3QgcmVtb3ZlIGl0IGZyb20gdGhpcy5yb290LnZpZXdtb2RlbC53cmFwcGVkXG4gIFx0XHR9XG5cbiAgXHRcdGluZGV4ID0gd3JhcHBlcnMuaW5kZXhPZih0aGlzKTtcbiAgXHRcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKGFycmF5X2luZGV4X19lcnJvck1lc3NhZ2UpO1xuICBcdFx0fVxuXG4gIFx0XHR3cmFwcGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gIFx0XHQvLyBpZiBub3RoaW5nIGVsc2UgZGVwZW5kcyBvbiB0aGlzIGFycmF5LCB3ZSBjYW4gcmV2ZXJ0IGl0IHRvIGl0c1xuICBcdFx0Ly8gbmF0dXJhbCBzdGF0ZVxuICBcdFx0aWYgKCF3cmFwcGVycy5sZW5ndGgpIHtcbiAgXHRcdFx0ZGVsZXRlIGFycmF5Ll9yYWN0aXZlO1xuICBcdFx0XHRwYXRjaC51bnBhdGNoKHRoaXMudmFsdWUpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Ly8gcmVtb3ZlIHJhY3RpdmUgaW5zdGFuY2UgaWYgcG9zc2libGVcbiAgXHRcdFx0aW5zdGFuY2VzW3RoaXMucm9vdC5fZ3VpZF0gLT0gMTtcbiAgXHRcdFx0aWYgKCFpbnN0YW5jZXNbdGhpcy5yb290Ll9ndWlkXSkge1xuICBcdFx0XHRcdGluZGV4ID0gaW5zdGFuY2VzLmluZGV4T2YodGhpcy5yb290KTtcblxuICBcdFx0XHRcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihhcnJheV9pbmRleF9fZXJyb3JNZXNzYWdlKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICBhcnJheV9pbmRleF9fZXJyb3JNZXNzYWdlID0gXCJTb21ldGhpbmcgd2VudCB3cm9uZyBpbiBhIHJhdGhlciBpbnRlcmVzdGluZyB3YXlcIjtcbiAgdmFyIGFycmF5X2luZGV4ID0gYXJyYXlBZGFwdG9yO1xuXG4gIHZhciBudW1lcmljID0gL15cXHMqWzAtOV0rXFxzKiQvO1xuXG4gIHZhciBjcmVhdGVCcmFuY2ggPSBmdW5jdGlvbiAoa2V5KSB7XG4gIFx0cmV0dXJuIG51bWVyaWMudGVzdChrZXkpID8gW10gOiB7fTtcbiAgfTtcblxuICB2YXIgbWFnaWNBZGFwdG9yLCBNYWdpY1dyYXBwZXI7XG5cbiAgdHJ5IHtcbiAgXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIFwidGVzdFwiLCB7IHZhbHVlOiAwIH0pO1xuXG4gIFx0bWFnaWNBZGFwdG9yID0ge1xuICBcdFx0ZmlsdGVyOiBmdW5jdGlvbiAob2JqZWN0LCBrZXlwYXRoLCByYWN0aXZlKSB7XG4gIFx0XHRcdHZhciBwYXJlbnRXcmFwcGVyLCBwYXJlbnRWYWx1ZTtcblxuICBcdFx0XHRpZiAoIWtleXBhdGgpIHtcbiAgXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRrZXlwYXRoID0gZ2V0S2V5cGF0aChrZXlwYXRoKTtcblxuICBcdFx0XHQvLyBJZiB0aGUgcGFyZW50IHZhbHVlIGlzIGEgd3JhcHBlciwgb3RoZXIgdGhhbiBhIG1hZ2ljIHdyYXBwZXIsXG4gIFx0XHRcdC8vIHdlIHNob3VsZG4ndCB3cmFwIHRoaXMgcHJvcGVydHlcbiAgXHRcdFx0aWYgKChwYXJlbnRXcmFwcGVyID0gcmFjdGl2ZS52aWV3bW9kZWwud3JhcHBlZFtrZXlwYXRoLnBhcmVudC5zdHJdKSAmJiAhcGFyZW50V3JhcHBlci5tYWdpYykge1xuICBcdFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHBhcmVudFZhbHVlID0gcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KGtleXBhdGgucGFyZW50KTtcblxuICBcdFx0XHQvLyBpZiBwYXJlbnRWYWx1ZSBpcyBhbiBhcnJheSB0aGF0IGRvZXNuJ3QgaW5jbHVkZSB0aGlzIG1lbWJlcixcbiAgXHRcdFx0Ly8gd2Ugc2hvdWxkIHJldHVybiBmYWxzZSBvdGhlcndpc2UgbGVuZ3RocyB3aWxsIGdldCBtZXNzZWQgdXBcbiAgXHRcdFx0aWYgKGlzQXJyYXkocGFyZW50VmFsdWUpICYmIC9eWzAtOV0rJC8udGVzdChrZXlwYXRoLmxhc3RLZXkpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIHBhcmVudFZhbHVlICYmICh0eXBlb2YgcGFyZW50VmFsdWUgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHBhcmVudFZhbHVlID09PSBcImZ1bmN0aW9uXCIpO1xuICBcdFx0fSxcbiAgXHRcdHdyYXA6IGZ1bmN0aW9uIChyYWN0aXZlLCBwcm9wZXJ0eSwga2V5cGF0aCkge1xuICBcdFx0XHRyZXR1cm4gbmV3IE1hZ2ljV3JhcHBlcihyYWN0aXZlLCBwcm9wZXJ0eSwga2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdE1hZ2ljV3JhcHBlciA9IGZ1bmN0aW9uIChyYWN0aXZlLCB2YWx1ZSwga2V5cGF0aCkge1xuICBcdFx0dmFyIG9iaktleXBhdGgsIHRlbXBsYXRlLCBzaWJsaW5ncztcblxuICBcdFx0a2V5cGF0aCA9IGdldEtleXBhdGgoa2V5cGF0aCk7XG5cbiAgXHRcdHRoaXMubWFnaWMgPSB0cnVlO1xuXG4gIFx0XHR0aGlzLnJhY3RpdmUgPSByYWN0aXZlO1xuICBcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcbiAgXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICBcdFx0dGhpcy5wcm9wID0ga2V5cGF0aC5sYXN0S2V5O1xuXG4gIFx0XHRvYmpLZXlwYXRoID0ga2V5cGF0aC5wYXJlbnQ7XG4gIFx0XHR0aGlzLm9iaiA9IG9iaktleXBhdGguaXNSb290ID8gcmFjdGl2ZS52aWV3bW9kZWwuZGF0YSA6IHJhY3RpdmUudmlld21vZGVsLmdldChvYmpLZXlwYXRoKTtcblxuICBcdFx0dGVtcGxhdGUgPSB0aGlzLm9yaWdpbmFsRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcy5vYmosIHRoaXMucHJvcCk7XG5cbiAgXHRcdC8vIEhhcyB0aGlzIHByb3BlcnR5IGFscmVhZHkgYmVlbiB3cmFwcGVkP1xuICBcdFx0aWYgKHRlbXBsYXRlICYmIHRlbXBsYXRlLnNldCAmJiAoc2libGluZ3MgPSB0ZW1wbGF0ZS5zZXQuX3JhY3RpdmVXcmFwcGVycykpIHtcblxuICBcdFx0XHQvLyBZZXMuIFJlZ2lzdGVyIHRoaXMgd3JhcHBlciB0byB0aGlzIHByb3BlcnR5LCBpZiBpdCBoYXNuJ3QgYmVlbiBhbHJlYWR5XG4gIFx0XHRcdGlmIChzaWJsaW5ncy5pbmRleE9mKHRoaXMpID09PSAtMSkge1xuICBcdFx0XHRcdHNpYmxpbmdzLnB1c2godGhpcyk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm47IC8vIGFscmVhZHkgd3JhcHBlZFxuICBcdFx0fVxuXG4gIFx0XHQvLyBObywgaXQgaGFzbid0IGJlZW4gd3JhcHBlZFxuICBcdFx0Y3JlYXRlQWNjZXNzb3JzKHRoaXMsIHZhbHVlLCB0ZW1wbGF0ZSk7XG4gIFx0fTtcblxuICBcdE1hZ2ljV3JhcHBlci5wcm90b3R5cGUgPSB7XG4gIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG4gIFx0XHR9LFxuICBcdFx0cmVzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0XHRpZiAodGhpcy51cGRhdGluZykge1xuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuICBcdFx0XHR0aGlzLm9ialt0aGlzLnByb3BdID0gdmFsdWU7IC8vIHRyaWdnZXIgc2V0KCkgYWNjZXNzb3JcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkUmFjdGl2ZSh0aGlzLnJhY3RpdmUpO1xuICBcdFx0XHR0aGlzLnJhY3RpdmUudmlld21vZGVsLm1hcmsodGhpcy5rZXlwYXRoLCB7IGtlZXBFeGlzdGluZ1dyYXBwZXI6IHRydWUgfSk7XG4gIFx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcbiAgXHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHR9LFxuICBcdFx0c2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICBcdFx0XHRpZiAodGhpcy51cGRhdGluZykge1xuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICghdGhpcy5vYmpbdGhpcy5wcm9wXSkge1xuICBcdFx0XHRcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuICBcdFx0XHRcdHRoaXMub2JqW3RoaXMucHJvcF0gPSBjcmVhdGVCcmFuY2goa2V5KTtcbiAgXHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLm9ialt0aGlzLnByb3BdW2tleV0gPSB2YWx1ZTtcbiAgXHRcdH0sXG4gIFx0XHR0ZWFyZG93bjogZnVuY3Rpb24gKCkge1xuICBcdFx0XHR2YXIgdGVtcGxhdGUsIHNldCwgdmFsdWUsIHdyYXBwZXJzLCBpbmRleDtcblxuICBcdFx0XHQvLyBJZiB0aGlzIG1ldGhvZCB3YXMgY2FsbGVkIGJlY2F1c2UgdGhlIGNhY2hlIHdhcyBiZWluZyBjbGVhcmVkIGFzIGFcbiAgXHRcdFx0Ly8gcmVzdWx0IG9mIGEgc2V0KCkvdXBkYXRlKCkgY2FsbCBtYWRlIGJ5IHRoaXMgd3JhcHBlciwgd2UgcmV0dXJuIGZhbHNlXG4gIFx0XHRcdC8vIHNvIHRoYXQgaXQgZG9lc24ndCBnZXQgdG9ybiBkb3duXG4gIFx0XHRcdGlmICh0aGlzLnVwZGF0aW5nKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGVtcGxhdGUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMub2JqLCB0aGlzLnByb3ApO1xuICBcdFx0XHRzZXQgPSB0ZW1wbGF0ZSAmJiB0ZW1wbGF0ZS5zZXQ7XG5cbiAgXHRcdFx0aWYgKCFzZXQpIHtcbiAgXHRcdFx0XHQvLyBtb3N0IGxpa2VseSwgdGhpcyB3YXMgYW4gYXJyYXkgbWVtYmVyIHRoYXQgd2FzIHNwbGljZWQgb3V0XG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0d3JhcHBlcnMgPSBzZXQuX3JhY3RpdmVXcmFwcGVycztcblxuICBcdFx0XHRpbmRleCA9IHdyYXBwZXJzLmluZGV4T2YodGhpcyk7XG4gIFx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcbiAgXHRcdFx0XHR3cmFwcGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gTGFzdCBvbmUgb3V0LCB0dXJuIG9mZiB0aGUgbGlnaHRzXG4gIFx0XHRcdGlmICghd3JhcHBlcnMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0dmFsdWUgPSB0aGlzLm9ialt0aGlzLnByb3BdO1xuXG4gIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMub2JqLCB0aGlzLnByb3AsIHRoaXMub3JpZ2luYWxEZXNjcmlwdG9yIHx8IHtcbiAgXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuICBcdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiAgXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICBcdFx0XHRcdH0pO1xuXG4gIFx0XHRcdFx0dGhpcy5vYmpbdGhpcy5wcm9wXSA9IHZhbHVlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gIFx0bWFnaWNBZGFwdG9yID0gZmFsc2U7IC8vIG5vIG1hZ2ljIGluIHRoaXMgYnJvd3NlclxuICB9XG5cbiAgdmFyIGFkYXB0b3JzX21hZ2ljID0gbWFnaWNBZGFwdG9yO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFjY2Vzc29ycyhvcmlnaW5hbFdyYXBwZXIsIHZhbHVlLCB0ZW1wbGF0ZSkge1xuXG4gIFx0dmFyIG9iamVjdCwgcHJvcGVydHksIG9sZEdldCwgb2xkU2V0LCBnZXQsIHNldDtcblxuICBcdG9iamVjdCA9IG9yaWdpbmFsV3JhcHBlci5vYmo7XG4gIFx0cHJvcGVydHkgPSBvcmlnaW5hbFdyYXBwZXIucHJvcDtcblxuICBcdC8vIElzIHRoaXMgdGVtcGxhdGUgY29uZmlndXJhYmxlP1xuICBcdGlmICh0ZW1wbGF0ZSAmJiAhdGVtcGxhdGUuY29uZmlndXJhYmxlKSB7XG4gIFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBhcnJheSBsZW5ndGhcbiAgXHRcdGlmIChwcm9wZXJ0eSA9PT0gXCJsZW5ndGhcIikge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgbWFnaWMgbW9kZSB3aXRoIHByb3BlcnR5IFxcXCJcIiArIHByb3BlcnR5ICsgXCJcXFwiIC0gb2JqZWN0IGlzIG5vdCBjb25maWd1cmFibGVcIik7XG4gIFx0fVxuXG4gIFx0Ly8gVGltZSB0byB3cmFwIHRoaXMgcHJvcGVydHlcbiAgXHRpZiAodGVtcGxhdGUpIHtcbiAgXHRcdG9sZEdldCA9IHRlbXBsYXRlLmdldDtcbiAgXHRcdG9sZFNldCA9IHRlbXBsYXRlLnNldDtcbiAgXHR9XG5cbiAgXHRnZXQgPSBvbGRHZXQgfHwgZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHZhbHVlO1xuICBcdH07XG5cbiAgXHRzZXQgPSBmdW5jdGlvbiAodikge1xuICBcdFx0aWYgKG9sZFNldCkge1xuICBcdFx0XHRvbGRTZXQodik7XG4gIFx0XHR9XG5cbiAgXHRcdHZhbHVlID0gb2xkR2V0ID8gb2xkR2V0KCkgOiB2O1xuICBcdFx0c2V0Ll9yYWN0aXZlV3JhcHBlcnMuZm9yRWFjaCh1cGRhdGVXcmFwcGVyKTtcbiAgXHR9O1xuXG4gIFx0ZnVuY3Rpb24gdXBkYXRlV3JhcHBlcih3cmFwcGVyKSB7XG4gIFx0XHR2YXIga2V5cGF0aCwgcmFjdGl2ZTtcblxuICBcdFx0d3JhcHBlci52YWx1ZSA9IHZhbHVlO1xuXG4gIFx0XHRpZiAod3JhcHBlci51cGRhdGluZykge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHJhY3RpdmUgPSB3cmFwcGVyLnJhY3RpdmU7XG4gIFx0XHRrZXlwYXRoID0gd3JhcHBlci5rZXlwYXRoO1xuXG4gIFx0XHR3cmFwcGVyLnVwZGF0aW5nID0gdHJ1ZTtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnN0YXJ0KHJhY3RpdmUpO1xuXG4gIFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5tYXJrKGtleXBhdGgpO1xuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcbiAgXHRcdHdyYXBwZXIudXBkYXRpbmcgPSBmYWxzZTtcbiAgXHR9XG5cbiAgXHQvLyBDcmVhdGUgYW4gYXJyYXkgb2Ygd3JhcHBlcnMsIGluIGNhc2Ugb3RoZXIga2V5cGF0aHMvcmFjdGl2ZXMgZGVwZW5kIG9uIHRoaXMgcHJvcGVydHkuXG4gIFx0Ly8gSGFuZGlseSwgd2UgY2FuIHN0b3JlIHRoZW0gYXMgYSBwcm9wZXJ0eSBvZiB0aGUgc2V0IGZ1bmN0aW9uLiBZYXkgSmF2YVNjcmlwdC5cbiAgXHRzZXQuX3JhY3RpdmVXcmFwcGVycyA9IFtvcmlnaW5hbFdyYXBwZXJdO1xuICBcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCB7IGdldDogZ2V0LCBzZXQ6IHNldCwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICB9XG5cbiAgdmFyIG1hZ2ljQXJyYXlBZGFwdG9yLCBNYWdpY0FycmF5V3JhcHBlcjtcblxuICBpZiAoYWRhcHRvcnNfbWFnaWMpIHtcbiAgXHRtYWdpY0FycmF5QWRhcHRvciA9IHtcbiAgXHRcdGZpbHRlcjogZnVuY3Rpb24gKG9iamVjdCwga2V5cGF0aCwgcmFjdGl2ZSkge1xuICBcdFx0XHRyZXR1cm4gYWRhcHRvcnNfbWFnaWMuZmlsdGVyKG9iamVjdCwga2V5cGF0aCwgcmFjdGl2ZSkgJiYgYXJyYXlfaW5kZXguZmlsdGVyKG9iamVjdCk7XG4gIFx0XHR9LFxuXG4gIFx0XHR3cmFwOiBmdW5jdGlvbiAocmFjdGl2ZSwgYXJyYXksIGtleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuIG5ldyBNYWdpY0FycmF5V3JhcHBlcihyYWN0aXZlLCBhcnJheSwga2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdE1hZ2ljQXJyYXlXcmFwcGVyID0gZnVuY3Rpb24gKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKSB7XG4gIFx0XHR0aGlzLnZhbHVlID0gYXJyYXk7XG5cbiAgXHRcdHRoaXMubWFnaWMgPSB0cnVlO1xuXG4gIFx0XHR0aGlzLm1hZ2ljV3JhcHBlciA9IGFkYXB0b3JzX21hZ2ljLndyYXAocmFjdGl2ZSwgYXJyYXksIGtleXBhdGgpO1xuICBcdFx0dGhpcy5hcnJheVdyYXBwZXIgPSBhcnJheV9pbmRleC53cmFwKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKTtcbiAgXHR9O1xuXG4gIFx0TWFnaWNBcnJheVdyYXBwZXIucHJvdG90eXBlID0ge1xuICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLnZhbHVlO1xuICBcdFx0fSxcbiAgXHRcdHRlYXJkb3duOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHRoaXMuYXJyYXlXcmFwcGVyLnRlYXJkb3duKCk7XG4gIFx0XHRcdHRoaXMubWFnaWNXcmFwcGVyLnRlYXJkb3duKCk7XG4gIFx0XHR9LFxuICBcdFx0cmVzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5tYWdpY1dyYXBwZXIucmVzZXQodmFsdWUpO1xuICBcdFx0fVxuICBcdH07XG4gIH1cblxuICB2YXIgbWFnaWNBcnJheSA9IG1hZ2ljQXJyYXlBZGFwdG9yO1xuXG4gIHZhciBwcm90b3R5cGVfYWRhcHQgPSBWaWV3bW9kZWwkYWRhcHQ7XG5cbiAgdmFyIHByZWZpeGVycyA9IHt9O1xuICBmdW5jdGlvbiBWaWV3bW9kZWwkYWRhcHQoa2V5cGF0aCwgdmFsdWUpIHtcbiAgXHR2YXIgbGVuLCBpLCBhZGFwdG9yLCB3cmFwcGVkO1xuXG4gIFx0aWYgKCF0aGlzLmFkYXB0b3JzKSByZXR1cm47XG5cbiAgXHQvLyBEbyB3ZSBoYXZlIGFuIGFkYXB0b3IgZm9yIHRoaXMgdmFsdWU/XG4gIFx0bGVuID0gdGhpcy5hZGFwdG9ycy5sZW5ndGg7XG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRhZGFwdG9yID0gdGhpcy5hZGFwdG9yc1tpXTtcblxuICBcdFx0aWYgKGFkYXB0b3IuZmlsdGVyKHZhbHVlLCBrZXlwYXRoLCB0aGlzLnJhY3RpdmUpKSB7XG4gIFx0XHRcdHdyYXBwZWQgPSB0aGlzLndyYXBwZWRba2V5cGF0aF0gPSBhZGFwdG9yLndyYXAodGhpcy5yYWN0aXZlLCB2YWx1ZSwga2V5cGF0aCwgZ2V0UHJlZml4ZXIoa2V5cGF0aCkpO1xuICBcdFx0XHR3cmFwcGVkLnZhbHVlID0gdmFsdWU7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBwcmVmaXhLZXlwYXRoKG9iaiwgcHJlZml4KSB7XG4gIFx0dmFyIHByZWZpeGVkID0ge30sXG4gIFx0ICAgIGtleTtcblxuICBcdGlmICghcHJlZml4KSB7XG4gIFx0XHRyZXR1cm4gb2JqO1xuICBcdH1cblxuICBcdHByZWZpeCArPSBcIi5cIjtcblxuICBcdGZvciAoa2V5IGluIG9iaikge1xuICBcdFx0aWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gIFx0XHRcdHByZWZpeGVkW3ByZWZpeCArIGtleV0gPSBvYmpba2V5XTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gcHJlZml4ZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQcmVmaXhlcihyb290S2V5cGF0aCkge1xuICBcdHZhciByb290RG90O1xuXG4gIFx0aWYgKCFwcmVmaXhlcnNbcm9vdEtleXBhdGhdKSB7XG4gIFx0XHRyb290RG90ID0gcm9vdEtleXBhdGggPyByb290S2V5cGF0aCArIFwiLlwiIDogXCJcIjtcblxuICBcdFx0cHJlZml4ZXJzW3Jvb3RLZXlwYXRoXSA9IGZ1bmN0aW9uIChyZWxhdGl2ZUtleXBhdGgsIHZhbHVlKSB7XG4gIFx0XHRcdHZhciBvYmo7XG5cbiAgXHRcdFx0aWYgKHR5cGVvZiByZWxhdGl2ZUtleXBhdGggPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0XHRvYmogPSB7fTtcbiAgXHRcdFx0XHRvYmpbcm9vdERvdCArIHJlbGF0aXZlS2V5cGF0aF0gPSB2YWx1ZTtcbiAgXHRcdFx0XHRyZXR1cm4gb2JqO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKHR5cGVvZiByZWxhdGl2ZUtleXBhdGggPT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdFx0XHQvLyAncmVsYXRpdmVLZXlwYXRoJyBpcyBpbiBmYWN0IGEgaGFzaCwgbm90IGEga2V5cGF0aFxuICBcdFx0XHRcdHJldHVybiByb290RG90ID8gcHJlZml4S2V5cGF0aChyZWxhdGl2ZUtleXBhdGgsIHJvb3RLZXlwYXRoKSA6IHJlbGF0aXZlS2V5cGF0aDtcbiAgXHRcdFx0fVxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcHJlZml4ZXJzW3Jvb3RLZXlwYXRoXTtcbiAgfVxuXG4gIC8vIFRFTVBcblxuICB2YXIgaGVscGVyc19nZXRVcHN0cmVhbUNoYW5nZXMgPSBnZXRVcHN0cmVhbUNoYW5nZXM7XG4gIGZ1bmN0aW9uIGdldFVwc3RyZWFtQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gIFx0dmFyIHVwc3RyZWFtQ2hhbmdlcyA9IFtyb290S2V5cGF0aF0sXG4gIFx0ICAgIGksXG4gIFx0ICAgIGtleXBhdGg7XG5cbiAgXHRpID0gY2hhbmdlcy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0a2V5cGF0aCA9IGNoYW5nZXNbaV0ucGFyZW50O1xuXG4gIFx0XHR3aGlsZSAoa2V5cGF0aCAmJiAha2V5cGF0aC5pc1Jvb3QpIHtcbiAgXHRcdFx0aWYgKGNoYW5nZXMuaW5kZXhPZihrZXlwYXRoKSA9PT0gLTEpIHtcbiAgXHRcdFx0XHRhZGRUb0FycmF5KHVwc3RyZWFtQ2hhbmdlcywga2V5cGF0aCk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0a2V5cGF0aCA9IGtleXBhdGgucGFyZW50O1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB1cHN0cmVhbUNoYW5nZXM7XG4gIH1cblxuICB2YXIgYXBwbHlDaGFuZ2VzX25vdGlmeVBhdHRlcm5PYnNlcnZlcnMgPSBub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzO1xuXG4gIGZ1bmN0aW9uIG5vdGlmeVBhdHRlcm5PYnNlcnZlcnModmlld21vZGVsLCBrZXlwYXRoLCBvbmx5RGlyZWN0KSB7XG4gIFx0dmFyIHBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcztcblxuICBcdHVwZGF0ZU1hdGNoaW5nUGF0dGVybk9ic2VydmVycyh2aWV3bW9kZWwsIGtleXBhdGgpO1xuXG4gIFx0aWYgKG9ubHlEaXJlY3QpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRwb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMgPSBrZXlwYXRoLndpbGRjYXJkTWF0Y2hlcygpO1xuICBcdHBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uICh1cHN0cmVhbVBhdHRlcm4pIHtcbiAgXHRcdGNhc2NhZGUodmlld21vZGVsLCB1cHN0cmVhbVBhdHRlcm4sIGtleXBhdGgpO1xuICBcdH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FzY2FkZSh2aWV3bW9kZWwsIHVwc3RyZWFtUGF0dGVybiwga2V5cGF0aCkge1xuICBcdHZhciBncm91cCwgbWFwLCBhY3R1YWxDaGlsZEtleXBhdGg7XG5cbiAgXHQvLyBUT0RPIHNob3VsZCBiZSBvbmUgb3IgdGhlIG90aGVyXG4gIFx0dXBzdHJlYW1QYXR0ZXJuID0gdXBzdHJlYW1QYXR0ZXJuLnN0ciB8fCB1cHN0cmVhbVBhdHRlcm47XG5cbiAgXHRncm91cCA9IHZpZXdtb2RlbC5kZXBzTWFwLnBhdHRlcm5PYnNlcnZlcnM7XG4gIFx0bWFwID0gZ3JvdXAgJiYgZ3JvdXBbdXBzdHJlYW1QYXR0ZXJuXTtcblxuICBcdGlmICghbWFwKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0bWFwLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkS2V5cGF0aCkge1xuICBcdFx0YWN0dWFsQ2hpbGRLZXlwYXRoID0ga2V5cGF0aC5qb2luKGNoaWxkS2V5cGF0aC5sYXN0S2V5KTsgLy8gJ2Zvby5iYXIuYmF6J1xuXG4gIFx0XHR1cGRhdGVNYXRjaGluZ1BhdHRlcm5PYnNlcnZlcnModmlld21vZGVsLCBhY3R1YWxDaGlsZEtleXBhdGgpO1xuICBcdFx0Y2FzY2FkZSh2aWV3bW9kZWwsIGNoaWxkS2V5cGF0aCwgYWN0dWFsQ2hpbGRLZXlwYXRoKTtcbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZU1hdGNoaW5nUGF0dGVybk9ic2VydmVycyh2aWV3bW9kZWwsIGtleXBhdGgpIHtcbiAgXHR2aWV3bW9kZWwucGF0dGVybk9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICBcdFx0aWYgKG9ic2VydmVyLnJlZ2V4LnRlc3Qoa2V5cGF0aC5zdHIpKSB7XG4gIFx0XHRcdG9ic2VydmVyLnVwZGF0ZShrZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9KTtcbiAgfVxuXG4gIHZhciBhcHBseUNoYW5nZXMgPSBWaWV3bW9kZWwkYXBwbHlDaGFuZ2VzO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRhcHBseUNoYW5nZXMoKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciBzZWxmID0gdGhpcyxcbiAgXHQgICAgY2hhbmdlcyxcbiAgXHQgICAgdXBzdHJlYW1DaGFuZ2VzLFxuICBcdCAgICBoYXNoID0ge30sXG4gIFx0ICAgIGJpbmRpbmdzO1xuXG4gIFx0Y2hhbmdlcyA9IHRoaXMuY2hhbmdlcztcblxuICBcdGlmICghY2hhbmdlcy5sZW5ndGgpIHtcbiAgXHRcdC8vIFRPRE8gd2UgZW5kIHVwIGhlcmUgb24gaW5pdGlhbCByZW5kZXIuIFBlcmhhcHMgd2Ugc2hvdWxkbid0P1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGZ1bmN0aW9uIGludmFsaWRhdGVDb21wdXRhdGlvbihjb21wdXRhdGlvbikge1xuICBcdFx0dmFyIGtleSA9IGNvbXB1dGF0aW9uLmtleTtcblxuICBcdFx0aWYgKGNvbXB1dGF0aW9uLnZpZXdtb2RlbCA9PT0gc2VsZikge1xuICBcdFx0XHRzZWxmLmNsZWFyQ2FjaGUoa2V5LnN0cik7XG4gIFx0XHRcdGNvbXB1dGF0aW9uLmludmFsaWRhdGUoKTtcblxuICBcdFx0XHRjaGFuZ2VzLnB1c2goa2V5KTtcbiAgXHRcdFx0Y2FzY2FkZShrZXkpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Y29tcHV0YXRpb24udmlld21vZGVsLm1hcmsoa2V5KTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiBjYXNjYWRlKGtleXBhdGgpIHtcbiAgXHRcdHZhciBtYXAsIGNvbXB1dGF0aW9ucztcblxuICBcdFx0aWYgKHNlbGYubm9DYXNjYWRlLmhhc093blByb3BlcnR5KGtleXBhdGguc3RyKSkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChjb21wdXRhdGlvbnMgPSBzZWxmLmRlcHMuY29tcHV0ZWRba2V5cGF0aC5zdHJdKSB7XG4gIFx0XHRcdGNvbXB1dGF0aW9ucy5mb3JFYWNoKGludmFsaWRhdGVDb21wdXRhdGlvbik7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChtYXAgPSBzZWxmLmRlcHNNYXAuY29tcHV0ZWRba2V5cGF0aC5zdHJdKSB7XG4gIFx0XHRcdG1hcC5mb3JFYWNoKGNhc2NhZGUpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGNoYW5nZXMuc2xpY2UoKS5mb3JFYWNoKGNhc2NhZGUpO1xuXG4gIFx0dXBzdHJlYW1DaGFuZ2VzID0gaGVscGVyc19nZXRVcHN0cmVhbUNoYW5nZXMoY2hhbmdlcyk7XG4gIFx0dXBzdHJlYW1DaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHZhciBjb21wdXRhdGlvbnM7XG5cbiAgXHRcdC8vIG1ha2Ugc3VyZSB3ZSBoYXZlbid0IGFscmVhZHkgYmVlbiBkb3duIHRoaXMgcGFydGljdWxhciBrZXlwYXRoIGluIHRoaXMgdHVyblxuICBcdFx0aWYgKGNoYW5nZXMuaW5kZXhPZihrZXlwYXRoKSA9PT0gLTEgJiYgKGNvbXB1dGF0aW9ucyA9IHNlbGYuZGVwcy5jb21wdXRlZFtrZXlwYXRoLnN0cl0pKSB7XG4gIFx0XHRcdGNvbXB1dGF0aW9ucy5mb3JFYWNoKGludmFsaWRhdGVDb21wdXRhdGlvbik7XG4gIFx0XHR9XG4gIFx0fSk7XG5cbiAgXHR0aGlzLmNoYW5nZXMgPSBbXTtcblxuICBcdC8vIFBhdHRlcm4gb2JzZXJ2ZXJzIGFyZSBhIHdlaXJkIHNwZWNpYWwgY2FzZVxuICBcdGlmICh0aGlzLnBhdHRlcm5PYnNlcnZlcnMubGVuZ3RoKSB7XG4gIFx0XHR1cHN0cmVhbUNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRyZXR1cm4gYXBwbHlDaGFuZ2VzX25vdGlmeVBhdHRlcm5PYnNlcnZlcnMoX3RoaXMsIGtleXBhdGgsIHRydWUpO1xuICBcdFx0fSk7XG4gIFx0XHRjaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuIGFwcGx5Q2hhbmdlc19ub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzKF90aGlzLCBrZXlwYXRoKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmRlcHMub2JzZXJ2ZXJzKSB7XG4gIFx0XHR1cHN0cmVhbUNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRyZXR1cm4gbm90aWZ5VXBzdHJlYW1EZXBlbmRhbnRzKF90aGlzLCBudWxsLCBrZXlwYXRoLCBcIm9ic2VydmVyc1wiKTtcbiAgXHRcdH0pO1xuICBcdFx0bm90aWZ5QWxsRGVwZW5kYW50cyh0aGlzLCBjaGFuZ2VzLCBcIm9ic2VydmVyc1wiKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5kZXBzW1wiZGVmYXVsdFwiXSkge1xuICBcdFx0YmluZGluZ3MgPSBbXTtcbiAgXHRcdHVwc3RyZWFtQ2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybiBub3RpZnlVcHN0cmVhbURlcGVuZGFudHMoX3RoaXMsIGJpbmRpbmdzLCBrZXlwYXRoLCBcImRlZmF1bHRcIik7XG4gIFx0XHR9KTtcblxuICBcdFx0aWYgKGJpbmRpbmdzLmxlbmd0aCkge1xuICBcdFx0XHRub3RpZnlCaW5kaW5ncyh0aGlzLCBiaW5kaW5ncywgY2hhbmdlcyk7XG4gIFx0XHR9XG5cbiAgXHRcdG5vdGlmeUFsbERlcGVuZGFudHModGhpcywgY2hhbmdlcywgXCJkZWZhdWx0XCIpO1xuICBcdH1cblxuICBcdC8vIFJldHVybiBhIGhhc2ggb2Yga2V5cGF0aHMgdG8gdXBkYXRlZCB2YWx1ZXNcbiAgXHRjaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdGhhc2hba2V5cGF0aC5zdHJdID0gX3RoaXMuZ2V0KGtleXBhdGgpO1xuICBcdH0pO1xuXG4gIFx0dGhpcy5pbXBsaWNpdENoYW5nZXMgPSB7fTtcbiAgXHR0aGlzLm5vQ2FzY2FkZSA9IHt9O1xuXG4gIFx0cmV0dXJuIGhhc2g7XG4gIH1cblxuICBmdW5jdGlvbiBub3RpZnlVcHN0cmVhbURlcGVuZGFudHModmlld21vZGVsLCBiaW5kaW5ncywga2V5cGF0aCwgZ3JvdXBOYW1lKSB7XG4gIFx0dmFyIGRlcGVuZGFudHMsIHZhbHVlO1xuXG4gIFx0aWYgKGRlcGVuZGFudHMgPSBmaW5kRGVwZW5kYW50cyh2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwTmFtZSkpIHtcbiAgXHRcdHZhbHVlID0gdmlld21vZGVsLmdldChrZXlwYXRoKTtcblxuICBcdFx0ZGVwZW5kYW50cy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gIFx0XHRcdC8vIGRvbid0IFwic2V0XCIgdGhlIHBhcmVudCB2YWx1ZSwgcmVmaW5lIGl0XG4gIFx0XHRcdC8vIGkuZS4gbm90IGRhdGEgPSB2YWx1ZSwgYnV0IGRhdGFbZm9vXSA9IGZvb1ZhbHVlXG4gIFx0XHRcdGlmIChiaW5kaW5ncyAmJiBkLnJlZmluZVZhbHVlKSB7XG4gIFx0XHRcdFx0YmluZGluZ3MucHVzaChkKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRkLnNldFZhbHVlKHZhbHVlKTtcbiAgXHRcdFx0fVxuICBcdFx0fSk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gbm90aWZ5QmluZGluZ3Modmlld21vZGVsLCBiaW5kaW5ncywgY2hhbmdlcykge1xuXG4gIFx0YmluZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoYmluZGluZykge1xuICBcdFx0dmFyIHVzZVNldCA9IGZhbHNlLFxuICBcdFx0ICAgIGkgPSAwLFxuICBcdFx0ICAgIGxlbmd0aCA9IGNoYW5nZXMubGVuZ3RoLFxuICBcdFx0ICAgIHJlZmluZW1lbnRzID0gW107XG5cbiAgXHRcdHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gIFx0XHRcdHZhciBrZXlwYXRoID0gY2hhbmdlc1tpXTtcblxuICBcdFx0XHRpZiAoa2V5cGF0aCA9PT0gYmluZGluZy5rZXlwYXRoKSB7XG4gIFx0XHRcdFx0dXNlU2V0ID0gdHJ1ZTtcbiAgXHRcdFx0XHRicmVhaztcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChrZXlwYXRoLnNsaWNlKDAsIGJpbmRpbmcua2V5cGF0aC5sZW5ndGgpID09PSBiaW5kaW5nLmtleXBhdGgpIHtcbiAgXHRcdFx0XHRyZWZpbmVtZW50cy5wdXNoKGtleXBhdGgpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aSsrO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodXNlU2V0KSB7XG4gIFx0XHRcdGJpbmRpbmcuc2V0VmFsdWUodmlld21vZGVsLmdldChiaW5kaW5nLmtleXBhdGgpKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHJlZmluZW1lbnRzLmxlbmd0aCkge1xuICBcdFx0XHRiaW5kaW5nLnJlZmluZVZhbHVlKHJlZmluZW1lbnRzKTtcbiAgXHRcdH1cbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeUFsbERlcGVuZGFudHModmlld21vZGVsLCBrZXlwYXRocywgZ3JvdXBOYW1lKSB7XG4gIFx0dmFyIHF1ZXVlID0gW107XG5cbiAgXHRhZGRLZXlwYXRocyhrZXlwYXRocyk7XG4gIFx0cXVldWUuZm9yRWFjaChkaXNwYXRjaCk7XG5cbiAgXHRmdW5jdGlvbiBhZGRLZXlwYXRocyhrZXlwYXRocykge1xuICBcdFx0a2V5cGF0aHMuZm9yRWFjaChhZGRLZXlwYXRoKTtcbiAgXHRcdGtleXBhdGhzLmZvckVhY2goY2FzY2FkZSk7XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gYWRkS2V5cGF0aChrZXlwYXRoKSB7XG4gIFx0XHR2YXIgZGVwcyA9IGZpbmREZXBlbmRhbnRzKHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXBOYW1lKTtcblxuICBcdFx0aWYgKGRlcHMpIHtcbiAgXHRcdFx0cXVldWUucHVzaCh7XG4gIFx0XHRcdFx0a2V5cGF0aDoga2V5cGF0aCxcbiAgXHRcdFx0XHRkZXBzOiBkZXBzXG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGZ1bmN0aW9uIGNhc2NhZGUoa2V5cGF0aCkge1xuICBcdFx0dmFyIGNoaWxkRGVwcztcblxuICBcdFx0aWYgKGNoaWxkRGVwcyA9IHZpZXdtb2RlbC5kZXBzTWFwW2dyb3VwTmFtZV1ba2V5cGF0aC5zdHJdKSB7XG4gIFx0XHRcdGFkZEtleXBhdGhzKGNoaWxkRGVwcyk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gZGlzcGF0Y2goc2V0KSB7XG4gIFx0XHR2YXIgdmFsdWUgPSB2aWV3bW9kZWwuZ2V0KHNldC5rZXlwYXRoKTtcbiAgXHRcdHNldC5kZXBzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgXHRcdFx0cmV0dXJuIGQuc2V0VmFsdWUodmFsdWUpO1xuICBcdFx0fSk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZERlcGVuZGFudHModmlld21vZGVsLCBrZXlwYXRoLCBncm91cE5hbWUpIHtcbiAgXHR2YXIgZ3JvdXAgPSB2aWV3bW9kZWwuZGVwc1tncm91cE5hbWVdO1xuICBcdHJldHVybiBncm91cCA/IGdyb3VwW2tleXBhdGguc3RyXSA6IG51bGw7XG4gIH1cblxuICB2YXIgY2FwdHVyZSA9IFZpZXdtb2RlbCRjYXB0dXJlO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRjYXB0dXJlKCkge1xuICBcdHRoaXMuY2FwdHVyZUdyb3Vwcy5wdXNoKFtdKTtcbiAgfVxuXG4gIHZhciBjbGVhckNhY2hlID0gVmlld21vZGVsJGNsZWFyQ2FjaGU7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJGNsZWFyQ2FjaGUoa2V5cGF0aCwga2VlcEV4aXN0aW5nV3JhcHBlcikge1xuICBcdHZhciBjYWNoZU1hcCwgd3JhcHBlcjtcblxuICBcdGlmICgha2VlcEV4aXN0aW5nV3JhcHBlcikge1xuICBcdFx0Ly8gSXMgdGhlcmUgYSB3cmFwcGVkIHByb3BlcnR5IGF0IHRoaXMga2V5cGF0aD9cbiAgXHRcdGlmICh3cmFwcGVyID0gdGhpcy53cmFwcGVkW2tleXBhdGhdKSB7XG4gIFx0XHRcdC8vIERpZCB3ZSB1bndyYXAgaXQ/XG4gIFx0XHRcdGlmICh3cmFwcGVyLnRlYXJkb3duKCkgIT09IGZhbHNlKSB7XG4gIFx0XHRcdFx0Ly8gSXMgdGhpcyByaWdodD9cbiAgXHRcdFx0XHQvLyBXaGF0J3MgdGhlIG1lYW5pbmcgb2YgcmV0dXJuaW5nIGZhbHNlIGZyb20gdGVhcmRvd24/XG4gIFx0XHRcdFx0Ly8gQ291bGQgdGhlcmUgYmUgYSBHQyByYW1pZmljYXRpb24gaWYgdGhpcyBpcyBhIFwicmVhbFwiIHJhY3RpdmUudGVhcmRvd24oKT9cbiAgXHRcdFx0XHR0aGlzLndyYXBwZWRba2V5cGF0aF0gPSBudWxsO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0dGhpcy5jYWNoZVtrZXlwYXRoXSA9IHVuZGVmaW5lZDtcblxuICBcdGlmIChjYWNoZU1hcCA9IHRoaXMuY2FjaGVNYXBba2V5cGF0aF0pIHtcbiAgXHRcdHdoaWxlIChjYWNoZU1hcC5sZW5ndGgpIHtcbiAgXHRcdFx0dGhpcy5jbGVhckNhY2hlKGNhY2hlTWFwLnBvcCgpKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgVW5yZXNvbHZlZERlcGVuZGVuY3kgPSBmdW5jdGlvbiAoY29tcHV0YXRpb24sIHJlZikge1xuICBcdHRoaXMuY29tcHV0YXRpb24gPSBjb21wdXRhdGlvbjtcbiAgXHR0aGlzLnZpZXdtb2RlbCA9IGNvbXB1dGF0aW9uLnZpZXdtb2RlbDtcbiAgXHR0aGlzLnJlZiA9IHJlZjtcblxuICBcdC8vIFRPRE8gdGhpcyBzZWVtcyBsaWtlIGEgcmVkIGZsYWchXG4gIFx0dGhpcy5yb290ID0gdGhpcy52aWV3bW9kZWwucmFjdGl2ZTtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gdGhpcy5yb290LmNvbXBvbmVudCAmJiB0aGlzLnJvb3QuY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuICB9O1xuXG4gIFVucmVzb2x2ZWREZXBlbmRlbmN5LnByb3RvdHlwZSA9IHtcbiAgXHRyZXNvbHZlOiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0dGhpcy5jb21wdXRhdGlvbi5zb2Z0RGVwcy5wdXNoKGtleXBhdGgpO1xuICBcdFx0dGhpcy5jb21wdXRhdGlvbi51bnJlc29sdmVkRGVwc1trZXlwYXRoLnN0cl0gPSBudWxsO1xuICBcdFx0dGhpcy52aWV3bW9kZWwucmVnaXN0ZXIoa2V5cGF0aCwgdGhpcy5jb21wdXRhdGlvbiwgXCJjb21wdXRlZFwiKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIENvbXB1dGF0aW9uX1VucmVzb2x2ZWREZXBlbmRlbmN5ID0gVW5yZXNvbHZlZERlcGVuZGVuY3k7XG5cbiAgdmFyIENvbXB1dGF0aW9uID0gZnVuY3Rpb24gKGtleSwgc2lnbmF0dXJlKSB7XG4gIFx0dGhpcy5rZXkgPSBrZXk7XG5cbiAgXHR0aGlzLmdldHRlciA9IHNpZ25hdHVyZS5nZXR0ZXI7XG4gIFx0dGhpcy5zZXR0ZXIgPSBzaWduYXR1cmUuc2V0dGVyO1xuXG4gIFx0dGhpcy5oYXJkRGVwcyA9IHNpZ25hdHVyZS5kZXBzIHx8IFtdO1xuICBcdHRoaXMuc29mdERlcHMgPSBbXTtcbiAgXHR0aGlzLnVucmVzb2x2ZWREZXBzID0ge307XG5cbiAgXHR0aGlzLmRlcFZhbHVlcyA9IHt9O1xuXG4gIFx0dGhpcy5fZGlydHkgPSB0aGlzLl9maXJzdFJ1biA9IHRydWU7XG4gIH07XG5cbiAgQ29tcHV0YXRpb24ucHJvdG90eXBlID0ge1xuICBcdGNvbnN0cnVjdG9yOiBDb21wdXRhdGlvbixcblxuICBcdGluaXQ6IGZ1bmN0aW9uICh2aWV3bW9kZWwpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdHZhciBpbml0aWFsO1xuXG4gIFx0XHR0aGlzLnZpZXdtb2RlbCA9IHZpZXdtb2RlbDtcbiAgXHRcdHRoaXMuYnlwYXNzID0gdHJ1ZTtcblxuICBcdFx0aW5pdGlhbCA9IHZpZXdtb2RlbC5nZXQodGhpcy5rZXkpO1xuICBcdFx0dmlld21vZGVsLmNsZWFyQ2FjaGUodGhpcy5rZXkuc3RyKTtcblxuICBcdFx0dGhpcy5ieXBhc3MgPSBmYWxzZTtcblxuICBcdFx0aWYgKHRoaXMuc2V0dGVyICYmIGluaXRpYWwgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0aGlzLnNldChpbml0aWFsKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMuaGFyZERlcHMpIHtcbiAgXHRcdFx0dGhpcy5oYXJkRGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gIFx0XHRcdFx0cmV0dXJuIHZpZXdtb2RlbC5yZWdpc3RlcihkLCBfdGhpcywgXCJjb21wdXRlZFwiKTtcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGludmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgXHR9LFxuXG4gIFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgbmV3RGVwcyxcbiAgXHRcdCAgICBkZXBlbmRlbmNpZXNDaGFuZ2VkLFxuICBcdFx0ICAgIGRlcGVuZGVuY3lWYWx1ZXNDaGFuZ2VkID0gZmFsc2U7XG5cbiAgXHRcdGlmICh0aGlzLmdldHRpbmcpIHtcbiAgXHRcdFx0Ly8gcHJldmVudCBkb3VibGUtY29tcHV0YXRpb24gKGUuZy4gY2F1c2VkIGJ5IGFycmF5IG11dGF0aW9uIGluc2lkZSBjb21wdXRhdGlvbilcbiAgXHRcdFx0dmFyIG1zZyA9IFwiVGhlIFwiICsgdGhpcy5rZXkuc3RyICsgXCIgY29tcHV0YXRpb24gaW5kaXJlY3RseSBjYWxsZWQgaXRzZWxmLiBUaGlzIHByb2JhYmx5IGluZGljYXRlcyBhIGJ1ZyBpbiB0aGUgY29tcHV0YXRpb24uIEl0IGlzIGNvbW1vbmx5IGNhdXNlZCBieSBgYXJyYXkuc29ydCguLi4pYCAtIGlmIHRoYXQncyB0aGUgY2FzZSwgY2xvbmUgdGhlIGFycmF5IGZpcnN0IHdpdGggYGFycmF5LnNsaWNlKCkuc29ydCguLi4pYFwiO1xuICBcdFx0XHR3YXJuT25jZShtc2cpO1xuICBcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5nZXR0aW5nID0gdHJ1ZTtcblxuICBcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG4gIFx0XHRcdC8vIGRldGVybWluZSB3aGV0aGVyIHRoZSBpbnB1dHMgaGF2ZSBjaGFuZ2VkLCBpbiBjYXNlIHRoaXMgZGVwZW5kcyBvblxuICBcdFx0XHQvLyBvdGhlciBjb21wdXRlZCB2YWx1ZXNcbiAgXHRcdFx0aWYgKHRoaXMuX2ZpcnN0UnVuIHx8ICF0aGlzLmhhcmREZXBzLmxlbmd0aCAmJiAhdGhpcy5zb2Z0RGVwcy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRkZXBlbmRlbmN5VmFsdWVzQ2hhbmdlZCA9IHRydWU7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0W3RoaXMuaGFyZERlcHMsIHRoaXMuc29mdERlcHNdLmZvckVhY2goZnVuY3Rpb24gKGRlcHMpIHtcbiAgXHRcdFx0XHRcdHZhciBrZXlwYXRoLCB2YWx1ZSwgaTtcblxuICBcdFx0XHRcdFx0aWYgKGRlcGVuZGVuY3lWYWx1ZXNDaGFuZ2VkKSB7XG4gIFx0XHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0aSA9IGRlcHMubGVuZ3RoO1xuICBcdFx0XHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdFx0XHRrZXlwYXRoID0gZGVwc1tpXTtcbiAgXHRcdFx0XHRcdFx0dmFsdWUgPSBfdGhpcy52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuXG4gIFx0XHRcdFx0XHRcdGlmICghaXNFcXVhbCh2YWx1ZSwgX3RoaXMuZGVwVmFsdWVzW2tleXBhdGguc3RyXSkpIHtcbiAgXHRcdFx0XHRcdFx0XHRfdGhpcy5kZXBWYWx1ZXNba2V5cGF0aC5zdHJdID0gdmFsdWU7XG4gIFx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeVZhbHVlc0NoYW5nZWQgPSB0cnVlO1xuXG4gIFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoZGVwZW5kZW5jeVZhbHVlc0NoYW5nZWQpIHtcbiAgXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5jYXB0dXJlKCk7XG5cbiAgXHRcdFx0XHR0cnkge1xuICBcdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMuZ2V0dGVyKCk7XG4gIFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG4gIFx0XHRcdFx0XHR3YXJuSWZEZWJ1ZyhcIkZhaWxlZCB0byBjb21wdXRlIFxcXCIlc1xcXCJcIiwgdGhpcy5rZXkuc3RyKTtcbiAgXHRcdFx0XHRcdGxvZ0lmRGVidWcoZXJyLnN0YWNrIHx8IGVycik7XG5cbiAgXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0bmV3RGVwcyA9IHRoaXMudmlld21vZGVsLnJlbGVhc2UoKTtcbiAgXHRcdFx0XHRkZXBlbmRlbmNpZXNDaGFuZ2VkID0gdGhpcy51cGRhdGVEZXBlbmRlbmNpZXMobmV3RGVwcyk7XG5cbiAgXHRcdFx0XHRpZiAoZGVwZW5kZW5jaWVzQ2hhbmdlZCkge1xuICBcdFx0XHRcdFx0W3RoaXMuaGFyZERlcHMsIHRoaXMuc29mdERlcHNdLmZvckVhY2goZnVuY3Rpb24gKGRlcHMpIHtcbiAgXHRcdFx0XHRcdFx0ZGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdFx0XHRcdFx0X3RoaXMuZGVwVmFsdWVzW2tleXBhdGguc3RyXSA9IF90aGlzLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG4gIFx0XHRcdFx0XHRcdH0pO1xuICBcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5nZXR0aW5nID0gdGhpcy5fZmlyc3RSdW4gPSBmYWxzZTtcbiAgXHRcdHJldHVybiB0aGlzLnZhbHVlO1xuICBcdH0sXG5cbiAgXHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0aWYgKHRoaXMuc2V0dGluZykge1xuICBcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCF0aGlzLnNldHRlcikge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb21wdXRlZCBwcm9wZXJ0aWVzIHdpdGhvdXQgc2V0dGVycyBhcmUgcmVhZC1vbmx5LiAoVGhpcyBtYXkgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgUmFjdGl2ZSEpXCIpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnNldHRlcih2YWx1ZSk7XG4gIFx0fSxcblxuICBcdHVwZGF0ZURlcGVuZGVuY2llczogZnVuY3Rpb24gKG5ld0RlcHMpIHtcbiAgXHRcdHZhciBpLCBvbGREZXBzLCBrZXlwYXRoLCBkZXBlbmRlbmNpZXNDaGFuZ2VkLCB1bnJlc29sdmVkO1xuXG4gIFx0XHRvbGREZXBzID0gdGhpcy5zb2Z0RGVwcztcblxuICBcdFx0Ly8gcmVtb3ZlIGRlcGVuZGVuY2llcyB0aGF0IGFyZSBubyBsb25nZXIgdXNlZFxuICBcdFx0aSA9IG9sZERlcHMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRrZXlwYXRoID0gb2xkRGVwc1tpXTtcblxuICBcdFx0XHRpZiAobmV3RGVwcy5pbmRleE9mKGtleXBhdGgpID09PSAtMSkge1xuICBcdFx0XHRcdGRlcGVuZGVuY2llc0NoYW5nZWQgPSB0cnVlO1xuICBcdFx0XHRcdHRoaXMudmlld21vZGVsLnVucmVnaXN0ZXIoa2V5cGF0aCwgdGhpcywgXCJjb21wdXRlZFwiKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBjcmVhdGUgcmVmZXJlbmNlcyBmb3IgYW55IG5ldyBkZXBlbmRlbmNpZXNcbiAgXHRcdGkgPSBuZXdEZXBzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0a2V5cGF0aCA9IG5ld0RlcHNbaV07XG5cbiAgXHRcdFx0aWYgKG9sZERlcHMuaW5kZXhPZihrZXlwYXRoKSA9PT0gLTEgJiYgKCF0aGlzLmhhcmREZXBzIHx8IHRoaXMuaGFyZERlcHMuaW5kZXhPZihrZXlwYXRoKSA9PT0gLTEpKSB7XG4gIFx0XHRcdFx0ZGVwZW5kZW5jaWVzQ2hhbmdlZCA9IHRydWU7XG5cbiAgXHRcdFx0XHQvLyBpZiB0aGlzIGtleXBhdGggaXMgY3VycmVudGx5IHVucmVzb2x2ZWQsIHdlIG5lZWQgdG8gbWFya1xuICBcdFx0XHRcdC8vIGl0IGFzIHN1Y2guIFRPRE8gdGhpcyBpcyBhIGJpdCBtdWRkeS4uLlxuICBcdFx0XHRcdGlmIChpc1VucmVzb2x2ZWQodGhpcy52aWV3bW9kZWwsIGtleXBhdGgpICYmICF0aGlzLnVucmVzb2x2ZWREZXBzW2tleXBhdGguc3RyXSkge1xuICBcdFx0XHRcdFx0dW5yZXNvbHZlZCA9IG5ldyBDb21wdXRhdGlvbl9VbnJlc29sdmVkRGVwZW5kZW5jeSh0aGlzLCBrZXlwYXRoLnN0cik7XG4gIFx0XHRcdFx0XHRuZXdEZXBzLnNwbGljZShpLCAxKTtcblxuICBcdFx0XHRcdFx0dGhpcy51bnJlc29sdmVkRGVwc1trZXlwYXRoLnN0cl0gPSB1bnJlc29sdmVkO1xuICBcdFx0XHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVW5yZXNvbHZlZCh1bnJlc29sdmVkKTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0dGhpcy52aWV3bW9kZWwucmVnaXN0ZXIoa2V5cGF0aCwgdGhpcywgXCJjb21wdXRlZFwiKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0aWYgKGRlcGVuZGVuY2llc0NoYW5nZWQpIHtcbiAgXHRcdFx0dGhpcy5zb2Z0RGVwcyA9IG5ld0RlcHMuc2xpY2UoKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGRlcGVuZGVuY2llc0NoYW5nZWQ7XG4gIFx0fVxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzVW5yZXNvbHZlZCh2aWV3bW9kZWwsIGtleXBhdGgpIHtcbiAgXHR2YXIga2V5ID0ga2V5cGF0aC5maXJzdEtleTtcblxuICBcdHJldHVybiAhKGtleSBpbiB2aWV3bW9kZWwuZGF0YSkgJiYgIShrZXkgaW4gdmlld21vZGVsLmNvbXB1dGF0aW9ucykgJiYgIShrZXkgaW4gdmlld21vZGVsLm1hcHBpbmdzKTtcbiAgfVxuXG4gIHZhciBDb21wdXRhdGlvbl9Db21wdXRhdGlvbiA9IENvbXB1dGF0aW9uO1xuXG4gIHZhciBjb21wdXRlID0gVmlld21vZGVsJGNvbXB1dGU7XG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRjb21wdXRlKGtleSwgc2lnbmF0dXJlKSB7XG4gIFx0dmFyIGNvbXB1dGF0aW9uID0gbmV3IENvbXB1dGF0aW9uX0NvbXB1dGF0aW9uKGtleSwgc2lnbmF0dXJlKTtcblxuICBcdGlmICh0aGlzLnJlYWR5KSB7XG4gIFx0XHRjb21wdXRhdGlvbi5pbml0KHRoaXMpO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLmNvbXB1dGF0aW9uc1trZXkuc3RyXSA9IGNvbXB1dGF0aW9uO1xuICB9XG5cbiAgdmFyIEZBSUxFRF9MT09LVVAgPSB7IEZBSUxFRF9MT09LVVA6IHRydWUgfTtcblxuICB2YXIgdmlld21vZGVsX3Byb3RvdHlwZV9nZXQgPSBWaWV3bW9kZWwkZ2V0O1xuXG4gIHZhciB2aWV3bW9kZWxfcHJvdG90eXBlX2dldF9fZW1wdHkgPSB7fTtcbiAgZnVuY3Rpb24gVmlld21vZGVsJGdldChrZXlwYXRoLCBvcHRpb25zKSB7XG4gIFx0dmFyIGNhY2hlID0gdGhpcy5jYWNoZSxcbiAgXHQgICAgdmFsdWUsXG4gIFx0ICAgIGNvbXB1dGF0aW9uLFxuICBcdCAgICB3cmFwcGVkLFxuICBcdCAgICBjYXB0dXJlR3JvdXAsXG4gIFx0ICAgIGtleXBhdGhTdHIgPSBrZXlwYXRoLnN0cixcbiAgXHQgICAga2V5O1xuXG4gIFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwgdmlld21vZGVsX3Byb3RvdHlwZV9nZXRfX2VtcHR5O1xuXG4gIFx0Ly8gY2FwdHVyZSB0aGUga2V5cGF0aCwgaWYgd2UncmUgaW5zaWRlIGEgY29tcHV0YXRpb25cbiAgXHRpZiAob3B0aW9ucy5jYXB0dXJlICYmIChjYXB0dXJlR3JvdXAgPSBsYXN0SXRlbSh0aGlzLmNhcHR1cmVHcm91cHMpKSkge1xuICBcdFx0aWYgKCEgfmNhcHR1cmVHcm91cC5pbmRleE9mKGtleXBhdGgpKSB7XG4gIFx0XHRcdGNhcHR1cmVHcm91cC5wdXNoKGtleXBhdGgpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChoYXNPd24uY2FsbCh0aGlzLm1hcHBpbmdzLCBrZXlwYXRoLmZpcnN0S2V5KSkge1xuICBcdFx0cmV0dXJuIHRoaXMubWFwcGluZ3Nba2V5cGF0aC5maXJzdEtleV0uZ2V0KGtleXBhdGgsIG9wdGlvbnMpO1xuICBcdH1cblxuICBcdGlmIChrZXlwYXRoLmlzU3BlY2lhbCkge1xuICBcdFx0cmV0dXJuIGtleXBhdGgudmFsdWU7XG4gIFx0fVxuXG4gIFx0aWYgKGNhY2hlW2tleXBhdGhTdHJdID09PSB1bmRlZmluZWQpIHtcblxuICBcdFx0Ly8gSXMgdGhpcyBhIGNvbXB1dGVkIHByb3BlcnR5P1xuICBcdFx0aWYgKChjb21wdXRhdGlvbiA9IHRoaXMuY29tcHV0YXRpb25zW2tleXBhdGhTdHJdKSAmJiAhY29tcHV0YXRpb24uYnlwYXNzKSB7XG4gIFx0XHRcdHZhbHVlID0gY29tcHV0YXRpb24uZ2V0KCk7XG4gIFx0XHRcdHRoaXMuYWRhcHQoa2V5cGF0aFN0ciwgdmFsdWUpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBJcyB0aGlzIGEgd3JhcHBlZCBwcm9wZXJ0eT9cbiAgXHRcdGVsc2UgaWYgKHdyYXBwZWQgPSB0aGlzLndyYXBwZWRba2V5cGF0aFN0cl0pIHtcbiAgXHRcdFx0dmFsdWUgPSB3cmFwcGVkLnZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBJcyBpdCB0aGUgcm9vdD9cbiAgXHRcdGVsc2UgaWYgKGtleXBhdGguaXNSb290KSB7XG4gIFx0XHRcdHRoaXMuYWRhcHQoXCJcIiwgdGhpcy5kYXRhKTtcbiAgXHRcdFx0dmFsdWUgPSB0aGlzLmRhdGE7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIE5vPyBUaGVuIHdlIG5lZWQgdG8gcmV0cmlldmUgdGhlIHZhbHVlIG9uZSBrZXkgYXQgYSB0aW1lXG4gIFx0XHRlbHNlIHtcbiAgXHRcdFx0dmFsdWUgPSByZXRyaWV2ZSh0aGlzLCBrZXlwYXRoKTtcbiAgXHRcdH1cblxuICBcdFx0Y2FjaGVba2V5cGF0aFN0cl0gPSB2YWx1ZTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0dmFsdWUgPSBjYWNoZVtrZXlwYXRoU3RyXTtcbiAgXHR9XG5cbiAgXHRpZiAoIW9wdGlvbnMubm9VbndyYXAgJiYgKHdyYXBwZWQgPSB0aGlzLndyYXBwZWRba2V5cGF0aFN0cl0pKSB7XG4gIFx0XHR2YWx1ZSA9IHdyYXBwZWQuZ2V0KCk7XG4gIFx0fVxuXG4gIFx0aWYgKGtleXBhdGguaXNSb290ICYmIG9wdGlvbnMuZnVsbFJvb3RHZXQpIHtcbiAgXHRcdGZvciAoa2V5IGluIHRoaXMubWFwcGluZ3MpIHtcbiAgXHRcdFx0dmFsdWVba2V5XSA9IHRoaXMubWFwcGluZ3Nba2V5XS5nZXRWYWx1ZSgpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB2YWx1ZSA9PT0gRkFJTEVEX0xPT0tVUCA/IHZvaWQgMCA6IHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmV0cmlldmUodmlld21vZGVsLCBrZXlwYXRoKSB7XG5cbiAgXHR2YXIgcGFyZW50VmFsdWUsIGNhY2hlTWFwLCB2YWx1ZSwgd3JhcHBlZDtcblxuICBcdHBhcmVudFZhbHVlID0gdmlld21vZGVsLmdldChrZXlwYXRoLnBhcmVudCk7XG5cbiAgXHRpZiAod3JhcHBlZCA9IHZpZXdtb2RlbC53cmFwcGVkW2tleXBhdGgucGFyZW50LnN0cl0pIHtcbiAgXHRcdHBhcmVudFZhbHVlID0gd3JhcHBlZC5nZXQoKTtcbiAgXHR9XG5cbiAgXHRpZiAocGFyZW50VmFsdWUgPT09IG51bGwgfHwgcGFyZW50VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIHVwZGF0ZSBjYWNoZSBtYXBcbiAgXHRpZiAoIShjYWNoZU1hcCA9IHZpZXdtb2RlbC5jYWNoZU1hcFtrZXlwYXRoLnBhcmVudC5zdHJdKSkge1xuICBcdFx0dmlld21vZGVsLmNhY2hlTWFwW2tleXBhdGgucGFyZW50LnN0cl0gPSBba2V5cGF0aC5zdHJdO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRpZiAoY2FjaGVNYXAuaW5kZXhPZihrZXlwYXRoLnN0cikgPT09IC0xKSB7XG4gIFx0XHRcdGNhY2hlTWFwLnB1c2goa2V5cGF0aC5zdHIpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIElmIHRoaXMgcHJvcGVydHkgZG9lc24ndCBleGlzdCwgd2UgcmV0dXJuIGEgc2VudGluZWwgdmFsdWVcbiAgXHQvLyBzbyB0aGF0IHdlIGtub3cgdG8gcXVlcnkgcGFyZW50IHNjb3BlIChpZiBzdWNoIHRoZXJlIGJlKVxuICBcdGlmICh0eXBlb2YgcGFyZW50VmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIShrZXlwYXRoLmxhc3RLZXkgaW4gcGFyZW50VmFsdWUpKSB7XG4gIFx0XHRyZXR1cm4gdmlld21vZGVsLmNhY2hlW2tleXBhdGguc3RyXSA9IEZBSUxFRF9MT09LVVA7XG4gIFx0fVxuXG4gIFx0dmFsdWUgPSBwYXJlbnRWYWx1ZVtrZXlwYXRoLmxhc3RLZXldO1xuXG4gIFx0Ly8gRG8gd2UgaGF2ZSBhbiBhZGFwdG9yIGZvciB0aGlzIHZhbHVlP1xuICBcdHZpZXdtb2RlbC5hZGFwdChrZXlwYXRoLnN0ciwgdmFsdWUsIGZhbHNlKTtcblxuICBcdC8vIFVwZGF0ZSBjYWNoZVxuICBcdHZpZXdtb2RlbC5jYWNoZVtrZXlwYXRoLnN0cl0gPSB2YWx1ZTtcbiAgXHRyZXR1cm4gdmFsdWU7XG4gIH1cblxuICB2YXIgdmlld21vZGVsX3Byb3RvdHlwZV9pbml0ID0gVmlld21vZGVsJGluaXQ7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJGluaXQoKSB7XG4gIFx0dmFyIGtleTtcblxuICBcdGZvciAoa2V5IGluIHRoaXMuY29tcHV0YXRpb25zKSB7XG4gIFx0XHR0aGlzLmNvbXB1dGF0aW9uc1trZXldLmluaXQodGhpcyk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9tYXAgPSBWaWV3bW9kZWwkbWFwO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRtYXAoa2V5LCBvcHRpb25zKSB7XG4gIFx0dmFyIG1hcHBpbmcgPSB0aGlzLm1hcHBpbmdzW2tleS5zdHJdID0gbmV3IE1hcHBpbmcoa2V5LCBvcHRpb25zKTtcbiAgXHRtYXBwaW5nLmluaXRWaWV3bW9kZWwodGhpcyk7XG4gIFx0cmV0dXJuIG1hcHBpbmc7XG4gIH1cblxuICB2YXIgTWFwcGluZyA9IGZ1bmN0aW9uIChsb2NhbEtleSwgb3B0aW9ucykge1xuICBcdHRoaXMubG9jYWxLZXkgPSBsb2NhbEtleTtcbiAgXHR0aGlzLmtleXBhdGggPSBvcHRpb25zLmtleXBhdGg7XG4gIFx0dGhpcy5vcmlnaW4gPSBvcHRpb25zLm9yaWdpbjtcblxuICBcdHRoaXMuZGVwcyA9IFtdO1xuICBcdHRoaXMudW5yZXNvbHZlZCA9IFtdO1xuXG4gIFx0dGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xuICB9O1xuXG4gIE1hcHBpbmcucHJvdG90eXBlID0ge1xuICBcdGZvcmNlUmVzb2x1dGlvbjogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gVE9ETyB3YXJuLCBhcyBwZXIgIzE2OTI/XG4gIFx0XHR0aGlzLmtleXBhdGggPSB0aGlzLmxvY2FsS2V5O1xuICBcdFx0dGhpcy5zZXR1cCgpO1xuICBcdH0sXG5cbiAgXHRnZXQ6IGZ1bmN0aW9uIChrZXlwYXRoLCBvcHRpb25zKSB7XG4gIFx0XHRpZiAoIXRoaXMucmVzb2x2ZWQpIHtcbiAgXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzLm9yaWdpbi5nZXQodGhpcy5tYXAoa2V5cGF0aCksIG9wdGlvbnMpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLmtleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzLm9yaWdpbi5nZXQodGhpcy5rZXlwYXRoKTtcbiAgXHR9LFxuXG4gIFx0aW5pdFZpZXdtb2RlbDogZnVuY3Rpb24gKHZpZXdtb2RlbCkge1xuICBcdFx0dGhpcy5sb2NhbCA9IHZpZXdtb2RlbDtcbiAgXHRcdHRoaXMuc2V0dXAoKTtcbiAgXHR9LFxuXG4gIFx0bWFwOiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0aWYgKHR5cGVvZiB0aGlzLmtleXBhdGggPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5sb2NhbEtleTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiBrZXlwYXRoLnJlcGxhY2UodGhpcy5sb2NhbEtleSwgdGhpcy5rZXlwYXRoKTtcbiAgXHR9LFxuXG4gIFx0cmVnaXN0ZXI6IGZ1bmN0aW9uIChrZXlwYXRoLCBkZXBlbmRhbnQsIGdyb3VwKSB7XG4gIFx0XHR0aGlzLmRlcHMucHVzaCh7IGtleXBhdGg6IGtleXBhdGgsIGRlcDogZGVwZW5kYW50LCBncm91cDogZ3JvdXAgfSk7XG5cbiAgXHRcdGlmICh0aGlzLnJlc29sdmVkKSB7XG4gIFx0XHRcdHRoaXMub3JpZ2luLnJlZ2lzdGVyKHRoaXMubWFwKGtleXBhdGgpLCBkZXBlbmRhbnQsIGdyb3VwKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmVzb2x2ZTogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdGlmICh0aGlzLmtleXBhdGggIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0aGlzLnVuYmluZCh0cnVlKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcbiAgXHRcdHRoaXMuc2V0dXAoKTtcbiAgXHR9LFxuXG4gIFx0c2V0OiBmdW5jdGlvbiAoa2V5cGF0aCwgdmFsdWUpIHtcbiAgXHRcdGlmICghdGhpcy5yZXNvbHZlZCkge1xuICBcdFx0XHR0aGlzLmZvcmNlUmVzb2x1dGlvbigpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLm9yaWdpbi5zZXQodGhpcy5tYXAoa2V5cGF0aCksIHZhbHVlKTtcbiAgXHR9LFxuXG4gIFx0c2V0dXA6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdGlmICh0aGlzLmtleXBhdGggPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMucmVzb2x2ZWQgPSB0cnVlO1xuXG4gIFx0XHQvLyBhY2N1bXVsYXRlZCBkZXBlbmRhbnRzIGNhbiBub3cgYmUgcmVnaXN0ZXJlZFxuICBcdFx0aWYgKHRoaXMuZGVwcy5sZW5ndGgpIHtcbiAgXHRcdFx0dGhpcy5kZXBzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgXHRcdFx0XHR2YXIga2V5cGF0aCA9IF90aGlzLm1hcChkLmtleXBhdGgpO1xuICBcdFx0XHRcdF90aGlzLm9yaWdpbi5yZWdpc3RlcihrZXlwYXRoLCBkLmRlcCwgZC5ncm91cCk7XG5cbiAgXHRcdFx0XHQvLyBUT0RPIHRoaXMgaXMgYSBiaXQgb2YgYSByZWQgZmxhZy4uLiBhbGwgZGVwcyBzaG91bGQgYmUgdGhlIHNhbWU/XG4gIFx0XHRcdFx0aWYgKGQuZGVwLnNldFZhbHVlKSB7XG4gIFx0XHRcdFx0XHRkLmRlcC5zZXRWYWx1ZShfdGhpcy5vcmlnaW4uZ2V0KGtleXBhdGgpKTtcbiAgXHRcdFx0XHR9IGVsc2UgaWYgKGQuZGVwLmludmFsaWRhdGUpIHtcbiAgXHRcdFx0XHRcdGQuZGVwLmludmFsaWRhdGUoKTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZC4gUGxlYXNlIHJhaXNlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9pc3N1ZXMgLSB0aGFua3MhXCIpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSk7XG5cbiAgXHRcdFx0dGhpcy5vcmlnaW4ubWFyayh0aGlzLmtleXBhdGgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHRpZiAoIXRoaXMua2V5cGF0aCkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNYXBwaW5nIGRvZXMgbm90IGhhdmUga2V5cGF0aCwgY2Fubm90IHNldCB2YWx1ZS4gUGxlYXNlIHJhaXNlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9pc3N1ZXMgLSB0aGFua3MhXCIpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLm9yaWdpbi5zZXQodGhpcy5rZXlwYXRoLCB2YWx1ZSk7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKGtlZXBMb2NhbCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0aWYgKCFrZWVwTG9jYWwpIHtcbiAgXHRcdFx0ZGVsZXRlIHRoaXMubG9jYWwubWFwcGluZ3NbdGhpcy5sb2NhbEtleV07XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghdGhpcy5yZXNvbHZlZCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gIFx0XHRcdF90aGlzLm9yaWdpbi51bnJlZ2lzdGVyKF90aGlzLm1hcChkLmtleXBhdGgpLCBkLmRlcCwgZC5ncm91cCk7XG4gIFx0XHR9KTtcblxuICBcdFx0aWYgKHRoaXMudHJhY2tlcikge1xuICBcdFx0XHR0aGlzLm9yaWdpbi51bnJlZ2lzdGVyKHRoaXMua2V5cGF0aCwgdGhpcy50cmFja2VyKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5yZWdpc3RlcjogZnVuY3Rpb24gKGtleXBhdGgsIGRlcGVuZGFudCwgZ3JvdXApIHtcbiAgXHRcdHZhciBkZXBzLCBpO1xuXG4gIFx0XHRpZiAoIXRoaXMucmVzb2x2ZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRkZXBzID0gdGhpcy5kZXBzO1xuICBcdFx0aSA9IGRlcHMubGVuZ3RoO1xuXG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGlmIChkZXBzW2ldLmRlcCA9PT0gZGVwZW5kYW50KSB7XG4gIFx0XHRcdFx0ZGVwcy5zcGxpY2UoaSwgMSk7XG4gIFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdHRoaXMub3JpZ2luLnVucmVnaXN0ZXIodGhpcy5tYXAoa2V5cGF0aCksIGRlcGVuZGFudCwgZ3JvdXApO1xuICBcdH1cbiAgfTtcblxuICB2YXIgbWFyayA9IFZpZXdtb2RlbCRtYXJrO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRtYXJrKGtleXBhdGgsIG9wdGlvbnMpIHtcbiAgXHR2YXIgY29tcHV0YXRpb24sXG4gIFx0ICAgIGtleXBhdGhTdHIgPSBrZXlwYXRoLnN0cjtcblxuICBcdC8vIGltcGxpY2l0IGNoYW5nZXMgKGkuZS4gYGZvby5sZW5ndGhgIG9uIGByYWN0aXZlLnB1c2goJ2ZvbycsNDIpYClcbiAgXHQvLyBzaG91bGQgbm90IGJlIHBpY2tlZCB1cCBieSBwYXR0ZXJuIG9ic2VydmVyc1xuICBcdGlmIChvcHRpb25zKSB7XG4gIFx0XHRpZiAob3B0aW9ucy5pbXBsaWNpdCkge1xuICBcdFx0XHR0aGlzLmltcGxpY2l0Q2hhbmdlc1trZXlwYXRoU3RyXSA9IHRydWU7XG4gIFx0XHR9XG4gIFx0XHRpZiAob3B0aW9ucy5ub0Nhc2NhZGUpIHtcbiAgXHRcdFx0dGhpcy5ub0Nhc2NhZGVba2V5cGF0aFN0cl0gPSB0cnVlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChjb21wdXRhdGlvbiA9IHRoaXMuY29tcHV0YXRpb25zW2tleXBhdGhTdHJdKSB7XG4gIFx0XHRjb21wdXRhdGlvbi5pbnZhbGlkYXRlKCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuY2hhbmdlcy5pbmRleE9mKGtleXBhdGgpID09PSAtMSkge1xuICBcdFx0dGhpcy5jaGFuZ2VzLnB1c2goa2V5cGF0aCk7XG4gIFx0fVxuXG4gIFx0Ly8gcGFzcyBvbiBrZWVwRXhpc3RpbmdXcmFwcGVyLCBpZiB3ZSBjYW5cbiAgXHR2YXIga2VlcEV4aXN0aW5nV3JhcHBlciA9IG9wdGlvbnMgPyBvcHRpb25zLmtlZXBFeGlzdGluZ1dyYXBwZXIgOiBmYWxzZTtcblxuICBcdHRoaXMuY2xlYXJDYWNoZShrZXlwYXRoU3RyLCBrZWVwRXhpc3RpbmdXcmFwcGVyKTtcblxuICBcdGlmICh0aGlzLnJlYWR5KSB7XG4gIFx0XHR0aGlzLm9uY2hhbmdlKCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIG1hcE9sZFRvTmV3SW5kZXggPSBmdW5jdGlvbiAob2xkQXJyYXksIG5ld0FycmF5KSB7XG4gIFx0dmFyIHVzZWRJbmRpY2VzLCBmaXJzdFVudXNlZEluZGV4LCBuZXdJbmRpY2VzLCBjaGFuZ2VkO1xuXG4gIFx0dXNlZEluZGljZXMgPSB7fTtcbiAgXHRmaXJzdFVudXNlZEluZGV4ID0gMDtcblxuICBcdG5ld0luZGljZXMgPSBvbGRBcnJheS5tYXAoZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgXHRcdHZhciBpbmRleCwgc3RhcnQsIGxlbjtcblxuICBcdFx0c3RhcnQgPSBmaXJzdFVudXNlZEluZGV4O1xuICBcdFx0bGVuID0gbmV3QXJyYXkubGVuZ3RoO1xuXG4gIFx0XHRkbyB7XG4gIFx0XHRcdGluZGV4ID0gbmV3QXJyYXkuaW5kZXhPZihpdGVtLCBzdGFydCk7XG5cbiAgXHRcdFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuICBcdFx0XHRcdHJldHVybiAtMTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHN0YXJ0ID0gaW5kZXggKyAxO1xuICBcdFx0fSB3aGlsZSAodXNlZEluZGljZXNbaW5kZXhdICYmIHN0YXJ0IDwgbGVuKTtcblxuICBcdFx0Ly8ga2VlcCB0cmFjayBvZiB0aGUgZmlyc3QgdW51c2VkIGluZGV4LCBzbyB3ZSBkb24ndCBzZWFyY2hcbiAgXHRcdC8vIHRoZSB3aG9sZSBvZiBuZXdBcnJheSBmb3IgZWFjaCBpdGVtIGluIG9sZEFycmF5IHVubmVjZXNzYXJpbHlcbiAgXHRcdGlmIChpbmRleCA9PT0gZmlyc3RVbnVzZWRJbmRleCkge1xuICBcdFx0XHRmaXJzdFVudXNlZEluZGV4ICs9IDE7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChpbmRleCAhPT0gaSkge1xuICBcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0dXNlZEluZGljZXNbaW5kZXhdID0gdHJ1ZTtcbiAgXHRcdHJldHVybiBpbmRleDtcbiAgXHR9KTtcblxuICBcdHJldHVybiBuZXdJbmRpY2VzO1xuICB9O1xuXG4gIHZhciBtZXJnZSA9IFZpZXdtb2RlbCRtZXJnZTtcblxuICB2YXIgY29tcGFyYXRvcnMgPSB7fTtcbiAgZnVuY3Rpb24gVmlld21vZGVsJG1lcmdlKGtleXBhdGgsIGN1cnJlbnRBcnJheSwgYXJyYXksIG9wdGlvbnMpIHtcbiAgXHR2YXIgb2xkQXJyYXksIG5ld0FycmF5LCBjb21wYXJhdG9yLCBuZXdJbmRpY2VzO1xuXG4gIFx0dGhpcy5tYXJrKGtleXBhdGgpO1xuXG4gIFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jb21wYXJlKSB7XG5cbiAgXHRcdGNvbXBhcmF0b3IgPSBnZXRDb21wYXJhdG9yRnVuY3Rpb24ob3B0aW9ucy5jb21wYXJlKTtcblxuICBcdFx0dHJ5IHtcbiAgXHRcdFx0b2xkQXJyYXkgPSBjdXJyZW50QXJyYXkubWFwKGNvbXBhcmF0b3IpO1xuICBcdFx0XHRuZXdBcnJheSA9IGFycmF5Lm1hcChjb21wYXJhdG9yKTtcbiAgXHRcdH0gY2F0Y2ggKGVycikge1xuICBcdFx0XHQvLyBmYWxsYmFjayB0byBhbiBpZGVudGl0eSBjaGVjayAtIHdvcnN0IGNhc2Ugc2NlbmFyaW8gd2UgaGF2ZVxuICBcdFx0XHQvLyB0byBkbyBtb3JlIERPTSBtYW5pcHVsYXRpb24gdGhhbiB3ZSB0aG91Z2h0Li4uXG4gIFx0XHRcdHdhcm5JZkRlYnVnKFwibWVyZ2UoKTogXFxcIiVzXFxcIiBjb21wYXJpc29uIGZhaWxlZC4gRmFsbGluZyBiYWNrIHRvIGlkZW50aXR5IGNoZWNraW5nXCIsIGtleXBhdGgpO1xuXG4gIFx0XHRcdG9sZEFycmF5ID0gY3VycmVudEFycmF5O1xuICBcdFx0XHRuZXdBcnJheSA9IGFycmF5O1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHRvbGRBcnJheSA9IGN1cnJlbnRBcnJheTtcbiAgXHRcdG5ld0FycmF5ID0gYXJyYXk7XG4gIFx0fVxuXG4gIFx0Ly8gZmluZCBuZXcgaW5kaWNlcyBmb3IgbWVtYmVycyBvZiBvbGRBcnJheVxuICBcdG5ld0luZGljZXMgPSBtYXBPbGRUb05ld0luZGV4KG9sZEFycmF5LCBuZXdBcnJheSk7XG5cbiAgXHR0aGlzLnNtYXJ0VXBkYXRlKGtleXBhdGgsIGFycmF5LCBuZXdJbmRpY2VzLCBjdXJyZW50QXJyYXkubGVuZ3RoICE9PSBhcnJheS5sZW5ndGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5KGl0ZW0pIHtcbiAgXHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoaXRlbSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb21wYXJhdG9yRnVuY3Rpb24oY29tcGFyYXRvcikge1xuICBcdC8vIElmIGBjb21wYXJlYCBpcyBgdHJ1ZWAsIHdlIHVzZSBKU09OLnN0cmluZ2lmeSB0byBjb21wYXJlXG4gIFx0Ly8gb2JqZWN0cyB0aGF0IGFyZSB0aGUgc2FtZSBzaGFwZSwgYnV0IG5vbi1pZGVudGljYWwgLSBpLmUuXG4gIFx0Ly8geyBmb286ICdiYXInIH0gIT09IHsgZm9vOiAnYmFyJyB9XG4gIFx0aWYgKGNvbXBhcmF0b3IgPT09IHRydWUpIHtcbiAgXHRcdHJldHVybiBzdHJpbmdpZnk7XG4gIFx0fVxuXG4gIFx0aWYgKHR5cGVvZiBjb21wYXJhdG9yID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRpZiAoIWNvbXBhcmF0b3JzW2NvbXBhcmF0b3JdKSB7XG4gIFx0XHRcdGNvbXBhcmF0b3JzW2NvbXBhcmF0b3JdID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgXHRcdFx0XHRyZXR1cm4gaXRlbVtjb21wYXJhdG9yXTtcbiAgXHRcdFx0fTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGNvbXBhcmF0b3JzW2NvbXBhcmF0b3JdO1xuICBcdH1cblxuICBcdGlmICh0eXBlb2YgY29tcGFyYXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRyZXR1cm4gY29tcGFyYXRvcjtcbiAgXHR9XG5cbiAgXHR0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYGNvbXBhcmVgIG9wdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24sIG9yIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBpZGVudGlmeWluZyBmaWVsZCAob3IgYHRydWVgIHRvIHVzZSBKU09OLnN0cmluZ2lmeSlcIik7XG4gIH1cblxuICB2YXIgcmVnaXN0ZXIgPSBWaWV3bW9kZWwkcmVnaXN0ZXI7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJHJlZ2lzdGVyKGtleXBhdGgsIGRlcGVuZGFudCkge1xuICBcdHZhciBncm91cCA9IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gXCJkZWZhdWx0XCIgOiBhcmd1bWVudHNbMl07XG5cbiAgXHR2YXIgbWFwcGluZywgZGVwc0J5S2V5cGF0aCwgZGVwcztcblxuICBcdGlmIChkZXBlbmRhbnQuaXNTdGF0aWMpIHtcbiAgXHRcdHJldHVybjsgLy8gVE9ETyB3ZSBzaG91bGQgbmV2ZXIgZ2V0IGhlcmUgaWYgYSBkZXBlbmRhbnQgaXMgc3RhdGljLi4uXG4gIFx0fVxuXG4gIFx0aWYgKG1hcHBpbmcgPSB0aGlzLm1hcHBpbmdzW2tleXBhdGguZmlyc3RLZXldKSB7XG4gIFx0XHRtYXBwaW5nLnJlZ2lzdGVyKGtleXBhdGgsIGRlcGVuZGFudCwgZ3JvdXApO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRkZXBzQnlLZXlwYXRoID0gdGhpcy5kZXBzW2dyb3VwXSB8fCAodGhpcy5kZXBzW2dyb3VwXSA9IHt9KTtcbiAgXHRcdGRlcHMgPSBkZXBzQnlLZXlwYXRoW2tleXBhdGguc3RyXSB8fCAoZGVwc0J5S2V5cGF0aFtrZXlwYXRoLnN0cl0gPSBbXSk7XG5cbiAgXHRcdGRlcHMucHVzaChkZXBlbmRhbnQpO1xuXG4gIFx0XHRpZiAoIXRoaXMuZGVwc01hcFtncm91cF0pIHtcbiAgXHRcdFx0dGhpcy5kZXBzTWFwW2dyb3VwXSA9IHt9O1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIWtleXBhdGguaXNSb290KSB7XG4gIFx0XHRcdHJlZ2lzdGVyX191cGRhdGVEZXBlbmRhbnRzTWFwKHRoaXMsIGtleXBhdGgsIGdyb3VwKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiByZWdpc3Rlcl9fdXBkYXRlRGVwZW5kYW50c01hcCh2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwKSB7XG4gIFx0dmFyIG1hcCwgcGFyZW50LCBrZXlwYXRoU3RyO1xuXG4gIFx0Ly8gdXBkYXRlIGRlcGVuZGFudHMgbWFwXG4gIFx0d2hpbGUgKCFrZXlwYXRoLmlzUm9vdCkge1xuICBcdFx0bWFwID0gdmlld21vZGVsLmRlcHNNYXBbZ3JvdXBdO1xuICBcdFx0cGFyZW50ID0gbWFwW2tleXBhdGgucGFyZW50LnN0cl0gfHwgKG1hcFtrZXlwYXRoLnBhcmVudC5zdHJdID0gW10pO1xuXG4gIFx0XHRrZXlwYXRoU3RyID0ga2V5cGF0aC5zdHI7XG5cbiAgXHRcdC8vIFRPRE8gZmluZCBhbiBhbHRlcm5hdGl2ZSB0byB0aGlzIG5hc3R5IGFwcHJvYWNoXG4gIFx0XHRpZiAocGFyZW50W1wiX1wiICsga2V5cGF0aFN0cl0gPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRwYXJlbnRbXCJfXCIgKyBrZXlwYXRoU3RyXSA9IDA7XG4gIFx0XHRcdHBhcmVudC5wdXNoKGtleXBhdGgpO1xuICBcdFx0fVxuXG4gIFx0XHRwYXJlbnRbXCJfXCIgKyBrZXlwYXRoU3RyXSArPSAxO1xuICBcdFx0a2V5cGF0aCA9IGtleXBhdGgucGFyZW50O1xuICBcdH1cbiAgfVxuXG4gIHZhciByZWxlYXNlID0gVmlld21vZGVsJHJlbGVhc2U7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJHJlbGVhc2UoKSB7XG4gIFx0cmV0dXJuIHRoaXMuY2FwdHVyZUdyb3Vwcy5wb3AoKTtcbiAgfVxuXG4gIHZhciByZXNldCA9IFZpZXdtb2RlbCRyZXNldDtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkcmVzZXQoZGF0YSkge1xuICBcdHRoaXMuZGF0YSA9IGRhdGE7XG4gIFx0dGhpcy5jbGVhckNhY2hlKFwiXCIpO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9zZXQgPSBWaWV3bW9kZWwkc2V0O1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRzZXQoa2V5cGF0aCwgdmFsdWUpIHtcbiAgXHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMl07XG5cbiAgXHR2YXIgbWFwcGluZywgY29tcHV0YXRpb24sIHdyYXBwZXIsIGtlZXBFeGlzdGluZ1dyYXBwZXI7XG5cbiAgXHQvLyB1bmxlc3MgZGF0YSBpcyBiZWluZyBzZXQgZm9yIGRhdGEgdHJhY2tpbmcgcHVycG9zZXNcbiAgXHRpZiAoIW9wdGlvbnMubm9NYXBwaW5nKSB7XG4gIFx0XHQvLyBJZiB0aGlzIGRhdGEgYmVsb25ncyB0byBhIGRpZmZlcmVudCB2aWV3bW9kZWwsXG4gIFx0XHQvLyBwYXNzIHRoZSBjaGFuZ2UgYWxvbmdcbiAgXHRcdGlmIChtYXBwaW5nID0gdGhpcy5tYXBwaW5nc1trZXlwYXRoLmZpcnN0S2V5XSkge1xuICBcdFx0XHRyZXR1cm4gbWFwcGluZy5zZXQoa2V5cGF0aCwgdmFsdWUpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGNvbXB1dGF0aW9uID0gdGhpcy5jb21wdXRhdGlvbnNba2V5cGF0aC5zdHJdO1xuICBcdGlmIChjb21wdXRhdGlvbikge1xuICBcdFx0aWYgKGNvbXB1dGF0aW9uLnNldHRpbmcpIHtcbiAgXHRcdFx0Ly8gbGV0IHRoZSBvdGhlciBjb21wdXRhdGlvbiBzZXQoKSBoYW5kbGUgdGhpbmdzLi4uXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdGNvbXB1dGF0aW9uLnNldCh2YWx1ZSk7XG4gIFx0XHR2YWx1ZSA9IGNvbXB1dGF0aW9uLmdldCgpO1xuICBcdH1cblxuICBcdGlmIChpc0VxdWFsKHRoaXMuY2FjaGVba2V5cGF0aC5zdHJdLCB2YWx1ZSkpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHR3cmFwcGVyID0gdGhpcy53cmFwcGVkW2tleXBhdGguc3RyXTtcblxuICBcdC8vIElmIHdlIGhhdmUgYSB3cmFwcGVyIHdpdGggYSBgcmVzZXQoKWAgbWV0aG9kLCB3ZSB0cnkgYW5kIHVzZSBpdC4gSWYgdGhlXG4gIFx0Ly8gYHJlc2V0KClgIG1ldGhvZCByZXR1cm5zIGZhbHNlLCB0aGUgd3JhcHBlciBzaG91bGQgYmUgdG9ybiBkb3duLCBhbmRcbiAgXHQvLyAobW9zdCBsaWtlbHkpIGEgbmV3IG9uZSBzaG91bGQgYmUgY3JlYXRlZCBsYXRlclxuICBcdGlmICh3cmFwcGVyICYmIHdyYXBwZXIucmVzZXQpIHtcbiAgXHRcdGtlZXBFeGlzdGluZ1dyYXBwZXIgPSB3cmFwcGVyLnJlc2V0KHZhbHVlKSAhPT0gZmFsc2U7XG5cbiAgXHRcdGlmIChrZWVwRXhpc3RpbmdXcmFwcGVyKSB7XG4gIFx0XHRcdHZhbHVlID0gd3JhcHBlci5nZXQoKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoIWNvbXB1dGF0aW9uICYmICFrZWVwRXhpc3RpbmdXcmFwcGVyKSB7XG4gIFx0XHRyZXNvbHZlU2V0KHRoaXMsIGtleXBhdGgsIHZhbHVlKTtcbiAgXHR9XG5cbiAgXHRpZiAoIW9wdGlvbnMuc2lsZW50KSB7XG4gIFx0XHR0aGlzLm1hcmsoa2V5cGF0aCk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdC8vIFdlJ3JlIHNldHRpbmcgYSBwYXJlbnQgb2YgdGhlIG9yaWdpbmFsIHRhcmdldCBrZXlwYXRoIChpLmUuXG4gIFx0XHQvLyBjcmVhdGluZyBhIGZyZXNoIGJyYW5jaCkgLSB3ZSBuZWVkIHRvIGNsZWFyIHRoZSBjYWNoZSwgYnV0XG4gIFx0XHQvLyBub3QgbWFyayBpdCBhcyBhIGNoYW5nZVxuICBcdFx0dGhpcy5jbGVhckNhY2hlKGtleXBhdGguc3RyKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlU2V0KHZpZXdtb2RlbCwga2V5cGF0aCwgdmFsdWUpIHtcbiAgXHR2YXIgd3JhcHBlciwgcGFyZW50VmFsdWUsIHdyYXBwZXJTZXQsIHZhbHVlU2V0O1xuXG4gIFx0d3JhcHBlclNldCA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh3cmFwcGVyLnNldCkge1xuICBcdFx0XHR3cmFwcGVyLnNldChrZXlwYXRoLmxhc3RLZXksIHZhbHVlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHBhcmVudFZhbHVlID0gd3JhcHBlci5nZXQoKTtcbiAgXHRcdFx0dmFsdWVTZXQoKTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0dmFsdWVTZXQgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXBhcmVudFZhbHVlKSB7XG4gIFx0XHRcdHBhcmVudFZhbHVlID0gY3JlYXRlQnJhbmNoKGtleXBhdGgubGFzdEtleSk7XG4gIFx0XHRcdHZpZXdtb2RlbC5zZXQoa2V5cGF0aC5wYXJlbnQsIHBhcmVudFZhbHVlLCB7IHNpbGVudDogdHJ1ZSB9KTtcbiAgXHRcdH1cbiAgXHRcdHBhcmVudFZhbHVlW2tleXBhdGgubGFzdEtleV0gPSB2YWx1ZTtcbiAgXHR9O1xuXG4gIFx0d3JhcHBlciA9IHZpZXdtb2RlbC53cmFwcGVkW2tleXBhdGgucGFyZW50LnN0cl07XG5cbiAgXHRpZiAod3JhcHBlcikge1xuICBcdFx0d3JhcHBlclNldCgpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRwYXJlbnRWYWx1ZSA9IHZpZXdtb2RlbC5nZXQoa2V5cGF0aC5wYXJlbnQpO1xuXG4gIFx0XHQvLyBtYXkgaGF2ZSBiZWVuIHdyYXBwZWQgdmlhIHRoZSBhYm92ZSAuZ2V0KClcbiAgXHRcdC8vIGNhbGwgb24gdmlld21vZGVsIGlmIHRoaXMgaXMgZmlyc3QgYWNjZXNzIHZpYSAuc2V0KCkhXG4gIFx0XHRpZiAod3JhcHBlciA9IHZpZXdtb2RlbC53cmFwcGVkW2tleXBhdGgucGFyZW50LnN0cl0pIHtcbiAgXHRcdFx0d3JhcHBlclNldCgpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dmFsdWVTZXQoKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgc21hcnRVcGRhdGUgPSBWaWV3bW9kZWwkc21hcnRVcGRhdGU7XG5cbiAgdmFyIGltcGxpY2l0T3B0aW9uID0geyBpbXBsaWNpdDogdHJ1ZSB9LFxuICAgICAgbm9DYXNjYWRlT3B0aW9uID0geyBub0Nhc2NhZGU6IHRydWUgfTtcbiAgZnVuY3Rpb24gVmlld21vZGVsJHNtYXJ0VXBkYXRlKGtleXBhdGgsIGFycmF5LCBuZXdJbmRpY2VzKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciBkZXBlbmRhbnRzLCBvbGRMZW5ndGgsIGk7XG5cbiAgXHRvbGRMZW5ndGggPSBuZXdJbmRpY2VzLmxlbmd0aDtcblxuICBcdC8vIEluZGljZXMgdGhhdCBhcmUgYmVpbmcgcmVtb3ZlZCBzaG91bGQgYmUgbWFya2VkIGFzIGRpcnR5XG4gIFx0bmV3SW5kaWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZXdJbmRleCwgb2xkSW5kZXgpIHtcbiAgXHRcdGlmIChuZXdJbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0X3RoaXMubWFyayhrZXlwYXRoLmpvaW4ob2xkSW5kZXgpLCBub0Nhc2NhZGVPcHRpb24pO1xuICBcdFx0fVxuICBcdH0pO1xuXG4gIFx0Ly8gVXBkYXRlIHRoZSBtb2RlbFxuICBcdC8vIFRPRE8gYWxsb3cgZXhpc3RpbmcgYXJyYXkgdG8gYmUgdXBkYXRlZCBpbiBwbGFjZSwgcmF0aGVyIHRoYW4gcmVwbGFjZWQ/XG4gIFx0dGhpcy5zZXQoa2V5cGF0aCwgYXJyYXksIHsgc2lsZW50OiB0cnVlIH0pO1xuXG4gIFx0aWYgKGRlcGVuZGFudHMgPSB0aGlzLmRlcHNbXCJkZWZhdWx0XCJdW2tleXBhdGguc3RyXSkge1xuICBcdFx0ZGVwZW5kYW50cy5maWx0ZXIoY2FuU2h1ZmZsZSkuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICBcdFx0XHRyZXR1cm4gZC5zaHVmZmxlKG5ld0luZGljZXMsIGFycmF5KTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdGlmIChvbGRMZW5ndGggIT09IGFycmF5Lmxlbmd0aCkge1xuICBcdFx0dGhpcy5tYXJrKGtleXBhdGguam9pbihcImxlbmd0aFwiKSwgaW1wbGljaXRPcHRpb24pO1xuXG4gIFx0XHRmb3IgKGkgPSBuZXdJbmRpY2VzLnRvdWNoZWRGcm9tOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdFx0dGhpcy5tYXJrKGtleXBhdGguam9pbihpKSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGRvbid0IGFsbG93IHJlbW92ZWQgaW5kZXhlcyBiZXlvbmQgZW5kIG9mIG5ldyBhcnJheSB0byB0cmlnZ2VyIHJlY29tcHV0YXRpb25zXG4gIFx0XHQvLyBUT0RPIGlzIHRoaXMgc3RpbGwgbmVjZXNzYXJ5LCBub3cgdGhhdCBjb21wdXRhdGlvbnMgYXJlIGxhenk/XG4gIFx0XHRmb3IgKGkgPSBhcnJheS5sZW5ndGg7IGkgPCBvbGRMZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0XHR0aGlzLm1hcmsoa2V5cGF0aC5qb2luKGkpLCBub0Nhc2NhZGVPcHRpb24pO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhblNodWZmbGUoZGVwZW5kYW50KSB7XG4gIFx0cmV0dXJuIHR5cGVvZiBkZXBlbmRhbnQuc2h1ZmZsZSA9PT0gXCJmdW5jdGlvblwiO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV90ZWFyZG93biA9IFZpZXdtb2RlbCR0ZWFyZG93bjtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkdGVhcmRvd24oKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciB1bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5O1xuXG4gIFx0Ly8gQ2xlYXIgZW50aXJlIGNhY2hlIC0gdGhpcyBoYXMgdGhlIGRlc2lyZWQgc2lkZS1lZmZlY3RcbiAgXHQvLyBvZiB1bndyYXBwaW5nIGFkYXB0ZWQgdmFsdWVzIChlLmcuIGFycmF5cylcbiAgXHRPYmplY3Qua2V5cyh0aGlzLmNhY2hlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRyZXR1cm4gX3RoaXMuY2xlYXJDYWNoZShrZXlwYXRoKTtcbiAgXHR9KTtcblxuICBcdC8vIFRlYXJkb3duIGFueSBmYWlsZWQgbG9va3VwcyAtIHdlIGRvbid0IG5lZWQgdGhlbSB0byByZXNvbHZlIGFueSBtb3JlXG4gIFx0d2hpbGUgKHVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kgPSB0aGlzLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llcy5wb3AoKSkge1xuICBcdFx0dW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeS50ZWFyZG93bigpO1xuICBcdH1cbiAgfVxuXG4gIHZhciB1bnJlZ2lzdGVyID0gVmlld21vZGVsJHVucmVnaXN0ZXI7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJHVucmVnaXN0ZXIoa2V5cGF0aCwgZGVwZW5kYW50KSB7XG4gIFx0dmFyIGdyb3VwID0gYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBcImRlZmF1bHRcIiA6IGFyZ3VtZW50c1syXTtcblxuICBcdHZhciBtYXBwaW5nLCBkZXBzLCBpbmRleDtcblxuICBcdGlmIChkZXBlbmRhbnQuaXNTdGF0aWMpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRpZiAobWFwcGluZyA9IHRoaXMubWFwcGluZ3Nba2V5cGF0aC5maXJzdEtleV0pIHtcbiAgXHRcdHJldHVybiBtYXBwaW5nLnVucmVnaXN0ZXIoa2V5cGF0aCwgZGVwZW5kYW50LCBncm91cCk7XG4gIFx0fVxuXG4gIFx0ZGVwcyA9IHRoaXMuZGVwc1tncm91cF1ba2V5cGF0aC5zdHJdO1xuICBcdGluZGV4ID0gZGVwcy5pbmRleE9mKGRlcGVuZGFudCk7XG5cbiAgXHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gcmVtb3ZlIGEgZGVwZW5kYW50IHRoYXQgd2FzIG5vIGxvbmdlciByZWdpc3RlcmVkISBUaGlzIHNob3VsZCBub3QgaGFwcGVuLiBJZiB5b3UgYXJlIHNlZWluZyB0aGlzIGJ1ZyBpbiBkZXZlbG9wbWVudCBwbGVhc2UgcmFpc2UgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL1JhY3RpdmVKUy9SYWN0aXZlL2lzc3VlcyAtIHRoYW5rc1wiKTtcbiAgXHR9XG5cbiAgXHRkZXBzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgXHRpZiAoa2V5cGF0aC5pc1Jvb3QpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHR1bnJlZ2lzdGVyX191cGRhdGVEZXBlbmRhbnRzTWFwKHRoaXMsIGtleXBhdGgsIGdyb3VwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVucmVnaXN0ZXJfX3VwZGF0ZURlcGVuZGFudHNNYXAodmlld21vZGVsLCBrZXlwYXRoLCBncm91cCkge1xuICBcdHZhciBtYXAsIHBhcmVudDtcblxuICBcdC8vIHVwZGF0ZSBkZXBlbmRhbnRzIG1hcFxuICBcdHdoaWxlICgha2V5cGF0aC5pc1Jvb3QpIHtcbiAgXHRcdG1hcCA9IHZpZXdtb2RlbC5kZXBzTWFwW2dyb3VwXTtcbiAgXHRcdHBhcmVudCA9IG1hcFtrZXlwYXRoLnBhcmVudC5zdHJdO1xuXG4gIFx0XHRwYXJlbnRbXCJfXCIgKyBrZXlwYXRoLnN0cl0gLT0gMTtcblxuICBcdFx0aWYgKCFwYXJlbnRbXCJfXCIgKyBrZXlwYXRoLnN0cl0pIHtcbiAgXHRcdFx0Ly8gcmVtb3ZlIGZyb20gcGFyZW50IGRlcHMgbWFwXG4gIFx0XHRcdHJlbW92ZUZyb21BcnJheShwYXJlbnQsIGtleXBhdGgpO1xuICBcdFx0XHRwYXJlbnRbXCJfXCIgKyBrZXlwYXRoLnN0cl0gPSB1bmRlZmluZWQ7XG4gIFx0XHR9XG5cbiAgXHRcdGtleXBhdGggPSBrZXlwYXRoLnBhcmVudDtcbiAgXHR9XG4gIH1cblxuICB2YXIgVmlld21vZGVsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR2YXIgYWRhcHQgPSBvcHRpb25zLmFkYXB0O1xuICBcdHZhciBkYXRhID0gb3B0aW9ucy5kYXRhO1xuICBcdHZhciByYWN0aXZlID0gb3B0aW9ucy5yYWN0aXZlO1xuICBcdHZhciBjb21wdXRlZCA9IG9wdGlvbnMuY29tcHV0ZWQ7XG4gIFx0dmFyIG1hcHBpbmdzID0gb3B0aW9ucy5tYXBwaW5ncztcbiAgXHR2YXIga2V5O1xuICBcdHZhciBtYXBwaW5nO1xuXG4gIFx0Ly8gVE9ETyBpcyBpdCBwb3NzaWJsZSB0byByZW1vdmUgdGhpcyByZWZlcmVuY2U/XG4gIFx0dGhpcy5yYWN0aXZlID0gcmFjdGl2ZTtcblxuICBcdHRoaXMuYWRhcHRvcnMgPSBhZGFwdDtcbiAgXHR0aGlzLm9uY2hhbmdlID0gb3B0aW9ucy5vbmNoYW5nZTtcblxuICBcdHRoaXMuY2FjaGUgPSB7fTsgLy8gd2UgbmVlZCB0byBiZSBhYmxlIHRvIHVzZSBoYXNPd25Qcm9wZXJ0eSwgc28gY2FuJ3QgaW5oZXJpdCBmcm9tIG51bGxcbiAgXHR0aGlzLmNhY2hlTWFwID0gY3JlYXRlKG51bGwpO1xuXG4gIFx0dGhpcy5kZXBzID0ge1xuICBcdFx0Y29tcHV0ZWQ6IGNyZWF0ZShudWxsKSxcbiAgXHRcdFwiZGVmYXVsdFwiOiBjcmVhdGUobnVsbClcbiAgXHR9O1xuICBcdHRoaXMuZGVwc01hcCA9IHtcbiAgXHRcdGNvbXB1dGVkOiBjcmVhdGUobnVsbCksXG4gIFx0XHRcImRlZmF1bHRcIjogY3JlYXRlKG51bGwpXG4gIFx0fTtcblxuICBcdHRoaXMucGF0dGVybk9ic2VydmVycyA9IFtdO1xuXG4gIFx0dGhpcy5zcGVjaWFscyA9IGNyZWF0ZShudWxsKTtcblxuICBcdHRoaXMud3JhcHBlZCA9IGNyZWF0ZShudWxsKTtcbiAgXHR0aGlzLmNvbXB1dGF0aW9ucyA9IGNyZWF0ZShudWxsKTtcblxuICBcdHRoaXMuY2FwdHVyZUdyb3VwcyA9IFtdO1xuICBcdHRoaXMudW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jaWVzID0gW107XG5cbiAgXHR0aGlzLmNoYW5nZXMgPSBbXTtcbiAgXHR0aGlzLmltcGxpY2l0Q2hhbmdlcyA9IHt9O1xuICBcdHRoaXMubm9DYXNjYWRlID0ge307XG5cbiAgXHR0aGlzLmRhdGEgPSBkYXRhO1xuXG4gIFx0Ly8gc2V0IHVwIGV4cGxpY2l0IG1hcHBpbmdzXG4gIFx0dGhpcy5tYXBwaW5ncyA9IGNyZWF0ZShudWxsKTtcbiAgXHRmb3IgKGtleSBpbiBtYXBwaW5ncykge1xuICBcdFx0dGhpcy5tYXAoZ2V0S2V5cGF0aChrZXkpLCBtYXBwaW5nc1trZXldKTtcbiAgXHR9XG5cbiAgXHRpZiAoZGF0YSkge1xuICBcdFx0Ly8gaWYgZGF0YSBleGlzdHMgbG9jYWxseSwgYnV0IGlzIG1pc3Npbmcgb24gdGhlIHBhcmVudCxcbiAgXHRcdC8vIHdlIHRyYW5zZmVyIG93bmVyc2hpcCB0byB0aGUgcGFyZW50XG4gIFx0XHRmb3IgKGtleSBpbiBkYXRhKSB7XG4gIFx0XHRcdGlmICgobWFwcGluZyA9IHRoaXMubWFwcGluZ3Nba2V5XSkgJiYgbWFwcGluZy5nZXRWYWx1ZSgpID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHRtYXBwaW5nLnNldFZhbHVlKGRhdGFba2V5XSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRmb3IgKGtleSBpbiBjb21wdXRlZCkge1xuICBcdFx0aWYgKG1hcHBpbmdzICYmIGtleSBpbiBtYXBwaW5ncykge1xuICBcdFx0XHRmYXRhbChcIkNhbm5vdCBtYXAgdG8gYSBjb21wdXRlZCBwcm9wZXJ0eSAoJyVzJylcIiwga2V5KTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5jb21wdXRlKGdldEtleXBhdGgoa2V5KSwgY29tcHV0ZWRba2V5XSk7XG4gIFx0fVxuXG4gIFx0dGhpcy5yZWFkeSA9IHRydWU7XG4gIH07XG5cbiAgVmlld21vZGVsLnByb3RvdHlwZSA9IHtcbiAgXHRhZGFwdDogcHJvdG90eXBlX2FkYXB0LFxuICBcdGFwcGx5Q2hhbmdlczogYXBwbHlDaGFuZ2VzLFxuICBcdGNhcHR1cmU6IGNhcHR1cmUsXG4gIFx0Y2xlYXJDYWNoZTogY2xlYXJDYWNoZSxcbiAgXHRjb21wdXRlOiBjb21wdXRlLFxuICBcdGdldDogdmlld21vZGVsX3Byb3RvdHlwZV9nZXQsXG4gIFx0aW5pdDogdmlld21vZGVsX3Byb3RvdHlwZV9pbml0LFxuICBcdG1hcDogcHJvdG90eXBlX21hcCxcbiAgXHRtYXJrOiBtYXJrLFxuICBcdG1lcmdlOiBtZXJnZSxcbiAgXHRyZWdpc3RlcjogcmVnaXN0ZXIsXG4gIFx0cmVsZWFzZTogcmVsZWFzZSxcbiAgXHRyZXNldDogcmVzZXQsXG4gIFx0c2V0OiBwcm90b3R5cGVfc2V0LFxuICBcdHNtYXJ0VXBkYXRlOiBzbWFydFVwZGF0ZSxcbiAgXHR0ZWFyZG93bjogcHJvdG90eXBlX3RlYXJkb3duLFxuICBcdHVucmVnaXN0ZXI6IHVucmVnaXN0ZXJcbiAgfTtcblxuICB2YXIgdmlld21vZGVsX1ZpZXdtb2RlbCA9IFZpZXdtb2RlbDtcblxuICBmdW5jdGlvbiBIb29rUXVldWUoZXZlbnQpIHtcbiAgXHR0aGlzLmhvb2sgPSBuZXcgaG9va3NfSG9vayhldmVudCk7XG4gIFx0dGhpcy5pblByb2Nlc3MgPSB7fTtcbiAgXHR0aGlzLnF1ZXVlID0ge307XG4gIH1cblxuICBIb29rUXVldWUucHJvdG90eXBlID0ge1xuXG4gIFx0Y29uc3RydWN0b3I6IEhvb2tRdWV1ZSxcblxuICBcdGJlZ2luOiBmdW5jdGlvbiAocmFjdGl2ZSkge1xuICBcdFx0dGhpcy5pblByb2Nlc3NbcmFjdGl2ZS5fZ3VpZF0gPSB0cnVlO1xuICBcdH0sXG5cbiAgXHRlbmQ6IGZ1bmN0aW9uIChyYWN0aXZlKSB7XG5cbiAgXHRcdHZhciBwYXJlbnQgPSByYWN0aXZlLnBhcmVudDtcblxuICBcdFx0Ly8gSWYgdGhpcyBpcyAqaXNuJ3QqIGEgY2hpbGQgb2YgYSBjb21wb25lbnQgdGhhdCdzIGluIHByb2Nlc3MsXG4gIFx0XHQvLyBpdCBzaG91bGQgY2FsbCBtZXRob2RzIG9yIGZpcmUgYXQgdGhpcyBwb2ludFxuICBcdFx0aWYgKCFwYXJlbnQgfHwgIXRoaXMuaW5Qcm9jZXNzW3BhcmVudC5fZ3VpZF0pIHtcbiAgXHRcdFx0ZmlyZSh0aGlzLCByYWN0aXZlKTtcbiAgXHRcdH1cbiAgXHRcdC8vIGVsc2V3aXNlLCBoYW5kb2ZmIHRvIHBhcmVudCB0byBmaXJlIHdoZW4gcmVhZHlcbiAgXHRcdGVsc2Uge1xuICBcdFx0XHRnZXRDaGlsZFF1ZXVlKHRoaXMucXVldWUsIHBhcmVudCkucHVzaChyYWN0aXZlKTtcbiAgXHRcdH1cblxuICBcdFx0ZGVsZXRlIHRoaXMuaW5Qcm9jZXNzW3JhY3RpdmUuX2d1aWRdO1xuICBcdH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRDaGlsZFF1ZXVlKHF1ZXVlLCByYWN0aXZlKSB7XG4gIFx0cmV0dXJuIHF1ZXVlW3JhY3RpdmUuX2d1aWRdIHx8IChxdWV1ZVtyYWN0aXZlLl9ndWlkXSA9IFtdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmUoaG9va1F1ZXVlLCByYWN0aXZlKSB7XG5cbiAgXHR2YXIgY2hpbGRRdWV1ZSA9IGdldENoaWxkUXVldWUoaG9va1F1ZXVlLnF1ZXVlLCByYWN0aXZlKTtcblxuICBcdGhvb2tRdWV1ZS5ob29rLmZpcmUocmFjdGl2ZSk7XG5cbiAgXHQvLyBxdWV1ZSBpcyBcImxpdmVcIiBiZWNhdXNlIGNvbXBvbmVudHMgY2FuIGVuZCB1cCBiZWluZ1xuICBcdC8vIGFkZGVkIHdoaWxlIGhvb2tzIGZpcmUgb24gcGFyZW50cyB0aGF0IG1vZGlmeSBkYXRhIHZhbHVlcy5cbiAgXHR3aGlsZSAoY2hpbGRRdWV1ZS5sZW5ndGgpIHtcbiAgXHRcdGZpcmUoaG9va1F1ZXVlLCBjaGlsZFF1ZXVlLnNoaWZ0KCkpO1xuICBcdH1cblxuICBcdGRlbGV0ZSBob29rUXVldWUucXVldWVbcmFjdGl2ZS5fZ3VpZF07XG4gIH1cblxuICB2YXIgaG9va3NfSG9va1F1ZXVlID0gSG9va1F1ZXVlO1xuXG4gIHZhciBoZWxwZXJzX2dldENvbXB1dGF0aW9uU2lnbmF0dXJlcyA9IGdldENvbXB1dGF0aW9uU2lnbmF0dXJlcztcblxuICB2YXIgaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXNfX3BhdHRlcm4gPSAvXFwkXFx7KFteXFx9XSspXFx9L2c7XG4gIGZ1bmN0aW9uIGdldENvbXB1dGF0aW9uU2lnbmF0dXJlcyhyYWN0aXZlLCBjb21wdXRlZCkge1xuICBcdHZhciBzaWduYXR1cmVzID0ge30sXG4gIFx0ICAgIGtleTtcblxuICBcdGZvciAoa2V5IGluIGNvbXB1dGVkKSB7XG4gIFx0XHRzaWduYXR1cmVzW2tleV0gPSBnZXRDb21wdXRhdGlvblNpZ25hdHVyZShyYWN0aXZlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICBcdH1cblxuICBcdHJldHVybiBzaWduYXR1cmVzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q29tcHV0YXRpb25TaWduYXR1cmUocmFjdGl2ZSwga2V5LCBzaWduYXR1cmUpIHtcbiAgXHR2YXIgZ2V0dGVyLCBzZXR0ZXI7XG5cbiAgXHRpZiAodHlwZW9mIHNpZ25hdHVyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRnZXR0ZXIgPSBoZWxwZXJzX2dldENvbXB1dGF0aW9uU2lnbmF0dXJlc19fYmluZChzaWduYXR1cmUsIHJhY3RpdmUpO1xuICBcdH1cblxuICBcdGlmICh0eXBlb2Ygc2lnbmF0dXJlID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRnZXR0ZXIgPSBjcmVhdGVGdW5jdGlvbkZyb21TdHJpbmcocmFjdGl2ZSwgc2lnbmF0dXJlKTtcbiAgXHR9XG5cbiAgXHRpZiAodHlwZW9mIHNpZ25hdHVyZSA9PT0gXCJvYmplY3RcIikge1xuICBcdFx0aWYgKHR5cGVvZiBzaWduYXR1cmUuZ2V0ID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdGdldHRlciA9IGNyZWF0ZUZ1bmN0aW9uRnJvbVN0cmluZyhyYWN0aXZlLCBzaWduYXR1cmUuZ2V0KTtcbiAgXHRcdH0gZWxzZSBpZiAodHlwZW9mIHNpZ25hdHVyZS5nZXQgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRnZXR0ZXIgPSBoZWxwZXJzX2dldENvbXB1dGF0aW9uU2lnbmF0dXJlc19fYmluZChzaWduYXR1cmUuZ2V0LCByYWN0aXZlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGZhdGFsKFwiYCVzYCBjb21wdXRhdGlvbiBtdXN0IGhhdmUgYSBgZ2V0KClgIG1ldGhvZFwiLCBrZXkpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodHlwZW9mIHNpZ25hdHVyZS5zZXQgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRzZXR0ZXIgPSBoZWxwZXJzX2dldENvbXB1dGF0aW9uU2lnbmF0dXJlc19fYmluZChzaWduYXR1cmUuc2V0LCByYWN0aXZlKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4geyBnZXR0ZXI6IGdldHRlciwgc2V0dGVyOiBzZXR0ZXIgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uRnJvbVN0cmluZyhyYWN0aXZlLCBzdHIpIHtcbiAgXHR2YXIgZnVuY3Rpb25Cb2R5LCBoYXNUaGlzLCBmbjtcblxuICBcdGZ1bmN0aW9uQm9keSA9IFwicmV0dXJuIChcIiArIHN0ci5yZXBsYWNlKGhlbHBlcnNfZ2V0Q29tcHV0YXRpb25TaWduYXR1cmVzX19wYXR0ZXJuLCBmdW5jdGlvbiAobWF0Y2gsIGtleXBhdGgpIHtcbiAgXHRcdGhhc1RoaXMgPSB0cnVlO1xuICBcdFx0cmV0dXJuIFwiX19yYWN0aXZlLmdldChcXFwiXCIgKyBrZXlwYXRoICsgXCJcXFwiKVwiO1xuICBcdH0pICsgXCIpO1wiO1xuXG4gIFx0aWYgKGhhc1RoaXMpIHtcbiAgXHRcdGZ1bmN0aW9uQm9keSA9IFwidmFyIF9fcmFjdGl2ZSA9IHRoaXM7IFwiICsgZnVuY3Rpb25Cb2R5O1xuICBcdH1cblxuICBcdGZuID0gbmV3IEZ1bmN0aW9uKGZ1bmN0aW9uQm9keSk7XG4gIFx0cmV0dXJuIGhhc1RoaXMgPyBmbi5iaW5kKHJhY3RpdmUpIDogZm47XG4gIH1cblxuICBmdW5jdGlvbiBoZWxwZXJzX2dldENvbXB1dGF0aW9uU2lnbmF0dXJlc19fYmluZChmbiwgY29udGV4dCkge1xuICBcdHJldHVybiAvdGhpcy8udGVzdChmbi50b1N0cmluZygpKSA/IGZuLmJpbmQoY29udGV4dCkgOiBmbjtcbiAgfVxuXG4gIHZhciBjb25zdHJ1Y3RIb29rID0gbmV3IGhvb2tzX0hvb2soXCJjb25zdHJ1Y3RcIik7XG4gIHZhciBjb25maWdIb29rID0gbmV3IGhvb2tzX0hvb2soXCJjb25maWdcIik7XG4gIHZhciBpbml0SG9vayA9IG5ldyBob29rc19Ib29rUXVldWUoXCJpbml0XCIpO1xuICB2YXIgaW5pdGlhbGlzZV9fdWlkID0gMDtcblxuICB2YXIgaW5pdGlhbGlzZV9fcmVnaXN0cnlOYW1lcyA9IFtcImFkYXB0b3JzXCIsIFwiY29tcG9uZW50c1wiLCBcImRlY29yYXRvcnNcIiwgXCJlYXNpbmdcIiwgXCJldmVudHNcIiwgXCJpbnRlcnBvbGF0b3JzXCIsIFwicGFydGlhbHNcIiwgXCJ0cmFuc2l0aW9uc1wiXTtcblxuICB2YXIgaW5pdGlhbGlzZSA9IGluaXRpYWxpc2VSYWN0aXZlSW5zdGFuY2U7XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGlzZVJhY3RpdmVJbnN0YW5jZShyYWN0aXZlKSB7XG4gIFx0dmFyIHVzZXJPcHRpb25zID0gYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcbiAgXHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMl07XG5cbiAgXHR2YXIgZWwsIHZpZXdtb2RlbDtcblxuICBcdGlmIChfUmFjdGl2ZS5ERUJVRykge1xuICBcdFx0d2VsY29tZSgpO1xuICBcdH1cblxuICBcdGluaXRpYWxpc2VQcm9wZXJ0aWVzKHJhY3RpdmUsIG9wdGlvbnMpO1xuXG4gIFx0Ly8gVE9ETyByZW1vdmUgdGhpcywgZXZlbnR1YWxseVxuICBcdGRlZmluZVByb3BlcnR5KHJhY3RpdmUsIFwiZGF0YVwiLCB7IGdldDogZGVwcmVjYXRlUmFjdGl2ZURhdGEgfSk7XG5cbiAgXHQvLyBUT0RPIGRvbid0IGFsbG93IGBvbmNvbnN0cnVjdGAgd2l0aCBgbmV3IFJhY3RpdmUoKWAsIHRoZXJlJ3Mgbm8gbmVlZCBmb3IgaXRcbiAgXHRjb25zdHJ1Y3RIb29rLmZpcmUocmFjdGl2ZSwgdXNlck9wdGlvbnMpO1xuXG4gIFx0Ly8gQWRkIHJlZ2lzdHJpZXNcbiAgXHRpbml0aWFsaXNlX19yZWdpc3RyeU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgXHRcdHJhY3RpdmVbbmFtZV0gPSB1dGlsc19vYmplY3RfX2V4dGVuZChjcmVhdGUocmFjdGl2ZS5jb25zdHJ1Y3RvcltuYW1lXSB8fCBudWxsKSwgdXNlck9wdGlvbnNbbmFtZV0pO1xuICBcdH0pO1xuXG4gIFx0Ly8gQ3JlYXRlIGEgdmlld21vZGVsXG4gIFx0dmlld21vZGVsID0gbmV3IHZpZXdtb2RlbF9WaWV3bW9kZWwoe1xuICBcdFx0YWRhcHQ6IGdldEFkYXB0b3JzKHJhY3RpdmUsIHJhY3RpdmUuYWRhcHQsIHVzZXJPcHRpb25zKSxcbiAgXHRcdGRhdGE6IGN1c3RvbV9kYXRhLmluaXQocmFjdGl2ZS5jb25zdHJ1Y3RvciwgcmFjdGl2ZSwgdXNlck9wdGlvbnMpLFxuICBcdFx0Y29tcHV0ZWQ6IGhlbHBlcnNfZ2V0Q29tcHV0YXRpb25TaWduYXR1cmVzKHJhY3RpdmUsIHV0aWxzX29iamVjdF9fZXh0ZW5kKGNyZWF0ZShyYWN0aXZlLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wdXRlZCksIHVzZXJPcHRpb25zLmNvbXB1dGVkKSksXG4gIFx0XHRtYXBwaW5nczogb3B0aW9ucy5tYXBwaW5ncyxcbiAgXHRcdHJhY3RpdmU6IHJhY3RpdmUsXG4gIFx0XHRvbmNoYW5nZTogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gZ2xvYmFsX3J1bmxvb3AuYWRkUmFjdGl2ZShyYWN0aXZlKTtcbiAgXHRcdH1cbiAgXHR9KTtcblxuICBcdHJhY3RpdmUudmlld21vZGVsID0gdmlld21vZGVsO1xuXG4gIFx0Ly8gVGhpcyBjYW4ndCBoYXBwZW4gZWFybGllciwgYmVjYXVzZSBjb21wdXRlZCBwcm9wZXJ0aWVzIG1heSBjYWxsIGByYWN0aXZlLmdldCgpYCwgZXRjXG4gIFx0dmlld21vZGVsLmluaXQoKTtcblxuICBcdC8vIGluaXQgY29uZmlnIGZyb20gUGFyZW50IGFuZCBvcHRpb25zXG4gIFx0Y29uZmlnX2NvbmZpZy5pbml0KHJhY3RpdmUuY29uc3RydWN0b3IsIHJhY3RpdmUsIHVzZXJPcHRpb25zKTtcblxuICBcdGNvbmZpZ0hvb2suZmlyZShyYWN0aXZlKTtcbiAgXHRpbml0SG9vay5iZWdpbihyYWN0aXZlKTtcblxuICBcdC8vIC8vIElmIHRoaXMgaXMgYSBjb21wb25lbnQgd2l0aCBhIGZ1bmN0aW9uIGBkYXRhYCBwcm9wZXJ0eSwgY2FsbCB0aGUgZnVuY3Rpb25cbiAgXHQvLyAvLyB3aXRoIGByYWN0aXZlYCBhcyBjb250ZXh0ICh1bmxlc3MgdGhlIGNoaWxkIHdhcyBhbHNvIGEgZnVuY3Rpb24pXG4gIFx0Ly8gaWYgKCB0eXBlb2YgcmFjdGl2ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuZGF0YSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdXNlck9wdGlvbnMuZGF0YSAhPT0gJ2Z1bmN0aW9uJyApIHtcbiAgXHQvLyBcdHZpZXdtb2RlbC5yZXNldCggcmFjdGl2ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuZGF0YS5jYWxsKCByYWN0aXZlICkgfHwgZmF0YWwoICdgZGF0YWAgZnVuY3Rpb25zIG11c3QgcmV0dXJuIGEgZGF0YSBvYmplY3QnICkgKTtcbiAgXHQvLyB9XG5cbiAgXHQvLyBSZW5kZXIgdmlydHVhbCBET01cbiAgXHRpZiAocmFjdGl2ZS50ZW1wbGF0ZSkge1xuICBcdFx0dmFyIGNzc0lkcyA9IHVuZGVmaW5lZDtcblxuICBcdFx0aWYgKG9wdGlvbnMuY3NzSWRzIHx8IHJhY3RpdmUuY3NzSWQpIHtcbiAgXHRcdFx0Y3NzSWRzID0gb3B0aW9ucy5jc3NJZHMgPyBvcHRpb25zLmNzc0lkcy5zbGljZSgpIDogW107XG5cbiAgXHRcdFx0aWYgKHJhY3RpdmUuY3NzSWQpIHtcbiAgXHRcdFx0XHRjc3NJZHMucHVzaChyYWN0aXZlLmNzc0lkKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyYWN0aXZlLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHR0ZW1wbGF0ZTogcmFjdGl2ZS50ZW1wbGF0ZSxcbiAgXHRcdFx0cm9vdDogcmFjdGl2ZSxcbiAgXHRcdFx0b3duZXI6IHJhY3RpdmUsIC8vIHNhdmVzIGRvaW5nIGBpZiAoIHRoaXMucGFyZW50ICkgeyAvKi4uLiovIH1gIGxhdGVyIG9uXG4gIFx0XHRcdGNzc0lkczogY3NzSWRzXG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRpbml0SG9vay5lbmQocmFjdGl2ZSk7XG5cbiAgXHQvLyByZW5kZXIgYXV0b21hdGljYWxseSAoIGlmIGBlbGAgaXMgc3BlY2lmaWVkIClcbiAgXHRpZiAoZWwgPSBnZXRFbGVtZW50KHJhY3RpdmUuZWwpKSB7XG4gIFx0XHR2YXIgcHJvbWlzZSA9IHJhY3RpdmUucmVuZGVyKGVsLCByYWN0aXZlLmFwcGVuZCk7XG5cbiAgXHRcdGlmIChfUmFjdGl2ZS5ERUJVR19QUk9NSVNFUykge1xuICBcdFx0XHRwcm9taXNlW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICBcdFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyhcIlByb21pc2UgZGVidWdnaW5nIGlzIGVuYWJsZWQsIHRvIGhlbHAgc29sdmUgZXJyb3JzIHRoYXQgaGFwcGVuIGFzeW5jaHJvbm91c2x5LiBTb21lIGJyb3dzZXJzIHdpbGwgbG9nIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbnMsIGluIHdoaWNoIGNhc2UgeW91IGNhbiBzYWZlbHkgZGlzYWJsZSBwcm9taXNlIGRlYnVnZ2luZzpcXG4gIFJhY3RpdmUuREVCVUdfUFJPTUlTRVMgPSBmYWxzZTtcIik7XG4gIFx0XHRcdFx0d2FybklmRGVidWcoXCJBbiBlcnJvciBoYXBwZW5lZCBkdXJpbmcgcmVuZGVyaW5nXCIsIHsgcmFjdGl2ZTogcmFjdGl2ZSB9KTtcbiAgXHRcdFx0XHRlcnIuc3RhY2sgJiYgbG9nSWZEZWJ1ZyhlcnIuc3RhY2spO1xuXG4gIFx0XHRcdFx0dGhyb3cgZXJyO1xuICBcdFx0XHR9KTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBZGFwdG9ycyhyYWN0aXZlLCBwcm90b0FkYXB0LCB1c2VyT3B0aW9ucykge1xuICBcdHZhciBhZGFwdCwgbWFnaWMsIG1vZGlmeUFycmF5cztcblxuICBcdHByb3RvQWRhcHQgPSBwcm90b0FkYXB0Lm1hcChsb29rdXApO1xuICBcdGFkYXB0ID0gZW5zdXJlQXJyYXkodXNlck9wdGlvbnMuYWRhcHQpLm1hcChsb29rdXApO1xuXG4gIFx0YWRhcHQgPSBpbml0aWFsaXNlX19jb21iaW5lKHByb3RvQWRhcHQsIGFkYXB0KTtcblxuICBcdG1hZ2ljID0gXCJtYWdpY1wiIGluIHVzZXJPcHRpb25zID8gdXNlck9wdGlvbnMubWFnaWMgOiByYWN0aXZlLm1hZ2ljO1xuICBcdG1vZGlmeUFycmF5cyA9IFwibW9kaWZ5QXJyYXlzXCIgaW4gdXNlck9wdGlvbnMgPyB1c2VyT3B0aW9ucy5tb2RpZnlBcnJheXMgOiByYWN0aXZlLm1vZGlmeUFycmF5cztcblxuICBcdGlmIChtYWdpYykge1xuICBcdFx0aWYgKCFlbnZpcm9ubWVudF9fbWFnaWMpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiR2V0dGVycyBhbmQgc2V0dGVycyAobWFnaWMgbW9kZSkgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyXCIpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAobW9kaWZ5QXJyYXlzKSB7XG4gIFx0XHRcdGFkYXB0LnB1c2gobWFnaWNBcnJheSk7XG4gIFx0XHR9XG5cbiAgXHRcdGFkYXB0LnB1c2goYWRhcHRvcnNfbWFnaWMpO1xuICBcdH1cblxuICBcdGlmIChtb2RpZnlBcnJheXMpIHtcbiAgXHRcdGFkYXB0LnB1c2goYXJyYXlfaW5kZXgpO1xuICBcdH1cblxuICBcdHJldHVybiBhZGFwdDtcblxuICBcdGZ1bmN0aW9uIGxvb2t1cChhZGFwdG9yKSB7XG4gIFx0XHRpZiAodHlwZW9mIGFkYXB0b3IgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0YWRhcHRvciA9IGZpbmRJblZpZXdIaWVyYXJjaHkoXCJhZGFwdG9yc1wiLCByYWN0aXZlLCBhZGFwdG9yKTtcblxuICBcdFx0XHRpZiAoIWFkYXB0b3IpIHtcbiAgXHRcdFx0XHRmYXRhbChtaXNzaW5nUGx1Z2luKGFkYXB0b3IsIFwiYWRhcHRvclwiKSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGFkYXB0b3I7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGlzZV9fY29tYmluZShhLCBiKSB7XG4gIFx0dmFyIGMgPSBhLnNsaWNlKCksXG4gIFx0ICAgIGkgPSBiLmxlbmd0aDtcblxuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGlmICghIH5jLmluZGV4T2YoYltpXSkpIHtcbiAgXHRcdFx0Yy5wdXNoKGJbaV0pO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBjO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGlzZVByb3BlcnRpZXMocmFjdGl2ZSwgb3B0aW9ucykge1xuICBcdC8vIEdlbmVyYXRlIGEgdW5pcXVlIGlkZW50aWZpZXIsIGZvciBwbGFjZXMgd2hlcmUgeW91J2QgdXNlIGEgd2VhayBtYXAgaWYgaXRcbiAgXHQvLyBleGlzdGVkXG4gIFx0cmFjdGl2ZS5fZ3VpZCA9IFwici1cIiArIGluaXRpYWxpc2VfX3VpZCsrO1xuXG4gIFx0Ly8gZXZlbnRzXG4gIFx0cmFjdGl2ZS5fc3VicyA9IGNyZWF0ZShudWxsKTtcblxuICBcdC8vIHN0b3JhZ2UgZm9yIGl0ZW0gY29uZmlndXJhdGlvbiBmcm9tIGluc3RhbnRpYXRpb24gdG8gcmVzZXQsXG4gIFx0Ly8gbGlrZSBkeW5hbWljIGZ1bmN0aW9ucyBvciBvcmlnaW5hbCB2YWx1ZXNcbiAgXHRyYWN0aXZlLl9jb25maWcgPSB7fTtcblxuICBcdC8vIHR3by13YXkgYmluZGluZ3NcbiAgXHRyYWN0aXZlLl90d293YXlCaW5kaW5ncyA9IGNyZWF0ZShudWxsKTtcblxuICBcdC8vIGFuaW1hdGlvbnMgKHNvIHdlIGNhbiBzdG9wIGFueSBpbiBwcm9ncmVzcyBhdCB0ZWFyZG93bilcbiAgXHRyYWN0aXZlLl9hbmltYXRpb25zID0gW107XG5cbiAgXHQvLyBub2RlcyByZWdpc3RyeVxuICBcdHJhY3RpdmUubm9kZXMgPSB7fTtcblxuICBcdC8vIGxpdmUgcXVlcmllc1xuICBcdHJhY3RpdmUuX2xpdmVRdWVyaWVzID0gW107XG4gIFx0cmFjdGl2ZS5fbGl2ZUNvbXBvbmVudFF1ZXJpZXMgPSBbXTtcblxuICBcdC8vIGJvdW5kIGRhdGEgZnVuY3Rpb25zXG4gIFx0cmFjdGl2ZS5fYm91bmRGdW5jdGlvbnMgPSBbXTtcblxuICBcdC8vIG9ic2VydmVyc1xuICBcdHJhY3RpdmUuX29ic2VydmVycyA9IFtdO1xuXG4gIFx0Ly8gcHJvcGVydGllcyBzcGVjaWZpYyB0byBpbmxpbmUgY29tcG9uZW50c1xuICBcdGlmIChvcHRpb25zLmNvbXBvbmVudCkge1xuICBcdFx0cmFjdGl2ZS5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgXHRcdHJhY3RpdmUuY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXIgfHwgbnVsbDtcbiAgXHRcdHJhY3RpdmUucm9vdCA9IHJhY3RpdmUucGFyZW50LnJvb3Q7XG5cbiAgXHRcdHJhY3RpdmUuY29tcG9uZW50ID0gb3B0aW9ucy5jb21wb25lbnQ7XG4gIFx0XHRvcHRpb25zLmNvbXBvbmVudC5pbnN0YW5jZSA9IHJhY3RpdmU7XG5cbiAgXHRcdC8vIGZvciBoYWNrYWJpbGl0eSwgdGhpcyBjb3VsZCBiZSBhbiBvcGVuIG9wdGlvblxuICBcdFx0Ly8gZm9yIGFueSByYWN0aXZlIGluc3RhbmNlLCBidXQgZm9yIG5vdywganVzdFxuICBcdFx0Ly8gZm9yIGNvbXBvbmVudHMgYW5kIGp1c3QgZm9yIHJhY3RpdmUuLi5cbiAgXHRcdHJhY3RpdmUuX2lubGluZVBhcnRpYWxzID0gb3B0aW9ucy5pbmxpbmVQYXJ0aWFscztcbiAgXHR9IGVsc2Uge1xuICBcdFx0cmFjdGl2ZS5yb290ID0gcmFjdGl2ZTtcbiAgXHRcdHJhY3RpdmUucGFyZW50ID0gcmFjdGl2ZS5jb250YWluZXIgPSBudWxsO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZVJhY3RpdmVEYXRhKCkge1xuICBcdHRocm93IG5ldyBFcnJvcihcIlVzaW5nIGByYWN0aXZlLmRhdGFgIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgLSB5b3UgbXVzdCB1c2UgdGhlIGByYWN0aXZlLmdldCgpYCBBUEkgaW5zdGVhZFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbXBsZXhQYXJhbWV0ZXIoY29tcG9uZW50LCB0ZW1wbGF0ZSwgY2FsbGJhY2spIHtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICBcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gIFx0XHRyb290OiBjb21wb25lbnQucm9vdCxcbiAgXHRcdG93bmVyOiB0aGlzXG4gIFx0fSk7XG5cbiAgXHR0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgdmFyIGluaXRpYWxpc2VfQ29tcGxleFBhcmFtZXRlciA9IENvbXBsZXhQYXJhbWV0ZXI7XG5cbiAgQ29tcGxleFBhcmFtZXRlci5wcm90b3R5cGUgPSB7XG4gIFx0YnViYmxlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuZGlydHkpIHtcbiAgXHRcdFx0dGhpcy5kaXJ0eSA9IHRydWU7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFZpZXcodGhpcyk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5jYWxsYmFjayh0aGlzLmZyYWdtZW50LmdldFZhbHVlKCkpO1xuICBcdFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuICBcdH0sXG5cbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgY3JlYXRlSW5zdGFuY2UgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBDb21wb25lbnQsIGF0dHJpYnV0ZXMsIHlpZWxkVGVtcGxhdGUsIHBhcnRpYWxzKSB7XG4gIFx0dmFyIGluc3RhbmNlLFxuICBcdCAgICBwYXJlbnRGcmFnbWVudCxcbiAgXHQgICAgcmFjdGl2ZSxcbiAgXHQgICAgZnJhZ21lbnQsXG4gIFx0ICAgIGNvbnRhaW5lcixcbiAgXHQgICAgaW5saW5lUGFydGlhbHMgPSB7fSxcbiAgXHQgICAgZGF0YSA9IHt9LFxuICBcdCAgICBtYXBwaW5ncyA9IHt9LFxuICBcdCAgICByZWFkeSxcbiAgXHQgICAgcmVzb2x2ZXJzID0gW107XG5cbiAgXHRwYXJlbnRGcmFnbWVudCA9IGNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcbiAgXHRyYWN0aXZlID0gY29tcG9uZW50LnJvb3Q7XG5cbiAgXHRwYXJ0aWFscyA9IHBhcnRpYWxzIHx8IHt9O1xuICBcdHV0aWxzX29iamVjdF9fZXh0ZW5kKGlubGluZVBhcnRpYWxzLCBwYXJ0aWFscyk7XG5cbiAgXHQvLyBNYWtlIGNvbnRlbnRzIGF2YWlsYWJsZSBhcyBhIHt7PmNvbnRlbnR9fSBwYXJ0aWFsXG4gIFx0cGFydGlhbHMuY29udGVudCA9IHlpZWxkVGVtcGxhdGUgfHwgW107XG5cbiAgXHQvLyBzZXQgYSBkZWZhdWx0IHBhcnRpYWwgZm9yIHlpZWxkcyB3aXRoIG5vIG5hbWVcbiAgXHRpbmxpbmVQYXJ0aWFsc1tcIlwiXSA9IHBhcnRpYWxzLmNvbnRlbnQ7XG5cbiAgXHRpZiAoQ29tcG9uZW50LmRlZmF1bHRzLmVsKSB7XG4gIFx0XHR3YXJuSWZEZWJ1ZyhcIlRoZSA8JXMvPiBjb21wb25lbnQgaGFzIGEgZGVmYXVsdCBgZWxgIHByb3BlcnR5OyBpdCBoYXMgYmVlbiBkaXNyZWdhcmRlZFwiLCBjb21wb25lbnQubmFtZSk7XG4gIFx0fVxuXG4gIFx0Ly8gZmluZCBjb250YWluZXJcbiAgXHRmcmFnbWVudCA9IHBhcmVudEZyYWdtZW50O1xuICBcdHdoaWxlIChmcmFnbWVudCkge1xuICBcdFx0aWYgKGZyYWdtZW50Lm93bmVyLnR5cGUgPT09IFlJRUxERVIpIHtcbiAgXHRcdFx0Y29udGFpbmVyID0gZnJhZ21lbnQub3duZXIuY29udGFpbmVyO1xuICBcdFx0XHRicmVhaztcbiAgXHRcdH1cblxuICBcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQ7XG4gIFx0fVxuXG4gIFx0Ly8gZWFjaCBhdHRyaWJ1dGUgcmVwcmVzZW50cyBlaXRoZXIgYSkgZGF0YSBvciBiKSBhIG1hcHBpbmdcbiAgXHRpZiAoYXR0cmlidXRlcykge1xuICBcdFx0T2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFx0XHRcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2tleV0sXG4gIFx0XHRcdCAgICBwYXJzZWQsXG4gIFx0XHRcdCAgICByZXNvbHZlcjtcblxuICBcdFx0XHRpZiAodHlwZW9mIGF0dHJpYnV0ZSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRcdC8vIGl0J3Mgc3RhdGljIGRhdGFcbiAgXHRcdFx0XHRwYXJzZWQgPSBwYXJzZUpTT04oYXR0cmlidXRlKTtcbiAgXHRcdFx0XHRkYXRhW2tleV0gPSBwYXJzZWQgPyBwYXJzZWQudmFsdWUgOiBhdHRyaWJ1dGU7XG4gIFx0XHRcdH0gZWxzZSBpZiAoYXR0cmlidXRlID09PSAwKSB7XG4gIFx0XHRcdFx0Ly8gaXQgaGFkIG5vICc9Jywgc28gd2UnbGwgY2FsbCBpdCB0cnVlXG4gIFx0XHRcdFx0ZGF0YVtrZXldID0gdHJ1ZTtcbiAgXHRcdFx0fSBlbHNlIGlmIChpc0FycmF5KGF0dHJpYnV0ZSkpIHtcbiAgXHRcdFx0XHQvLyB0aGlzIHJlcHJlc2VudHMgZHluYW1pYyBkYXRhXG4gIFx0XHRcdFx0aWYgKGlzU2luZ2xlSW50ZXJwb2xhdG9yKGF0dHJpYnV0ZSkpIHtcbiAgXHRcdFx0XHRcdG1hcHBpbmdzW2tleV0gPSB7XG4gIFx0XHRcdFx0XHRcdG9yaWdpbjogY29tcG9uZW50LnJvb3Qudmlld21vZGVsLFxuICBcdFx0XHRcdFx0XHRrZXlwYXRoOiB1bmRlZmluZWRcbiAgXHRcdFx0XHRcdH07XG5cbiAgXHRcdFx0XHRcdHJlc29sdmVyID0gY3JlYXRlUmVzb2x2ZXIoY29tcG9uZW50LCBhdHRyaWJ1dGVbMF0sIGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdFx0XHRcdGlmIChrZXlwYXRoLmlzU3BlY2lhbCkge1xuICBcdFx0XHRcdFx0XHRcdGlmIChyZWFkeSkge1xuICBcdFx0XHRcdFx0XHRcdFx0aW5zdGFuY2Uuc2V0KGtleSwga2V5cGF0aC52YWx1ZSk7IC8vIFRPRE8gdXNlIHZpZXdtb2RlbD9cbiAgXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0XHRcdFx0ZGF0YVtrZXldID0ga2V5cGF0aC52YWx1ZTtcblxuICBcdFx0XHRcdFx0XHRcdFx0Ly8gVE9ETyBlcnJyLi4uLiB3b3VsZCBiZSBiZXR0ZXIgaWYgd2UgZGlkbid0IGhhdmUgdG8gZG8gdGhpc1xuICBcdFx0XHRcdFx0XHRcdFx0ZGVsZXRlIG1hcHBpbmdzW2tleV07XG4gIFx0XHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0XHRcdGlmIChyZWFkeSkge1xuICBcdFx0XHRcdFx0XHRcdFx0aW5zdGFuY2Uudmlld21vZGVsLm1hcHBpbmdzW2tleV0ucmVzb2x2ZShrZXlwYXRoKTtcbiAgXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0XHRcdFx0Ly8gcmVzb2x2ZWQgaW1tZWRpYXRlbHlcbiAgXHRcdFx0XHRcdFx0XHRcdG1hcHBpbmdzW2tleV0ua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0XHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0cmVzb2x2ZXIgPSBuZXcgaW5pdGlhbGlzZV9Db21wbGV4UGFyYW1ldGVyKGNvbXBvbmVudCwgYXR0cmlidXRlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdFx0XHRcdFx0aWYgKHJlYWR5KSB7XG4gIFx0XHRcdFx0XHRcdFx0aW5zdGFuY2Uuc2V0KGtleSwgdmFsdWUpOyAvLyBUT0RPIHVzZSB2aWV3bW9kZWw/XG4gIFx0XHRcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRcdFx0ZGF0YVtrZXldID0gdmFsdWU7XG4gIFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdH0pO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdHJlc29sdmVycy5wdXNoKHJlc29sdmVyKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJlcm0gd3V0XCIpO1xuICBcdFx0XHR9XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRpbnN0YW5jZSA9IGNyZWF0ZShDb21wb25lbnQucHJvdG90eXBlKTtcblxuICBcdGluaXRpYWxpc2UoaW5zdGFuY2UsIHtcbiAgXHRcdGVsOiBudWxsLFxuICBcdFx0YXBwZW5kOiB0cnVlLFxuICBcdFx0ZGF0YTogZGF0YSxcbiAgXHRcdHBhcnRpYWxzOiBwYXJ0aWFscyxcbiAgXHRcdG1hZ2ljOiByYWN0aXZlLm1hZ2ljIHx8IENvbXBvbmVudC5kZWZhdWx0cy5tYWdpYyxcbiAgXHRcdG1vZGlmeUFycmF5czogcmFjdGl2ZS5tb2RpZnlBcnJheXMsXG4gIFx0XHQvLyBuZWVkIHRvIGluaGVyaXQgcnVudGltZSBwYXJlbnQgYWRhcHRvcnNcbiAgXHRcdGFkYXB0OiByYWN0aXZlLmFkYXB0XG4gIFx0fSwge1xuICBcdFx0cGFyZW50OiByYWN0aXZlLFxuICBcdFx0Y29tcG9uZW50OiBjb21wb25lbnQsXG4gIFx0XHRjb250YWluZXI6IGNvbnRhaW5lcixcbiAgXHRcdG1hcHBpbmdzOiBtYXBwaW5ncyxcbiAgXHRcdGlubGluZVBhcnRpYWxzOiBpbmxpbmVQYXJ0aWFscyxcbiAgXHRcdGNzc0lkczogcGFyZW50RnJhZ21lbnQuY3NzSWRzXG4gIFx0fSk7XG5cbiAgXHRyZWFkeSA9IHRydWU7XG4gIFx0Y29tcG9uZW50LnJlc29sdmVycyA9IHJlc29sdmVycztcblxuICBcdHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICBmdW5jdGlvbiBjcmVhdGVSZXNvbHZlcihjb21wb25lbnQsIHRlbXBsYXRlLCBjYWxsYmFjaykge1xuICBcdHZhciByZXNvbHZlcjtcblxuICBcdGlmICh0ZW1wbGF0ZS5yKSB7XG4gIFx0XHRyZXNvbHZlciA9IFJlc29sdmVyc19jcmVhdGVSZWZlcmVuY2VSZXNvbHZlcihjb21wb25lbnQsIHRlbXBsYXRlLnIsIGNhbGxiYWNrKTtcbiAgXHR9IGVsc2UgaWYgKHRlbXBsYXRlLngpIHtcbiAgXHRcdHJlc29sdmVyID0gbmV3IFJlc29sdmVyc19FeHByZXNzaW9uUmVzb2x2ZXIoY29tcG9uZW50LCBjb21wb25lbnQucGFyZW50RnJhZ21lbnQsIHRlbXBsYXRlLngsIGNhbGxiYWNrKTtcbiAgXHR9IGVsc2UgaWYgKHRlbXBsYXRlLnJ4KSB7XG4gIFx0XHRyZXNvbHZlciA9IG5ldyBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXJfUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyKGNvbXBvbmVudCwgdGVtcGxhdGUucngsIGNhbGxiYWNrKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcmVzb2x2ZXI7XG4gIH1cblxuICBmdW5jdGlvbiBpc1NpbmdsZUludGVycG9sYXRvcih0ZW1wbGF0ZSkge1xuICBcdHJldHVybiB0ZW1wbGF0ZS5sZW5ndGggPT09IDEgJiYgdGVtcGxhdGVbMF0udCA9PT0gSU5URVJQT0xBVE9SO1xuICB9XG5cbiAgLy8gVE9ETyBob3cgc2hvdWxkIGV2ZW50IGFyZ3VtZW50cyBiZSBoYW5kbGVkPyBlLmcuXG4gIC8vIDx3aWRnZXQgb24tZm9vPSdiYXI6MSwyLDMnLz5cbiAgLy8gVGhlIGV2ZW50ICdiYXInIHdpbGwgYmUgZmlyZWQgb24gdGhlIHBhcmVudCBpbnN0YW5jZVxuICAvLyB3aGVuICdmb28nIGZpcmVzIG9uIHRoZSBjaGlsZCwgYnV0IHRoZSAxLDIsMyBhcmd1bWVudHNcbiAgLy8gd2lsbCBiZSBsb3N0XG5cbiAgdmFyIGluaXRpYWxpc2VfcHJvcGFnYXRlRXZlbnRzID0gcHJvcGFnYXRlRXZlbnRzO1xuXG4gIGZ1bmN0aW9uIHByb3BhZ2F0ZUV2ZW50cyhjb21wb25lbnQsIGV2ZW50c0Rlc2NyaXB0b3IpIHtcbiAgXHR2YXIgZXZlbnROYW1lO1xuXG4gIFx0Zm9yIChldmVudE5hbWUgaW4gZXZlbnRzRGVzY3JpcHRvcikge1xuICBcdFx0aWYgKGV2ZW50c0Rlc2NyaXB0b3IuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICBcdFx0XHRwcm9wYWdhdGVFdmVudChjb21wb25lbnQuaW5zdGFuY2UsIGNvbXBvbmVudC5yb290LCBldmVudE5hbWUsIGV2ZW50c0Rlc2NyaXB0b3JbZXZlbnROYW1lXSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvcGFnYXRlRXZlbnQoY2hpbGRJbnN0YW5jZSwgcGFyZW50SW5zdGFuY2UsIGV2ZW50TmFtZSwgcHJveHlFdmVudE5hbWUpIHtcbiAgXHRpZiAodHlwZW9mIHByb3h5RXZlbnROYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRmYXRhbChcIkNvbXBvbmVudHMgY3VycmVudGx5IG9ubHkgc3VwcG9ydCBzaW1wbGUgZXZlbnRzIC0geW91IGNhbm5vdCBpbmNsdWRlIGFyZ3VtZW50cy4gU29ycnkhXCIpO1xuICBcdH1cblxuICBcdGNoaWxkSW5zdGFuY2Uub24oZXZlbnROYW1lLCBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZXZlbnQsIGFyZ3M7XG5cbiAgXHRcdC8vIHNlbWktd2VhayB0ZXN0LCBidXQgd2hhdCBlbHNlPyB0YWcgdGhlIGV2ZW50IG9iaiAuX2lzRXZlbnQgP1xuICBcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzBdICYmIGFyZ3VtZW50c1swXS5ub2RlKSB7XG4gIFx0XHRcdGV2ZW50ID0gQXJyYXkucHJvdG90eXBlLnNoaWZ0LmNhbGwoYXJndW1lbnRzKTtcbiAgXHRcdH1cblxuICBcdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgXHRcdHNoYXJlZF9maXJlRXZlbnQocGFyZW50SW5zdGFuY2UsIHByb3h5RXZlbnROYW1lLCB7IGV2ZW50OiBldmVudCwgYXJnczogYXJncyB9KTtcblxuICBcdFx0Ly8gY2FuY2VsIGJ1YmJsaW5nXG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fSk7XG4gIH1cblxuICB2YXIgaW5pdGlhbGlzZV91cGRhdGVMaXZlUXVlcmllcyA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgXHR2YXIgYW5jZXN0b3IsIHF1ZXJ5O1xuXG4gIFx0Ly8gSWYgdGhlcmUncyBhIGxpdmUgcXVlcnkgZm9yIHRoaXMgY29tcG9uZW50IHR5cGUsIGFkZCBpdFxuICBcdGFuY2VzdG9yID0gY29tcG9uZW50LnJvb3Q7XG4gIFx0d2hpbGUgKGFuY2VzdG9yKSB7XG4gIFx0XHRpZiAocXVlcnkgPSBhbmNlc3Rvci5fbGl2ZUNvbXBvbmVudFF1ZXJpZXNbXCJfXCIgKyBjb21wb25lbnQubmFtZV0pIHtcbiAgXHRcdFx0cXVlcnkucHVzaChjb21wb25lbnQuaW5zdGFuY2UpO1xuICBcdFx0fVxuXG4gIFx0XHRhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfaW5pdCA9IENvbXBvbmVudCRpbml0O1xuICBmdW5jdGlvbiBDb21wb25lbnQkaW5pdChvcHRpb25zLCBDb21wb25lbnQpIHtcbiAgXHR2YXIgcGFyZW50RnJhZ21lbnQsIHJvb3Q7XG5cbiAgXHRpZiAoIUNvbXBvbmVudCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50IFxcXCJcIiArIHRoaXMubmFtZSArIFwiXFxcIiBub3QgZm91bmRcIik7XG4gIFx0fVxuXG4gIFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcbiAgXHRyb290ID0gcGFyZW50RnJhZ21lbnQucm9vdDtcblxuICBcdHRoaXMucm9vdCA9IHJvb3Q7XG4gIFx0dGhpcy50eXBlID0gQ09NUE9ORU5UO1xuICBcdHRoaXMubmFtZSA9IG9wdGlvbnMudGVtcGxhdGUuZTtcbiAgXHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcbiAgXHR0aGlzLmluZGV4UmVmQmluZGluZ3MgPSB7fTtcbiAgXHR0aGlzLnlpZWxkZXJzID0ge307XG4gIFx0dGhpcy5yZXNvbHZlcnMgPSBbXTtcblxuICBcdGNyZWF0ZUluc3RhbmNlKHRoaXMsIENvbXBvbmVudCwgb3B0aW9ucy50ZW1wbGF0ZS5hLCBvcHRpb25zLnRlbXBsYXRlLmYsIG9wdGlvbnMudGVtcGxhdGUucCk7XG4gIFx0aW5pdGlhbGlzZV9wcm9wYWdhdGVFdmVudHModGhpcywgb3B0aW9ucy50ZW1wbGF0ZS52KTtcblxuICBcdC8vIGludHJvLCBvdXRybyBhbmQgZGVjb3JhdG9yIGRpcmVjdGl2ZXMgaGF2ZSBubyBlZmZlY3RcbiAgXHRpZiAob3B0aW9ucy50ZW1wbGF0ZS50MCB8fCBvcHRpb25zLnRlbXBsYXRlLnQxIHx8IG9wdGlvbnMudGVtcGxhdGUudDIgfHwgb3B0aW9ucy50ZW1wbGF0ZS5vKSB7XG4gIFx0XHR3YXJuSWZEZWJ1ZyhcIlRoZSBcXFwiaW50cm9cXFwiLCBcXFwib3V0cm9cXFwiIGFuZCBcXFwiZGVjb3JhdG9yXFxcIiBkaXJlY3RpdmVzIGhhdmUgbm8gZWZmZWN0IG9uIGNvbXBvbmVudHNcIiwgeyByYWN0aXZlOiB0aGlzLmluc3RhbmNlIH0pO1xuICBcdH1cblxuICBcdGluaXRpYWxpc2VfdXBkYXRlTGl2ZVF1ZXJpZXModGhpcyk7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9yZWJpbmQgPSBDb21wb25lbnQkcmViaW5kO1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCRyZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdHZhciBxdWVyeTtcblxuICBcdHRoaXMucmVzb2x2ZXJzLmZvckVhY2gocmViaW5kKTtcblxuICBcdGZvciAodmFyIGsgaW4gdGhpcy55aWVsZGVycykge1xuICBcdFx0aWYgKHRoaXMueWllbGRlcnNba11bMF0pIHtcbiAgXHRcdFx0cmViaW5kKHRoaXMueWllbGRlcnNba11bMF0pO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChxdWVyeSA9IHRoaXMucm9vdC5fbGl2ZUNvbXBvbmVudFF1ZXJpZXNbXCJfXCIgKyB0aGlzLm5hbWVdKSB7XG4gIFx0XHRxdWVyeS5fbWFrZURpcnR5KCk7XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gcmViaW5kKHgpIHtcbiAgXHRcdHgucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX3JlbmRlciA9IENvbXBvbmVudCRyZW5kZXI7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JHJlbmRlcigpIHtcbiAgXHR2YXIgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlO1xuXG4gIFx0aW5zdGFuY2UucmVuZGVyKHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpKTtcblxuICBcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICBcdHJldHVybiBpbnN0YW5jZS5mcmFnbWVudC5kZXRhY2goKTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX3RvU3RyaW5nID0gQ29tcG9uZW50JHRvU3RyaW5nO1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCR0b1N0cmluZygpIHtcbiAgXHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC50b1N0cmluZygpO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfdW5iaW5kID0gQ29tcG9uZW50JHVuYmluZDtcblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV91bmJpbmRfX3RlYXJkb3duSG9vayA9IG5ldyBob29rc19Ib29rKFwidGVhcmRvd25cIik7XG4gIGZ1bmN0aW9uIENvbXBvbmVudCR1bmJpbmQoKSB7XG4gIFx0dmFyIGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZTtcblxuICBcdHRoaXMucmVzb2x2ZXJzLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5iaW5kKTtcblxuICBcdHJlbW92ZUZyb21MaXZlQ29tcG9uZW50UXVlcmllcyh0aGlzKTtcblxuICBcdGluc3RhbmNlLl9vYnNlcnZlcnMuZm9yRWFjaChjYW5jZWwpO1xuXG4gIFx0Ly8gdGVhcmRvd24gdGhlIGluc3RhbmNlXG4gIFx0aW5zdGFuY2UuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0aW5zdGFuY2Uudmlld21vZGVsLnRlYXJkb3duKCk7XG5cbiAgXHRpZiAoaW5zdGFuY2UuZnJhZ21lbnQucmVuZGVyZWQgJiYgaW5zdGFuY2UuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fKSB7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkoaW5zdGFuY2UuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLCBpbnN0YW5jZSk7XG4gIFx0fVxuXG4gIFx0Q29tcG9uZW50X3Byb3RvdHlwZV91bmJpbmRfX3RlYXJkb3duSG9vay5maXJlKGluc3RhbmNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUZyb21MaXZlQ29tcG9uZW50UXVlcmllcyhjb21wb25lbnQpIHtcbiAgXHR2YXIgaW5zdGFuY2UsIHF1ZXJ5O1xuXG4gIFx0aW5zdGFuY2UgPSBjb21wb25lbnQucm9vdDtcblxuICBcdGRvIHtcbiAgXHRcdGlmIChxdWVyeSA9IGluc3RhbmNlLl9saXZlQ29tcG9uZW50UXVlcmllc1tcIl9cIiArIGNvbXBvbmVudC5uYW1lXSkge1xuICBcdFx0XHRxdWVyeS5fcmVtb3ZlKGNvbXBvbmVudCk7XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoaW5zdGFuY2UgPSBpbnN0YW5jZS5wYXJlbnQpO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfdW5yZW5kZXIgPSBDb21wb25lbnQkdW5yZW5kZXI7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JHVucmVuZGVyKHNob3VsZERlc3Ryb3kpIHtcbiAgXHR0aGlzLnNob3VsZERlc3Ryb3kgPSBzaG91bGREZXN0cm95O1xuICBcdHRoaXMuaW5zdGFuY2UudW5yZW5kZXIoKTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnQgPSBmdW5jdGlvbiAob3B0aW9ucywgQ29uc3RydWN0b3IpIHtcbiAgXHR0aGlzLmluaXQob3B0aW9ucywgQ29uc3RydWN0b3IpO1xuICB9O1xuXG4gIENvbXBvbmVudC5wcm90b3R5cGUgPSB7XG4gIFx0ZGV0YWNoOiBDb21wb25lbnRfcHJvdG90eXBlX2RldGFjaCxcbiAgXHRmaW5kOiBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmQsXG4gIFx0ZmluZEFsbDogQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kQWxsLFxuICBcdGZpbmRBbGxDb21wb25lbnRzOiBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmRBbGxDb21wb25lbnRzLFxuICBcdGZpbmRDb21wb25lbnQ6IENvbXBvbmVudF9wcm90b3R5cGVfZmluZENvbXBvbmVudCxcbiAgXHRmaW5kTmV4dE5vZGU6IENvbXBvbmVudF9wcm90b3R5cGVfZmluZE5leHROb2RlLFxuICBcdGZpcnN0Tm9kZTogQ29tcG9uZW50X3Byb3RvdHlwZV9maXJzdE5vZGUsXG4gIFx0aW5pdDogQ29tcG9uZW50X3Byb3RvdHlwZV9pbml0LFxuICBcdHJlYmluZDogQ29tcG9uZW50X3Byb3RvdHlwZV9yZWJpbmQsXG4gIFx0cmVuZGVyOiBDb21wb25lbnRfcHJvdG90eXBlX3JlbmRlcixcbiAgXHR0b1N0cmluZzogQ29tcG9uZW50X3Byb3RvdHlwZV90b1N0cmluZyxcbiAgXHR1bmJpbmQ6IENvbXBvbmVudF9wcm90b3R5cGVfdW5iaW5kLFxuICBcdHVucmVuZGVyOiBDb21wb25lbnRfcHJvdG90eXBlX3VucmVuZGVyXG4gIH07XG5cbiAgdmFyIF9Db21wb25lbnQgPSBDb21wb25lbnQ7XG5cbiAgdmFyIENvbW1lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHRoaXMudHlwZSA9IENPTU1FTlQ7XG4gIFx0dGhpcy52YWx1ZSA9IG9wdGlvbnMudGVtcGxhdGUuYztcbiAgfTtcblxuICBDb21tZW50LnByb3RvdHlwZSA9IHtcbiAgXHRkZXRhY2g6IHNoYXJlZF9kZXRhY2gsXG5cbiAgXHRmaXJzdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLm5vZGU7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLm5vZGUpIHtcbiAgXHRcdFx0dGhpcy5ub2RlID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0aGlzLnZhbHVlKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXMubm9kZTtcbiAgXHR9LFxuXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBcIjwhLS1cIiArIHRoaXMudmFsdWUgKyBcIi0tPlwiO1xuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdGlmIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHRcdHRoaXMubm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubm9kZSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBpdGVtc19Db21tZW50ID0gQ29tbWVudDtcblxuICB2YXIgWWllbGRlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dmFyIGNvbnRhaW5lciwgY29tcG9uZW50O1xuXG4gIFx0dGhpcy50eXBlID0gWUlFTERFUjtcblxuICBcdHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudC5yb290O1xuICBcdHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50ID0gY29udGFpbmVyLmNvbXBvbmVudDtcblxuICBcdHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICBcdHRoaXMuY29udGFpbmVyRnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBjb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG5cbiAgXHR2YXIgbmFtZSA9IHRoaXMubmFtZSA9IG9wdGlvbnMudGVtcGxhdGUubiB8fCBcIlwiO1xuXG4gIFx0dmFyIHRlbXBsYXRlID0gY29udGFpbmVyLl9pbmxpbmVQYXJ0aWFsc1tuYW1lXTtcblxuICBcdGlmICghdGVtcGxhdGUpIHtcbiAgXHRcdHdhcm5JZkRlYnVnKFwiQ291bGQgbm90IGZpbmQgdGVtcGxhdGUgZm9yIHBhcnRpYWwgXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiLCB7IHJhY3RpdmU6IG9wdGlvbnMucm9vdCB9KTtcbiAgXHRcdHRlbXBsYXRlID0gW107XG4gIFx0fVxuXG4gIFx0dGhpcy5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdG93bmVyOiB0aGlzLFxuICBcdFx0cm9vdDogY29udGFpbmVyLnBhcmVudCxcbiAgXHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgXHRcdHBFbGVtZW50OiB0aGlzLmNvbnRhaW5lckZyYWdtZW50LnBFbGVtZW50XG4gIFx0fSk7XG5cbiAgXHQvLyBldmVuIHRob3VnaCBvbmx5IG9uZSB5aWVsZGVyIGlzIGFsbG93ZWQsIHdlIG5lZWQgdG8gaGF2ZSBhbiBhcnJheSBvZiB0aGVtXG4gIFx0Ly8gYXMgaXQncyBwb3NzaWJsZSB0byBjYXVzZSBhIHlpZWxkZXIgdG8gYmUgY3JlYXRlZCBiZWZvcmUgdGhlIGxhc3Qgb25lXG4gIFx0Ly8gd2FzIGRlc3Ryb3llZCBpbiB0aGUgc2FtZSB0dXJuIG9mIHRoZSBydW5sb29wXG4gIFx0aWYgKCFpc0FycmF5KGNvbXBvbmVudC55aWVsZGVyc1tuYW1lXSkpIHtcbiAgXHRcdGNvbXBvbmVudC55aWVsZGVyc1tuYW1lXSA9IFt0aGlzXTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0Y29tcG9uZW50LnlpZWxkZXJzW25hbWVdLnB1c2godGhpcyk7XG4gIFx0fVxuXG4gIFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmIChjb21wb25lbnQueWllbGRlcnNbbmFtZV0ubGVuZ3RoID4gMSkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBIGNvbXBvbmVudCB0ZW1wbGF0ZSBjYW4gb25seSBoYXZlIG9uZSB7e3lpZWxkXCIgKyAobmFtZSA/IFwiIFwiICsgbmFtZSA6IFwiXCIpICsgXCJ9fSBkZWNsYXJhdGlvbiBhdCBhIHRpbWVcIik7XG4gIFx0XHR9XG4gIFx0fSk7XG4gIH07XG5cbiAgWWllbGRlci5wcm90b3R5cGUgPSB7XG4gIFx0ZGV0YWNoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5kZXRhY2goKTtcbiAgXHR9LFxuXG4gIFx0ZmluZDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kKHNlbGVjdG9yKTtcbiAgXHR9LFxuXG4gIFx0ZmluZEFsbDogZnVuY3Rpb24gKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZEFsbChzZWxlY3RvciwgcXVlcnkpO1xuICBcdH0sXG5cbiAgXHRmaW5kQ29tcG9uZW50OiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRDb21wb25lbnQoc2VsZWN0b3IpO1xuICBcdH0sXG5cbiAgXHRmaW5kQWxsQ29tcG9uZW50czogZnVuY3Rpb24gKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9LFxuXG4gIFx0ZmluZE5leHROb2RlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJGcmFnbWVudC5maW5kTmV4dE5vZGUodGhpcyk7XG4gIFx0fSxcblxuICBcdGZpcnN0Tm9kZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmlyc3ROb2RlKCk7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZ2V0VmFsdWUob3B0aW9ucyk7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQucmVuZGVyKCk7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyKHNob3VsZERlc3Ryb3kpO1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMuY29tcG9uZW50LnlpZWxkZXJzW3RoaXMubmFtZV0sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9LFxuXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBpdGVtc19ZaWVsZGVyID0gWWllbGRlcjtcblxuICB2YXIgRG9jdHlwZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy5kZWNsYXJhdGlvbiA9IG9wdGlvbnMudGVtcGxhdGUuYTtcbiAgfTtcblxuICBEb2N0eXBlLnByb3RvdHlwZSA9IHtcbiAgXHRpbml0OiBub29wLFxuICBcdHJlbmRlcjogbm9vcCxcbiAgXHR1bnJlbmRlcjogbm9vcCxcbiAgXHR0ZWFyZG93bjogbm9vcCxcbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIFwiPCFET0NUWVBFXCIgKyB0aGlzLmRlY2xhcmF0aW9uICsgXCI+XCI7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBpdGVtc19Eb2N0eXBlID0gRG9jdHlwZTtcblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX2luaXQgPSBGcmFnbWVudCRpbml0O1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGluaXQob3B0aW9ucykge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR0aGlzLm93bmVyID0gb3B0aW9ucy5vd25lcjsgLy8gVGhlIGl0ZW0gdGhhdCBvd25zIHRoaXMgZnJhZ21lbnQgLSBhbiBlbGVtZW50LCBzZWN0aW9uLCBwYXJ0aWFsLCBvciBhdHRyaWJ1dGVcbiAgXHR0aGlzLnBhcmVudCA9IHRoaXMub3duZXIucGFyZW50RnJhZ21lbnQ7XG5cbiAgXHQvLyBpbmhlcml0ZWQgcHJvcGVydGllc1xuICBcdHRoaXMucm9vdCA9IG9wdGlvbnMucm9vdDtcbiAgXHR0aGlzLnBFbGVtZW50ID0gb3B0aW9ucy5wRWxlbWVudDtcbiAgXHR0aGlzLmNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQ7XG4gIFx0dGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG4gIFx0dGhpcy5rZXkgPSBvcHRpb25zLmtleTtcbiAgXHR0aGlzLnJlZ2lzdGVyZWRJbmRleFJlZnMgPSBbXTtcblxuICBcdC8vIGVuY2Fwc3VsYXRlZCBzdHlsZXMgc2hvdWxkIGJlIGluaGVyaXRlZCB1bnRpbCB0aGV5IGdldCBhcHBsaWVkIGJ5IGFuIGVsZW1lbnRcbiAgXHR0aGlzLmNzc0lkcyA9IFwiY3NzSWRzXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuY3NzSWRzIDogdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5jc3NJZHMgOiBudWxsO1xuXG4gIFx0dGhpcy5pdGVtcyA9IG9wdGlvbnMudGVtcGxhdGUubWFwKGZ1bmN0aW9uICh0ZW1wbGF0ZSwgaSkge1xuICBcdFx0cmV0dXJuIGNyZWF0ZUl0ZW0oe1xuICBcdFx0XHRwYXJlbnRGcmFnbWVudDogX3RoaXMsXG4gIFx0XHRcdHBFbGVtZW50OiBvcHRpb25zLnBFbGVtZW50LFxuICBcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gIFx0XHRcdGluZGV4OiBpXG4gIFx0XHR9KTtcbiAgXHR9KTtcblxuICBcdHRoaXMudmFsdWUgPSB0aGlzLmFyZ3NMaXN0ID0gbnVsbDtcbiAgXHR0aGlzLmRpcnR5QXJncyA9IHRoaXMuZGlydHlWYWx1ZSA9IHRydWU7XG5cbiAgXHR0aGlzLmJvdW5kID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUl0ZW0ob3B0aW9ucykge1xuICBcdGlmICh0eXBlb2Ygb3B0aW9ucy50ZW1wbGF0ZSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0cmV0dXJuIG5ldyBpdGVtc19UZXh0KG9wdGlvbnMpO1xuICBcdH1cblxuICBcdHN3aXRjaCAob3B0aW9ucy50ZW1wbGF0ZS50KSB7XG4gIFx0XHRjYXNlIFlJRUxERVI6XG4gIFx0XHRcdHJldHVybiBuZXcgaXRlbXNfWWllbGRlcihvcHRpb25zKTtcbiAgXHRcdGNhc2UgSU5URVJQT0xBVE9SOlxuICBcdFx0XHRyZXR1cm4gbmV3IGl0ZW1zX0ludGVycG9sYXRvcihvcHRpb25zKTtcbiAgXHRcdGNhc2UgU0VDVElPTjpcbiAgXHRcdFx0cmV0dXJuIG5ldyBfU2VjdGlvbihvcHRpb25zKTtcbiAgXHRcdGNhc2UgVFJJUExFOlxuICBcdFx0XHRyZXR1cm4gbmV3IF9UcmlwbGUob3B0aW9ucyk7XG4gIFx0XHRjYXNlIEVMRU1FTlQ6XG4gIFx0XHRcdHZhciBjb25zdHJ1Y3RvciA9IHVuZGVmaW5lZDtcbiAgXHRcdFx0aWYgKGNvbnN0cnVjdG9yID0gQ29tcG9uZW50X2dldENvbXBvbmVudChvcHRpb25zLnBhcmVudEZyYWdtZW50LnJvb3QsIG9wdGlvbnMudGVtcGxhdGUuZSkpIHtcbiAgXHRcdFx0XHRyZXR1cm4gbmV3IF9Db21wb25lbnQob3B0aW9ucywgY29uc3RydWN0b3IpO1xuICBcdFx0XHR9XG4gIFx0XHRcdHJldHVybiBuZXcgX0VsZW1lbnQob3B0aW9ucyk7XG4gIFx0XHRjYXNlIFBBUlRJQUw6XG4gIFx0XHRcdHJldHVybiBuZXcgX1BhcnRpYWwob3B0aW9ucyk7XG4gIFx0XHRjYXNlIENPTU1FTlQ6XG4gIFx0XHRcdHJldHVybiBuZXcgaXRlbXNfQ29tbWVudChvcHRpb25zKTtcbiAgXHRcdGNhc2UgRE9DVFlQRTpcbiAgXHRcdFx0cmV0dXJuIG5ldyBpdGVtc19Eb2N0eXBlKG9wdGlvbnMpO1xuXG4gIFx0XHRkZWZhdWx0OlxuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJTb21ldGhpbmcgdmVyeSBzdHJhbmdlIGhhcHBlbmVkLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzLiBUaGFua3MhXCIpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfcmViaW5kID0gRnJhZ21lbnQkcmViaW5kO1xuICBmdW5jdGlvbiBGcmFnbWVudCRyZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuXG4gIFx0Ly8gYXNzaWduIG5ldyBjb250ZXh0IGtleXBhdGggaWYgbmVlZGVkXG4gIFx0aWYgKCF0aGlzLm93bmVyIHx8IHRoaXMub3duZXIuaGFzQ29udGV4dCkge1xuICBcdFx0YXNzaWduTmV3S2V5cGF0aCh0aGlzLCBcImNvbnRleHRcIiwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fVxuXG4gIFx0dGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gIFx0XHRpZiAoaXRlbS5yZWJpbmQpIHtcbiAgXHRcdFx0aXRlbS5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fSk7XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX3JlbmRlciA9IEZyYWdtZW50JHJlbmRlcjtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRyZW5kZXIoKSB7XG4gIFx0dmFyIHJlc3VsdDtcblxuICBcdGlmICh0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMSkge1xuICBcdFx0cmVzdWx0ID0gdGhpcy5pdGVtc1swXS5yZW5kZXIoKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cmVzdWx0ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gIFx0XHR0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgXHRcdFx0cmVzdWx0LmFwcGVuZENoaWxkKGl0ZW0ucmVuZGVyKCkpO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gIFx0cmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfdG9TdHJpbmcgPSBGcmFnbWVudCR0b1N0cmluZztcblxuICBmdW5jdGlvbiBGcmFnbWVudCR0b1N0cmluZyhlc2NhcGUpIHtcbiAgXHRpZiAoIXRoaXMuaXRlbXMpIHtcbiAgXHRcdHJldHVybiBcIlwiO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLml0ZW1zLm1hcChlc2NhcGUgPyB0b0VzY2FwZWRTdHJpbmcgOiBGcmFnbWVudF9wcm90b3R5cGVfdG9TdHJpbmdfX3RvU3RyaW5nKS5qb2luKFwiXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnRfcHJvdG90eXBlX3RvU3RyaW5nX190b1N0cmluZyhpdGVtKSB7XG4gIFx0cmV0dXJuIGl0ZW0udG9TdHJpbmcoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvRXNjYXBlZFN0cmluZyhpdGVtKSB7XG4gIFx0cmV0dXJuIGl0ZW0udG9TdHJpbmcodHJ1ZSk7XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX3VuYmluZCA9IEZyYWdtZW50JHVuYmluZDtcblxuICBmdW5jdGlvbiBGcmFnbWVudCR1bmJpbmQoKSB7XG4gIFx0aWYgKCF0aGlzLmJvdW5kKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0dGhpcy5pdGVtcy5mb3JFYWNoKHVuYmluZEl0ZW0pO1xuICBcdHRoaXMuYm91bmQgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuYmluZEl0ZW0oaXRlbSkge1xuICBcdGlmIChpdGVtLnVuYmluZCkge1xuICBcdFx0aXRlbS51bmJpbmQoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX3VucmVuZGVyID0gRnJhZ21lbnQkdW5yZW5kZXI7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkdW5yZW5kZXIoc2hvdWxkRGVzdHJveSkge1xuICBcdGlmICghdGhpcy5yZW5kZXJlZCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIHVucmVuZGVyIGEgZnJhZ21lbnQgdGhhdCB3YXMgbm90IHJlbmRlcmVkXCIpO1xuICBcdH1cblxuICBcdHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICBcdFx0cmV0dXJuIGkudW5yZW5kZXIoc2hvdWxkRGVzdHJveSk7XG4gIFx0fSk7XG4gIFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIEZyYWdtZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLmluaXQob3B0aW9ucyk7XG4gIH07XG5cbiAgRnJhZ21lbnQucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogcHJvdG90eXBlX2J1YmJsZSxcbiAgXHRkZXRhY2g6IEZyYWdtZW50X3Byb3RvdHlwZV9kZXRhY2gsXG4gIFx0ZmluZDogRnJhZ21lbnRfcHJvdG90eXBlX2ZpbmQsXG4gIFx0ZmluZEFsbDogRnJhZ21lbnRfcHJvdG90eXBlX2ZpbmRBbGwsXG4gIFx0ZmluZEFsbENvbXBvbmVudHM6IEZyYWdtZW50X3Byb3RvdHlwZV9maW5kQWxsQ29tcG9uZW50cyxcbiAgXHRmaW5kQ29tcG9uZW50OiBGcmFnbWVudF9wcm90b3R5cGVfZmluZENvbXBvbmVudCxcbiAgXHRmaW5kTmV4dE5vZGU6IHByb3RvdHlwZV9maW5kTmV4dE5vZGUsXG4gIFx0Zmlyc3ROb2RlOiBwcm90b3R5cGVfZmlyc3ROb2RlLFxuICBcdGdldEFyZ3NMaXN0OiBnZXRBcmdzTGlzdCxcbiAgXHRnZXROb2RlOiBnZXROb2RlLFxuICBcdGdldFZhbHVlOiBwcm90b3R5cGVfZ2V0VmFsdWUsXG4gIFx0aW5pdDogRnJhZ21lbnRfcHJvdG90eXBlX2luaXQsXG4gIFx0cmViaW5kOiBGcmFnbWVudF9wcm90b3R5cGVfcmViaW5kLFxuICBcdHJlZ2lzdGVySW5kZXhSZWY6IGZ1bmN0aW9uIChpZHgpIHtcbiAgXHRcdHZhciBpZHhzID0gdGhpcy5yZWdpc3RlcmVkSW5kZXhSZWZzO1xuICBcdFx0aWYgKGlkeHMuaW5kZXhPZihpZHgpID09PSAtMSkge1xuICBcdFx0XHRpZHhzLnB1c2goaWR4KTtcbiAgXHRcdH1cbiAgXHR9LFxuICBcdHJlbmRlcjogRnJhZ21lbnRfcHJvdG90eXBlX3JlbmRlcixcbiAgXHR0b1N0cmluZzogRnJhZ21lbnRfcHJvdG90eXBlX3RvU3RyaW5nLFxuICBcdHVuYmluZDogRnJhZ21lbnRfcHJvdG90eXBlX3VuYmluZCxcbiAgXHR1bnJlZ2lzdGVySW5kZXhSZWY6IGZ1bmN0aW9uIChpZHgpIHtcbiAgXHRcdHZhciBpZHhzID0gdGhpcy5yZWdpc3RlcmVkSW5kZXhSZWZzO1xuICBcdFx0aWR4cy5zcGxpY2UoaWR4cy5pbmRleE9mKGlkeCksIDEpO1xuICBcdH0sXG4gIFx0dW5yZW5kZXI6IEZyYWdtZW50X3Byb3RvdHlwZV91bnJlbmRlclxuICB9O1xuXG4gIHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50ID0gRnJhZ21lbnQ7XG5cbiAgdmFyIHByb3RvdHlwZV9yZXNldCA9IFJhY3RpdmUkcmVzZXQ7XG4gIHZhciBzaG91bGRSZXJlbmRlciA9IFtcInRlbXBsYXRlXCIsIFwicGFydGlhbHNcIiwgXCJjb21wb25lbnRzXCIsIFwiZGVjb3JhdG9yc1wiLCBcImV2ZW50c1wiXSxcbiAgICAgIHJlc2V0SG9vayA9IG5ldyBob29rc19Ib29rKFwicmVzZXRcIik7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkcmVzZXQoZGF0YSkge1xuICBcdHZhciBwcm9taXNlLCB3cmFwcGVyLCBjaGFuZ2VzLCBpLCByZXJlbmRlcjtcblxuICBcdGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIFx0aWYgKHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcmVzZXQgbWV0aG9kIHRha2VzIGVpdGhlciBubyBhcmd1bWVudHMsIG9yIGFuIG9iamVjdCBjb250YWluaW5nIG5ldyBkYXRhXCIpO1xuICBcdH1cblxuICBcdC8vIElmIHRoZSByb290IG9iamVjdCBpcyB3cmFwcGVkLCB0cnkgYW5kIHVzZSB0aGUgd3JhcHBlcidzIHJlc2V0IHZhbHVlXG4gIFx0aWYgKCh3cmFwcGVyID0gdGhpcy52aWV3bW9kZWwud3JhcHBlZFtcIlwiXSkgJiYgd3JhcHBlci5yZXNldCkge1xuICBcdFx0aWYgKHdyYXBwZXIucmVzZXQoZGF0YSkgPT09IGZhbHNlKSB7XG4gIFx0XHRcdC8vIHJlc2V0IHdhcyByZWplY3RlZCwgd2UgbmVlZCB0byByZXBsYWNlIHRoZSBvYmplY3RcbiAgXHRcdFx0dGhpcy52aWV3bW9kZWwucmVzZXQoZGF0YSk7XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHRoaXMudmlld21vZGVsLnJlc2V0KGRhdGEpO1xuICBcdH1cblxuICBcdC8vIHJlc2V0IGNvbmZpZyBpdGVtcyBhbmQgdHJhY2sgaWYgbmVlZCB0byByZXJlbmRlclxuICBcdGNoYW5nZXMgPSBjb25maWdfY29uZmlnLnJlc2V0KHRoaXMpO1xuXG4gIFx0aSA9IGNoYW5nZXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGlmIChzaG91bGRSZXJlbmRlci5pbmRleE9mKGNoYW5nZXNbaV0pID4gLTEpIHtcbiAgXHRcdFx0cmVyZW5kZXIgPSB0cnVlO1xuICBcdFx0XHRicmVhaztcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAocmVyZW5kZXIpIHtcbiAgXHRcdHZhciBjb21wb25lbnQgPSB1bmRlZmluZWQ7XG5cbiAgXHRcdHRoaXMudmlld21vZGVsLm1hcmsocm9vdEtleXBhdGgpO1xuXG4gIFx0XHQvLyBJcyB0aGlzIGlzIGEgY29tcG9uZW50LCB3ZSBuZWVkIHRvIHNldCB0aGUgYHNob3VsZERlc3Ryb3lgXG4gIFx0XHQvLyBmbGFnLCBvdGhlcndpc2UgaXQgd2lsbCBhc3N1bWUgYnkgZGVmYXVsdCB0aGF0IGEgcGFyZW50IG5vZGVcbiAgXHRcdC8vIHdpbGwgYmUgZGV0YWNoZWQsIGFuZCB0aGVyZWZvcmUgaXQgZG9lc24ndCBuZWVkIHRvIGJvdGhlclxuICBcdFx0Ly8gZGV0YWNoaW5nIGl0cyBvd24gbm9kZXNcbiAgXHRcdGlmIChjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudCkge1xuICBcdFx0XHRjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMudW5yZW5kZXIoKTtcblxuICBcdFx0aWYgKGNvbXBvbmVudCkge1xuICBcdFx0XHRjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IGZhbHNlO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBJZiB0aGUgdGVtcGxhdGUgY2hhbmdlZCwgd2UgbmVlZCB0byBkZXN0cm95IHRoZSBwYXJhbGxlbCBET01cbiAgXHRcdC8vIFRPRE8gaWYgd2UncmUgaGVyZSwgcHJlc3VtYWJseSBpdCBkaWQ/XG4gIFx0XHRpZiAodGhpcy5mcmFnbWVudC50ZW1wbGF0ZSAhPT0gdGhpcy50ZW1wbGF0ZSkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdFx0dGVtcGxhdGU6IHRoaXMudGVtcGxhdGUsXG4gIFx0XHRcdFx0cm9vdDogdGhpcyxcbiAgXHRcdFx0XHRvd25lcjogdGhpc1xuICBcdFx0XHR9KTtcbiAgXHRcdH1cblxuICBcdFx0cHJvbWlzZSA9IHRoaXMucmVuZGVyKHRoaXMuZWwsIHRoaXMuYW5jaG9yKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cHJvbWlzZSA9IGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMsIHRydWUpO1xuICBcdFx0dGhpcy52aWV3bW9kZWwubWFyayhyb290S2V5cGF0aCk7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcbiAgXHR9XG5cbiAgXHRyZXNldEhvb2suZmlyZSh0aGlzLCBkYXRhKTtcblxuICBcdHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgdmFyIHJlc2V0UGFydGlhbCA9IGZ1bmN0aW9uIChuYW1lLCBwYXJ0aWFsKSB7XG4gIFx0dmFyIHByb21pc2UsXG4gIFx0ICAgIGNvbGxlY3Rpb24gPSBbXTtcblxuICBcdGZ1bmN0aW9uIGNvbGxlY3Qoc291cmNlLCBkZXN0LCByYWN0aXZlKSB7XG4gIFx0XHQvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IGFuZCBpdCBoYXMgaXRzIG93biBwYXJ0aWFsLCBiYWlsXG4gIFx0XHRpZiAocmFjdGl2ZSAmJiByYWN0aXZlLnBhcnRpYWxzW25hbWVdKSByZXR1cm47XG5cbiAgXHRcdHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gIFx0XHRcdC8vIHF1ZXVlIHRvIHJlcmVuZGVyIGlmIHRoZSBpdGVtIGlzIGEgcGFydGlhbCBhbmQgdGhlIGN1cnJlbnQgbmFtZSBtYXRjaGVzXG4gIFx0XHRcdGlmIChpdGVtLnR5cGUgPT09IFBBUlRJQUwgJiYgaXRlbS5nZXRQYXJ0aWFsTmFtZSgpID09PSBuYW1lKSB7XG4gIFx0XHRcdFx0ZGVzdC5wdXNoKGl0ZW0pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gaWYgaXQgaGFzIGEgZnJhZ21lbnQsIHByb2Nlc3MgaXRzIGl0ZW1zXG4gIFx0XHRcdGlmIChpdGVtLmZyYWdtZW50KSB7XG4gIFx0XHRcdFx0Y29sbGVjdChpdGVtLmZyYWdtZW50Lml0ZW1zLCBkZXN0LCByYWN0aXZlKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIG9yIGlmIGl0IGhhcyBmcmFnbWVudHNcbiAgXHRcdFx0aWYgKGlzQXJyYXkoaXRlbS5mcmFnbWVudHMpKSB7XG4gIFx0XHRcdFx0Y29sbGVjdChpdGVtLmZyYWdtZW50cywgZGVzdCwgcmFjdGl2ZSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBvciBpZiBpdCBpcyBpdHNlbGYgYSBmcmFnbWVudCwgcHJvY2VzcyBpdHMgaXRlbXNcbiAgXHRcdFx0ZWxzZSBpZiAoaXNBcnJheShpdGVtLml0ZW1zKSkge1xuICBcdFx0XHRcdGNvbGxlY3QoaXRlbS5pdGVtcywgZGVzdCwgcmFjdGl2ZSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBvciBpZiBpdCBpcyBhIGNvbXBvbmVudCwgc3RlcCBpbiBhbmQgcHJvY2VzcyBpdHMgaXRlbXNcbiAgXHRcdFx0ZWxzZSBpZiAoaXRlbS50eXBlID09PSBDT01QT05FTlQgJiYgaXRlbS5pbnN0YW5jZSkge1xuICBcdFx0XHRcdGNvbGxlY3QoaXRlbS5pbnN0YW5jZS5mcmFnbWVudC5pdGVtcywgZGVzdCwgaXRlbS5pbnN0YW5jZSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBpZiB0aGUgaXRlbSBpcyBhbiBlbGVtZW50LCBwcm9jZXNzIGl0cyBhdHRyaWJ1dGVzIHRvb1xuICBcdFx0XHRpZiAoaXRlbS50eXBlID09PSBFTEVNRU5UKSB7XG4gIFx0XHRcdFx0aWYgKGlzQXJyYXkoaXRlbS5hdHRyaWJ1dGVzKSkge1xuICBcdFx0XHRcdFx0Y29sbGVjdChpdGVtLmF0dHJpYnV0ZXMsIGRlc3QsIHJhY3RpdmUpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGlmIChpc0FycmF5KGl0ZW0uY29uZGl0aW9uYWxBdHRyaWJ1dGVzKSkge1xuICBcdFx0XHRcdFx0Y29sbGVjdChpdGVtLmNvbmRpdGlvbmFsQXR0cmlidXRlcywgZGVzdCwgcmFjdGl2ZSk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRjb2xsZWN0KHRoaXMuZnJhZ21lbnQuaXRlbXMsIGNvbGxlY3Rpb24pO1xuICBcdHRoaXMucGFydGlhbHNbbmFtZV0gPSBwYXJ0aWFsO1xuXG4gIFx0cHJvbWlzZSA9IGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMsIHRydWUpO1xuXG4gIFx0Y29sbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gIFx0XHRpdGVtLnZhbHVlID0gdW5kZWZpbmVkO1xuICBcdFx0aXRlbS5zZXRWYWx1ZShuYW1lKTtcbiAgXHR9KTtcblxuICBcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgLy8gVE9ETyBzaG91bGQgcmVzZXRUZW1wbGF0ZSBiZSBhc3luY2hyb25vdXM/IGkuZS4gc2hvdWxkIGl0IGJlIGEgY2FzZVxuICAvLyBvZiBvdXRybywgdXBkYXRlIHRlbXBsYXRlLCBpbnRybz8gSSByZWNrb24gcHJvYmFibHkgbm90LCBzaW5jZSB0aGF0XG4gIC8vIGNvdWxkIGJlIGFjaGlldmVkIHdpdGggdW5yZW5kZXItcmVzZXRUZW1wbGF0ZS1yZW5kZXIuIEFsc28sIGl0IHNob3VsZFxuICAvLyBjb25jZXB0dWFsbHkgYmUgc2ltaWxhciB0byByZXNldFBhcnRpYWwsIHdoaWNoIGNvdWxkbid0IGJlIGFzeW5jXG5cbiAgdmFyIHJlc2V0VGVtcGxhdGUgPSBSYWN0aXZlJHJlc2V0VGVtcGxhdGU7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkcmVzZXRUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICBcdHZhciB0cmFuc2l0aW9uc0VuYWJsZWQsIGNvbXBvbmVudDtcblxuICBcdHRlbXBsYXRlX3RlbXBsYXRlLmluaXQobnVsbCwgdGhpcywgeyB0ZW1wbGF0ZTogdGVtcGxhdGUgfSk7XG5cbiAgXHR0cmFuc2l0aW9uc0VuYWJsZWQgPSB0aGlzLnRyYW5zaXRpb25zRW5hYmxlZDtcbiAgXHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IGZhbHNlO1xuXG4gIFx0Ly8gSXMgdGhpcyBpcyBhIGNvbXBvbmVudCwgd2UgbmVlZCB0byBzZXQgdGhlIGBzaG91bGREZXN0cm95YFxuICBcdC8vIGZsYWcsIG90aGVyd2lzZSBpdCB3aWxsIGFzc3VtZSBieSBkZWZhdWx0IHRoYXQgYSBwYXJlbnQgbm9kZVxuICBcdC8vIHdpbGwgYmUgZGV0YWNoZWQsIGFuZCB0aGVyZWZvcmUgaXQgZG9lc24ndCBuZWVkIHRvIGJvdGhlclxuICBcdC8vIGRldGFjaGluZyBpdHMgb3duIG5vZGVzXG4gIFx0aWYgKGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50KSB7XG4gIFx0XHRjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IHRydWU7XG4gIFx0fVxuXG4gIFx0dGhpcy51bnJlbmRlcigpO1xuXG4gIFx0aWYgKGNvbXBvbmVudCkge1xuICBcdFx0Y29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSBmYWxzZTtcbiAgXHR9XG5cbiAgXHQvLyByZW1vdmUgZXhpc3RpbmcgZnJhZ21lbnQgYW5kIGNyZWF0ZSBuZXcgb25lXG4gIFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0dGVtcGxhdGU6IHRoaXMudGVtcGxhdGUsXG4gIFx0XHRyb290OiB0aGlzLFxuICBcdFx0b3duZXI6IHRoaXNcbiAgXHR9KTtcblxuICBcdHRoaXMucmVuZGVyKHRoaXMuZWwsIHRoaXMuYW5jaG9yKTtcblxuICBcdHRoaXMudHJhbnNpdGlvbnNFbmFibGVkID0gdHJhbnNpdGlvbnNFbmFibGVkO1xuICB9XG5cbiAgdmFyIHJldmVyc2UgPSBtYWtlQXJyYXlNZXRob2QoXCJyZXZlcnNlXCIpO1xuXG4gIHZhciBSYWN0aXZlX3Byb3RvdHlwZV9zZXQgPSBSYWN0aXZlJHNldDtcblxuICBmdW5jdGlvbiBSYWN0aXZlJHNldChrZXlwYXRoLCB2YWx1ZSkge1xuICBcdHZhciBtYXAsIHByb21pc2U7XG5cbiAgXHRwcm9taXNlID0gZ2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcywgdHJ1ZSk7XG5cbiAgXHQvLyBTZXQgbXVsdGlwbGUga2V5cGF0aHMgaW4gb25lIGdvXG4gIFx0aWYgKGlzT2JqZWN0KGtleXBhdGgpKSB7XG4gIFx0XHRtYXAgPSBrZXlwYXRoO1xuXG4gIFx0XHRmb3IgKGtleXBhdGggaW4gbWFwKSB7XG4gIFx0XHRcdGlmIChtYXAuaGFzT3duUHJvcGVydHkoa2V5cGF0aCkpIHtcbiAgXHRcdFx0XHR2YWx1ZSA9IG1hcFtrZXlwYXRoXTtcbiAgXHRcdFx0XHRzZXQodGhpcywga2V5cGF0aCwgdmFsdWUpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gU2V0IGEgc2luZ2xlIGtleXBhdGhcbiAgXHRlbHNlIHtcbiAgXHRcdHNldCh0aGlzLCBrZXlwYXRoLCB2YWx1ZSk7XG4gIFx0fVxuXG4gIFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG5cbiAgXHRyZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldChyYWN0aXZlLCBrZXlwYXRoLCB2YWx1ZSkge1xuICBcdGtleXBhdGggPSBnZXRLZXlwYXRoKG5vcm1hbGlzZShrZXlwYXRoKSk7XG5cbiAgXHRpZiAoa2V5cGF0aC5pc1BhdHRlcm4pIHtcbiAgXHRcdGdldE1hdGNoaW5nS2V5cGF0aHMocmFjdGl2ZSwga2V5cGF0aCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5zZXQoa2V5cGF0aCwgdmFsdWUpO1xuICBcdFx0fSk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJhY3RpdmUudmlld21vZGVsLnNldChrZXlwYXRoLCB2YWx1ZSk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHNoaWZ0ID0gbWFrZUFycmF5TWV0aG9kKFwic2hpZnRcIik7XG5cbiAgdmFyIHByb3RvdHlwZV9zb3J0ID0gbWFrZUFycmF5TWV0aG9kKFwic29ydFwiKTtcblxuICB2YXIgc3BsaWNlID0gbWFrZUFycmF5TWV0aG9kKFwic3BsaWNlXCIpO1xuXG4gIHZhciBzdWJ0cmFjdCA9IFJhY3RpdmUkc3VidHJhY3Q7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkc3VidHJhY3Qoa2V5cGF0aCwgZCkge1xuICBcdHJldHVybiBzaGFyZWRfYWRkKHRoaXMsIGtleXBhdGgsIGQgPT09IHVuZGVmaW5lZCA/IC0xIDogLWQpO1xuICB9XG5cbiAgLy8gVGVhcmRvd24uIFRoaXMgZ29lcyB0aHJvdWdoIHRoZSByb290IGZyYWdtZW50IGFuZCBhbGwgaXRzIGNoaWxkcmVuLCByZW1vdmluZyBvYnNlcnZlcnNcbiAgLy8gYW5kIGdlbmVyYWxseSBjbGVhbmluZyB1cCBhZnRlciBpdHNlbGZcblxuICB2YXIgUmFjdGl2ZV9wcm90b3R5cGVfdGVhcmRvd24gPSBSYWN0aXZlJHRlYXJkb3duO1xuXG4gIHZhciBSYWN0aXZlX3Byb3RvdHlwZV90ZWFyZG93bl9fdGVhcmRvd25Ib29rID0gbmV3IGhvb2tzX0hvb2soXCJ0ZWFyZG93blwiKTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSR0ZWFyZG93bigpIHtcbiAgXHR2YXIgcHJvbWlzZTtcblxuICBcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0dGhpcy52aWV3bW9kZWwudGVhcmRvd24oKTtcblxuICBcdHRoaXMuX29ic2VydmVycy5mb3JFYWNoKGNhbmNlbCk7XG5cbiAgXHRpZiAodGhpcy5mcmFnbWVudC5yZW5kZXJlZCAmJiB0aGlzLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXykge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLCB0aGlzKTtcbiAgXHR9XG5cbiAgXHR0aGlzLnNob3VsZERlc3Ryb3kgPSB0cnVlO1xuICBcdHByb21pc2UgPSB0aGlzLmZyYWdtZW50LnJlbmRlcmVkID8gdGhpcy51bnJlbmRlcigpIDogdXRpbHNfUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgXHRSYWN0aXZlX3Byb3RvdHlwZV90ZWFyZG93bl9fdGVhcmRvd25Ib29rLmZpcmUodGhpcyk7XG5cbiAgXHR0aGlzLl9ib3VuZEZ1bmN0aW9ucy5mb3JFYWNoKGRlbGV0ZUZ1bmN0aW9uQ29weSk7XG5cbiAgXHRyZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUZ1bmN0aW9uQ29weShib3VuZCkge1xuICBcdGRlbGV0ZSBib3VuZC5mbltib3VuZC5wcm9wXTtcbiAgfVxuXG4gIHZhciB0b2dnbGUgPSBSYWN0aXZlJHRvZ2dsZTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSR0b2dnbGUoa2V5cGF0aCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRpZiAodHlwZW9mIGtleXBhdGggIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYmFkQXJndW1lbnRzKTtcbiAgXHR9XG5cbiAgXHR2YXIgY2hhbmdlcyA9IHVuZGVmaW5lZDtcblxuICBcdGlmICgvXFwqLy50ZXN0KGtleXBhdGgpKSB7XG4gIFx0XHRjaGFuZ2VzID0ge307XG5cbiAgXHRcdGdldE1hdGNoaW5nS2V5cGF0aHModGhpcywgZ2V0S2V5cGF0aChub3JtYWxpc2Uoa2V5cGF0aCkpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdGNoYW5nZXNba2V5cGF0aC5zdHJdID0gIV90aGlzLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG4gIFx0XHR9KTtcblxuICBcdFx0cmV0dXJuIHRoaXMuc2V0KGNoYW5nZXMpO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLnNldChrZXlwYXRoLCAhdGhpcy5nZXQoa2V5cGF0aCkpO1xuICB9XG5cbiAgdmFyIHRvSFRNTCA9IFJhY3RpdmUkdG9IVE1MO1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkdG9IVE1MKCkge1xuICBcdHJldHVybiB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKHRydWUpO1xuICB9XG5cbiAgdmFyIFJhY3RpdmVfcHJvdG90eXBlX3VucmVuZGVyID0gUmFjdGl2ZSR1bnJlbmRlcjtcbiAgdmFyIHVucmVuZGVySG9vayA9IG5ldyBob29rc19Ib29rKFwidW5yZW5kZXJcIik7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkdW5yZW5kZXIoKSB7XG4gIFx0dmFyIHByb21pc2UsIHNob3VsZERlc3Ryb3k7XG5cbiAgXHRpZiAoIXRoaXMuZnJhZ21lbnQucmVuZGVyZWQpIHtcbiAgXHRcdHdhcm5JZkRlYnVnKFwicmFjdGl2ZS51bnJlbmRlcigpIHdhcyBjYWxsZWQgb24gYSBSYWN0aXZlIGluc3RhbmNlIHRoYXQgd2FzIG5vdCByZW5kZXJlZFwiKTtcbiAgXHRcdHJldHVybiB1dGlsc19Qcm9taXNlLnJlc29sdmUoKTtcbiAgXHR9XG5cbiAgXHRwcm9taXNlID0gZ2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcywgdHJ1ZSk7XG5cbiAgXHQvLyBJZiB0aGlzIGlzIGEgY29tcG9uZW50LCBhbmQgdGhlIGNvbXBvbmVudCBpc24ndCBtYXJrZWQgZm9yIGRlc3RydWN0aW9uLFxuICBcdC8vIGRvbid0IGRldGFjaCBub2RlcyBmcm9tIHRoZSBET00gdW5uZWNlc3NhcmlseVxuICBcdHNob3VsZERlc3Ryb3kgPSAhdGhpcy5jb21wb25lbnQgfHwgdGhpcy5jb21wb25lbnQuc2hvdWxkRGVzdHJveSB8fCB0aGlzLnNob3VsZERlc3Ryb3k7XG5cbiAgXHQvLyBDYW5jZWwgYW55IGFuaW1hdGlvbnMgaW4gcHJvZ3Jlc3NcbiAgXHR3aGlsZSAodGhpcy5fYW5pbWF0aW9uc1swXSkge1xuICBcdFx0dGhpcy5fYW5pbWF0aW9uc1swXS5zdG9wKCk7IC8vIGl0IHdpbGwgcmVtb3ZlIGl0c2VsZiBmcm9tIHRoZSBpbmRleFxuICBcdH1cblxuICBcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIoc2hvdWxkRGVzdHJveSk7XG5cbiAgXHRyZW1vdmVGcm9tQXJyYXkodGhpcy5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18sIHRoaXMpO1xuXG4gIFx0dW5yZW5kZXJIb29rLmZpcmUodGhpcyk7XG5cbiAgXHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcbiAgXHRyZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHZhciB1bnNoaWZ0ID0gbWFrZUFycmF5TWV0aG9kKFwidW5zaGlmdFwiKTtcblxuICB2YXIgUmFjdGl2ZV9wcm90b3R5cGVfdXBkYXRlID0gUmFjdGl2ZSR1cGRhdGU7XG4gIHZhciB1cGRhdGVIb29rID0gbmV3IGhvb2tzX0hvb2soXCJ1cGRhdGVcIik7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkdXBkYXRlKGtleXBhdGgpIHtcbiAgXHR2YXIgcHJvbWlzZTtcblxuICBcdGtleXBhdGggPSBnZXRLZXlwYXRoKGtleXBhdGgpIHx8IHJvb3RLZXlwYXRoO1xuXG4gIFx0cHJvbWlzZSA9IGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMsIHRydWUpO1xuICBcdHRoaXMudmlld21vZGVsLm1hcmsoa2V5cGF0aCk7XG4gIFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG5cbiAgXHR1cGRhdGVIb29rLmZpcmUodGhpcywga2V5cGF0aCk7XG5cbiAgXHRyZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfdXBkYXRlTW9kZWwgPSBSYWN0aXZlJHVwZGF0ZU1vZGVsO1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkdXBkYXRlTW9kZWwoa2V5cGF0aCwgY2FzY2FkZSkge1xuICBcdHZhciB2YWx1ZXMsIGtleSwgYmluZGluZ3M7XG5cbiAgXHRpZiAodHlwZW9mIGtleXBhdGggPT09IFwic3RyaW5nXCIgJiYgIWNhc2NhZGUpIHtcbiAgXHRcdGJpbmRpbmdzID0gdGhpcy5fdHdvd2F5QmluZGluZ3Nba2V5cGF0aF07XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGJpbmRpbmdzID0gW107XG5cbiAgXHRcdGZvciAoa2V5IGluIHRoaXMuX3R3b3dheUJpbmRpbmdzKSB7XG4gIFx0XHRcdGlmICgha2V5cGF0aCB8fCBnZXRLZXlwYXRoKGtleSkuZXF1YWxzT3JTdGFydHNXaXRoKGtleXBhdGgpKSB7XG4gIFx0XHRcdFx0Ly8gVE9ETyBpcyB0aGlzIHJpZ2h0P1xuICBcdFx0XHRcdGJpbmRpbmdzLnB1c2guYXBwbHkoYmluZGluZ3MsIHRoaXMuX3R3b3dheUJpbmRpbmdzW2tleV0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0dmFsdWVzID0gY29uc29saWRhdGUodGhpcywgYmluZGluZ3MpO1xuICBcdHJldHVybiB0aGlzLnNldCh2YWx1ZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc29saWRhdGUocmFjdGl2ZSwgYmluZGluZ3MpIHtcbiAgXHR2YXIgdmFsdWVzID0ge30sXG4gIFx0ICAgIGNoZWNrYm94R3JvdXBzID0gW107XG5cbiAgXHRiaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gIFx0XHR2YXIgb2xkVmFsdWUsIG5ld1ZhbHVlO1xuXG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSByYWRpbyBuYW1lIGJpbmRpbmdzXG4gIFx0XHRpZiAoYi5yYWRpb05hbWUgJiYgIWIuZWxlbWVudC5ub2RlLmNoZWNrZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBjaGVja2JveCBuYW1lIGJpbmRpbmdzIGNvbWUgaW4gZ3JvdXBzLCBzb1xuICBcdFx0Ly8gd2Ugd2FudCB0byBnZXQgdGhlIHZhbHVlIG9uY2UgYXQgbW9zdFxuICBcdFx0aWYgKGIuY2hlY2tib3hOYW1lKSB7XG4gIFx0XHRcdGlmICghY2hlY2tib3hHcm91cHNbYi5rZXlwYXRoLnN0cl0gJiYgIWIuY2hhbmdlZCgpKSB7XG4gIFx0XHRcdFx0Y2hlY2tib3hHcm91cHMucHVzaChiLmtleXBhdGgpO1xuICBcdFx0XHRcdGNoZWNrYm94R3JvdXBzW2Iua2V5cGF0aC5zdHJdID0gYjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0b2xkVmFsdWUgPSBiLmF0dHJpYnV0ZS52YWx1ZTtcbiAgXHRcdG5ld1ZhbHVlID0gYi5nZXRWYWx1ZSgpO1xuXG4gIFx0XHRpZiAoYXJyYXlDb250ZW50c01hdGNoKG9sZFZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIWlzRXF1YWwob2xkVmFsdWUsIG5ld1ZhbHVlKSkge1xuICBcdFx0XHR2YWx1ZXNbYi5rZXlwYXRoLnN0cl0gPSBuZXdWYWx1ZTtcbiAgXHRcdH1cbiAgXHR9KTtcblxuICBcdC8vIEhhbmRsZSBncm91cHMgb2YgYDxpbnB1dCB0eXBlPSdjaGVja2JveCcgbmFtZT0ne3tmb299fScgLi4uPmBcbiAgXHRpZiAoY2hlY2tib3hHcm91cHMubGVuZ3RoKSB7XG4gIFx0XHRjaGVja2JveEdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdHZhciBiaW5kaW5nLCBvbGRWYWx1ZSwgbmV3VmFsdWU7XG5cbiAgXHRcdFx0YmluZGluZyA9IGNoZWNrYm94R3JvdXBzW2tleXBhdGguc3RyXTsgLy8gb25lIHRvIHJlcHJlc2VudCB0aGUgZW50aXJlIGdyb3VwXG4gIFx0XHRcdG9sZFZhbHVlID0gYmluZGluZy5hdHRyaWJ1dGUudmFsdWU7XG4gIFx0XHRcdG5ld1ZhbHVlID0gYmluZGluZy5nZXRWYWx1ZSgpO1xuXG4gIFx0XHRcdGlmICghYXJyYXlDb250ZW50c01hdGNoKG9sZFZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgXHRcdFx0XHR2YWx1ZXNba2V5cGF0aC5zdHJdID0gbmV3VmFsdWU7XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlID0ge1xuICBcdGFkZDogcHJvdG90eXBlX2FkZCxcbiAgXHRhbmltYXRlOiBwcm90b3R5cGVfYW5pbWF0ZSxcbiAgXHRkZXRhY2g6IHByb3RvdHlwZV9kZXRhY2gsXG4gIFx0ZmluZDogcHJvdG90eXBlX2ZpbmQsXG4gIFx0ZmluZEFsbDogcHJvdG90eXBlX2ZpbmRBbGwsXG4gIFx0ZmluZEFsbENvbXBvbmVudHM6IHByb3RvdHlwZV9maW5kQWxsQ29tcG9uZW50cyxcbiAgXHRmaW5kQ29tcG9uZW50OiBwcm90b3R5cGVfZmluZENvbXBvbmVudCxcbiAgXHRmaW5kQ29udGFpbmVyOiBmaW5kQ29udGFpbmVyLFxuICBcdGZpbmRQYXJlbnQ6IGZpbmRQYXJlbnQsXG4gIFx0ZmlyZTogcHJvdG90eXBlX2ZpcmUsXG4gIFx0Z2V0OiBwcm90b3R5cGVfZ2V0LFxuICBcdGluc2VydDogaW5zZXJ0LFxuICBcdG1lcmdlOiBwcm90b3R5cGVfbWVyZ2UsXG4gIFx0b2JzZXJ2ZTogb2JzZXJ2ZSxcbiAgXHRvYnNlcnZlT25jZTogb2JzZXJ2ZU9uY2UsXG4gIFx0b2ZmOiBvZmYsXG4gIFx0b246IG9uLFxuICBcdG9uY2U6IG9uY2UsXG4gIFx0cG9wOiBwb3AsXG4gIFx0cHVzaDogcHVzaCxcbiAgXHRyZW5kZXI6IHByb3RvdHlwZV9yZW5kZXIsXG4gIFx0cmVzZXQ6IHByb3RvdHlwZV9yZXNldCxcbiAgXHRyZXNldFBhcnRpYWw6IHJlc2V0UGFydGlhbCxcbiAgXHRyZXNldFRlbXBsYXRlOiByZXNldFRlbXBsYXRlLFxuICBcdHJldmVyc2U6IHJldmVyc2UsXG4gIFx0c2V0OiBSYWN0aXZlX3Byb3RvdHlwZV9zZXQsXG4gIFx0c2hpZnQ6IHNoaWZ0LFxuICBcdHNvcnQ6IHByb3RvdHlwZV9zb3J0LFxuICBcdHNwbGljZTogc3BsaWNlLFxuICBcdHN1YnRyYWN0OiBzdWJ0cmFjdCxcbiAgXHR0ZWFyZG93bjogUmFjdGl2ZV9wcm90b3R5cGVfdGVhcmRvd24sXG4gIFx0dG9nZ2xlOiB0b2dnbGUsXG4gIFx0dG9IVE1MOiB0b0hUTUwsXG4gIFx0dG9IdG1sOiB0b0hUTUwsXG4gIFx0dW5yZW5kZXI6IFJhY3RpdmVfcHJvdG90eXBlX3VucmVuZGVyLFxuICBcdHVuc2hpZnQ6IHVuc2hpZnQsXG4gIFx0dXBkYXRlOiBSYWN0aXZlX3Byb3RvdHlwZV91cGRhdGUsXG4gIFx0dXBkYXRlTW9kZWw6IHByb3RvdHlwZV91cGRhdGVNb2RlbFxuICB9O1xuXG4gIHZhciB3cmFwTWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZCwgc3VwZXJNZXRob2QsIGZvcmNlKSB7XG5cbiAgXHRpZiAoZm9yY2UgfHwgbmVlZHNTdXBlcihtZXRob2QsIHN1cGVyTWV0aG9kKSkge1xuXG4gIFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXG4gIFx0XHRcdHZhciBoYXNTdXBlciA9IChcIl9zdXBlclwiIGluIHRoaXMpLFxuICBcdFx0XHQgICAgX3N1cGVyID0gdGhpcy5fc3VwZXIsXG4gIFx0XHRcdCAgICByZXN1bHQ7XG5cbiAgXHRcdFx0dGhpcy5fc3VwZXIgPSBzdXBlck1ldGhvZDtcblxuICBcdFx0XHRyZXN1bHQgPSBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBcdFx0XHRpZiAoaGFzU3VwZXIpIHtcbiAgXHRcdFx0XHR0aGlzLl9zdXBlciA9IF9zdXBlcjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiByZXN1bHQ7XG4gIFx0XHR9O1xuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXR1cm4gbWV0aG9kO1xuICBcdH1cbiAgfTtcblxuICBmdW5jdGlvbiBuZWVkc1N1cGVyKG1ldGhvZCwgc3VwZXJNZXRob2QpIHtcbiAgXHRyZXR1cm4gdHlwZW9mIHN1cGVyTWV0aG9kID09PSBcImZ1bmN0aW9uXCIgJiYgL19zdXBlci8udGVzdChtZXRob2QpO1xuICB9XG5cbiAgdmFyIHVud3JhcEV4dGVuZGVkID0gdW53cmFwO1xuXG4gIGZ1bmN0aW9uIHVud3JhcChDaGlsZCkge1xuICBcdHZhciBvcHRpb25zID0ge307XG5cbiAgXHR3aGlsZSAoQ2hpbGQpIHtcbiAgXHRcdGFkZFJlZ2lzdHJpZXMoQ2hpbGQsIG9wdGlvbnMpO1xuICBcdFx0YWRkT3RoZXJPcHRpb25zKENoaWxkLCBvcHRpb25zKTtcblxuICBcdFx0aWYgKENoaWxkLl9QYXJlbnQgIT09IF9SYWN0aXZlKSB7XG4gIFx0XHRcdENoaWxkID0gQ2hpbGQuX1BhcmVudDtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdENoaWxkID0gZmFsc2U7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG9wdGlvbnM7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRSZWdpc3RyaWVzKENoaWxkLCBvcHRpb25zKSB7XG4gIFx0Y29uZmlnX3JlZ2lzdHJpZXMuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICBcdFx0YWRkUmVnaXN0cnkoci51c2VEZWZhdWx0cyA/IENoaWxkLnByb3RvdHlwZSA6IENoaWxkLCBvcHRpb25zLCByLm5hbWUpO1xuICBcdH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkUmVnaXN0cnkodGFyZ2V0LCBvcHRpb25zLCBuYW1lKSB7XG4gIFx0dmFyIHJlZ2lzdHJ5LFxuICBcdCAgICBrZXlzID0gT2JqZWN0LmtleXModGFyZ2V0W25hbWVdKTtcblxuICBcdGlmICgha2V5cy5sZW5ndGgpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRpZiAoIShyZWdpc3RyeSA9IG9wdGlvbnNbbmFtZV0pKSB7XG4gIFx0XHRyZWdpc3RyeSA9IG9wdGlvbnNbbmFtZV0gPSB7fTtcbiAgXHR9XG5cbiAgXHRrZXlzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gIFx0XHRyZXR1cm4gIShrZXkgaW4gcmVnaXN0cnkpO1xuICBcdH0pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBcdFx0cmV0dXJuIHJlZ2lzdHJ5W2tleV0gPSB0YXJnZXRbbmFtZV1ba2V5XTtcbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZE90aGVyT3B0aW9ucyhDaGlsZCwgb3B0aW9ucykge1xuICBcdE9iamVjdC5rZXlzKENoaWxkLnByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFx0XHRpZiAoa2V5ID09PSBcImNvbXB1dGVkXCIpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgdmFsdWUgPSBDaGlsZC5wcm90b3R5cGVba2V5XTtcblxuICBcdFx0aWYgKCEoa2V5IGluIG9wdGlvbnMpKSB7XG4gIFx0XHRcdG9wdGlvbnNba2V5XSA9IHZhbHVlLl9tZXRob2QgPyB2YWx1ZS5fbWV0aG9kIDogdmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGlzIGl0IGEgd3JhcHBlZCBmdW5jdGlvbj9cbiAgXHRcdGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zW2tleV0gPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJiBvcHRpb25zW2tleV0uX21ldGhvZCkge1xuXG4gIFx0XHRcdHZhciByZXN1bHQgPSB1bmRlZmluZWQsXG4gIFx0XHRcdCAgICBuZWVkc1N1cGVyID0gdmFsdWUuX21ldGhvZDtcblxuICBcdFx0XHRpZiAobmVlZHNTdXBlcikge1xuICBcdFx0XHRcdHZhbHVlID0gdmFsdWUuX21ldGhvZDtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIHJld3JhcCBib3VuZCBkaXJlY3RseSB0byBwYXJlbnQgZm5cbiAgXHRcdFx0cmVzdWx0ID0gd3JhcE1ldGhvZChvcHRpb25zW2tleV0uX21ldGhvZCwgdmFsdWUpO1xuXG4gIFx0XHRcdGlmIChuZWVkc1N1cGVyKSB7XG4gIFx0XHRcdFx0cmVzdWx0Ll9tZXRob2QgPSByZXN1bHQ7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRvcHRpb25zW2tleV0gPSByZXN1bHQ7XG4gIFx0XHR9XG4gIFx0fSk7XG4gIH1cblxuICB2YXIgX2V4dGVuZCA9IF9leHRlbmRfX2V4dGVuZDtcblxuICBmdW5jdGlvbiBfZXh0ZW5kX19leHRlbmQoKSB7XG4gIFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG9wdGlvbnMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgXHRcdG9wdGlvbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIFx0fVxuXG4gIFx0aWYgKCFvcHRpb25zLmxlbmd0aCkge1xuICBcdFx0cmV0dXJuIGV4dGVuZE9uZSh0aGlzKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cmV0dXJuIG9wdGlvbnMucmVkdWNlKGV4dGVuZE9uZSwgdGhpcyk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kT25lKFBhcmVudCkge1xuICBcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICBcdHZhciBDaGlsZCwgcHJvdG87XG5cbiAgXHQvLyBpZiB3ZSdyZSBleHRlbmRpbmcgd2l0aCBhbm90aGVyIFJhY3RpdmUgaW5zdGFuY2UuLi5cbiAgXHQvL1xuICBcdC8vICAgdmFyIEh1bWFuID0gUmFjdGl2ZS5leHRlbmQoLi4uKSwgU3BpZGVyID0gUmFjdGl2ZS5leHRlbmQoLi4uKTtcbiAgXHQvLyAgIHZhciBTcGlkZXJtYW4gPSBIdW1hbi5leHRlbmQoIFNwaWRlciApO1xuICBcdC8vXG4gIFx0Ly8gLi4uaW5oZXJpdCBwcm90b3R5cGUgbWV0aG9kcyBhbmQgZGVmYXVsdCBvcHRpb25zIGFzIHdlbGxcbiAgXHRpZiAob3B0aW9ucy5wcm90b3R5cGUgaW5zdGFuY2VvZiBfUmFjdGl2ZSkge1xuICBcdFx0b3B0aW9ucyA9IHVud3JhcEV4dGVuZGVkKG9wdGlvbnMpO1xuICBcdH1cblxuICBcdENoaWxkID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBDaGlsZCkpIHJldHVybiBuZXcgQ2hpbGQob3B0aW9ucyk7XG4gIFx0XHRpbml0aWFsaXNlKHRoaXMsIG9wdGlvbnMpO1xuICBcdH07XG5cbiAgXHRwcm90byA9IGNyZWF0ZShQYXJlbnQucHJvdG90eXBlKTtcbiAgXHRwcm90by5jb25zdHJ1Y3RvciA9IENoaWxkO1xuXG4gIFx0Ly8gU3RhdGljIHByb3BlcnRpZXNcbiAgXHRkZWZpbmVQcm9wZXJ0aWVzKENoaWxkLCB7XG4gIFx0XHQvLyBhbGlhcyBwcm90b3R5cGUgYXMgZGVmYXVsdHNcbiAgXHRcdGRlZmF1bHRzOiB7IHZhbHVlOiBwcm90byB9LFxuXG4gIFx0XHQvLyBleHRlbmRhYmxlXG4gIFx0XHRleHRlbmQ6IHsgdmFsdWU6IF9leHRlbmRfX2V4dGVuZCwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFxuXG4gIFx0XHQvLyBQYXJlbnQgLSBmb3IgSUU4LCBjYW4ndCB1c2UgT2JqZWN0LmdldFByb3RvdHlwZU9mXG4gIFx0XHRfUGFyZW50OiB7IHZhbHVlOiBQYXJlbnQgfVxuICBcdH0pO1xuXG4gIFx0Ly8gZXh0ZW5kIGNvbmZpZ3VyYXRpb25cbiAgXHRjb25maWdfY29uZmlnLmV4dGVuZChQYXJlbnQsIHByb3RvLCBvcHRpb25zKTtcblxuICBcdGN1c3RvbV9kYXRhLmV4dGVuZChQYXJlbnQsIHByb3RvLCBvcHRpb25zKTtcblxuICBcdGlmIChvcHRpb25zLmNvbXB1dGVkKSB7XG4gIFx0XHRwcm90by5jb21wdXRlZCA9IHV0aWxzX29iamVjdF9fZXh0ZW5kKGNyZWF0ZShQYXJlbnQucHJvdG90eXBlLmNvbXB1dGVkKSwgb3B0aW9ucy5jb21wdXRlZCk7XG4gIFx0fVxuXG4gIFx0Q2hpbGQucHJvdG90eXBlID0gcHJvdG87XG5cbiAgXHRyZXR1cm4gQ2hpbGQ7XG4gIH1cblxuICB2YXIgZ2V0Tm9kZUluZm8gPSBmdW5jdGlvbiAobm9kZSkge1xuICBcdHZhciBpbmZvID0ge30sXG4gIFx0ICAgIHByaXYsXG4gIFx0ICAgIGluZGljZXM7XG5cbiAgXHRpZiAoIW5vZGUgfHwgIShwcml2ID0gbm9kZS5fcmFjdGl2ZSkpIHtcbiAgXHRcdHJldHVybiBpbmZvO1xuICBcdH1cblxuICBcdGluZm8ucmFjdGl2ZSA9IHByaXYucm9vdDtcbiAgXHRpbmZvLmtleXBhdGggPSBwcml2LmtleXBhdGguc3RyO1xuICBcdGluZm8uaW5kZXggPSB7fTtcblxuICBcdC8vIGZpbmQgYWxsIGluZGV4IHJlZmVyZW5jZXMgYW5kIHJlc29sdmUgdGhlbVxuICBcdGlmIChpbmRpY2VzID0gUmVzb2x2ZXJzX2ZpbmRJbmRleFJlZnMocHJpdi5wcm94eS5wYXJlbnRGcmFnbWVudCkpIHtcbiAgXHRcdGluZm8uaW5kZXggPSBSZXNvbHZlcnNfZmluZEluZGV4UmVmcy5yZXNvbHZlKGluZGljZXMpO1xuICBcdH1cblxuICBcdHJldHVybiBpbmZvO1xuICB9O1xuXG4gIHZhciBSYWN0aXZlLCBwcm9wZXJ0aWVzO1xuXG4gIC8vIE1haW4gUmFjdGl2ZSByZXF1aXJlZCBvYmplY3RcbiAgUmFjdGl2ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFJhY3RpdmUpKSByZXR1cm4gbmV3IFJhY3RpdmUob3B0aW9ucyk7XG4gIFx0aW5pdGlhbGlzZSh0aGlzLCBvcHRpb25zKTtcbiAgfTtcblxuICAvLyBSYWN0aXZlIHByb3BlcnRpZXNcbiAgcHJvcGVydGllcyA9IHtcblxuICBcdC8vIGRlYnVnIGZsYWdcbiAgXHRERUJVRzogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHRydWUgfSxcbiAgXHRERUJVR19QUk9NSVNFUzogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHRydWUgfSxcblxuICBcdC8vIHN0YXRpYyBtZXRob2RzOlxuICBcdGV4dGVuZDogeyB2YWx1ZTogX2V4dGVuZCB9LFxuICBcdGdldE5vZGVJbmZvOiB7IHZhbHVlOiBnZXROb2RlSW5mbyB9LFxuICBcdHBhcnNlOiB7IHZhbHVlOiBfcGFyc2UgfSxcblxuICBcdC8vIE5hbWVzcGFjZWQgY29uc3RydWN0b3JzXG4gIFx0UHJvbWlzZTogeyB2YWx1ZTogdXRpbHNfUHJvbWlzZSB9LFxuXG4gIFx0Ly8gc3VwcG9ydFxuICBcdHN2ZzogeyB2YWx1ZTogc3ZnIH0sXG4gIFx0bWFnaWM6IHsgdmFsdWU6IGVudmlyb25tZW50X19tYWdpYyB9LFxuXG4gIFx0Ly8gdmVyc2lvblxuICBcdFZFUlNJT046IHsgdmFsdWU6IFwiMC43LjNcIiB9LFxuXG4gIFx0Ly8gUGx1Z2luc1xuICBcdGFkYXB0b3JzOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfSxcbiAgXHRjb21wb25lbnRzOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfSxcbiAgXHRkZWNvcmF0b3JzOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfSxcbiAgXHRlYXNpbmc6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBzdGF0aWNfZWFzaW5nIH0sXG4gIFx0ZXZlbnRzOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfSxcbiAgXHRpbnRlcnBvbGF0b3JzOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogc3RhdGljX2ludGVycG9sYXRvcnMgfSxcbiAgXHRwYXJ0aWFsczogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG4gIFx0dHJhbnNpdGlvbnM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9XG4gIH07XG5cbiAgLy8gUmFjdGl2ZSBwcm9wZXJ0aWVzXG4gIGRlZmluZVByb3BlcnRpZXMoUmFjdGl2ZSwgcHJvcGVydGllcyk7XG5cbiAgUmFjdGl2ZS5wcm90b3R5cGUgPSB1dGlsc19vYmplY3RfX2V4dGVuZChwcm90b3R5cGUsIGNvbmZpZ19kZWZhdWx0cyk7XG5cbiAgUmFjdGl2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSYWN0aXZlO1xuXG4gIC8vIGFsaWFzIHByb3RvdHlwZSBhcyBkZWZhdWx0c1xuICBSYWN0aXZlLmRlZmF1bHRzID0gUmFjdGl2ZS5wcm90b3R5cGU7XG5cbiAgLy8gUmFjdGl2ZS5qcyBtYWtlcyBsaWJlcmFsIHVzZSBvZiB0aGluZ3MgbGlrZSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi4gSW5cbiAgLy8gb2xkZXIgYnJvd3NlcnMsIHRoZXNlIGFyZSBtYWRlIGF2YWlsYWJsZSB2aWEgYSBzaGltIC0gaGVyZSwgd2UgZG8gYSBxdWlja1xuICAvLyBwcmUtZmxpZ2h0IGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGF0IGVpdGhlciBhKSB3ZSdyZSBub3QgaW4gYSBzaGl0IGJyb3dzZXIsXG4gIC8vIG9yIGIpIHdlJ3JlIHVzaW5nIGEgUmFjdGl2ZS1sZWdhY3kuanMgYnVpbGRcbiAgdmFyIEZVTkNUSU9OID0gXCJmdW5jdGlvblwiO1xuXG4gIGlmICh0eXBlb2YgRGF0ZS5ub3cgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBTdHJpbmcucHJvdG90eXBlLnRyaW0gIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBPYmplY3Qua2V5cyAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIEFycmF5LnByb3RvdHlwZS5pbmRleE9mICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBBcnJheS5wcm90b3R5cGUubWFwICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgQXJyYXkucHJvdG90eXBlLmZpbHRlciAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgIT09IEZVTkNUSU9OKSB7XG4gIFx0dGhyb3cgbmV3IEVycm9yKFwiSXQgbG9va3MgbGlrZSB5b3UncmUgYXR0ZW1wdGluZyB0byB1c2UgUmFjdGl2ZS5qcyBpbiBhbiBvbGRlciBicm93c2VyLiBZb3UnbGwgbmVlZCB0byB1c2Ugb25lIG9mIHRoZSAnbGVnYWN5IGJ1aWxkcycgaW4gb3JkZXIgdG8gY29udGludWUgLSBzZWUgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3QvbGVnYWN5LWJ1aWxkcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIik7XG4gIH1cblxuICB2YXIgX1JhY3RpdmUgPSBSYWN0aXZlO1xuXG4gIHJldHVybiBfUmFjdGl2ZTtcblxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFjdGl2ZS5qcy5tYXBcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVub2RlaWZ5KGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXNcblx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRhcmdzLnB1c2goZnVuY3Rpb24oZXJyLCByZXMpIHtcblx0XHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRcdHJlamVjdChlcnIpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXMpXG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cblx0XHRcdHZhciByZXMgPSBmbi5hcHBseShzZWxmLCBhcmdzKVxuXG5cdFx0XHR2YXIgaXNQcm9taXNlID0gcmVzXG5cdFx0XHRcdCYmICh0eXBlb2YgcmVzID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcmVzID09PSAnZnVuY3Rpb24nKVxuXHRcdFx0XHQmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbidcblxuXHRcdFx0aWYgKGlzUHJvbWlzZSkge1xuXHRcdFx0XHRyZXNvbHZlKHJlcylcblx0XHRcdH1cblx0XHR9KVxuXHR9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIHRhcmdldCA9IHt9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuIiwiZnVuY3Rpb24gdGltZShhY3Rpb24sIHNlY29uZHMpIHtcblx0cmV0dXJuIHsgYWN0aW9uLCBzZWNvbmRzIH1cbn1cbmZ1bmN0aW9uIHdhbGsoc2Vjb25kcykge1xuXHRyZXR1cm4gdGltZSgnd2FsaycsIHNlY29uZHMpXG59XG5mdW5jdGlvbiBqb2coc2Vjb25kcykge1xuXHRyZXR1cm4gdGltZSgnam9nJywgc2Vjb25kcylcbn1cbmZ1bmN0aW9uIHdhcm11cChzZWNvbmRzKSB7XG5cdHJldHVybiB0aW1lKCd3YXJtdXAnLCBzZWNvbmRzKVxufVxuZnVuY3Rpb24gY29vbGRvd24oc2Vjb25kcykge1xuXHRyZXR1cm4gdGltZSgnY29vbGRvd24nLCBzZWNvbmRzKVxufVxuXG5jb25zdCBmaXJzdFdlZWsgPSBbXG5cdHdhcm11cCguMDUgKiA2MCksXG5cdGpvZyg2MCksIHdhbGsoNjApLFxuXHRqb2coNjApLCB3YWxrKDYwKSxcblx0am9nKDYwKSwgd2Fsayg2MCksXG5cdGpvZyg2MCksIHdhbGsoNjApLFxuXHRqb2coNjApLCB3YWxrKDYwKSxcblx0am9nKDYwKSwgd2Fsayg2MCksXG5cdGpvZyg2MCksIHdhbGsoNjApLFxuXHRqb2coNjApLCB3YWxrKDYwKSxcblx0Y29vbGRvd24oNSAqIDYwKVxuXVxuY29uc3Qgc2Vjb25kV2VlayA9IFtcblx0d2FybXVwKDUgKiA2MCksXG5cdGpvZyg5MCksIHdhbGsoMTIwKSxcblx0am9nKDkwKSwgd2FsaygxMjApLFxuXHRqb2coOTApLCB3YWxrKDEyMCksXG5cdGpvZyg5MCksIHdhbGsoMTIwKSxcblx0am9nKDkwKSwgd2FsaygxMjApLFxuXHRqb2coOTApLCB3YWxrKDEyMCksXG5cdGNvb2xkb3duKDQgKiA2MClcbl1cbmNvbnN0IHRoaXJkV2VlayA9IFtcblx0d2FybXVwKDUgKiA2MCksXG5cdGpvZyg5MCksIHdhbGsoMTIwKSxcblx0am9nKDkwKSwgd2FsaygxMjApLFxuXHRqb2coMyAqIDYwKSwgd2FsaygzICogNjApLFxuXHRqb2coMyAqIDYwKSwgd2FsaygzICogNjApLFxuXHRqb2coOTApLCB3YWxrKDEyMCksXG5cdGpvZyg5MCksIHdhbGsoMTIwKSxcblx0am9nKDMgKiA2MCksIHdhbGsoMyAqIDYwKSxcblx0am9nKDMgKiA2MCksIHdhbGsoMyAqIDYwKSxcblx0Y29vbGRvd24oNSAqIDYwKVxuXVxuY29uc3QgZm91cnRoV2VlayA9IFtcblx0d2FybXVwKDUgKiA2MCksXG5cdGpvZyg1ICogNjApLCB3YWxrKDkwKSxcblx0am9nKDUgKiA2MCksIHdhbGsoMTUwKSxcblx0am9nKDMgKiA2MCksIHdhbGsoOTApLFxuXHRqb2coNSAqIDYwKSxcblx0Y29vbGRvd24oMyAqIDYwICsgMzApXG5dXG5jb25zdCBmaWZ0aFdlZWtEYXlPbmUgPSBbXG5cdHdhcm11cCg1ICogNjApLFxuXHRqb2coNSAqIDYwKSwgd2FsaygzICogNjApLFxuXHRqb2coNSAqIDYwKSwgd2FsaygzICogNjApLFxuXHRqb2coNSAqIDYwKSxcblx0Y29vbGRvd24oNCAqIDYwKVxuXVxuY29uc3QgZmlmdGhXZWVrRGF5VHdvID0gW1xuXHR3YXJtdXAoNSAqIDYwKSxcblx0am9nKDggKiA2MCksIHdhbGsoNSAqIDYwKSxcblx0am9nKDggKiA2MCksXG5cdGNvb2xkb3duKDQgKiA2MClcbl1cbmNvbnN0IGZpZnRoV2Vla0RheVRocmVlID0gW1xuXHR3YXJtdXAoNSAqIDYwKSxcblx0am9nKDIwICogNjApLFxuXHRjb29sZG93big1ICogNjApXG5dXG5cbmNvbnN0IHNpeHRoV2Vla0RheU9uZSA9IFtcblx0d2FybXVwKDUgKiA2MCksXG5cdGpvZyg1ICogNjApLCB3YWxrKDMgKiA2MCksXG5cdGpvZyg4ICogNjApLCB3YWxrKDMgKiA2MCksXG5cdGpvZyg1ICogNjApLFxuXHRjb29sZG93big0ICogNjApXG5dXG5jb25zdCBzaXh0aFdlZWtEYXlUd28gPSBbXG5cdHdhcm11cCg1ICogNjApLFxuXHRqb2coMTAgKiA2MCksIHdhbGsoMyAqIDYwKSxcblx0am9nKDEwICogNjApLFxuXHRjb29sZG93big0ICogNjApXG5dXG5jb25zdCBzaXh0aFdlZWtEYXlUaHJlZSA9IFtcblx0d2FybXVwKDUgKiA2MCksXG5cdGpvZygyMiAqIDYwKSxcblx0Y29vbGRvd24oNSAqIDYwKVxuXVxuXG5jb25zdCBzZXZlbnRoV2VlayA9IFtcblx0d2FybXVwKDUgKiA2MCksXG5cdGpvZygyNSlcbl1cblxuY29uc3QgZWlnaHRXZWVrID0gW1xuXHR3YXJtdXAoNSAqIDYwKSxcblx0am9nKDI4KVxuXVxuXG5jb25zdCBuaW50aFdlZWsgPSBbXG5cdHdhcm11cCg1ICogNjApLFxuXHRqb2coMzApXG5dXG5cbm1vZHVsZS5leHBvcnRzID0gW1xuXHRbZmlyc3RXZWVrLCBmaXJzdFdlZWssIGZpcnN0V2Vla10sXG5cdFtzZWNvbmRXZWVrLCBzZWNvbmRXZWVrLCBzZWNvbmRXZWVrXSxcblx0W3RoaXJkV2VlaywgdGhpcmRXZWVrLCB0aGlyZFdlZWtdLFxuXHRbZm91cnRoV2VlaywgZm91cnRoV2VlaywgZm91cnRoV2Vla10sXG5cdFtmaWZ0aFdlZWtEYXlPbmUsIGZpZnRoV2Vla0RheVR3bywgZmlmdGhXZWVrRGF5VGhyZWVdLFxuXHRbc2l4dGhXZWVrRGF5T25lLCBzaXh0aFdlZWtEYXlUd28sIHNpeHRoV2Vla0RheVRocmVlXSxcblx0W3NldmVudGhXZWVrLCBzZXZlbnRoV2Vlaywgc2V2ZW50aFdlZWtdLFxuXHRbZWlnaHRXZWVrLCBlaWdodFdlZWssIGVpZ2h0V2Vla10sXG5cdFtuaW50aFdlZWssIG5pbnRoV2VlaywgbmludGhXZWVrXVxuXVxuIl19
