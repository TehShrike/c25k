(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var weeks = require('./schedule');
var ractiveStateRouter = require('ractive-state-router');
var abstractStateRouter = require('abstract-state-router');
var ractiveStateRenderer = ractiveStateRouter(require('ractive'));
var stateRouter = abstractStateRouter(ractiveStateRenderer, '#app-content');

var colors = {
	walk: 'blue',
	cooldown: 'aqua',
	warmup: 'olive',
	jog: 'orange'
};

stateRouter.addState({
	name: 'day-selection',
	template: '#day-selection',
	route: '/select',
	resolve: function resolve(data, params, cb) {
		cb(null, {
			allPlans: weeks
		});
	},
	activate: function activate(context) {}
});
stateRouter.addState({
	name: 'timer',
	template: {
		template: '#timer',
		computed: {
			currentPlan: function currentPlan() {
				return this.get('plan')[this.get('currentStep')];
			},
			percentage: function percentage() {
				return Math.min(this.get('secondsThisStep') / this.get('currentPlan').seconds * 100, 100);
			},
			color: function color() {
				return colors[this.get('currentPlan').action];
			}
		}
	},
	route: '/timer/:week(\\d+)/:day(\\d+)',
	resolve: function resolve(data, params, cb) {
		cb(null, {
			plan: weeks[params.week][params.day],
			parameters: params,
			currentStep: 0,
			secondsThisStep: 0
		});
	},
	activate: function activate(context) {
		var startOfStep = performance.now();
		var ractive = context.domApi;

		var interval = setInterval(debounceToNextFrame(function () {
			var doneWithThisStep = ractive.get('secondsThisStep') >= ractive.get('currentPlan').seconds;
			if (doneWithThisStep) {
				startOfStep = performance.now();
				ractive.set({
					currentStep: ractive.get('currentStep') + 1,
					secondsThisStep: 0
				});
			} else {
				var newSeconds = (performance.now() - startOfStep) / 1000;
				ractive.set({
					secondsThisStep: newSeconds
				});
			}
		}), 100);
		context.on('destroy', function () {
			return clearInterval(interval);
		});
	}
});

function debounceToNextFrame(fn) {
	var happening = false;
	return function () {
		if (!happening) {
			happening = true;
			window.requestAnimationFrame(function () {
				happening = false;
				fn();
			});
		}
	};
}

stateRouter.evaluateCurrentRoute('day-selection');

},{"./schedule":29,"abstract-state-router":3,"ractive":26,"ractive-state-router":25}],2:[function(require,module,exports){
module.exports = { reverse: false }
},{}],3:[function(require,module,exports){
(function (process){
var StateState = require('./lib/state-state')
var StateComparison = require('./lib/state-comparison')
var CurrentState = require('./lib/current-state')
var stateChangeLogic = require('./lib/state-change-logic')
var parse = require('./lib/state-string-parser')
var StateTransitionManager = require('./lib/state-transition-manager')
var defaultRouterOptions = require('./default-router-options.js')

var series = require('./lib/promise-map-series')
var denodeify = require('then-denodeify')

var EventEmitter = require('events').EventEmitter
var extend = require('xtend')
var newHashBrownRouter = require('hash-brown-router')
var combine = require('combine-arrays')
var buildPath = require('page-path-builder')

require('native-promise-only/npo')

var expectedPropertiesOfAddState = ['name', 'route', 'defaultChild', 'data', 'template', 'resolve', 'activate', 'querystringParameters', 'defaultQuerystringParameters']

module.exports = function StateProvider(makeRenderer, rootElement, stateRouterOptions) {
	var prototypalStateHolder = StateState()
	var lastCompletelyLoadedState = CurrentState()
	var lastStateStartedActivating = CurrentState()
	var stateProviderEmitter = new EventEmitter()
	StateTransitionManager(stateProviderEmitter)
	stateRouterOptions = extend({
		throwOnError: true,
		pathPrefix: '#'
	}, stateRouterOptions)

	if (!stateRouterOptions.router) {
		stateRouterOptions.router = newHashBrownRouter(defaultRouterOptions)
	}

	stateRouterOptions.router.setDefault(function(route, parameters) {
		stateProviderEmitter.emit('routeNotFound', route, parameters)
	})

	var destroyDom = null
	var getDomChild = null
	var renderDom = null
	var resetDom = null

	var activeDomApis = {}
	var activeStateResolveContent = {}
	var activeEmitters = {}

	function handleError(event, err) {
		process.nextTick(function() {
			stateProviderEmitter.emit(event, err)
			console.error(event + ' - ' + err.message)
			if (stateRouterOptions.throwOnError) {
				throw err
			}
		})
	}

	function destroyStateName(stateName) {
		var state = prototypalStateHolder.get(stateName)
		stateProviderEmitter.emit('beforeDestroyState', {
			state: state,
			domApi: activeDomApis[stateName]
		})

		activeEmitters[stateName].emit('destroy')
		activeEmitters[stateName].removeAllListeners()
		delete activeEmitters[stateName]
		delete activeStateResolveContent[stateName]

		return destroyDom(activeDomApis[stateName]).then(function() {
			delete activeDomApis[stateName]
			stateProviderEmitter.emit('afterDestroyState', {
				state: state
			})
		})
	}

	function resetStateName(parameters, stateName) {
		var domApi = activeDomApis[stateName]
		var content = getContentObject(activeStateResolveContent, stateName)
		var state = prototypalStateHolder.get(stateName)

		stateProviderEmitter.emit('beforeResetState', {
			domApi: domApi,
			content: content,
			state: state,
			parameters: parameters
		})

		activeEmitters[stateName].emit('destroy')
		delete activeEmitters[stateName]

		return resetDom({
			domApi: domApi,
			content: content,
			template: state.template,
			parameters: parameters
		}).then(function() {
			stateProviderEmitter.emit('afterResetState', {
				domApi: domApi,
				content: content,
				state: state,
				parameters: parameters
			})
		})
	}

	function getChildElementForStateName(stateName) {
		return new Promise(function(resolve) {
			var parent = prototypalStateHolder.getParent(stateName)
			if (parent) {
				var parentDomApi = activeDomApis[parent.name]
				resolve(getDomChild(parentDomApi))
			} else {
				resolve(rootElement)
			}
		})
	}

	function renderStateName(parameters, stateName) {
		return getChildElementForStateName(stateName).then(function(childElement) {
			var state = prototypalStateHolder.get(stateName)
			var content = getContentObject(activeStateResolveContent, stateName)

			stateProviderEmitter.emit('beforeCreateState', {
				state: state,
				content: content,
				parameters: parameters
			})

			return renderDom({
				element: childElement,
				template: state.template,
				content: content,
				parameters: parameters
			}).then(function(domApi) {
				activeDomApis[stateName] = domApi
				stateProviderEmitter.emit('afterCreateState', {
					state: state,
					domApi: domApi,
					content: content,
					parameters: parameters
				})
				return domApi
			})
		})
	}

	function renderAll(stateNames, parameters) {
		return series(stateNames, renderStateName.bind(null, parameters))
	}

	function onRouteChange(state, parameters) {
		try {
			var finalDestinationStateName = prototypalStateHolder.applyDefaultChildStates(state.name)

			if (finalDestinationStateName === state.name) {
				emitEventAndAttemptStateChange(finalDestinationStateName, parameters)
			} else {
				// There are default child states that need to be applied

				var theRouteWeNeedToEndUpAt = makePath(finalDestinationStateName, parameters)
				var currentRoute = stateRouterOptions.router.location.get()

				if (theRouteWeNeedToEndUpAt === currentRoute) {
					// the child state has the same route as the current one, just start navigating there
					emitEventAndAttemptStateChange(finalDestinationStateName, parameters)
				} else {
					// change the url to match the full default child state route
					stateProviderEmitter.go(finalDestinationStateName, parameters, { replace: true })
				}
			}
		} catch (err) {
			handleError('stateError', err)
		}
	}

	function addState(state) {
		if (typeof state === 'undefined') {
			throw new Error('Expected \'state\' to be passed in.')
		} else if (typeof state.name === 'undefined') {
			throw new Error('Expected the \'name\' option to be passed in.')
		} else if (typeof state.template === 'undefined') {
			throw new Error('Expected the \'template\' option to be passed in.')
		}
		Object.keys(state).filter(function(key) {
			return expectedPropertiesOfAddState.indexOf(key) === -1
		}).forEach(function(key) {
			console.warn('Unexpected property passed to addState:', key)
		})

		prototypalStateHolder.add(state.name, state)

		var route = prototypalStateHolder.buildFullStateRoute(state.name)

		stateRouterOptions.router.add(route, onRouteChange.bind(null, state))
	}

	function getStatesToResolve(stateChanges) {
		return stateChanges.change.concat(stateChanges.create).map(prototypalStateHolder.get)
	}

	function emitEventAndAttemptStateChange(newStateName, parameters) {
		stateProviderEmitter.emit('stateChangeAttempt', function stateGo(transition) {
			attemptStateChange(newStateName, parameters, transition)
		})
	}

	function attemptStateChange(newStateName, parameters, transition) {
		function ifNotCancelled(fn) {
			return function() {
				if (transition.cancelled) {
					var err = new Error('The transition to ' + newStateName + 'was cancelled')
					err.wasCancelledBySomeoneElse = true
					throw err
				} else {
					return fn.apply(null, arguments)
				}
			}
		}

		return promiseMe(prototypalStateHolder.guaranteeAllStatesExist, newStateName)
		.then(function applyDefaultParameters() {
			var state = prototypalStateHolder.get(newStateName)
			var defaultParams = state.defaultQuerystringParameters || {}
			var needToApplyDefaults = Object.keys(defaultParams).some(function missingParameterValue(param) {
				return !parameters[param]
			})

			if (needToApplyDefaults) {
				throw redirector(newStateName, extend(defaultParams, parameters))
			}
			return state
		}).then(ifNotCancelled(function(state) {
			stateProviderEmitter.emit('stateChangeStart', state, parameters)
			lastStateStartedActivating.set(state.name, parameters)
		})).then(function getStateChanges() {
			var stateComparisonResults = StateComparison(prototypalStateHolder)(lastCompletelyLoadedState.get().name, lastCompletelyLoadedState.get().parameters, newStateName, parameters)
			return stateChangeLogic(stateComparisonResults) // { destroy, change, create }
		}).then(ifNotCancelled(function resolveDestroyAndActivateStates(stateChanges) {
			return resolveStates(getStatesToResolve(stateChanges), extend(parameters)).catch(function onResolveError(e) {
				e.stateChangeError = true
				throw e
			}).then(ifNotCancelled(function destroyAndActivate(stateResolveResultsObject) {
				transition.cancellable = false

				function activateAll() {
					var statesToActivate = stateChanges.change.concat(stateChanges.create)

					return activateStates(statesToActivate)
				}

				activeStateResolveContent = extend(activeStateResolveContent, stateResolveResultsObject)

				return series(reverse(stateChanges.destroy), destroyStateName).then(function() {
					return series(reverse(stateChanges.change), resetStateName.bind(null, extend(parameters)))
				}).then(function() {
					return renderAll(stateChanges.create, extend(parameters)).then(activateAll)
				})
			}))

			function activateStates(stateNames) {
				return stateNames.map(prototypalStateHolder.get).forEach(function(state) {
					var emitter = new EventEmitter()
					var context = Object.create(emitter)
					context.domApi = activeDomApis[state.name]
					context.data = state.data
					context.parameters = parameters
					context.content = getContentObject(activeStateResolveContent, state.name)
					activeEmitters[state.name] = emitter

					try {
						state.activate && state.activate(context)
					} catch (e) {
						process.nextTick(function() {
							throw e
						})
					}
				})
			}
		})).then(function stateChangeComplete() {
			lastCompletelyLoadedState.set(newStateName, parameters)
			try {
				stateProviderEmitter.emit('stateChangeEnd', prototypalStateHolder.get(newStateName), parameters)
			} catch (e) {
				handleError('stateError', e)
			}
		}).catch(ifNotCancelled(function handleStateChangeError(err) {
			if (err && err.redirectTo) {
				stateProviderEmitter.emit('stateChangeCancelled', err)
				return stateProviderEmitter.go(err.redirectTo.name, err.redirectTo.params, { replace: true })
			} else if (err) {
				handleError('stateChangeError', err)
			}
		})).catch(function handleCancellation(err) {
			if (err && err.wasCancelledBySomeoneElse) {
				// we don't care, the state transition manager has already emitted the stateChangeCancelled for us
			} else {
				throw new Error("This probably shouldn't happen, maybe file an issue or something " + err)
			}
		})
	}

	function makePath(stateName, parameters, options) {
		if (options && options.inherit) {
			parameters = extend(lastStateStartedActivating.get().parameters, parameters)
		}

		prototypalStateHolder.guaranteeAllStatesExist(stateName)
		var route = prototypalStateHolder.buildFullStateRoute(stateName)
		return buildPath(route, parameters || {})
	}

	var defaultOptions = {
		replace: false
	}

	stateProviderEmitter.addState = addState
	stateProviderEmitter.go = function go(newStateName, parameters, options) {
		options = extend(defaultOptions, options)
		var goFunction = options.replace ? stateRouterOptions.router.replace : stateRouterOptions.router.go

		return promiseMe(makePath, newStateName, parameters, options).then(goFunction, handleError.bind(null, 'stateChangeError'))
	}
	stateProviderEmitter.evaluateCurrentRoute = function evaluateCurrentRoute(defaultState, defaultParams) {
		return promiseMe(makePath, defaultState, defaultParams).then(function(defaultPath) {
			stateRouterOptions.router.evaluateCurrent(defaultPath)
		}).catch(function(err) {
			handleError('stateError', err)
		})
	}
	stateProviderEmitter.makePath = function makePathAndPrependHash(stateName, parameters, options) {
		return stateRouterOptions.pathPrefix + makePath(stateName, parameters, options)
	}
	stateProviderEmitter.stateIsActive = function stateIsActive(stateName, opts) {
		var currentState = lastCompletelyLoadedState.get()
		return (currentState.name === stateName || currentState.name.indexOf(stateName + '.') === 0) && (typeof opts === 'undefined' || Object.keys(opts).every(function matches(key) {
			return opts[key] === currentState.parameters[key]
		}))
	}

	var renderer = makeRenderer(stateProviderEmitter)

	destroyDom = denodeify(renderer.destroy)
	getDomChild = denodeify(renderer.getChildElement)
	renderDom = denodeify(renderer.render)
	resetDom = denodeify(renderer.reset)

	return stateProviderEmitter
}

function getContentObject(stateResolveResultsObject, stateName) {
	var allPossibleResolvedStateNames = parse(stateName)

	return allPossibleResolvedStateNames.filter(function(stateName) {
		return stateResolveResultsObject[stateName]
	}).reduce(function(obj, stateName) {
		return extend(obj, stateResolveResultsObject[stateName])
	}, {})
}

function redirector(newStateName, parameters) {
	return {
		redirectTo: {
			name: newStateName,
			params: parameters
		}
	}
}

// { [stateName]: resolveResult }
function resolveStates(states, parameters) {
	var statesWithResolveFunctions = states.filter(isFunction('resolve'))
	var stateNamesWithResolveFunctions = statesWithResolveFunctions.map(property('name'))
	var resolves = Promise.all(statesWithResolveFunctions.map(function(state) {
		return new Promise(function (resolve, reject) {
			function resolveCb(err, content) {
				err ? reject(err) : resolve(content)
			}

			resolveCb.redirect = function redirect(newStateName, parameters) {
				reject(redirector(newStateName, parameters))
			}

			var res = state.resolve(state.data, parameters, resolveCb)
			if (res && (typeof res === 'object' || typeof res === 'function') && typeof res.then === 'function') {
				resolve(res)
			}
		})
	}))

	return resolves.then(function(resolveResults) {
		return combine({
			stateName: stateNamesWithResolveFunctions,
			resolveResult: resolveResults
		}).reduce(function(obj, result) {
			obj[result.stateName] = result.resolveResult
			return obj
		}, {})
	})
}

function property(name) {
	return function(obj) {
		return obj[name]
	}
}

function reverse(ary) {
	return ary.slice().reverse()
}

function isFunction(property) {
	return function(obj) {
		return typeof obj[property] === 'function'
	}
}

function promiseMe() {
	var fn = Array.prototype.shift.apply(arguments)
	var args = arguments
	return new Promise(function(resolve) {
		resolve(fn.apply(null, args))
	})
}

}).call(this,require('_process'))

},{"./default-router-options.js":2,"./lib/current-state":4,"./lib/promise-map-series":5,"./lib/state-change-logic":6,"./lib/state-comparison":7,"./lib/state-state":8,"./lib/state-string-parser":9,"./lib/state-transition-manager":10,"_process":21,"combine-arrays":12,"events":13,"hash-brown-router":15,"native-promise-only/npo":16,"page-path-builder":17,"then-denodeify":27,"xtend":28}],4:[function(require,module,exports){
module.exports = function CurrentState() {
	var current = {
		name: '',
		parameters: {}
	}

	return {
		get: function() {
			return current
		},
		set: function(name, parameters) {
			current = {
				name: name,
				parameters: parameters
			}
		}
	}
}

},{}],5:[function(require,module,exports){
// Pulled from https://github.com/joliss/promise-map-series and prettied up a bit

var Promise = require('native-promise-only/npo')

module.exports = function sequence(array, iterator, thisArg) {
	var current = Promise.resolve()
	var cb = arguments.length > 2 ? iterator.bind(thisArg) : iterator

	var results = array.map(function(value, i) {
		return current = current.then(function(j) {
			return cb(value, j, array)
		}.bind(null, i))
	})

	return Promise.all(results)
}

},{"native-promise-only/npo":16}],6:[function(require,module,exports){
module.exports = function stateChangeLogic(stateComparisonResults) {
	var hitChangingState = false
	var hitDestroyedState = false

	var output = {
		destroy: [],
		change: [],
		create: []
	}

	stateComparisonResults.forEach(function(state) {
		hitChangingState = hitChangingState || state.stateParametersChanged
		hitDestroyedState = hitDestroyedState || state.stateNameChanged

		if (state.nameBefore) {
			if (hitDestroyedState) {
				output.destroy.push(state.nameBefore)
			} else if (hitChangingState) {
				output.change.push(state.nameBefore)
			}
		}

		if (state.nameAfter && hitDestroyedState) {
			output.create.push(state.nameAfter)
		}
	})

	return output
}

},{}],7:[function(require,module,exports){
var stateStringParser = require('./state-string-parser')
var combine = require('combine-arrays')
var pathToRegexp = require('path-to-regexp-with-reversible-keys')

module.exports = function StateComparison(stateState) {
	var getPathParameters = pathParameters()

	var parametersChanged = parametersThatMatterWereChanged.bind(null, stateState, getPathParameters)

	return stateComparison.bind(null, parametersChanged)
}

function pathParameters() {
	var parameters = {}

	return function getPathParameters(path) {
		if (!path) {
			return []
		}

		if (!parameters[path]) {
			parameters[path] = pathToRegexp(path).keys.map(function(key) {
				return key.name
			})
		}

		return parameters[path]
	}
}

function parametersThatMatterWereChanged(stateState, getPathParameters, stateName, fromParameters, toParameters) {
	var state = stateState.get(stateName)
	var querystringParameters = state.querystringParameters || []
	var parameters = getPathParameters(state.route).concat(querystringParameters)

	return Array.isArray(parameters) && parameters.some(function(key) {
		return fromParameters[key] !== toParameters[key]
	})
}

function stateComparison(parametersChanged, originalState, originalParameters, newState, newParameters) {
	var states = combine({
		start: stateStringParser(originalState),
		end: stateStringParser(newState)
	})

	return states.map(function(states) {
		return {
			nameBefore: states.start,
			nameAfter: states.end,
			stateNameChanged: states.start !== states.end,
			stateParametersChanged: states.start === states.end && parametersChanged(states.start, originalParameters, newParameters)
		}
	})
}

},{"./state-string-parser":9,"combine-arrays":12,"path-to-regexp-with-reversible-keys":19}],8:[function(require,module,exports){
var stateStringParser = require('./state-string-parser')
var parse = require('./state-string-parser')

module.exports = function StateState() {
	var states = {}

	function getHierarchy(name) {
		var names = stateStringParser(name)

		return names.map(function(name) {
			if (!states[name]) {
				throw new Error('State ' + name + ' not found')
			}
			return states[name]
		})
	}

	function getParent(name) {
		var parentName = getParentName(name)

		return parentName && states[parentName]
	}

	function getParentName(name) {
		var names = stateStringParser(name)

		if (names.length > 1) {
			var secondToLast = names.length - 2

			return names[secondToLast]
		} else {
			return null
		}
	}

	function guaranteeAllStatesExist(newStateName) {
		var stateNames = parse(newStateName)
		var statesThatDontExist = stateNames.filter(function(name) {
			return !states[name]
		})

		if (statesThatDontExist.length > 0) {
			throw new Error('State ' + statesThatDontExist[statesThatDontExist.length - 1] + ' does not exist')
		}
	}

	function buildFullStateRoute(stateName) {
		return getHierarchy(stateName).map(function(state) {
			return '/' + (state.route || '')
		}).join('').replace(/\/{2,}/g, '/')
	}

	function applyDefaultChildStates(stateName) {
		var state = states[stateName]

		function getDefaultChildStateName() {
			return state && (typeof state.defaultChild === 'function'
				? state.defaultChild()
				: state.defaultChild)
		}

		var defaultChildStateName = getDefaultChildStateName()

		if (!defaultChildStateName) {
			return stateName
		}

		var fullStateName = stateName + '.' + defaultChildStateName

		return applyDefaultChildStates(fullStateName)
	}


	return {
		add: function(name, state) {
			states[name] = state
		},
		get: function(name) {
			return name && states[name]
		},
		getHierarchy: getHierarchy,
		getParent: getParent,
		getParentName: getParentName,
		guaranteeAllStatesExist: guaranteeAllStatesExist,
		buildFullStateRoute: buildFullStateRoute,
		applyDefaultChildStates: applyDefaultChildStates
	}
}

},{"./state-string-parser":9}],9:[function(require,module,exports){
module.exports = function(stateString) {
	return stateString.split('.').reduce(function(stateNames, latestNameChunk) {
		if (stateNames.length) {
			latestNameChunk = stateNames[stateNames.length - 1] + '.' + latestNameChunk
		}
		stateNames.push(latestNameChunk)
		return stateNames
	}, [])
}

},{}],10:[function(require,module,exports){
module.exports = function (emitter) {
	var currentTransitionAttempt = null
	var nextTransition = null

	function doneTransitioning() {
		currentTransitionAttempt = null
		if (nextTransition) {
			beginNextTransitionAttempt()
		}
	}

	function isTransitioning() {
		return !!currentTransitionAttempt
	}

	function beginNextTransitionAttempt() {
		currentTransitionAttempt = nextTransition
		nextTransition = null
		currentTransitionAttempt.beginStateChange()
	}

	function cancelCurrentTransition() {
		currentTransitionAttempt.transition.cancelled = true
		var err = new Error('State transition cancelled by the state transition manager')
		err.wasCancelledBySomeoneElse = true
		emitter.emit('stateChangeCancelled', err)
	}

	emitter.on('stateChangeAttempt', function(beginStateChange) {
		nextTransition = createStateTransitionAttempt(beginStateChange)

		if (isTransitioning() && currentTransitionAttempt.transition.cancellable) {
			cancelCurrentTransition()
		} else if (!isTransitioning()) {
			beginNextTransitionAttempt()
		}
	})

	emitter.on('stateChangeError', doneTransitioning)
	emitter.on('stateChangeCancelled', doneTransitioning)
	emitter.on('stateChangeEnd', doneTransitioning)

	function createStateTransitionAttempt(beginStateChange) {
		var transition = {
			cancelled: false,
			cancellable: true
		}
		return {
			transition: transition,
			beginStateChange: beginStateChange.bind(null, transition)
		}
	}
}

},{}],11:[function(require,module,exports){
// Array.prototype.find - MIT License (c) 2013 Paul Miller <http://paulmillr.com>
// For all details and docs: https://github.com/paulmillr/array.prototype.find
// Fixes and tests supplied by Duncan Hall <http://duncanhall.net> 
(function(globals){
  if (Array.prototype.find) return;

  var find = function(predicate) {
    var list = Object(this);
    var length = list.length < 0 ? 0 : list.length >>> 0; // ES.ToUint32;
    if (length === 0) return undefined;
    if (typeof predicate !== 'function' || Object.prototype.toString.call(predicate) !== '[object Function]') {
      throw new TypeError('Array#find: predicate must be a function');
    }
    var thisArg = arguments[1];
    for (var i = 0, value; i < length; i++) {
      value = list[i];
      if (predicate.call(thisArg, value, i, list)) return value;
    }
    return undefined;
  };

  if (Object.defineProperty) {
    try {
      Object.defineProperty(Array.prototype, 'find', {
        value: find, configurable: true, enumerable: false, writable: true
      });
    } catch(e) {}
  }

  if (!Array.prototype.find) {
    Array.prototype.find = find;
  }
})(this);

},{}],12:[function(require,module,exports){
module.exports = function(obj) {
	var keys = Object.keys(obj)

	keys.forEach(function(key) {
		if (!Array.isArray(obj[key])) {
			throw new Error(key + ' is not an array')
		}
	})

	var maxIndex = keys.reduce(function(maxSoFar, key) {
		var len = obj[key].length
		return maxSoFar > len ? maxSoFar : len
	}, 0)

	var output = []

	function getObject(index) {
		var o = {}
		keys.forEach(function(key) {
			o[key] = obj[key][index]
		})
		return o
	}

	for (var i = 0; i < maxIndex; ++i) {
		output.push(getObject(i))
	}

	return output
}

},{}],13:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],14:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter

module.exports = function HashLocation(window) {
	var emitter = new EventEmitter()
	var last = ''
	var needToDecode = getNeedToDecode()

	window.addEventListener('hashchange', function() {
		if (last !== emitter.get()) {
			last = emitter.get()
			emitter.emit('hashchange')
		}
	})

	emitter.go = go.bind(null, window)
	emitter.replace = replace.bind(null, window)
	emitter.get = get.bind(null, window, needToDecode)

	return emitter
}

function replace(window, newPath) {
	window.location.replace(everythingBeforeTheSlash(window.location.href) + '#' + newPath)
}

function everythingBeforeTheSlash(url) {
	var hashIndex = url.indexOf('#')
	return hashIndex === -1 ? url : url.substring(0, hashIndex)
}

function go(window, newPath) {
	window.location.hash = newPath
}

function get(window, needToDecode) {
	var hash = removeHashFromPath(window.location.hash)
	return needToDecode ? decodeURI(hash) : hash
}

function removeHashFromPath(path) {
	return (path && path[0] === '#') ? path.substr(1) : path
}

function getNeedToDecode() {
	var a = document.createElement('a')
	a.href = '#x x'
	return !/x x/.test(a.hash)
}

},{"events":13}],15:[function(require,module,exports){
var pathToRegexp = require('path-to-regexp-with-reversible-keys')
var qs = require('querystring')
var xtend = require('xtend')
var browserHashLocation = require('./hash-location.js')
require('array.prototype.find')

module.exports = function Router(opts, hashLocation) {
	if (isHashLocation(opts)) {
		hashLocation = opts
		opts = null
	}

	opts = opts || {}

	if (!hashLocation) {
		hashLocation = browserHashLocation(window)
	}

	var routes = []

	var onHashChange = evaluateCurrentPath.bind(null, routes, hashLocation, !!opts.reverse)

	hashLocation.on('hashchange', onHashChange)

	function stop() {
		hashLocation.removeListener('hashchange', onHashChange)
	}

	return {
		add: add.bind(null, routes),
		stop: stop,
		evaluateCurrent: evaluateCurrentPathOrGoToDefault.bind(null, routes, hashLocation, !!opts.reverse),
		setDefault: setDefault.bind(null, routes),
		replace: hashLocation.replace,
		go: hashLocation.go,
		location: hashLocation
	}
}

function evaluateCurrentPath(routes, hashLocation, reverse) {
	evaluatePath(routes, hashLocation.get(), reverse)
}

function getPathParts(path) {
	var chunks = path.split('?')
	return {
		path: chunks.shift(),
		queryString: qs.parse(chunks.join(''))
	}
}

function evaluatePath(routes, path, reverse) {
	var pathParts = getPathParts(path)
	path = pathParts.path
	var queryStringParameters = pathParts.queryString

	var matchingRoute = (reverse ? reverseArray(routes) : routes).find("".match, path)

	if (matchingRoute) {
		var regexResult = matchingRoute.exec(path)
		var routeParameters = makeParametersObjectFromRegexResult(matchingRoute.keys, regexResult)
		var params = xtend(queryStringParameters, routeParameters)
		matchingRoute.fn(params)
	} else if (routes.defaultFn) {
		routes.defaultFn(path, queryStringParameters)
	}
}

function reverseArray(ary) {
	return ary.slice().reverse()
}

function makeParametersObjectFromRegexResult(keys, regexResult) {
	return keys.reduce(function(memo, urlKey, index) {
		memo[urlKey.name] = regexResult[index + 1]
		return memo
	}, {})
}

function add(routes, routeString, routeFunction) {
	if (typeof routeFunction !== 'function') {
		throw new Error('The router add function must be passed a callback function')
	}
	var newRoute = pathToRegexp(routeString)
	newRoute.fn = routeFunction
	routes.push(newRoute)
}

function evaluateCurrentPathOrGoToDefault(routes, hashLocation, reverse, defaultPath) {
	if (hashLocation.get()) {
		var routesCopy = routes.slice()
		routesCopy.defaultFn = function() {
			hashLocation.go(defaultPath)
		}
		evaluateCurrentPath(routesCopy, hashLocation, reverse)
	} else {
		hashLocation.go(defaultPath)
	}
}

function setDefault(routes, defaultFn) {
	routes.defaultFn = defaultFn
}

function isHashLocation(hashLocation) {
	return hashLocation && hashLocation.go && hashLocation.replace && hashLocation.on
}
},{"./hash-location.js":14,"array.prototype.find":11,"path-to-regexp-with-reversible-keys":19,"querystring":24,"xtend":28}],16:[function(require,module,exports){
(function (global){
/*! Native Promise Only
    v0.8.1 (c) Kyle Simpson
    MIT License: http://getify.mit-license.org
*/
!function(t,n,e){n[t]=n[t]||e(),"undefined"!=typeof module&&module.exports?module.exports=n[t]:"function"==typeof define&&define.amd&&define(function(){return n[t]})}("Promise","undefined"!=typeof global?global:this,function(){"use strict";function t(t,n){l.add(t,n),h||(h=y(l.drain))}function n(t){var n,e=typeof t;return null==t||"object"!=e&&"function"!=e||(n=t.then),"function"==typeof n?n:!1}function e(){for(var t=0;t<this.chain.length;t++)o(this,1===this.state?this.chain[t].success:this.chain[t].failure,this.chain[t]);this.chain.length=0}function o(t,e,o){var r,i;try{e===!1?o.reject(t.msg):(r=e===!0?t.msg:e.call(void 0,t.msg),r===o.promise?o.reject(TypeError("Promise-chain cycle")):(i=n(r))?i.call(r,o.resolve,o.reject):o.resolve(r))}catch(c){o.reject(c)}}function r(o){var c,u=this;if(!u.triggered){u.triggered=!0,u.def&&(u=u.def);try{(c=n(o))?t(function(){var t=new f(u);try{c.call(o,function(){r.apply(t,arguments)},function(){i.apply(t,arguments)})}catch(n){i.call(t,n)}}):(u.msg=o,u.state=1,u.chain.length>0&&t(e,u))}catch(a){i.call(new f(u),a)}}}function i(n){var o=this;o.triggered||(o.triggered=!0,o.def&&(o=o.def),o.msg=n,o.state=2,o.chain.length>0&&t(e,o))}function c(t,n,e,o){for(var r=0;r<n.length;r++)!function(r){t.resolve(n[r]).then(function(t){e(r,t)},o)}(r)}function f(t){this.def=t,this.triggered=!1}function u(t){this.promise=t,this.state=0,this.triggered=!1,this.chain=[],this.msg=void 0}function a(n){if("function"!=typeof n)throw TypeError("Not a function");if(0!==this.__NPO__)throw TypeError("Not a promise");this.__NPO__=1;var o=new u(this);this.then=function(n,r){var i={success:"function"==typeof n?n:!0,failure:"function"==typeof r?r:!1};return i.promise=new this.constructor(function(t,n){if("function"!=typeof t||"function"!=typeof n)throw TypeError("Not a function");i.resolve=t,i.reject=n}),o.chain.push(i),0!==o.state&&t(e,o),i.promise},this["catch"]=function(t){return this.then(void 0,t)};try{n.call(void 0,function(t){r.call(o,t)},function(t){i.call(o,t)})}catch(c){i.call(o,c)}}var s,h,l,p=Object.prototype.toString,y="undefined"!=typeof setImmediate?function(t){return setImmediate(t)}:setTimeout;try{Object.defineProperty({},"x",{}),s=function(t,n,e,o){return Object.defineProperty(t,n,{value:e,writable:!0,configurable:o!==!1})}}catch(d){s=function(t,n,e){return t[n]=e,t}}l=function(){function t(t,n){this.fn=t,this.self=n,this.next=void 0}var n,e,o;return{add:function(r,i){o=new t(r,i),e?e.next=o:n=o,e=o,o=void 0},drain:function(){var t=n;for(n=e=h=void 0;t;)t.fn.call(t.self),t=t.next}}}();var g=s({},"constructor",a,!1);return a.prototype=g,s(g,"__NPO__",0,!1),s(a,"resolve",function(t){var n=this;return t&&"object"==typeof t&&1===t.__NPO__?t:new n(function(n,e){if("function"!=typeof n||"function"!=typeof e)throw TypeError("Not a function");n(t)})}),s(a,"reject",function(t){return new this(function(n,e){if("function"!=typeof n||"function"!=typeof e)throw TypeError("Not a function");e(t)})}),s(a,"all",function(t){var n=this;return"[object Array]"!=p.call(t)?n.reject(TypeError("Not an array")):0===t.length?n.resolve([]):new n(function(e,o){if("function"!=typeof e||"function"!=typeof o)throw TypeError("Not a function");var r=t.length,i=Array(r),f=0;c(n,t,function(t,n){i[t]=n,++f===r&&e(i)},o)})}),s(a,"race",function(t){var n=this;return"[object Array]"!=p.call(t)?n.reject(TypeError("Not an array")):new n(function(e,o){if("function"!=typeof e||"function"!=typeof o)throw TypeError("Not a function");c(n,t,function(t,n){e(n)},o)})}),a});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],17:[function(require,module,exports){
var parser = require('./path-parser')
var stringifyQuerystring = require('querystring').stringify

module.exports = function(pathStr, parameters) {

	var parsed = typeof pathStr === 'string' ? parser(pathStr) : pathStr
	var allTokens = parsed.allTokens
	var regex = parsed.regex

	if (parameters) {
		var path = allTokens.map(function(bit) {
			if (bit.string) {
				return bit.string
			}

			var defined = typeof parameters[bit.name] !== 'undefined'
			if (!bit.optional && !defined) {
				throw new Error('Must supply argument ' + bit.name + ' for path ' + pathStr)
			}

			return defined ? (bit.delimiter + encodeURIComponent(parameters[bit.name])) : ''
		}).join('')

		if (!regex.test(path)) {
			throw new Error('Provided arguments do not match the original arguments')
		}

		return buildPathWithQuerystring(path, parameters, allTokens)
	} else {
		return parsed
	}
}

function buildPathWithQuerystring(path, parameters, tokenArray) {
	var parametersInQuerystring = getParametersWithoutMatchingToken(parameters, tokenArray)

	if (Object.keys(parametersInQuerystring).length === 0) {
		return path
	}

	return path + '?' + stringifyQuerystring(parametersInQuerystring)
}

function getParametersWithoutMatchingToken(parameters, tokenArray) {
	var tokenHash = tokenArray.reduce(function(memo, bit) {
		if (!bit.string) {
			memo[bit.name] = bit
		}
		return memo
	}, {})

	return Object.keys(parameters).filter(function(param) {
		return !tokenHash[param]
	}).reduce(function(newParameters, param) {
		newParameters[param] = parameters[param]
		return newParameters
	}, {})
}

},{"./path-parser":18,"querystring":24}],18:[function(require,module,exports){
// This file to be replaced with an official implementation maintained by
// the page.js crew if and when that becomes an option

var pathToRegexp = require('path-to-regexp-with-reversible-keys')

module.exports = function(pathString) {
	var parseResults = pathToRegexp(pathString)

	// The only reason I'm returning a new object instead of the results of the pathToRegexp
	// function is so that if the official implementation ends up returning an
	// allTokens-style array via some other mechanism, I may be able to change this file
	// without having to change the rest of the module in index.js
	return {
		regex: parseResults,
		allTokens: parseResults.allTokens
	}
}

},{"path-to-regexp-with-reversible-keys":19}],19:[function(require,module,exports){
var isArray = require('isarray');

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?"]
  // "/route(\\d+)" => [undefined, undefined, undefined, "\d+", undefined]
  '([\\/.])?(?:\\:(\\w+)(?:\\(((?:\\\\.|[^)])*)\\))?|\\(((?:\\\\.|[^)])*)\\))([+*?])?',
  // Match regexp special characters that are always escaped.
  '([.+*?=^!:${}()[\\]|\\/])'
].join('|'), 'g');

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {String} group
 * @return {String}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {RegExp} re
 * @param  {Array}  keys
 * @return {RegExp}
 */
function attachKeys (re, keys, allTokens) {
  re.keys = keys;
  re.allTokens = allTokens;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {String}
 */
function flags (options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {RegExp} path
 * @param  {Array}  keys
 * @return {RegExp}
 */
function regexpToRegexp (path, keys, allTokens) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name:      i,
        delimiter: null,
        optional:  false,
        repeat:    false
      });
    }
  }

  return attachKeys(path, keys, allTokens);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {Array}  path
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */
function arrayToRegexp (path, keys, options, allTokens) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options, allTokens).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));
  return attachKeys(regexp, keys, allTokens);
}

/**
 * Replace the specific tags with regexp strings.
 *
 * @param  {String} path
 * @param  {Array}  keys
 * @return {String}
 */
function replacePath (path, keys, allTokens) {
  var index = 0;
  var lastEndIndex = 0

  function addLastToken(lastToken) {
    if (lastEndIndex === 0 && lastToken[0] !== '/') {
      lastToken = '/' + lastToken
    }
    allTokens.push({
      string: lastToken
    });
  }


  function replace (match, escaped, prefix, key, capture, group, suffix, escape, offset) {
    if (escaped) {
      return escaped;
    }

    if (escape) {
      return '\\' + escape;
    }

    var repeat   = suffix === '+' || suffix === '*';
    var optional = suffix === '?' || suffix === '*';

    if (offset > lastEndIndex) {
      addLastToken(path.substring(lastEndIndex, offset));
    }

    lastEndIndex = offset + match.length;

    var newKey = {
      name:      key || index++,
      delimiter: prefix || '/',
      optional:  optional,
      repeat:    repeat
    }

    keys.push(newKey);
    allTokens.push(newKey);

    prefix = prefix ? ('\\' + prefix) : '';
    capture = escapeGroup(capture || group || '[^' + (prefix || '\\/') + ']+?');

    if (repeat) {
      capture = capture + '(?:' + prefix + capture + ')*';
    }

    if (optional) {
      return '(?:' + prefix + '(' + capture + '))?';
    }

    // Basic parameter support.
    return prefix + '(' + capture + ')';
  }

  var newPath = path.replace(PATH_REGEXP, replace);

  if (lastEndIndex < path.length) {
    addLastToken(path.substring(lastEndIndex))
  }

  return newPath;
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(String|RegExp|Array)} path
 * @param  {Array}                 [keys]
 * @param  {Object}                [options]
 * @return {RegExp}
 */
function pathToRegexp (path, keys, options, allTokens) {
  keys = keys || [];
  allTokens = allTokens || [];

  if (!isArray(keys)) {
    options = keys;
    keys = [];
  } else if (!options) {
    options = {};
  }

  if (path instanceof RegExp) {
    return regexpToRegexp(path, keys, options, allTokens);
  }

  if (isArray(path)) {
    return arrayToRegexp(path, keys, options, allTokens);
  }

  var strict = options.strict;
  var end = options.end !== false;
  var route = replacePath(path, keys, allTokens);
  var endsWithSlash = path.charAt(path.length - 1) === '/';

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithSlash ? '' : '(?=\\/|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys, allTokens);
}

},{"isarray":20}],20:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],21:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

(function () {
  try {
    cachedSetTimeout = setTimeout;
  } catch (e) {
    cachedSetTimeout = function () {
      throw new Error('setTimeout is not defined');
    }
  }
  try {
    cachedClearTimeout = clearTimeout;
  } catch (e) {
    cachedClearTimeout = function () {
      throw new Error('clearTimeout is not defined');
    }
  }
} ())
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = cachedSetTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    cachedClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        cachedSetTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],22:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],23:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],24:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":22,"./encode":23}],25:[function(require,module,exports){
var extend = require('xtend')

function wrapWackyPromise(promise, cb) {
	promise.then(function() {
		cb()
	}, function(err) {
		cb(err)
	})
}

module.exports = function RactiveStateRouter(Ractive, ractiveOptions, options) {
	function copyIfAppropriate(value) {
		if (options && options.deepCopyDataOnSet) {
			return copy(value)
		} else {
			return value
		}
	}
	return function makeRenderer(stateRouter) {
		var ExtendedRactive = Ractive.extend(ractiveOptions || {})
		var extendedData = ExtendedRactive.defaults.data
		var ractiveData = Ractive.defaults.data

		extendedData.makePath = ractiveData.makePath = stateRouter.makePath

		extendedData.active = ractiveData.active = function active(stateName) {
			return stateRouter.stateIsActive(stateName) ? 'active' : ''
		}

		return {
			render: function render(context, cb) {
				var element = context.element
				var inputTemplate = context.template

				var defaultDecorators = {
					active: activeStateDecarator.bind(null, stateRouter)
				}

				function getData() {
					var copyOfContent = copyIfAppropriate(context.content)
					return isTemplate(inputTemplate) ? copyOfContent : extend(inputTemplate.data, copyOfContent)
				}
				function getDecorators() {
					return isTemplate(inputTemplate) ? defaultDecorators : extend(defaultDecorators, inputTemplate.decorators)
				}
				function getOptions() {
					var bareOptions = isTemplate(inputTemplate) ? { template: inputTemplate } : inputTemplate

					return extend(bareOptions, {
						decorators: getDecorators(),
						data: getData(),
						el: element
					})
				}

				try {
					var ractive = new ExtendedRactive(getOptions())
					cb(null, ractive)
				} catch (e) {
					cb(e)
				}
			},
			reset: function reset(context, cb) {
				var ractive = context.domApi
				ractive.off()
				wrapWackyPromise(ractive.reset(copyIfAppropriate(context.content)), cb)
			},
			destroy: function destroy(ractive, cb) {
				wrapWackyPromise(ractive.teardown(), cb)
			},
			getChildElement: function getChildElement(ractive, cb) {
				try {
					var child = ractive.find('ui-view')
					cb(null, child)
				} catch (e) {
					cb(e)
				}
			}
		}
	}
}

function copy(value) {
	if (Array.isArray(value)) {
		return value.map(copy)
	} else if (object(value)) {
		var target = {}
		Object.keys(value).forEach(function(key) {
			target[key] = copy(value[key])
		})
		return target
	} else {
		return value
	}
}

function object(o) {
	return o && typeof o === 'object'
}

function activeStateDecarator(stateRouter, element, stateName) {
	var parametersToMatch = parseParameters(arguments)
	function onStateChange() {
		var active = stateRouter.stateIsActive(stateName, parametersToMatch)

		if (active) {
			element.classList.add('active')
		} else {
			element.classList.remove('active')
		}

	}

	stateRouter.on('stateChangeEnd', onStateChange)

	function teardown() {
		stateRouter.removeListener('stateChangeEnd', onStateChange)
	}

	return {
		teardown: teardown
	}
}

function parseParameters(args) {
	args = Array.prototype.slice.call(args, 2)
	return args.reduce(function(allParameters, parameterPair) {
		var keyAndValue = parameterPair.split(':')
		if (keyAndValue.length > 1) {
			allParameters[keyAndValue[0]] = keyAndValue[1]
		}
		return allParameters
	}, {})
}

function allParametersMatch(toMatch, parameters) {
	return Object.keys(toMatch).every(function(key) {
		return toMatch[key] == parameters[key]
	})
}

function isTemplate(inputTemplate) {
	return typeof inputTemplate === 'string' || isRactiveTemplateObject(inputTemplate)
}

function isRactiveTemplateObject(template) {
	// Based on https://github.com/ractivejs/ractive/blob/b1c9e1e5c22daac3210ee7db0f511065b31aac3c/src/Ractive/config/custom/template/template.js#L113-L116
	return template && typeof template.v === 'number'
}

},{"xtend":28}],26:[function(require,module,exports){
/*
	Ractive.js v0.7.3
	Sat Apr 25 2015 13:52:38 GMT-0400 (EDT) - commit da40f81c660ba2f09c45a09a9c20fdd34ee36d80

	http://ractivejs.org
	http://twitter.com/RactiveJS

	Released under the MIT License.
*/

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  global.Ractive = factory()
}(this, function () { 'use strict';

  var TEMPLATE_VERSION = 3;

  var defaultOptions = {

  	// render placement:
  	el: void 0,
  	append: false,

  	// template:
  	template: { v: TEMPLATE_VERSION, t: [] },

  	// parse:     // TODO static delimiters?
  	preserveWhitespace: false,
  	sanitize: false,
  	stripComments: true,
  	delimiters: ["{{", "}}"],
  	tripleDelimiters: ["{{{", "}}}"],
  	interpolate: false,

  	// data & binding:
  	data: {},
  	computed: {},
  	magic: false,
  	modifyArrays: true,
  	adapt: [],
  	isolated: false,
  	twoway: true,
  	lazy: false,

  	// transitions:
  	noIntro: false,
  	transitionsEnabled: true,
  	complete: void 0,

  	// css:
  	css: null,
  	noCssTransform: false
  };

  var config_defaults = defaultOptions;

  // These are a subset of the easing equations found at
  // https://raw.github.com/danro/easing-js - license info
  // follows:

  // --------------------------------------------------
  // easing.js v0.5.4
  // Generic set of easing functions with AMD support
  // https://github.com/danro/easing-js
  // This code may be freely distributed under the MIT license
  // http://danro.mit-license.org/
  // --------------------------------------------------
  // All functions adapted from Thomas Fuchs & Jeremy Kahn
  // Easing Equations (c) 2003 Robert Penner, BSD license
  // https://raw.github.com/danro/easing-js/master/LICENSE
  // --------------------------------------------------

  // In that library, the functions named easeIn, easeOut, and
  // easeInOut below are named easeInCubic, easeOutCubic, and
  // (you guessed it) easeInOutCubic.
  //
  // You can add additional easing functions to this list, and they
  // will be globally available.

  var static_easing = {
  	linear: function (pos) {
  		return pos;
  	},
  	easeIn: function (pos) {
  		return Math.pow(pos, 3);
  	},
  	easeOut: function (pos) {
  		return Math.pow(pos - 1, 3) + 1;
  	},
  	easeInOut: function (pos) {
  		if ((pos /= 0.5) < 1) {
  			return 0.5 * Math.pow(pos, 3);
  		}
  		return 0.5 * (Math.pow(pos - 2, 3) + 2);
  	}
  };

  /*global console, navigator */
  var isClient, isJsdom, hasConsole, environment__magic, namespaces, svg, vendors;

  isClient = typeof document === "object";

  isJsdom = typeof navigator !== "undefined" && /jsDom/.test(navigator.appName);

  hasConsole = typeof console !== "undefined" && typeof console.warn === "function" && typeof console.warn.apply === "function";

  try {
  	Object.defineProperty({}, "test", { value: 0 });
  	environment__magic = true;
  } catch (e) {
  	environment__magic = false;
  }

  namespaces = {
  	html: "http://www.w3.org/1999/xhtml",
  	mathml: "http://www.w3.org/1998/Math/MathML",
  	svg: "http://www.w3.org/2000/svg",
  	xlink: "http://www.w3.org/1999/xlink",
  	xml: "http://www.w3.org/XML/1998/namespace",
  	xmlns: "http://www.w3.org/2000/xmlns/"
  };

  if (typeof document === "undefined") {
  	svg = false;
  } else {
  	svg = document && document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
  }

  vendors = ["o", "ms", "moz", "webkit"];

  var createElement, matches, dom__div, methodNames, unprefixed, prefixed, dom__i, j, makeFunction;

  // Test for SVG support
  if (!svg) {
  	createElement = function (type, ns) {
  		if (ns && ns !== namespaces.html) {
  			throw "This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you're trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information";
  		}

  		return document.createElement(type);
  	};
  } else {
  	createElement = function (type, ns) {
  		if (!ns || ns === namespaces.html) {
  			return document.createElement(type);
  		}

  		return document.createElementNS(ns, type);
  	};
  }

  function getElement(input) {
  	var output;

  	if (!input || typeof input === "boolean") {
  		return;
  	}

  	if (typeof window === "undefined" || !document || !input) {
  		return null;
  	}

  	// We already have a DOM node - no work to do. (Duck typing alert!)
  	if (input.nodeType) {
  		return input;
  	}

  	// Get node from string
  	if (typeof input === "string") {
  		// try ID first
  		output = document.getElementById(input);

  		// then as selector, if possible
  		if (!output && document.querySelector) {
  			output = document.querySelector(input);
  		}

  		// did it work?
  		if (output && output.nodeType) {
  			return output;
  		}
  	}

  	// If we've been given a collection (jQuery, Zepto etc), extract the first item
  	if (input[0] && input[0].nodeType) {
  		return input[0];
  	}

  	return null;
  }

  if (!isClient) {
  	matches = null;
  } else {
  	dom__div = createElement("div");
  	methodNames = ["matches", "matchesSelector"];

  	makeFunction = function (methodName) {
  		return function (node, selector) {
  			return node[methodName](selector);
  		};
  	};

  	dom__i = methodNames.length;

  	while (dom__i-- && !matches) {
  		unprefixed = methodNames[dom__i];

  		if (dom__div[unprefixed]) {
  			matches = makeFunction(unprefixed);
  		} else {
  			j = vendors.length;
  			while (j--) {
  				prefixed = vendors[dom__i] + unprefixed.substr(0, 1).toUpperCase() + unprefixed.substring(1);

  				if (dom__div[prefixed]) {
  					matches = makeFunction(prefixed);
  					break;
  				}
  			}
  		}
  	}

  	// IE8...
  	if (!matches) {
  		matches = function (node, selector) {
  			var nodes, parentNode, i;

  			parentNode = node.parentNode;

  			if (!parentNode) {
  				// empty dummy <div>
  				dom__div.innerHTML = "";

  				parentNode = dom__div;
  				node = node.cloneNode();

  				dom__div.appendChild(node);
  			}

  			nodes = parentNode.querySelectorAll(selector);

  			i = nodes.length;
  			while (i--) {
  				if (nodes[i] === node) {
  					return true;
  				}
  			}

  			return false;
  		};
  	}
  }

  function detachNode(node) {
  	if (node && typeof node.parentNode !== "unknown" && node.parentNode) {
  		node.parentNode.removeChild(node);
  	}

  	return node;
  }

  function safeToStringValue(value) {
  	return value == null || !value.toString ? "" : value;
  }

  var legacy = null;

  var create, defineProperty, defineProperties;

  try {
  	Object.defineProperty({}, "test", { value: 0 });

  	if (isClient) {
  		Object.defineProperty(document.createElement("div"), "test", { value: 0 });
  	}

  	defineProperty = Object.defineProperty;
  } catch (err) {
  	// Object.defineProperty doesn't exist, or we're in IE8 where you can
  	// only use it with DOM objects (what were you smoking, MSFT?)
  	defineProperty = function (obj, prop, desc) {
  		obj[prop] = desc.value;
  	};
  }

  try {
  	try {
  		Object.defineProperties({}, { test: { value: 0 } });
  	} catch (err) {
  		// TODO how do we account for this? noMagic = true;
  		throw err;
  	}

  	if (isClient) {
  		Object.defineProperties(createElement("div"), { test: { value: 0 } });
  	}

  	defineProperties = Object.defineProperties;
  } catch (err) {
  	defineProperties = function (obj, props) {
  		var prop;

  		for (prop in props) {
  			if (props.hasOwnProperty(prop)) {
  				defineProperty(obj, prop, props[prop]);
  			}
  		}
  	};
  }

  try {
  	Object.create(null);

  	create = Object.create;
  } catch (err) {
  	// sigh
  	create = (function () {
  		var F = function () {};

  		return function (proto, props) {
  			var obj;

  			if (proto === null) {
  				return {};
  			}

  			F.prototype = proto;
  			obj = new F();

  			if (props) {
  				Object.defineProperties(obj, props);
  			}

  			return obj;
  		};
  	})();
  }

  function utils_object__extend(target) {
  	for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		sources[_key - 1] = arguments[_key];
  	}

  	var prop, source;

  	while (source = sources.shift()) {
  		for (prop in source) {
  			if (hasOwn.call(source, prop)) {
  				target[prop] = source[prop];
  			}
  		}
  	}

  	return target;
  }

  function fillGaps(target) {
  	for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		sources[_key - 1] = arguments[_key];
  	}

  	sources.forEach(function (s) {
  		for (var key in s) {
  			if (s.hasOwnProperty(key) && !(key in target)) {
  				target[key] = s[key];
  			}
  		}
  	});

  	return target;
  }

  var hasOwn = Object.prototype.hasOwnProperty;

  // thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
  var is__toString = Object.prototype.toString,
      arrayLikePattern = /^\[object (?:Array|FileList)\]$/;
  function isArray(thing) {
  	return is__toString.call(thing) === "[object Array]";
  }

  function isArrayLike(obj) {
  	return arrayLikePattern.test(is__toString.call(obj));
  }

  function isEqual(a, b) {
  	if (a === null && b === null) {
  		return true;
  	}

  	if (typeof a === "object" || typeof b === "object") {
  		return false;
  	}

  	return a === b;
  }

  function is__isNumeric(thing) {
  	return !isNaN(parseFloat(thing)) && isFinite(thing);
  }

  function isObject(thing) {
  	return thing && is__toString.call(thing) === "[object Object]";
  }

  var noop = function () {};

  /* global console */
  var alreadyWarned = {},
      log,
      printWarning,
      welcome;

  if (hasConsole) {
  	(function () {
  		var welcomeIntro = ["%cRactive.js %c0.7.3 %cin debug mode, %cmore...", "color: rgb(114, 157, 52); font-weight: normal;", "color: rgb(85, 85, 85); font-weight: normal;", "color: rgb(85, 85, 85); font-weight: normal;", "color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;"];
  		var welcomeMessage = "You're running Ractive 0.7.3 in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\n\nTo disable debug mode, add this line at the start of your app:\n  Ractive.DEBUG = false;\n\nTo disable debug mode when your app is minified, add this snippet:\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\n\nGet help and support:\n  http://docs.ractivejs.org\n  http://stackoverflow.com/questions/tagged/ractivejs\n  http://groups.google.com/forum/#!forum/ractive-js\n  http://twitter.com/ractivejs\n\nFound a bug? Raise an issue:\n  https://github.com/ractivejs/ractive/issues\n\n";

  		welcome = function () {
  			var hasGroup = !!console.groupCollapsed;
  			console[hasGroup ? "groupCollapsed" : "log"].apply(console, welcomeIntro);
  			console.log(welcomeMessage);
  			if (hasGroup) {
  				console.groupEnd(welcomeIntro);
  			}

  			welcome = noop;
  		};

  		printWarning = function (message, args) {
  			welcome();

  			// extract information about the instance this message pertains to, if applicable
  			if (typeof args[args.length - 1] === "object") {
  				var options = args.pop();
  				var ractive = options ? options.ractive : null;

  				if (ractive) {
  					// if this is an instance of a component that we know the name of, add
  					// it to the message
  					var _name = undefined;
  					if (ractive.component && (_name = ractive.component.name)) {
  						message = "<" + _name + "> " + message;
  					}

  					var node = undefined;
  					if (node = options.node || ractive.fragment && ractive.fragment.rendered && ractive.find("*")) {
  						args.push(node);
  					}
  				}
  			}

  			console.warn.apply(console, ["%cRactive.js: %c" + message, "color: rgb(114, 157, 52);", "color: rgb(85, 85, 85);"].concat(args));
  		};

  		log = function () {
  			console.log.apply(console, arguments);
  		};
  	})();
  } else {
  	printWarning = log = welcome = noop;
  }

  function format(message, args) {
  	return message.replace(/%s/g, function () {
  		return args.shift();
  	});
  }

  function fatal(message) {
  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		args[_key - 1] = arguments[_key];
  	}

  	message = format(message, args);
  	throw new Error(message);
  }

  function logIfDebug() {
  	if (_Ractive.DEBUG) {
  		log.apply(null, arguments);
  	}
  }

  function warn(message) {
  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		args[_key - 1] = arguments[_key];
  	}

  	message = format(message, args);
  	printWarning(message, args);
  }

  function warnOnce(message) {
  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		args[_key - 1] = arguments[_key];
  	}

  	message = format(message, args);

  	if (alreadyWarned[message]) {
  		return;
  	}

  	alreadyWarned[message] = true;
  	printWarning(message, args);
  }

  function warnIfDebug() {
  	if (_Ractive.DEBUG) {
  		warn.apply(null, arguments);
  	}
  }

  function warnOnceIfDebug() {
  	if (_Ractive.DEBUG) {
  		warnOnce.apply(null, arguments);
  	}
  }

  // Error messages that are used (or could be) in multiple places
  var badArguments = "Bad arguments";
  var noRegistryFunctionReturn = "A function was specified for \"%s\" %s, but no %s was returned";
  var missingPlugin = function (name, type) {
    return "Missing \"" + name + "\" " + type + " plugin. You may need to download a plugin via http://docs.ractivejs.org/latest/plugins#" + type + "s";
  };

  function findInViewHierarchy(registryName, ractive, name) {
  	var instance = findInstance(registryName, ractive, name);
  	return instance ? instance[registryName][name] : null;
  }

  function findInstance(registryName, ractive, name) {
  	while (ractive) {
  		if (name in ractive[registryName]) {
  			return ractive;
  		}

  		if (ractive.isolated) {
  			return null;
  		}

  		ractive = ractive.parent;
  	}
  }

  var interpolate = function (from, to, ractive, type) {
  	if (from === to) {
  		return snap(to);
  	}

  	if (type) {

  		var interpol = findInViewHierarchy("interpolators", ractive, type);
  		if (interpol) {
  			return interpol(from, to) || snap(to);
  		}

  		fatal(missingPlugin(type, "interpolator"));
  	}

  	return static_interpolators.number(from, to) || static_interpolators.array(from, to) || static_interpolators.object(from, to) || snap(to);
  };

  var shared_interpolate = interpolate;

  function snap(to) {
  	return function () {
  		return to;
  	};
  }

  var interpolators = {
  	number: function (from, to) {
  		var delta;

  		if (!is__isNumeric(from) || !is__isNumeric(to)) {
  			return null;
  		}

  		from = +from;
  		to = +to;

  		delta = to - from;

  		if (!delta) {
  			return function () {
  				return from;
  			};
  		}

  		return function (t) {
  			return from + t * delta;
  		};
  	},

  	array: function (from, to) {
  		var intermediate, interpolators, len, i;

  		if (!isArray(from) || !isArray(to)) {
  			return null;
  		}

  		intermediate = [];
  		interpolators = [];

  		i = len = Math.min(from.length, to.length);
  		while (i--) {
  			interpolators[i] = shared_interpolate(from[i], to[i]);
  		}

  		// surplus values - don't interpolate, but don't exclude them either
  		for (i = len; i < from.length; i += 1) {
  			intermediate[i] = from[i];
  		}

  		for (i = len; i < to.length; i += 1) {
  			intermediate[i] = to[i];
  		}

  		return function (t) {
  			var i = len;

  			while (i--) {
  				intermediate[i] = interpolators[i](t);
  			}

  			return intermediate;
  		};
  	},

  	object: function (from, to) {
  		var properties, len, interpolators, intermediate, prop;

  		if (!isObject(from) || !isObject(to)) {
  			return null;
  		}

  		properties = [];
  		intermediate = {};
  		interpolators = {};

  		for (prop in from) {
  			if (hasOwn.call(from, prop)) {
  				if (hasOwn.call(to, prop)) {
  					properties.push(prop);
  					interpolators[prop] = shared_interpolate(from[prop], to[prop]);
  				} else {
  					intermediate[prop] = from[prop];
  				}
  			}
  		}

  		for (prop in to) {
  			if (hasOwn.call(to, prop) && !hasOwn.call(from, prop)) {
  				intermediate[prop] = to[prop];
  			}
  		}

  		len = properties.length;

  		return function (t) {
  			var i = len,
  			    prop;

  			while (i--) {
  				prop = properties[i];

  				intermediate[prop] = interpolators[prop](t);
  			}

  			return intermediate;
  		};
  	}
  };

  var static_interpolators = interpolators;

  // This function takes a keypath such as 'foo.bar.baz', and returns
  // all the variants of that keypath that include a wildcard in place
  // of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.
  // These are then checked against the dependants map (ractive.viewmodel.depsMap)
  // to see if any pattern observers are downstream of one or more of
  // these wildcard keypaths (e.g. 'foo.bar.*.status')
  var utils_getPotentialWildcardMatches = getPotentialWildcardMatches;

  var starMaps = {};
  function getPotentialWildcardMatches(keypath) {
  	var keys, starMap, mapper, i, result, wildcardKeypath;

  	keys = keypath.split(".");
  	if (!(starMap = starMaps[keys.length])) {
  		starMap = getStarMap(keys.length);
  	}

  	result = [];

  	mapper = function (star, i) {
  		return star ? "*" : keys[i];
  	};

  	i = starMap.length;
  	while (i--) {
  		wildcardKeypath = starMap[i].map(mapper).join(".");

  		if (!result.hasOwnProperty(wildcardKeypath)) {
  			result.push(wildcardKeypath);
  			result[wildcardKeypath] = true;
  		}
  	}

  	return result;
  }

  // This function returns all the possible true/false combinations for
  // a given number - e.g. for two, the possible combinations are
  // [ true, true ], [ true, false ], [ false, true ], [ false, false ].
  // It does so by getting all the binary values between 0 and e.g. 11
  function getStarMap(num) {
  	var ones = "",
  	    max,
  	    binary,
  	    starMap,
  	    mapper,
  	    i,
  	    j,
  	    l,
  	    map;

  	if (!starMaps[num]) {
  		starMap = [];

  		while (ones.length < num) {
  			ones += 1;
  		}

  		max = parseInt(ones, 2);

  		mapper = function (digit) {
  			return digit === "1";
  		};

  		for (i = 0; i <= max; i += 1) {
  			binary = i.toString(2);
  			while (binary.length < num) {
  				binary = "0" + binary;
  			}

  			map = [];
  			l = binary.length;
  			for (j = 0; j < l; j++) {
  				map.push(mapper(binary[j]));
  			}
  			starMap[i] = map;
  		}

  		starMaps[num] = starMap;
  	}

  	return starMaps[num];
  }

  var refPattern = /\[\s*(\*|[0-9]|[1-9][0-9]+)\s*\]/g;
  var patternPattern = /\*/;
  var keypathCache = {};

  var Keypath = function (str) {
  	var keys = str.split(".");

  	this.str = str;

  	if (str[0] === "@") {
  		this.isSpecial = true;
  		this.value = decodeKeypath(str);
  	}

  	this.firstKey = keys[0];
  	this.lastKey = keys.pop();

  	this.isPattern = patternPattern.test(str);

  	this.parent = str === "" ? null : getKeypath(keys.join("."));
  	this.isRoot = !str;
  };

  Keypath.prototype = {
  	equalsOrStartsWith: function (keypath) {
  		return keypath === this || this.startsWith(keypath);
  	},

  	join: function (str) {
  		return getKeypath(this.isRoot ? String(str) : this.str + "." + str);
  	},

  	replace: function (oldKeypath, newKeypath) {
  		if (this === oldKeypath) {
  			return newKeypath;
  		}

  		if (this.startsWith(oldKeypath)) {
  			return newKeypath === null ? newKeypath : getKeypath(this.str.replace(oldKeypath.str + ".", newKeypath.str + "."));
  		}
  	},

  	startsWith: function (keypath) {
  		if (!keypath) {
  			// TODO under what circumstances does this happen?
  			return false;
  		}

  		return keypath && this.str.substr(0, keypath.str.length + 1) === keypath.str + ".";
  	},

  	toString: function () {
  		throw new Error("Bad coercion");
  	},

  	valueOf: function () {
  		throw new Error("Bad coercion");
  	},

  	wildcardMatches: function () {
  		return this._wildcardMatches || (this._wildcardMatches = utils_getPotentialWildcardMatches(this.str));
  	}
  };
  function assignNewKeypath(target, property, oldKeypath, newKeypath) {
  	var existingKeypath = target[property];

  	if (existingKeypath && (existingKeypath.equalsOrStartsWith(newKeypath) || !existingKeypath.equalsOrStartsWith(oldKeypath))) {
  		return;
  	}

  	target[property] = existingKeypath ? existingKeypath.replace(oldKeypath, newKeypath) : newKeypath;
  	return true;
  }

  function decodeKeypath(keypath) {
  	var value = keypath.slice(2);

  	if (keypath[1] === "i") {
  		return is__isNumeric(value) ? +value : value;
  	} else {
  		return value;
  	}
  }

  function getKeypath(str) {
  	if (str == null) {
  		return str;
  	}

  	// TODO it *may* be worth having two versions of this function - one where
  	// keypathCache inherits from null, and one for IE8. Depends on how
  	// much of an overhead hasOwnProperty is - probably negligible
  	if (!keypathCache.hasOwnProperty(str)) {
  		keypathCache[str] = new Keypath(str);
  	}

  	return keypathCache[str];
  }

  function getMatchingKeypaths(ractive, keypath) {
  	var keys, key, matchingKeypaths;

  	keys = keypath.str.split(".");
  	matchingKeypaths = [rootKeypath];

  	while (key = keys.shift()) {
  		if (key === "*") {
  			// expand to find all valid child keypaths
  			matchingKeypaths = matchingKeypaths.reduce(expand, []);
  		} else {
  			if (matchingKeypaths[0] === rootKeypath) {
  				// first key
  				matchingKeypaths[0] = getKeypath(key);
  			} else {
  				matchingKeypaths = matchingKeypaths.map(concatenate(key));
  			}
  		}
  	}

  	return matchingKeypaths;

  	function expand(matchingKeypaths, keypath) {
  		var wrapper, value, keys;

  		if (keypath.isRoot) {
  			keys = [].concat(Object.keys(ractive.viewmodel.data), Object.keys(ractive.viewmodel.mappings), Object.keys(ractive.viewmodel.computations));
  		} else {
  			wrapper = ractive.viewmodel.wrapped[keypath.str];
  			value = wrapper ? wrapper.get() : ractive.viewmodel.get(keypath);

  			keys = value ? Object.keys(value) : null;
  		}

  		if (keys) {
  			keys.forEach(function (key) {
  				if (key !== "_ractive" || !isArray(value)) {
  					matchingKeypaths.push(keypath.join(key));
  				}
  			});
  		}

  		return matchingKeypaths;
  	}
  }

  function concatenate(key) {
  	return function (keypath) {
  		return keypath.join(key);
  	};
  }
  function normalise(ref) {
  	return ref ? ref.replace(refPattern, ".$1") : "";
  }

  var rootKeypath = getKeypath("");

  var shared_add = add;
  var shared_add__errorMessage = "Cannot add to a non-numeric value";
  function add(root, keypath, d) {
  	if (typeof keypath !== "string" || !is__isNumeric(d)) {
  		throw new Error("Bad arguments");
  	}

  	var value = undefined,
  	    changes = undefined;

  	if (/\*/.test(keypath)) {
  		changes = {};

  		getMatchingKeypaths(root, getKeypath(normalise(keypath))).forEach(function (keypath) {
  			var value = root.viewmodel.get(keypath);

  			if (!is__isNumeric(value)) {
  				throw new Error(shared_add__errorMessage);
  			}

  			changes[keypath.str] = value + d;
  		});

  		return root.set(changes);
  	}

  	value = root.get(keypath);

  	if (!is__isNumeric(value)) {
  		throw new Error(shared_add__errorMessage);
  	}

  	return root.set(keypath, +value + d);
  }

  var prototype_add = Ractive$add;
  function Ractive$add(keypath, d) {
  	return shared_add(this, keypath, d === undefined ? 1 : +d);
  }

  var requestAnimationFrame;

  // If window doesn't exist, we don't need requestAnimationFrame
  if (typeof window === "undefined") {
  	requestAnimationFrame = null;
  } else {
  	// https://gist.github.com/paulirish/1579671
  	(function (vendors, lastTime, window) {

  		var x, setTimeout;

  		if (window.requestAnimationFrame) {
  			return;
  		}

  		for (x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
  			window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
  		}

  		if (!window.requestAnimationFrame) {
  			setTimeout = window.setTimeout;

  			window.requestAnimationFrame = function (callback) {
  				var currTime, timeToCall, id;

  				currTime = Date.now();
  				timeToCall = Math.max(0, 16 - (currTime - lastTime));
  				id = setTimeout(function () {
  					callback(currTime + timeToCall);
  				}, timeToCall);

  				lastTime = currTime + timeToCall;
  				return id;
  			};
  		}
  	})(vendors, 0, window);

  	requestAnimationFrame = window.requestAnimationFrame;
  }

  var rAF = requestAnimationFrame;

  var getTime;

  if (typeof window !== "undefined" && window.performance && typeof window.performance.now === "function") {
  	getTime = function () {
  		return window.performance.now();
  	};
  } else {
  	getTime = function () {
  		return Date.now();
  	};
  }

  var utils_getTime = getTime;

  var deprecations = {
  	construct: {
  		deprecated: "beforeInit",
  		replacement: "onconstruct"
  	},
  	render: {
  		deprecated: "init",
  		message: "The \"init\" method has been deprecated " + "and will likely be removed in a future release. " + "You can either use the \"oninit\" method which will fire " + "only once prior to, and regardless of, any eventual ractive " + "instance being rendered, or if you need to access the " + "rendered DOM, use \"onrender\" instead. " + "See http://docs.ractivejs.org/latest/migrating for more information."
  	},
  	complete: {
  		deprecated: "complete",
  		replacement: "oncomplete"
  	}
  };

  function Hook(event) {
  	this.event = event;
  	this.method = "on" + event;
  	this.deprecate = deprecations[event];
  }

  Hook.prototype.fire = function (ractive, arg) {
  	function call(method) {
  		if (ractive[method]) {
  			arg ? ractive[method](arg) : ractive[method]();
  			return true;
  		}
  	}

  	call(this.method);

  	if (!ractive[this.method] && this.deprecate && call(this.deprecate.deprecated)) {
  		if (this.deprecate.message) {
  			warnIfDebug(this.deprecate.message);
  		} else {
  			warnIfDebug("The method \"%s\" has been deprecated in favor of \"%s\" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.", this.deprecate.deprecated, this.deprecate.replacement);
  		}
  	}

  	arg ? ractive.fire(this.event, arg) : ractive.fire(this.event);
  };

  var hooks_Hook = Hook;

  function addToArray(array, value) {
  	var index = array.indexOf(value);

  	if (index === -1) {
  		array.push(value);
  	}
  }

  function arrayContains(array, value) {
  	for (var i = 0, c = array.length; i < c; i++) {
  		if (array[i] == value) {
  			return true;
  		}
  	}

  	return false;
  }

  function arrayContentsMatch(a, b) {
  	var i;

  	if (!isArray(a) || !isArray(b)) {
  		return false;
  	}

  	if (a.length !== b.length) {
  		return false;
  	}

  	i = a.length;
  	while (i--) {
  		if (a[i] !== b[i]) {
  			return false;
  		}
  	}

  	return true;
  }

  function ensureArray(x) {
  	if (typeof x === "string") {
  		return [x];
  	}

  	if (x === undefined) {
  		return [];
  	}

  	return x;
  }

  function lastItem(array) {
  	return array[array.length - 1];
  }

  function removeFromArray(array, member) {
  	var index = array.indexOf(member);

  	if (index !== -1) {
  		array.splice(index, 1);
  	}
  }

  function toArray(arrayLike) {
  	var array = [],
  	    i = arrayLike.length;
  	while (i--) {
  		array[i] = arrayLike[i];
  	}

  	return array;
  }

  var _Promise,
      PENDING = {},
      FULFILLED = {},
      REJECTED = {};

  if (typeof Promise === "function") {
  	// use native Promise
  	_Promise = Promise;
  } else {
  	_Promise = function (callback) {
  		var fulfilledHandlers = [],
  		    rejectedHandlers = [],
  		    state = PENDING,
  		    result,
  		    dispatchHandlers,
  		    makeResolver,
  		    fulfil,
  		    reject,
  		    promise;

  		makeResolver = function (newState) {
  			return function (value) {
  				if (state !== PENDING) {
  					return;
  				}

  				result = value;
  				state = newState;

  				dispatchHandlers = makeDispatcher(state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result);

  				// dispatch onFulfilled and onRejected handlers asynchronously
  				wait(dispatchHandlers);
  			};
  		};

  		fulfil = makeResolver(FULFILLED);
  		reject = makeResolver(REJECTED);

  		try {
  			callback(fulfil, reject);
  		} catch (err) {
  			reject(err);
  		}

  		promise = {
  			// `then()` returns a Promise - 2.2.7
  			then: function (onFulfilled, onRejected) {
  				var promise2 = new _Promise(function (fulfil, reject) {

  					var processResolutionHandler = function (handler, handlers, forward) {

  						// 2.2.1.1
  						if (typeof handler === "function") {
  							handlers.push(function (p1result) {
  								var x;

  								try {
  									x = handler(p1result);
  									utils_Promise__resolve(promise2, x, fulfil, reject);
  								} catch (err) {
  									reject(err);
  								}
  							});
  						} else {
  							// Forward the result of promise1 to promise2, if resolution handlers
  							// are not given
  							handlers.push(forward);
  						}
  					};

  					// 2.2
  					processResolutionHandler(onFulfilled, fulfilledHandlers, fulfil);
  					processResolutionHandler(onRejected, rejectedHandlers, reject);

  					if (state !== PENDING) {
  						// If the promise has resolved already, dispatch the appropriate handlers asynchronously
  						wait(dispatchHandlers);
  					}
  				});

  				return promise2;
  			}
  		};

  		promise["catch"] = function (onRejected) {
  			return this.then(null, onRejected);
  		};

  		return promise;
  	};

  	_Promise.all = function (promises) {
  		return new _Promise(function (fulfil, reject) {
  			var result = [],
  			    pending,
  			    i,
  			    processPromise;

  			if (!promises.length) {
  				fulfil(result);
  				return;
  			}

  			processPromise = function (promise, i) {
  				if (promise && typeof promise.then === "function") {
  					promise.then(function (value) {
  						result[i] = value;
  						--pending || fulfil(result);
  					}, reject);
  				} else {
  					result[i] = promise;
  					--pending || fulfil(result);
  				}
  			};

  			pending = i = promises.length;
  			while (i--) {
  				processPromise(promises[i], i);
  			}
  		});
  	};

  	_Promise.resolve = function (value) {
  		return new _Promise(function (fulfil) {
  			fulfil(value);
  		});
  	};

  	_Promise.reject = function (reason) {
  		return new _Promise(function (fulfil, reject) {
  			reject(reason);
  		});
  	};
  }

  var utils_Promise = _Promise;

  // TODO use MutationObservers or something to simulate setImmediate
  function wait(callback) {
  	setTimeout(callback, 0);
  }

  function makeDispatcher(handlers, result) {
  	return function () {
  		var handler;

  		while (handler = handlers.shift()) {
  			handler(result);
  		}
  	};
  }

  function utils_Promise__resolve(promise, x, fulfil, reject) {
  	// Promise Resolution Procedure
  	var then;

  	// 2.3.1
  	if (x === promise) {
  		throw new TypeError("A promise's fulfillment handler cannot return the same promise");
  	}

  	// 2.3.2
  	if (x instanceof _Promise) {
  		x.then(fulfil, reject);
  	}

  	// 2.3.3
  	else if (x && (typeof x === "object" || typeof x === "function")) {
  		try {
  			then = x.then; // 2.3.3.1
  		} catch (e) {
  			reject(e); // 2.3.3.2
  			return;
  		}

  		// 2.3.3.3
  		if (typeof then === "function") {
  			var called, resolvePromise, rejectPromise;

  			resolvePromise = function (y) {
  				if (called) {
  					return;
  				}
  				called = true;
  				utils_Promise__resolve(promise, y, fulfil, reject);
  			};

  			rejectPromise = function (r) {
  				if (called) {
  					return;
  				}
  				called = true;
  				reject(r);
  			};

  			try {
  				then.call(x, resolvePromise, rejectPromise);
  			} catch (e) {
  				if (!called) {
  					// 2.3.3.3.4.1
  					reject(e); // 2.3.3.3.4.2
  					called = true;
  					return;
  				}
  			}
  		} else {
  			fulfil(x);
  		}
  	} else {
  		fulfil(x);
  	}
  }

  var getInnerContext = function (fragment) {
  	do {
  		if (fragment.context !== undefined) {
  			return fragment.context;
  		}
  	} while (fragment = fragment.parent);

  	return rootKeypath;
  };

  var shared_resolveRef = resolveRef;

  function resolveRef(ractive, ref, fragment) {
  	var keypath;

  	ref = normalise(ref);

  	// If a reference begins '~/', it's a top-level reference
  	if (ref.substr(0, 2) === "~/") {
  		keypath = getKeypath(ref.substring(2));
  		createMappingIfNecessary(ractive, keypath.firstKey, fragment);
  	}

  	// If a reference begins with '.', it's either a restricted reference or
  	// an ancestor reference...
  	else if (ref[0] === ".") {
  		keypath = resolveAncestorRef(getInnerContext(fragment), ref);

  		if (keypath) {
  			createMappingIfNecessary(ractive, keypath.firstKey, fragment);
  		}
  	}

  	// ...otherwise we need to figure out the keypath based on context
  	else {
  		keypath = resolveAmbiguousReference(ractive, getKeypath(ref), fragment);
  	}

  	return keypath;
  }

  function resolveAncestorRef(baseContext, ref) {
  	var contextKeys;

  	// TODO...
  	if (baseContext != undefined && typeof baseContext !== "string") {
  		baseContext = baseContext.str;
  	}

  	// {{.}} means 'current context'
  	if (ref === ".") return getKeypath(baseContext);

  	contextKeys = baseContext ? baseContext.split(".") : [];

  	// ancestor references (starting "../") go up the tree
  	if (ref.substr(0, 3) === "../") {
  		while (ref.substr(0, 3) === "../") {
  			if (!contextKeys.length) {
  				throw new Error("Could not resolve reference - too many \"../\" prefixes");
  			}

  			contextKeys.pop();
  			ref = ref.substring(3);
  		}

  		contextKeys.push(ref);
  		return getKeypath(contextKeys.join("."));
  	}

  	// not an ancestor reference - must be a restricted reference (prepended with "." or "./")
  	if (!baseContext) {
  		return getKeypath(ref.replace(/^\.\/?/, ""));
  	}

  	return getKeypath(baseContext + ref.replace(/^\.\//, "."));
  }

  function resolveAmbiguousReference(ractive, ref, fragment, isParentLookup) {
  	var context, key, parentValue, hasContextChain, parentKeypath;

  	if (ref.isRoot) {
  		return ref;
  	}

  	key = ref.firstKey;

  	while (fragment) {
  		context = fragment.context;
  		fragment = fragment.parent;

  		if (!context) {
  			continue;
  		}

  		hasContextChain = true;
  		parentValue = ractive.viewmodel.get(context);

  		if (parentValue && (typeof parentValue === "object" || typeof parentValue === "function") && key in parentValue) {
  			return context.join(ref.str);
  		}
  	}

  	// Root/computed/mapped property?
  	if (isRootProperty(ractive.viewmodel, key)) {
  		return ref;
  	}

  	// If this is an inline component, and it's not isolated, we
  	// can try going up the scope chain
  	if (ractive.parent && !ractive.isolated) {
  		hasContextChain = true;
  		fragment = ractive.component.parentFragment;

  		key = getKeypath(key);

  		if (parentKeypath = resolveAmbiguousReference(ractive.parent, key, fragment, true)) {
  			// We need to create an inter-component binding
  			ractive.viewmodel.map(key, {
  				origin: ractive.parent.viewmodel,
  				keypath: parentKeypath
  			});

  			return ref;
  		}
  	}

  	// If there's no context chain, and the instance is either a) isolated or
  	// b) an orphan, then we know that the keypath is identical to the reference
  	if (!isParentLookup && !hasContextChain) {
  		// the data object needs to have a property by this name,
  		// to prevent future failed lookups
  		ractive.viewmodel.set(ref, undefined);
  		return ref;
  	}
  }

  function createMappingIfNecessary(ractive, key) {
  	var parentKeypath;

  	if (!ractive.parent || ractive.isolated || isRootProperty(ractive.viewmodel, key)) {
  		return;
  	}

  	key = getKeypath(key);

  	if (parentKeypath = resolveAmbiguousReference(ractive.parent, key, ractive.component.parentFragment, true)) {
  		ractive.viewmodel.map(key, {
  			origin: ractive.parent.viewmodel,
  			keypath: parentKeypath
  		});
  	}
  }

  function isRootProperty(viewmodel, key) {
  	// special case for reference to root
  	return key === "" || key in viewmodel.data || key in viewmodel.computations || key in viewmodel.mappings;
  }

  function teardown(x) {
    x.teardown();
  }

  function methodCallers__unbind(x) {
    x.unbind();
  }

  function methodCallers__unrender(x) {
    x.unrender();
  }

  function cancel(x) {
    x.cancel();
  }

  var TransitionManager = function (callback, parent) {
  	this.callback = callback;
  	this.parent = parent;

  	this.intros = [];
  	this.outros = [];

  	this.children = [];
  	this.totalChildren = this.outroChildren = 0;

  	this.detachQueue = [];
  	this.decoratorQueue = [];
  	this.outrosComplete = false;

  	if (parent) {
  		parent.addChild(this);
  	}
  };

  TransitionManager.prototype = {
  	addChild: function (child) {
  		this.children.push(child);

  		this.totalChildren += 1;
  		this.outroChildren += 1;
  	},

  	decrementOutros: function () {
  		this.outroChildren -= 1;
  		check(this);
  	},

  	decrementTotal: function () {
  		this.totalChildren -= 1;
  		check(this);
  	},

  	add: function (transition) {
  		var list = transition.isIntro ? this.intros : this.outros;
  		list.push(transition);
  	},

  	addDecorator: function (decorator) {
  		this.decoratorQueue.push(decorator);
  	},

  	remove: function (transition) {
  		var list = transition.isIntro ? this.intros : this.outros;
  		removeFromArray(list, transition);
  		check(this);
  	},

  	init: function () {
  		this.ready = true;
  		check(this);
  	},

  	detachNodes: function () {
  		this.decoratorQueue.forEach(teardown);
  		this.detachQueue.forEach(detach);
  		this.children.forEach(detachNodes);
  	}
  };

  function detach(element) {
  	element.detach();
  }

  function detachNodes(tm) {
  	tm.detachNodes();
  }

  function check(tm) {
  	if (!tm.ready || tm.outros.length || tm.outroChildren) return;

  	// If all outros are complete, and we haven't already done this,
  	// we notify the parent if there is one, otherwise
  	// start detaching nodes
  	if (!tm.outrosComplete) {
  		if (tm.parent) {
  			tm.parent.decrementOutros(tm);
  		} else {
  			tm.detachNodes();
  		}

  		tm.outrosComplete = true;
  	}

  	// Once everything is done, we can notify parent transition
  	// manager and call the callback
  	if (!tm.intros.length && !tm.totalChildren) {
  		if (typeof tm.callback === "function") {
  			tm.callback();
  		}

  		if (tm.parent) {
  			tm.parent.decrementTotal();
  		}
  	}
  }

  var global_TransitionManager = TransitionManager;

  var batch,
      runloop,
      unresolved = [],
      changeHook = new hooks_Hook("change");

  runloop = {
  	start: function (instance, returnPromise) {
  		var promise, fulfilPromise;

  		if (returnPromise) {
  			promise = new utils_Promise(function (f) {
  				return fulfilPromise = f;
  			});
  		}

  		batch = {
  			previousBatch: batch,
  			transitionManager: new global_TransitionManager(fulfilPromise, batch && batch.transitionManager),
  			views: [],
  			tasks: [],
  			ractives: [],
  			instance: instance
  		};

  		if (instance) {
  			batch.ractives.push(instance);
  		}

  		return promise;
  	},

  	end: function () {
  		flushChanges();

  		batch.transitionManager.init();
  		if (!batch.previousBatch && !!batch.instance) batch.instance.viewmodel.changes = [];
  		batch = batch.previousBatch;
  	},

  	addRactive: function (ractive) {
  		if (batch) {
  			addToArray(batch.ractives, ractive);
  		}
  	},

  	registerTransition: function (transition) {
  		transition._manager = batch.transitionManager;
  		batch.transitionManager.add(transition);
  	},

  	registerDecorator: function (decorator) {
  		batch.transitionManager.addDecorator(decorator);
  	},

  	addView: function (view) {
  		batch.views.push(view);
  	},

  	addUnresolved: function (thing) {
  		unresolved.push(thing);
  	},

  	removeUnresolved: function (thing) {
  		removeFromArray(unresolved, thing);
  	},

  	// synchronise node detachments with transition ends
  	detachWhenReady: function (thing) {
  		batch.transitionManager.detachQueue.push(thing);
  	},

  	scheduleTask: function (task, postRender) {
  		var _batch;

  		if (!batch) {
  			task();
  		} else {
  			_batch = batch;
  			while (postRender && _batch.previousBatch) {
  				// this can't happen until the DOM has been fully updated
  				// otherwise in some situations (with components inside elements)
  				// transitions and decorators will initialise prematurely
  				_batch = _batch.previousBatch;
  			}

  			_batch.tasks.push(task);
  		}
  	}
  };

  var global_runloop = runloop;

  function flushChanges() {
  	var i, thing, changeHash;

  	while (batch.ractives.length) {
  		thing = batch.ractives.pop();
  		changeHash = thing.viewmodel.applyChanges();

  		if (changeHash) {
  			changeHook.fire(thing, changeHash);
  		}
  	}

  	attemptKeypathResolution();

  	// Now that changes have been fully propagated, we can update the DOM
  	// and complete other tasks
  	for (i = 0; i < batch.views.length; i += 1) {
  		batch.views[i].update();
  	}
  	batch.views.length = 0;

  	for (i = 0; i < batch.tasks.length; i += 1) {
  		batch.tasks[i]();
  	}
  	batch.tasks.length = 0;

  	// If updating the view caused some model blowback - e.g. a triple
  	// containing <option> elements caused the binding on the <select>
  	// to update - then we start over
  	if (batch.ractives.length) return flushChanges();
  }

  function attemptKeypathResolution() {
  	var i, item, keypath, resolved;

  	i = unresolved.length;

  	// see if we can resolve any unresolved references
  	while (i--) {
  		item = unresolved[i];

  		if (item.keypath) {
  			// it resolved some other way. TODO how? two-way binding? Seems
  			// weird that we'd still end up here
  			unresolved.splice(i, 1);
  			continue; // avoid removing the wrong thing should the next condition be true
  		}

  		if (keypath = shared_resolveRef(item.root, item.ref, item.parentFragment)) {
  			(resolved || (resolved = [])).push({
  				item: item,
  				keypath: keypath
  			});

  			unresolved.splice(i, 1);
  		}
  	}

  	if (resolved) {
  		resolved.forEach(global_runloop__resolve);
  	}
  }

  function global_runloop__resolve(resolved) {
  	resolved.item.resolve(resolved.keypath);
  }

  var queue = [];

  var animations = {
  	tick: function () {
  		var i, animation, now;

  		now = utils_getTime();

  		global_runloop.start();

  		for (i = 0; i < queue.length; i += 1) {
  			animation = queue[i];

  			if (!animation.tick(now)) {
  				// animation is complete, remove it from the stack, and decrement i so we don't miss one
  				queue.splice(i--, 1);
  			}
  		}

  		global_runloop.end();

  		if (queue.length) {
  			rAF(animations.tick);
  		} else {
  			animations.running = false;
  		}
  	},

  	add: function (animation) {
  		queue.push(animation);

  		if (!animations.running) {
  			animations.running = true;
  			rAF(animations.tick);
  		}
  	},

  	// TODO optimise this
  	abort: function (keypath, root) {
  		var i = queue.length,
  		    animation;

  		while (i--) {
  			animation = queue[i];

  			if (animation.root === root && animation.keypath === keypath) {
  				animation.stop();
  			}
  		}
  	}
  };

  var shared_animations = animations;

  var Animation = function (options) {
  	var key;

  	this.startTime = Date.now();

  	// from and to
  	for (key in options) {
  		if (options.hasOwnProperty(key)) {
  			this[key] = options[key];
  		}
  	}

  	this.interpolator = shared_interpolate(this.from, this.to, this.root, this.interpolator);
  	this.running = true;

  	this.tick();
  };

  Animation.prototype = {
  	tick: function () {
  		var elapsed, t, value, timeNow, index, keypath;

  		keypath = this.keypath;

  		if (this.running) {
  			timeNow = Date.now();
  			elapsed = timeNow - this.startTime;

  			if (elapsed >= this.duration) {
  				if (keypath !== null) {
  					global_runloop.start(this.root);
  					this.root.viewmodel.set(keypath, this.to);
  					global_runloop.end();
  				}

  				if (this.step) {
  					this.step(1, this.to);
  				}

  				this.complete(this.to);

  				index = this.root._animations.indexOf(this);

  				// TODO investigate why this happens
  				if (index === -1) {
  					warnIfDebug("Animation was not found");
  				}

  				this.root._animations.splice(index, 1);

  				this.running = false;
  				return false; // remove from the stack
  			}

  			t = this.easing ? this.easing(elapsed / this.duration) : elapsed / this.duration;

  			if (keypath !== null) {
  				value = this.interpolator(t);
  				global_runloop.start(this.root);
  				this.root.viewmodel.set(keypath, value);
  				global_runloop.end();
  			}

  			if (this.step) {
  				this.step(t, value);
  			}

  			return true; // keep in the stack
  		}

  		return false; // remove from the stack
  	},

  	stop: function () {
  		var index;

  		this.running = false;

  		index = this.root._animations.indexOf(this);

  		// TODO investigate why this happens
  		if (index === -1) {
  			warnIfDebug("Animation was not found");
  		}

  		this.root._animations.splice(index, 1);
  	}
  };

  var animate_Animation = Animation;

  var prototype_animate = Ractive$animate;

  var noAnimation = { stop: noop };
  function Ractive$animate(keypath, to, options) {
  	var promise, fulfilPromise, k, animation, animations, easing, duration, step, complete, makeValueCollector, currentValues, collectValue, dummy, dummyOptions;

  	promise = new utils_Promise(function (fulfil) {
  		return fulfilPromise = fulfil;
  	});

  	// animate multiple keypaths
  	if (typeof keypath === "object") {
  		options = to || {};
  		easing = options.easing;
  		duration = options.duration;

  		animations = [];

  		// we don't want to pass the `step` and `complete` handlers, as they will
  		// run for each animation! So instead we'll store the handlers and create
  		// our own...
  		step = options.step;
  		complete = options.complete;

  		if (step || complete) {
  			currentValues = {};

  			options.step = null;
  			options.complete = null;

  			makeValueCollector = function (keypath) {
  				return function (t, value) {
  					currentValues[keypath] = value;
  				};
  			};
  		}

  		for (k in keypath) {
  			if (keypath.hasOwnProperty(k)) {
  				if (step || complete) {
  					collectValue = makeValueCollector(k);
  					options = { easing: easing, duration: duration };

  					if (step) {
  						options.step = collectValue;
  					}
  				}

  				options.complete = complete ? collectValue : noop;
  				animations.push(animate(this, k, keypath[k], options));
  			}
  		}

  		// Create a dummy animation, to facilitate step/complete
  		// callbacks, and Promise fulfilment
  		dummyOptions = { easing: easing, duration: duration };

  		if (step) {
  			dummyOptions.step = function (t) {
  				return step(t, currentValues);
  			};
  		}

  		if (complete) {
  			promise.then(function (t) {
  				return complete(t, currentValues);
  			});
  		}

  		dummyOptions.complete = fulfilPromise;

  		dummy = animate(this, null, null, dummyOptions);
  		animations.push(dummy);

  		promise.stop = function () {
  			var animation;

  			while (animation = animations.pop()) {
  				animation.stop();
  			}

  			if (dummy) {
  				dummy.stop();
  			}
  		};

  		return promise;
  	}

  	// animate a single keypath
  	options = options || {};

  	if (options.complete) {
  		promise.then(options.complete);
  	}

  	options.complete = fulfilPromise;
  	animation = animate(this, keypath, to, options);

  	promise.stop = function () {
  		return animation.stop();
  	};
  	return promise;
  }

  function animate(root, keypath, to, options) {
  	var easing, duration, animation, from;

  	if (keypath) {
  		keypath = getKeypath(normalise(keypath));
  	}

  	if (keypath !== null) {
  		from = root.viewmodel.get(keypath);
  	}

  	// cancel any existing animation
  	// TODO what about upstream/downstream keypaths?
  	shared_animations.abort(keypath, root);

  	// don't bother animating values that stay the same
  	if (isEqual(from, to)) {
  		if (options.complete) {
  			options.complete(options.to);
  		}

  		return noAnimation;
  	}

  	// easing function
  	if (options.easing) {
  		if (typeof options.easing === "function") {
  			easing = options.easing;
  		} else {
  			easing = root.easing[options.easing];
  		}

  		if (typeof easing !== "function") {
  			easing = null;
  		}
  	}

  	// duration
  	duration = options.duration === undefined ? 400 : options.duration;

  	// TODO store keys, use an internal set method
  	animation = new animate_Animation({
  		keypath: keypath,
  		from: from,
  		to: to,
  		root: root,
  		duration: duration,
  		easing: easing,
  		interpolator: options.interpolator,

  		// TODO wrap callbacks if necessary, to use instance as context
  		step: options.step,
  		complete: options.complete
  	});

  	shared_animations.add(animation);
  	root._animations.push(animation);

  	return animation;
  }

  var prototype_detach = Ractive$detach;
  var prototype_detach__detachHook = new hooks_Hook("detach");
  function Ractive$detach() {
  	if (this.detached) {
  		return this.detached;
  	}

  	if (this.el) {
  		removeFromArray(this.el.__ractive_instances__, this);
  	}
  	this.detached = this.fragment.detach();
  	prototype_detach__detachHook.fire(this);
  	return this.detached;
  }

  var prototype_find = Ractive$find;

  function Ractive$find(selector) {
  	if (!this.el) {
  		return null;
  	}

  	return this.fragment.find(selector);
  }

  var test = Query$test;
  function Query$test(item, noDirty) {
  	var itemMatches;

  	if (this._isComponentQuery) {
  		itemMatches = !this.selector || item.name === this.selector;
  	} else {
  		itemMatches = item.node ? matches(item.node, this.selector) : null;
  	}

  	if (itemMatches) {
  		this.push(item.node || item.instance);

  		if (!noDirty) {
  			this._makeDirty();
  		}

  		return true;
  	}
  }

  var makeQuery_cancel = function () {
  	var liveQueries, selector, index;

  	liveQueries = this._root[this._isComponentQuery ? "liveComponentQueries" : "liveQueries"];
  	selector = this.selector;

  	index = liveQueries.indexOf(selector);

  	if (index !== -1) {
  		liveQueries.splice(index, 1);
  		liveQueries[selector] = null;
  	}
  };

  var sortByItemPosition = function (a, b) {
  	var ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;

  	ancestryA = getAncestry(a.component || a._ractive.proxy);
  	ancestryB = getAncestry(b.component || b._ractive.proxy);

  	oldestA = lastItem(ancestryA);
  	oldestB = lastItem(ancestryB);

  	// remove items from the end of both ancestries as long as they are identical
  	// - the final one removed is the closest mutual ancestor
  	while (oldestA && oldestA === oldestB) {
  		ancestryA.pop();
  		ancestryB.pop();

  		mutualAncestor = oldestA;

  		oldestA = lastItem(ancestryA);
  		oldestB = lastItem(ancestryB);
  	}

  	// now that we have the mutual ancestor, we can find which is earliest
  	oldestA = oldestA.component || oldestA;
  	oldestB = oldestB.component || oldestB;

  	fragmentA = oldestA.parentFragment;
  	fragmentB = oldestB.parentFragment;

  	// if both items share a parent fragment, our job is easy
  	if (fragmentA === fragmentB) {
  		indexA = fragmentA.items.indexOf(oldestA);
  		indexB = fragmentB.items.indexOf(oldestB);

  		// if it's the same index, it means one contains the other,
  		// so we see which has the longest ancestry
  		return indexA - indexB || ancestryA.length - ancestryB.length;
  	}

  	// if mutual ancestor is a section, we first test to see which section
  	// fragment comes first
  	if (fragments = mutualAncestor.fragments) {
  		indexA = fragments.indexOf(fragmentA);
  		indexB = fragments.indexOf(fragmentB);

  		return indexA - indexB || ancestryA.length - ancestryB.length;
  	}

  	throw new Error("An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!");
  };

  function getParent(item) {
  	var parentFragment;

  	if (parentFragment = item.parentFragment) {
  		return parentFragment.owner;
  	}

  	if (item.component && (parentFragment = item.component.parentFragment)) {
  		return parentFragment.owner;
  	}
  }

  function getAncestry(item) {
  	var ancestry, ancestor;

  	ancestry = [item];

  	ancestor = getParent(item);

  	while (ancestor) {
  		ancestry.push(ancestor);
  		ancestor = getParent(ancestor);
  	}

  	return ancestry;
  }

  var sortByDocumentPosition = function (node, otherNode) {
  	var bitmask;

  	if (node.compareDocumentPosition) {
  		bitmask = node.compareDocumentPosition(otherNode);
  		return bitmask & 2 ? 1 : -1;
  	}

  	// In old IE, we can piggy back on the mechanism for
  	// comparing component positions
  	return sortByItemPosition(node, otherNode);
  };

  var sort = function () {
  	this.sort(this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition);
  	this._dirty = false;
  };

  var makeQuery_dirty = function () {
  	var _this = this;

  	if (!this._dirty) {
  		this._dirty = true;

  		// Once the DOM has been updated, ensure the query
  		// is correctly ordered
  		global_runloop.scheduleTask(function () {
  			_this._sort();
  		});
  	}
  };

  var remove = function (nodeOrComponent) {
  	var index = this.indexOf(this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent);

  	if (index !== -1) {
  		this.splice(index, 1);
  	}
  };

  var _makeQuery = makeQuery;
  function makeQuery(ractive, selector, live, isComponentQuery) {
  	var query = [];

  	defineProperties(query, {
  		selector: { value: selector },
  		live: { value: live },

  		_isComponentQuery: { value: isComponentQuery },
  		_test: { value: test }
  	});

  	if (!live) {
  		return query;
  	}

  	defineProperties(query, {
  		cancel: { value: makeQuery_cancel },

  		_root: { value: ractive },
  		_sort: { value: sort },
  		_makeDirty: { value: makeQuery_dirty },
  		_remove: { value: remove },

  		_dirty: { value: false, writable: true }
  	});

  	return query;
  }

  var prototype_findAll = Ractive$findAll;
  function Ractive$findAll(selector, options) {
  	var liveQueries, query;

  	if (!this.el) {
  		return [];
  	}

  	options = options || {};
  	liveQueries = this._liveQueries;

  	// Shortcut: if we're maintaining a live query with this
  	// selector, we don't need to traverse the parallel DOM
  	if (query = liveQueries[selector]) {

  		// Either return the exact same query, or (if not live) a snapshot
  		return options && options.live ? query : query.slice();
  	}

  	query = _makeQuery(this, selector, !!options.live, false);

  	// Add this to the list of live queries Ractive needs to maintain,
  	// if applicable
  	if (query.live) {
  		liveQueries.push(selector);
  		liveQueries["_" + selector] = query;
  	}

  	this.fragment.findAll(selector, query);
  	return query;
  }

  var prototype_findAllComponents = Ractive$findAllComponents;
  function Ractive$findAllComponents(selector, options) {
  	var liveQueries, query;

  	options = options || {};
  	liveQueries = this._liveComponentQueries;

  	// Shortcut: if we're maintaining a live query with this
  	// selector, we don't need to traverse the parallel DOM
  	if (query = liveQueries[selector]) {

  		// Either return the exact same query, or (if not live) a snapshot
  		return options && options.live ? query : query.slice();
  	}

  	query = _makeQuery(this, selector, !!options.live, true);

  	// Add this to the list of live queries Ractive needs to maintain,
  	// if applicable
  	if (query.live) {
  		liveQueries.push(selector);
  		liveQueries["_" + selector] = query;
  	}

  	this.fragment.findAllComponents(selector, query);
  	return query;
  }

  var prototype_findComponent = Ractive$findComponent;

  function Ractive$findComponent(selector) {
  	return this.fragment.findComponent(selector);
  }

  var findContainer = Ractive$findContainer;

  function Ractive$findContainer(selector) {
  	if (this.container) {
  		if (this.container.component && this.container.component.name === selector) {
  			return this.container;
  		} else {
  			return this.container.findContainer(selector);
  		}
  	}

  	return null;
  }

  var findParent = Ractive$findParent;

  function Ractive$findParent(selector) {

  	if (this.parent) {
  		if (this.parent.component && this.parent.component.name === selector) {
  			return this.parent;
  		} else {
  			return this.parent.findParent(selector);
  		}
  	}

  	return null;
  }

  var eventStack = {
  	enqueue: function (ractive, event) {
  		if (ractive.event) {
  			ractive._eventQueue = ractive._eventQueue || [];
  			ractive._eventQueue.push(ractive.event);
  		}
  		ractive.event = event;
  	},
  	dequeue: function (ractive) {
  		if (ractive._eventQueue && ractive._eventQueue.length) {
  			ractive.event = ractive._eventQueue.pop();
  		} else {
  			delete ractive.event;
  		}
  	}
  };

  var shared_eventStack = eventStack;

  var shared_fireEvent = fireEvent;

  function fireEvent(ractive, eventName) {
  	var options = arguments[2] === undefined ? {} : arguments[2];

  	if (!eventName) {
  		return;
  	}

  	if (!options.event) {
  		options.event = {
  			name: eventName,
  			// until event not included as argument default
  			_noArg: true
  		};
  	} else {
  		options.event.name = eventName;
  	}

  	var eventNames = getKeypath(eventName).wildcardMatches();
  	fireEventAs(ractive, eventNames, options.event, options.args, true);
  }

  function fireEventAs(ractive, eventNames, event, args) {
  	var initialFire = arguments[4] === undefined ? false : arguments[4];

  	var subscribers,
  	    i,
  	    bubble = true;

  	shared_eventStack.enqueue(ractive, event);

  	for (i = eventNames.length; i >= 0; i--) {
  		subscribers = ractive._subs[eventNames[i]];

  		if (subscribers) {
  			bubble = notifySubscribers(ractive, subscribers, event, args) && bubble;
  		}
  	}

  	shared_eventStack.dequeue(ractive);

  	if (ractive.parent && bubble) {

  		if (initialFire && ractive.component) {
  			var fullName = ractive.component.name + "." + eventNames[eventNames.length - 1];
  			eventNames = getKeypath(fullName).wildcardMatches();

  			if (event) {
  				event.component = ractive;
  			}
  		}

  		fireEventAs(ractive.parent, eventNames, event, args);
  	}
  }

  function notifySubscribers(ractive, subscribers, event, args) {
  	var originalEvent = null,
  	    stopEvent = false;

  	if (event && !event._noArg) {
  		args = [event].concat(args);
  	}

  	// subscribers can be modified inflight, e.g. "once" functionality
  	// so we need to copy to make sure everyone gets called
  	subscribers = subscribers.slice();

  	for (var i = 0, len = subscribers.length; i < len; i += 1) {
  		if (subscribers[i].apply(ractive, args) === false) {
  			stopEvent = true;
  		}
  	}

  	if (event && !event._noArg && stopEvent && (originalEvent = event.original)) {
  		originalEvent.preventDefault && originalEvent.preventDefault();
  		originalEvent.stopPropagation && originalEvent.stopPropagation();
  	}

  	return !stopEvent;
  }

  var prototype_fire = Ractive$fire;
  function Ractive$fire(eventName) {

  	var options = {
  		args: Array.prototype.slice.call(arguments, 1)
  	};

  	shared_fireEvent(this, eventName, options);
  }

  var prototype_get = Ractive$get;
  var options = {
  	capture: true, // top-level calls should be intercepted
  	noUnwrap: true, // wrapped values should NOT be unwrapped
  	fullRootGet: true // root get should return mappings
  };
  function Ractive$get(keypath) {
  	var value;

  	keypath = getKeypath(normalise(keypath));
  	value = this.viewmodel.get(keypath, options);

  	// Create inter-component binding, if necessary
  	if (value === undefined && this.parent && !this.isolated) {
  		if (shared_resolveRef(this, keypath.str, this.component.parentFragment)) {
  			// creates binding as side-effect, if appropriate
  			value = this.viewmodel.get(keypath);
  		}
  	}

  	return value;
  }

  var insert = Ractive$insert;

  var insertHook = new hooks_Hook("insert");
  function Ractive$insert(target, anchor) {
  	if (!this.fragment.rendered) {
  		// TODO create, and link to, documentation explaining this
  		throw new Error("The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.");
  	}

  	target = getElement(target);
  	anchor = getElement(anchor) || null;

  	if (!target) {
  		throw new Error("You must specify a valid target to insert into");
  	}

  	target.insertBefore(this.detach(), anchor);
  	this.el = target;

  	(target.__ractive_instances__ || (target.__ractive_instances__ = [])).push(this);
  	this.detached = null;

  	fireInsertHook(this);
  }

  function fireInsertHook(ractive) {
  	insertHook.fire(ractive);

  	ractive.findAllComponents("*").forEach(function (child) {
  		fireInsertHook(child.instance);
  	});
  }

  var prototype_merge = Ractive$merge;
  function Ractive$merge(keypath, array, options) {
  	var currentArray, promise;

  	keypath = getKeypath(normalise(keypath));
  	currentArray = this.viewmodel.get(keypath);

  	// If either the existing value or the new value isn't an
  	// array, just do a regular set
  	if (!isArray(currentArray) || !isArray(array)) {
  		return this.set(keypath, array, options && options.complete);
  	}

  	// Manage transitions
  	promise = global_runloop.start(this, true);
  	this.viewmodel.merge(keypath, currentArray, array, options);
  	global_runloop.end();

  	return promise;
  }

  var Observer = function (ractive, keypath, callback, options) {
  	this.root = ractive;
  	this.keypath = keypath;
  	this.callback = callback;
  	this.defer = options.defer;

  	// default to root as context, but allow it to be overridden
  	this.context = options && options.context ? options.context : ractive;
  };

  Observer.prototype = {
  	init: function (immediate) {
  		this.value = this.root.get(this.keypath.str);

  		if (immediate !== false) {
  			this.update();
  		} else {
  			this.oldValue = this.value;
  		}
  	},

  	setValue: function (value) {
  		var _this = this;

  		if (!isEqual(value, this.value)) {
  			this.value = value;

  			if (this.defer && this.ready) {
  				global_runloop.scheduleTask(function () {
  					return _this.update();
  				});
  			} else {
  				this.update();
  			}
  		}
  	},

  	update: function () {
  		// Prevent infinite loops
  		if (this.updating) {
  			return;
  		}

  		this.updating = true;

  		this.callback.call(this.context, this.value, this.oldValue, this.keypath.str);
  		this.oldValue = this.value;

  		this.updating = false;
  	}
  };

  var observe_Observer = Observer;

  var observe_getPattern = getPattern;
  function getPattern(ractive, pattern) {
  	var matchingKeypaths, values;

  	matchingKeypaths = getMatchingKeypaths(ractive, pattern);

  	values = {};
  	matchingKeypaths.forEach(function (keypath) {
  		values[keypath.str] = ractive.get(keypath.str);
  	});

  	return values;
  }

  var PatternObserver,
      slice = Array.prototype.slice;

  PatternObserver = function (ractive, keypath, callback, options) {
  	this.root = ractive;

  	this.callback = callback;
  	this.defer = options.defer;

  	this.keypath = keypath;
  	this.regex = new RegExp("^" + keypath.str.replace(/\./g, "\\.").replace(/\*/g, "([^\\.]+)") + "$");
  	this.values = {};

  	if (this.defer) {
  		this.proxies = [];
  	}

  	// default to root as context, but allow it to be overridden
  	this.context = options && options.context ? options.context : ractive;
  };

  PatternObserver.prototype = {
  	init: function (immediate) {
  		var values, keypath;

  		values = observe_getPattern(this.root, this.keypath);

  		if (immediate !== false) {
  			for (keypath in values) {
  				if (values.hasOwnProperty(keypath)) {
  					this.update(getKeypath(keypath));
  				}
  			}
  		} else {
  			this.values = values;
  		}
  	},

  	update: function (keypath) {
  		var _this = this;

  		var values;

  		if (keypath.isPattern) {
  			values = observe_getPattern(this.root, keypath);

  			for (keypath in values) {
  				if (values.hasOwnProperty(keypath)) {
  					this.update(getKeypath(keypath));
  				}
  			}

  			return;
  		}

  		// special case - array mutation should not trigger `array.*`
  		// pattern observer with `array.length`
  		if (this.root.viewmodel.implicitChanges[keypath.str]) {
  			return;
  		}

  		if (this.defer && this.ready) {
  			global_runloop.scheduleTask(function () {
  				return _this.getProxy(keypath).update();
  			});
  			return;
  		}

  		this.reallyUpdate(keypath);
  	},

  	reallyUpdate: function (keypath) {
  		var keypathStr, value, keys, args;

  		keypathStr = keypath.str;
  		value = this.root.viewmodel.get(keypath);

  		// Prevent infinite loops
  		if (this.updating) {
  			this.values[keypathStr] = value;
  			return;
  		}

  		this.updating = true;

  		if (!isEqual(value, this.values[keypathStr]) || !this.ready) {
  			keys = slice.call(this.regex.exec(keypathStr), 1);
  			args = [value, this.values[keypathStr], keypathStr].concat(keys);

  			this.values[keypathStr] = value;
  			this.callback.apply(this.context, args);
  		}

  		this.updating = false;
  	},

  	getProxy: function (keypath) {
  		var _this = this;

  		if (!this.proxies[keypath.str]) {
  			this.proxies[keypath.str] = {
  				update: function () {
  					return _this.reallyUpdate(keypath);
  				}
  			};
  		}

  		return this.proxies[keypath.str];
  	}
  };

  var observe_PatternObserver = PatternObserver;

  var observe_getObserverFacade = getObserverFacade;
  var emptyObject = {};
  function getObserverFacade(ractive, keypath, callback, options) {
  	var observer, isPatternObserver, cancelled;

  	keypath = getKeypath(normalise(keypath));
  	options = options || emptyObject;

  	// pattern observers are treated differently
  	if (keypath.isPattern) {
  		observer = new observe_PatternObserver(ractive, keypath, callback, options);
  		ractive.viewmodel.patternObservers.push(observer);
  		isPatternObserver = true;
  	} else {
  		observer = new observe_Observer(ractive, keypath, callback, options);
  	}

  	observer.init(options.init);
  	ractive.viewmodel.register(keypath, observer, isPatternObserver ? "patternObservers" : "observers");

  	// This flag allows observers to initialise even with undefined values
  	observer.ready = true;

  	var facade = {
  		cancel: function () {
  			var index;

  			if (cancelled) {
  				return;
  			}

  			if (isPatternObserver) {
  				index = ractive.viewmodel.patternObservers.indexOf(observer);

  				ractive.viewmodel.patternObservers.splice(index, 1);
  				ractive.viewmodel.unregister(keypath, observer, "patternObservers");
  			} else {
  				ractive.viewmodel.unregister(keypath, observer, "observers");
  			}
  			cancelled = true;
  		}
  	};

  	ractive._observers.push(facade);
  	return facade;
  }

  var observe = Ractive$observe;
  function Ractive$observe(keypath, callback, options) {

  	var observers, map, keypaths, i;

  	// Allow a map of keypaths to handlers
  	if (isObject(keypath)) {
  		options = callback;
  		map = keypath;

  		observers = [];

  		for (keypath in map) {
  			if (map.hasOwnProperty(keypath)) {
  				callback = map[keypath];
  				observers.push(this.observe(keypath, callback, options));
  			}
  		}

  		return {
  			cancel: function () {
  				while (observers.length) {
  					observers.pop().cancel();
  				}
  			}
  		};
  	}

  	// Allow `ractive.observe( callback )` - i.e. observe entire model
  	if (typeof keypath === "function") {
  		options = callback;
  		callback = keypath;
  		keypath = "";

  		return observe_getObserverFacade(this, keypath, callback, options);
  	}

  	keypaths = keypath.split(" ");

  	// Single keypath
  	if (keypaths.length === 1) {
  		return observe_getObserverFacade(this, keypath, callback, options);
  	}

  	// Multiple space-separated keypaths
  	observers = [];

  	i = keypaths.length;
  	while (i--) {
  		keypath = keypaths[i];

  		if (keypath) {
  			observers.push(observe_getObserverFacade(this, keypath, callback, options));
  		}
  	}

  	return {
  		cancel: function () {
  			while (observers.length) {
  				observers.pop().cancel();
  			}
  		}
  	};
  }

  var observeOnce = Ractive$observeOnce;

  function Ractive$observeOnce(property, callback, options) {

  	var observer = this.observe(property, function () {
  		callback.apply(this, arguments);
  		observer.cancel();
  	}, { init: false, defer: options && options.defer });

  	return observer;
  }

  var shared_trim = function (str) {
    return str.trim();
  };

  var notEmptyString = function (str) {
    return str !== "";
  };

  var off = Ractive$off;
  function Ractive$off(eventName, callback) {
  	var _this = this;

  	var eventNames;

  	// if no arguments specified, remove all callbacks
  	if (!eventName) {
  		// TODO use this code instead, once the following issue has been resolved
  		// in PhantomJS (tests are unpassable otherwise!)
  		// https://github.com/ariya/phantomjs/issues/11856
  		// defineProperty( this, '_subs', { value: create( null ), configurable: true });
  		for (eventName in this._subs) {
  			delete this._subs[eventName];
  		}
  	} else {
  		// Handle multiple space-separated event names
  		eventNames = eventName.split(" ").map(shared_trim).filter(notEmptyString);

  		eventNames.forEach(function (eventName) {
  			var subscribers, index;

  			// If we have subscribers for this event...
  			if (subscribers = _this._subs[eventName]) {
  				// ...if a callback was specified, only remove that
  				if (callback) {
  					index = subscribers.indexOf(callback);
  					if (index !== -1) {
  						subscribers.splice(index, 1);
  					}
  				}

  				// ...otherwise remove all callbacks
  				else {
  					_this._subs[eventName] = [];
  				}
  			}
  		});
  	}

  	return this;
  }

  var on = Ractive$on;
  function Ractive$on(eventName, callback) {
  	var _this = this;

  	var listeners, n, eventNames;

  	// allow mutliple listeners to be bound in one go
  	if (typeof eventName === "object") {
  		listeners = [];

  		for (n in eventName) {
  			if (eventName.hasOwnProperty(n)) {
  				listeners.push(this.on(n, eventName[n]));
  			}
  		}

  		return {
  			cancel: function () {
  				var listener;

  				while (listener = listeners.pop()) {
  					listener.cancel();
  				}
  			}
  		};
  	}

  	// Handle multiple space-separated event names
  	eventNames = eventName.split(" ").map(shared_trim).filter(notEmptyString);

  	eventNames.forEach(function (eventName) {
  		(_this._subs[eventName] || (_this._subs[eventName] = [])).push(callback);
  	});

  	return {
  		cancel: function () {
  			return _this.off(eventName, callback);
  		}
  	};
  }

  var once = Ractive$once;

  function Ractive$once(eventName, handler) {

  	var listener = this.on(eventName, function () {
  		handler.apply(this, arguments);
  		listener.cancel();
  	});

  	// so we can still do listener.cancel() manually
  	return listener;
  }

  // This function takes an array, the name of a mutator method, and the
  // arguments to call that mutator method with, and returns an array that
  // maps the old indices to their new indices.

  // So if you had something like this...
  //
  //     array = [ 'a', 'b', 'c', 'd' ];
  //     array.push( 'e' );
  //
  // ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices
  // have changed. If you then did this...
  //
  //     array.unshift( 'z' );
  //
  // ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved
  // one higher to make room for the 'z'. If you removed an item, the new index
  // would be -1...
  //
  //     array.splice( 2, 2 );
  //
  // ...this would result in [ 0, 1, -1, -1, 2, 3 ].
  //
  // This information is used to enable fast, non-destructive shuffling of list
  // sections when you do e.g. `ractive.splice( 'items', 2, 2 );

  var shared_getNewIndices = getNewIndices;

  function getNewIndices(array, methodName, args) {
  	var spliceArguments,
  	    len,
  	    newIndices = [],
  	    removeStart,
  	    removeEnd,
  	    balance,
  	    i;

  	spliceArguments = getSpliceEquivalent(array, methodName, args);

  	if (!spliceArguments) {
  		return null; // TODO support reverse and sort?
  	}

  	len = array.length;
  	balance = spliceArguments.length - 2 - spliceArguments[1];

  	removeStart = Math.min(len, spliceArguments[0]);
  	removeEnd = removeStart + spliceArguments[1];

  	for (i = 0; i < removeStart; i += 1) {
  		newIndices.push(i);
  	}

  	for (; i < removeEnd; i += 1) {
  		newIndices.push(-1);
  	}

  	for (; i < len; i += 1) {
  		newIndices.push(i + balance);
  	}

  	// there is a net shift for the rest of the array starting with index + balance
  	if (balance !== 0) {
  		newIndices.touchedFrom = spliceArguments[0];
  	} else {
  		newIndices.touchedFrom = array.length;
  	}

  	return newIndices;
  }

  // The pop, push, shift an unshift methods can all be represented
  // as an equivalent splice
  function getSpliceEquivalent(array, methodName, args) {
  	switch (methodName) {
  		case "splice":
  			if (args[0] !== undefined && args[0] < 0) {
  				args[0] = array.length + Math.max(args[0], -array.length);
  			}

  			while (args.length < 2) {
  				args.push(0);
  			}

  			// ensure we only remove elements that exist
  			args[1] = Math.min(args[1], array.length - args[0]);

  			return args;

  		case "sort":
  		case "reverse":
  			return null;

  		case "pop":
  			if (array.length) {
  				return [array.length - 1, 1];
  			}
  			return [0, 0];

  		case "push":
  			return [array.length, 0].concat(args);

  		case "shift":
  			return [0, array.length ? 1 : 0];

  		case "unshift":
  			return [0, 0].concat(args);
  	}
  }

  var arrayProto = Array.prototype;

  var makeArrayMethod = function (methodName) {
  	return function (keypath) {
  		for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  			args[_key - 1] = arguments[_key];
  		}

  		var array,
  		    newIndices = [],
  		    len,
  		    promise,
  		    result;

  		keypath = getKeypath(normalise(keypath));

  		array = this.viewmodel.get(keypath);
  		len = array.length;

  		if (!isArray(array)) {
  			throw new Error("Called ractive." + methodName + "('" + keypath.str + "'), but '" + keypath.str + "' does not refer to an array");
  		}

  		newIndices = shared_getNewIndices(array, methodName, args);

  		result = arrayProto[methodName].apply(array, args);
  		promise = global_runloop.start(this, true).then(function () {
  			return result;
  		});

  		if (!!newIndices) {
  			this.viewmodel.smartUpdate(keypath, array, newIndices);
  		} else {
  			this.viewmodel.mark(keypath);
  		}

  		global_runloop.end();

  		return promise;
  	};
  };

  var pop = makeArrayMethod("pop");

  var push = makeArrayMethod("push");

  var css,
      update,
      styleElement,
      head,
      styleSheet,
      inDom,
      global_css__prefix = "/* Ractive.js component styles */\n",
      styles = [],
      dirty = false;

  if (!isClient) {
  	// TODO handle encapsulated CSS in server-rendered HTML!
  	css = {
  		add: noop,
  		apply: noop
  	};
  } else {
  	styleElement = document.createElement("style");
  	styleElement.type = "text/css";

  	head = document.getElementsByTagName("head")[0];

  	inDom = false;

  	// Internet Exploder won't let you use styleSheet.innerHTML - we have to
  	// use styleSheet.cssText instead
  	styleSheet = styleElement.styleSheet;

  	update = function () {
  		var css = global_css__prefix + styles.map(function (s) {
  			return "\n/* {" + s.id + "} */\n" + s.styles;
  		}).join("\n");

  		if (styleSheet) {
  			styleSheet.cssText = css;
  		} else {
  			styleElement.innerHTML = css;
  		}

  		if (!inDom) {
  			head.appendChild(styleElement);
  			inDom = true;
  		}
  	};

  	css = {
  		add: function (s) {
  			styles.push(s);
  			dirty = true;
  		},

  		apply: function () {
  			if (dirty) {
  				update();
  				dirty = false;
  			}
  		}
  	};
  }

  var global_css = css;

  var prototype_render = Ractive$render;

  var renderHook = new hooks_Hook("render"),
      completeHook = new hooks_Hook("complete");
  function Ractive$render(target, anchor) {
  	var _this = this;

  	var promise, instances, transitionsEnabled;

  	// if `noIntro` is `true`, temporarily disable transitions
  	transitionsEnabled = this.transitionsEnabled;
  	if (this.noIntro) {
  		this.transitionsEnabled = false;
  	}

  	promise = global_runloop.start(this, true);
  	global_runloop.scheduleTask(function () {
  		return renderHook.fire(_this);
  	}, true);

  	if (this.fragment.rendered) {
  		throw new Error("You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first");
  	}

  	target = getElement(target) || this.el;
  	anchor = getElement(anchor) || this.anchor;

  	this.el = target;
  	this.anchor = anchor;

  	if (!this.append && target) {
  		// Teardown any existing instances *before* trying to set up the new one -
  		// avoids certain weird bugs
  		var others = target.__ractive_instances__;
  		if (others && others.length) {
  			removeOtherInstances(others);
  		}

  		// make sure we are the only occupants
  		target.innerHTML = ""; // TODO is this quicker than removeChild? Initial research inconclusive
  	}

  	if (this.cssId) {
  		// ensure encapsulated CSS is up-to-date
  		global_css.apply();
  	}

  	if (target) {
  		if (!(instances = target.__ractive_instances__)) {
  			target.__ractive_instances__ = [this];
  		} else {
  			instances.push(this);
  		}

  		if (anchor) {
  			target.insertBefore(this.fragment.render(), anchor);
  		} else {
  			target.appendChild(this.fragment.render());
  		}
  	}

  	global_runloop.end();

  	this.transitionsEnabled = transitionsEnabled;

  	return promise.then(function () {
  		return completeHook.fire(_this);
  	});
  }

  function removeOtherInstances(others) {
  	others.splice(0, others.length).forEach(teardown);
  }

  var adaptConfigurator = {
  	extend: function (Parent, proto, options) {
  		proto.adapt = custom_adapt__combine(proto.adapt, ensureArray(options.adapt));
  	},

  	init: function () {}
  };

  var custom_adapt = adaptConfigurator;

  function custom_adapt__combine(a, b) {
  	var c = a.slice(),
  	    i = b.length;

  	while (i--) {
  		if (! ~c.indexOf(b[i])) {
  			c.push(b[i]);
  		}
  	}

  	return c;
  }

  var transform = transformCss;

  var selectorsPattern = /(?:^|\})?\s*([^\{\}]+)\s*\{/g,
      commentsPattern = /\/\*.*?\*\//g,
      selectorUnitPattern = /((?:(?:\[[^\]+]\])|(?:[^\s\+\>\~:]))+)((?::[^\s\+\>\~\(]+(?:\([^\)]+\))?)?\s*[\s\+\>\~]?)\s*/g,
      mediaQueryPattern = /^@media/,
      dataRvcGuidPattern = /\[data-ractive-css~="\{[a-z0-9-]+\}"]/g;
  function transformCss(css, id) {
  	var transformed, dataAttr, addGuid;

  	dataAttr = "[data-ractive-css~=\"{" + id + "}\"]";

  	addGuid = function (selector) {
  		var selectorUnits,
  		    match,
  		    unit,
  		    base,
  		    prepended,
  		    appended,
  		    i,
  		    transformed = [];

  		selectorUnits = [];

  		while (match = selectorUnitPattern.exec(selector)) {
  			selectorUnits.push({
  				str: match[0],
  				base: match[1],
  				modifiers: match[2]
  			});
  		}

  		// For each simple selector within the selector, we need to create a version
  		// that a) combines with the id, and b) is inside the id
  		base = selectorUnits.map(extractString);

  		i = selectorUnits.length;
  		while (i--) {
  			appended = base.slice();

  			// Pseudo-selectors should go after the attribute selector
  			unit = selectorUnits[i];
  			appended[i] = unit.base + dataAttr + unit.modifiers || "";

  			prepended = base.slice();
  			prepended[i] = dataAttr + " " + prepended[i];

  			transformed.push(appended.join(" "), prepended.join(" "));
  		}

  		return transformed.join(", ");
  	};

  	if (dataRvcGuidPattern.test(css)) {
  		transformed = css.replace(dataRvcGuidPattern, dataAttr);
  	} else {
  		transformed = css.replace(commentsPattern, "").replace(selectorsPattern, function (match, $1) {
  			var selectors, transformed;

  			// don't transform media queries!
  			if (mediaQueryPattern.test($1)) return match;

  			selectors = $1.split(",").map(trim);
  			transformed = selectors.map(addGuid).join(", ") + " ";

  			return match.replace($1, transformed);
  		});
  	}

  	return transformed;
  }

  function trim(str) {
  	if (str.trim) {
  		return str.trim();
  	}

  	return str.replace(/^\s+/, "").replace(/\s+$/, "");
  }

  function extractString(unit) {
  	return unit.str;
  }

  var css_css__uid = 1;

  var cssConfigurator = {
  	name: "css",

  	extend: function (Parent, proto, options) {
  		if (options.css) {
  			var id = css_css__uid++;
  			var styles = options.noCssTransform ? options.css : transform(options.css, id);

  			proto.cssId = id;
  			global_css.add({ id: id, styles: styles });
  		}
  	},

  	init: function () {}
  };

  var css_css = cssConfigurator;

  function validate(data) {
  	// Warn if userOptions.data is a non-POJO
  	if (data && data.constructor !== Object) {
  		if (typeof data === "function") {} else if (typeof data !== "object") {
  			fatal("data option must be an object or a function, `" + data + "` is not valid");
  		} else {
  			warnIfDebug("If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged");
  		}
  	}
  }

  var dataConfigurator = {
  	name: "data",

  	extend: function (Parent, proto, options) {
  		var key = undefined,
  		    value = undefined;

  		// check for non-primitives, which could cause mutation-related bugs
  		if (options.data && isObject(options.data)) {
  			for (key in options.data) {
  				value = options.data[key];

  				if (value && typeof value === "object") {
  					if (isObject(value) || isArray(value)) {
  						warnIfDebug("Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\n\n  // this...\n  data: function () {\n    return {\n      myObject: {}\n    };\n  })\n\n  // instead of this:\n  data: {\n    myObject: {}\n  }");
  					}
  				}
  			}
  		}

  		proto.data = custom_data__combine(proto.data, options.data);
  	},

  	init: function (Parent, ractive, options) {
  		var result = custom_data__combine(Parent.prototype.data, options.data);

  		if (typeof result === "function") {
  			result = result.call(ractive);
  		}

  		return result || {};
  	},

  	reset: function (ractive) {
  		var result = this.init(ractive.constructor, ractive, ractive.viewmodel);

  		ractive.viewmodel.reset(result);
  		return true;
  	}
  };

  var custom_data = dataConfigurator;

  function custom_data__combine(parentValue, childValue) {
  	validate(childValue);

  	var parentIsFn = typeof parentValue === "function";
  	var childIsFn = typeof childValue === "function";

  	// Very important, otherwise child instance can become
  	// the default data object on Ractive or a component.
  	// then ractive.set() ends up setting on the prototype!
  	if (!childValue && !parentIsFn) {
  		childValue = {};
  	}

  	// Fast path, where we just need to copy properties from
  	// parent to child
  	if (!parentIsFn && !childIsFn) {
  		return fromProperties(childValue, parentValue);
  	}

  	return function () {
  		var child = childIsFn ? callDataFunction(childValue, this) : childValue;
  		var parent = parentIsFn ? callDataFunction(parentValue, this) : parentValue;

  		return fromProperties(child, parent);
  	};
  }

  function callDataFunction(fn, context) {
  	var data = fn.call(context);

  	if (!data) return;

  	if (typeof data !== "object") {
  		fatal("Data function must return an object");
  	}

  	if (data.constructor !== Object) {
  		warnOnceIfDebug("Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged");
  	}

  	return data;
  }

  function fromProperties(primary, secondary) {
  	if (primary && secondary) {
  		for (var key in secondary) {
  			if (!(key in primary)) {
  				primary[key] = secondary[key];
  			}
  		}

  		return primary;
  	}

  	return primary || secondary;
  }

  // TODO do we need to support this in the new Ractive() case?

  var Parser,
      ParseError,
      parse_Parser__leadingWhitespace = /^\s+/;

  ParseError = function (message) {
  	this.name = "ParseError";
  	this.message = message;
  	try {
  		throw new Error(message);
  	} catch (e) {
  		this.stack = e.stack;
  	}
  };

  ParseError.prototype = Error.prototype;

  Parser = function (str, options) {
  	var items,
  	    item,
  	    lineStart = 0;

  	this.str = str;
  	this.options = options || {};
  	this.pos = 0;

  	this.lines = this.str.split("\n");
  	this.lineEnds = this.lines.map(function (line) {
  		var lineEnd = lineStart + line.length + 1; // +1 for the newline

  		lineStart = lineEnd;
  		return lineEnd;
  	}, 0);

  	// Custom init logic
  	if (this.init) this.init(str, options);

  	items = [];

  	while (this.pos < this.str.length && (item = this.read())) {
  		items.push(item);
  	}

  	this.leftover = this.remaining();
  	this.result = this.postProcess ? this.postProcess(items, options) : items;
  };

  Parser.prototype = {
  	read: function (converters) {
  		var pos, i, len, item;

  		if (!converters) converters = this.converters;

  		pos = this.pos;

  		len = converters.length;
  		for (i = 0; i < len; i += 1) {
  			this.pos = pos; // reset for each attempt

  			if (item = converters[i](this)) {
  				return item;
  			}
  		}

  		return null;
  	},

  	getLinePos: function (char) {
  		var lineNum = 0,
  		    lineStart = 0,
  		    columnNum;

  		while (char >= this.lineEnds[lineNum]) {
  			lineStart = this.lineEnds[lineNum];
  			lineNum += 1;
  		}

  		columnNum = char - lineStart;
  		return [lineNum + 1, columnNum + 1, char]; // line/col should be one-based, not zero-based!
  	},

  	error: function (message) {
  		var pos = this.getLinePos(this.pos);
  		var lineNum = pos[0];
  		var columnNum = pos[1];

  		var line = this.lines[pos[0] - 1];
  		var numTabs = 0;
  		var annotation = line.replace(/\t/g, function (match, char) {
  			if (char < pos[1]) {
  				numTabs += 1;
  			}

  			return "  ";
  		}) + "\n" + new Array(pos[1] + numTabs).join(" ") + "^----";

  		var error = new ParseError("" + message + " at line " + lineNum + " character " + columnNum + ":\n" + annotation);

  		error.line = pos[0];
  		error.character = pos[1];
  		error.shortMessage = message;

  		throw error;
  	},

  	matchString: function (string) {
  		if (this.str.substr(this.pos, string.length) === string) {
  			this.pos += string.length;
  			return string;
  		}
  	},

  	matchPattern: function (pattern) {
  		var match;

  		if (match = pattern.exec(this.remaining())) {
  			this.pos += match[0].length;
  			return match[1] || match[0];
  		}
  	},

  	allowWhitespace: function () {
  		this.matchPattern(parse_Parser__leadingWhitespace);
  	},

  	remaining: function () {
  		return this.str.substring(this.pos);
  	},

  	nextChar: function () {
  		return this.str.charAt(this.pos);
  	}
  };

  Parser.extend = function (proto) {
  	var Parent = this,
  	    Child,
  	    key;

  	Child = function (str, options) {
  		Parser.call(this, str, options);
  	};

  	Child.prototype = create(Parent.prototype);

  	for (key in proto) {
  		if (hasOwn.call(proto, key)) {
  			Child.prototype[key] = proto[key];
  		}
  	}

  	Child.extend = Parser.extend;
  	return Child;
  };

  var parse_Parser = Parser;

  var TEXT = 1;
  var INTERPOLATOR = 2;
  var TRIPLE = 3;
  var SECTION = 4;
  var INVERTED = 5;
  var CLOSING = 6;
  var ELEMENT = 7;
  var PARTIAL = 8;
  var COMMENT = 9;
  var DELIMCHANGE = 10;
  var ATTRIBUTE = 13;
  var CLOSING_TAG = 14;
  var COMPONENT = 15;
  var YIELDER = 16;
  var INLINE_PARTIAL = 17;
  var DOCTYPE = 18;

  var NUMBER_LITERAL = 20;
  var STRING_LITERAL = 21;
  var ARRAY_LITERAL = 22;
  var OBJECT_LITERAL = 23;
  var BOOLEAN_LITERAL = 24;
  var REGEXP_LITERAL = 25;

  var GLOBAL = 26;
  var KEY_VALUE_PAIR = 27;

  var REFERENCE = 30;
  var REFINEMENT = 31;
  var MEMBER = 32;
  var PREFIX_OPERATOR = 33;
  var BRACKETED = 34;
  var CONDITIONAL = 35;
  var INFIX_OPERATOR = 36;

  var INVOCATION = 40;

  var SECTION_IF = 50;
  var SECTION_UNLESS = 51;
  var SECTION_EACH = 52;
  var SECTION_WITH = 53;
  var SECTION_IF_WITH = 54;

  var ELSE = 60;
  var ELSEIF = 61;

  var mustache_readDelimiterChange = readDelimiterChange;
  var delimiterChangePattern = /^[^\s=]+/,
      whitespacePattern = /^\s+/;
  function readDelimiterChange(parser) {
  	var start, opening, closing;

  	if (!parser.matchString("=")) {
  		return null;
  	}

  	start = parser.pos;

  	// allow whitespace before new opening delimiter
  	parser.allowWhitespace();

  	opening = parser.matchPattern(delimiterChangePattern);
  	if (!opening) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace (in fact, it's necessary...)
  	if (!parser.matchPattern(whitespacePattern)) {
  		return null;
  	}

  	closing = parser.matchPattern(delimiterChangePattern);
  	if (!closing) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace before closing '='
  	parser.allowWhitespace();

  	if (!parser.matchString("=")) {
  		parser.pos = start;
  		return null;
  	}

  	return [opening, closing];
  }

  var readRegexpLiteral = readRegexpLiteral__readNumberLiteral;
  var regexpPattern = /^(\/(?:[^\n\r\u2028\u2029/\\[]|\\.|\[(?:[^\n\r\u2028\u2029\]\\]|\\.)*])+\/(?:([gimuy])(?![a-z]*\2))*(?![a-zA-Z_$0-9]))/;
  function readRegexpLiteral__readNumberLiteral(parser) {
  	var result;

  	if (result = parser.matchPattern(regexpPattern)) {
  		return {
  			t: REGEXP_LITERAL,
  			v: result
  		};
  	}

  	return null;
  }

  var converters_readMustache = readMustache;

  var delimiterChangeToken = { t: DELIMCHANGE, exclude: true };
  function readMustache(parser) {
  	var mustache, i;

  	// If we're inside a <script> or <style> tag, and we're not
  	// interpolating, bug out
  	if (parser.interpolate[parser.inside] === false) {
  		return null;
  	}

  	for (i = 0; i < parser.tags.length; i += 1) {
  		if (mustache = readMustacheOfType(parser, parser.tags[i])) {
  			return mustache;
  		}
  	}
  }

  function readMustacheOfType(parser, tag) {
  	var start, mustache, reader, i;

  	start = parser.pos;

  	if (parser.matchString("\\" + tag.open)) {
  		if (start === 0 || parser.str[start - 1] !== "\\") {
  			return tag.open;
  		}
  	} else if (!parser.matchString(tag.open)) {
  		return null;
  	}

  	// delimiter change?
  	if (mustache = mustache_readDelimiterChange(parser)) {
  		// find closing delimiter or abort...
  		if (!parser.matchString(tag.close)) {
  			return null;
  		}

  		// ...then make the switch
  		tag.open = mustache[0];
  		tag.close = mustache[1];
  		parser.sortMustacheTags();

  		return delimiterChangeToken;
  	}

  	parser.allowWhitespace();

  	// illegal section closer
  	if (parser.matchString("/")) {
  		parser.pos -= 1;
  		var rewind = parser.pos;
  		if (!readRegexpLiteral(parser)) {
  			parser.pos = rewind - tag.close.length;
  			parser.error("Attempted to close a section that wasn't open");
  		} else {
  			parser.pos = rewind;
  		}
  	}

  	for (i = 0; i < tag.readers.length; i += 1) {
  		reader = tag.readers[i];

  		if (mustache = reader(parser, tag)) {
  			if (tag.isStatic) {
  				mustache.s = true; // TODO make this `1` instead - more compact
  			}

  			if (parser.includeLinePositions) {
  				mustache.p = parser.getLinePos(start);
  			}

  			return mustache;
  		}
  	}

  	parser.pos = start;
  	return null;
  }

  var expectedExpression = "Expected a JavaScript expression";
  var expectedParen = "Expected closing paren";

  var literal_readNumberLiteral = literal_readNumberLiteral__readNumberLiteral;
  var literal_readNumberLiteral__numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
  function literal_readNumberLiteral__readNumberLiteral(parser) {
  	var result;

  	if (result = parser.matchPattern(literal_readNumberLiteral__numberPattern)) {
  		return {
  			t: NUMBER_LITERAL,
  			v: result
  		};
  	}

  	return null;
  }

  var literal_readBooleanLiteral = readBooleanLiteral;
  function readBooleanLiteral(parser) {
  	var remaining = parser.remaining();

  	if (remaining.substr(0, 4) === "true") {
  		parser.pos += 4;
  		return {
  			t: BOOLEAN_LITERAL,
  			v: "true"
  		};
  	}

  	if (remaining.substr(0, 5) === "false") {
  		parser.pos += 5;
  		return {
  			t: BOOLEAN_LITERAL,
  			v: "false"
  		};
  	}

  	return null;
  }

  var stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;

  // Match one or more characters until: ", ', \, or EOL/EOF.
  // EOL/EOF is written as (?!.) (meaning there's no non-newline char next).
  stringMiddlePattern = /^(?=.)[^"'\\]+?(?:(?!.)|(?=["'\\]))/;

  // Match one escape sequence, including the backslash.
  escapeSequencePattern = /^\\(?:['"\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;

  // Match one ES5 line continuation (backslash + line terminator).
  lineContinuationPattern = /^\\(?:\r\n|[\u000A\u000D\u2028\u2029])/;

  // Helper for defining getDoubleQuotedString and getSingleQuotedString.
  var makeQuotedStringMatcher = function (okQuote) {
  	return function (parser) {
  		var start, literal, done, next;

  		start = parser.pos;
  		literal = "\"";
  		done = false;

  		while (!done) {
  			next = parser.matchPattern(stringMiddlePattern) || parser.matchPattern(escapeSequencePattern) || parser.matchString(okQuote);
  			if (next) {
  				if (next === "\"") {
  					literal += "\\\"";
  				} else if (next === "\\'") {
  					literal += "'";
  				} else {
  					literal += next;
  				}
  			} else {
  				next = parser.matchPattern(lineContinuationPattern);
  				if (next) {
  					// convert \(newline-like) into a \u escape, which is allowed in JSON
  					literal += "\\u" + ("000" + next.charCodeAt(1).toString(16)).slice(-4);
  				} else {
  					done = true;
  				}
  			}
  		}

  		literal += "\"";

  		// use JSON.parse to interpret escapes
  		return JSON.parse(literal);
  	};
  };

  var getSingleQuotedString = makeQuotedStringMatcher("\"");
  var getDoubleQuotedString = makeQuotedStringMatcher("'");

  var readStringLiteral = function (parser) {
  	var start, string;

  	start = parser.pos;

  	if (parser.matchString("\"")) {
  		string = getDoubleQuotedString(parser);

  		if (!parser.matchString("\"")) {
  			parser.pos = start;
  			return null;
  		}

  		return {
  			t: STRING_LITERAL,
  			v: string
  		};
  	}

  	if (parser.matchString("'")) {
  		string = getSingleQuotedString(parser);

  		if (!parser.matchString("'")) {
  			parser.pos = start;
  			return null;
  		}

  		return {
  			t: STRING_LITERAL,
  			v: string
  		};
  	}

  	return null;
  };

  var patterns__name = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;

  // http://mathiasbynens.be/notes/javascript-properties
  // can be any name, string literal, or number literal
  var shared_readKey = readKey;
  var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
  function readKey(parser) {
  	var token;

  	if (token = readStringLiteral(parser)) {
  		return identifier.test(token.v) ? token.v : "\"" + token.v.replace(/"/g, "\\\"") + "\"";
  	}

  	if (token = literal_readNumberLiteral(parser)) {
  		return token.v;
  	}

  	if (token = parser.matchPattern(patterns__name)) {
  		return token;
  	}
  }

  var keyValuePair = readKeyValuePair;
  function readKeyValuePair(parser) {
  	var start, key, value;

  	start = parser.pos;

  	// allow whitespace between '{' and key
  	parser.allowWhitespace();

  	key = shared_readKey(parser);
  	if (key === null) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace between key and ':'
  	parser.allowWhitespace();

  	// next character must be ':'
  	if (!parser.matchString(":")) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace between ':' and value
  	parser.allowWhitespace();

  	// next expression must be a, well... expression
  	value = converters_readExpression(parser);
  	if (value === null) {
  		parser.pos = start;
  		return null;
  	}

  	return {
  		t: KEY_VALUE_PAIR,
  		k: key,
  		v: value
  	};
  }

  var objectLiteral_keyValuePairs = readKeyValuePairs;
  function readKeyValuePairs(parser) {
  	var start, pairs, pair, keyValuePairs;

  	start = parser.pos;

  	pair = keyValuePair(parser);
  	if (pair === null) {
  		return null;
  	}

  	pairs = [pair];

  	if (parser.matchString(",")) {
  		keyValuePairs = readKeyValuePairs(parser);

  		if (!keyValuePairs) {
  			parser.pos = start;
  			return null;
  		}

  		return pairs.concat(keyValuePairs);
  	}

  	return pairs;
  }

  var readObjectLiteral = function (parser) {
  	var start, keyValuePairs;

  	start = parser.pos;

  	// allow whitespace
  	parser.allowWhitespace();

  	if (!parser.matchString("{")) {
  		parser.pos = start;
  		return null;
  	}

  	keyValuePairs = objectLiteral_keyValuePairs(parser);

  	// allow whitespace between final value and '}'
  	parser.allowWhitespace();

  	if (!parser.matchString("}")) {
  		parser.pos = start;
  		return null;
  	}

  	return {
  		t: OBJECT_LITERAL,
  		m: keyValuePairs
  	};
  };

  var shared_readExpressionList = readExpressionList;
  function readExpressionList(parser) {
  	var start, expressions, expr, next;

  	start = parser.pos;

  	parser.allowWhitespace();

  	expr = converters_readExpression(parser);

  	if (expr === null) {
  		return null;
  	}

  	expressions = [expr];

  	// allow whitespace between expression and ','
  	parser.allowWhitespace();

  	if (parser.matchString(",")) {
  		next = readExpressionList(parser);
  		if (next === null) {
  			parser.error(expectedExpression);
  		}

  		next.forEach(append);
  	}

  	function append(expression) {
  		expressions.push(expression);
  	}

  	return expressions;
  }

  var readArrayLiteral = function (parser) {
  	var start, expressionList;

  	start = parser.pos;

  	// allow whitespace before '['
  	parser.allowWhitespace();

  	if (!parser.matchString("[")) {
  		parser.pos = start;
  		return null;
  	}

  	expressionList = shared_readExpressionList(parser);

  	if (!parser.matchString("]")) {
  		parser.pos = start;
  		return null;
  	}

  	return {
  		t: ARRAY_LITERAL,
  		m: expressionList
  	};
  };

  var primary_readLiteral = readLiteral;
  function readLiteral(parser) {
  	return literal_readNumberLiteral(parser) || literal_readBooleanLiteral(parser) || readStringLiteral(parser) || readObjectLiteral(parser) || readArrayLiteral(parser) || readRegexpLiteral(parser);
  }

  var primary_readReference = readReference;
  var prefixPattern = /^(?:~\/|(?:\.\.\/)+|\.\/(?:\.\.\/)*|\.)/,
      globals,
      keywords;

  // if a reference is a browser global, we don't deference it later, so it needs special treatment
  globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)\b/;

  // keywords are not valid references, with the exception of `this`
  keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;

  var legalReference = /^[a-zA-Z$_0-9]+(?:(?:\.[a-zA-Z$_0-9]+)|(?:\[[0-9]+\]))*/;
  var relaxedName = /^[a-zA-Z_$][-a-zA-Z_$0-9]*/;
  function readReference(parser) {
  	var startPos, prefix, name, global, reference, lastDotIndex;

  	startPos = parser.pos;

  	name = parser.matchPattern(/^@(?:keypath|index|key)/);

  	if (!name) {
  		prefix = parser.matchPattern(prefixPattern) || "";
  		name = !prefix && parser.relaxedNames && parser.matchPattern(relaxedName) || parser.matchPattern(legalReference);

  		if (!name && prefix === ".") {
  			prefix = "";
  			name = ".";
  		}
  	}

  	if (!name) {
  		return null;
  	}

  	// bug out if it's a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)
  	if (!prefix && !parser.relaxedNames && keywords.test(name)) {
  		parser.pos = startPos;
  		return null;
  	}

  	// if this is a browser global, stop here
  	if (!prefix && globals.test(name)) {
  		global = globals.exec(name)[0];
  		parser.pos = startPos + global.length;

  		return {
  			t: GLOBAL,
  			v: global
  		};
  	}

  	reference = (prefix || "") + normalise(name);

  	if (parser.matchString("(")) {
  		// if this is a method invocation (as opposed to a function) we need
  		// to strip the method name from the reference combo, else the context
  		// will be wrong
  		lastDotIndex = reference.lastIndexOf(".");
  		if (lastDotIndex !== -1) {
  			reference = reference.substr(0, lastDotIndex);
  			parser.pos = startPos + reference.length;
  		} else {
  			parser.pos -= 1;
  		}
  	}

  	return {
  		t: REFERENCE,
  		n: reference.replace(/^this\./, "./").replace(/^this$/, ".")
  	};
  }

  var primary_readBracketedExpression = readBracketedExpression;
  function readBracketedExpression(parser) {
  	var start, expr;

  	start = parser.pos;

  	if (!parser.matchString("(")) {
  		return null;
  	}

  	parser.allowWhitespace();

  	expr = converters_readExpression(parser);
  	if (!expr) {
  		parser.error(expectedExpression);
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString(")")) {
  		parser.error(expectedParen);
  	}

  	return {
  		t: BRACKETED,
  		x: expr
  	};
  }

  var readPrimary = function (parser) {
  	return primary_readLiteral(parser) || primary_readReference(parser) || primary_readBracketedExpression(parser);
  };

  var shared_readRefinement = readRefinement;
  function readRefinement(parser) {
  	var start, name, expr;

  	start = parser.pos;

  	parser.allowWhitespace();

  	// "." name
  	if (parser.matchString(".")) {
  		parser.allowWhitespace();

  		if (name = parser.matchPattern(patterns__name)) {
  			return {
  				t: REFINEMENT,
  				n: name
  			};
  		}

  		parser.error("Expected a property name");
  	}

  	// "[" expression "]"
  	if (parser.matchString("[")) {
  		parser.allowWhitespace();

  		expr = converters_readExpression(parser);
  		if (!expr) {
  			parser.error(expectedExpression);
  		}

  		parser.allowWhitespace();

  		if (!parser.matchString("]")) {
  			parser.error("Expected ']'");
  		}

  		return {
  			t: REFINEMENT,
  			x: expr
  		};
  	}

  	return null;
  }

  var readMemberOrInvocation = function (parser) {
  	var current, expression, refinement, expressionList;

  	expression = readPrimary(parser);

  	if (!expression) {
  		return null;
  	}

  	while (expression) {
  		current = parser.pos;

  		if (refinement = shared_readRefinement(parser)) {
  			expression = {
  				t: MEMBER,
  				x: expression,
  				r: refinement
  			};
  		} else if (parser.matchString("(")) {
  			parser.allowWhitespace();
  			expressionList = shared_readExpressionList(parser);

  			parser.allowWhitespace();

  			if (!parser.matchString(")")) {
  				parser.error(expectedParen);
  			}

  			expression = {
  				t: INVOCATION,
  				x: expression
  			};

  			if (expressionList) {
  				expression.o = expressionList;
  			}
  		} else {
  			break;
  		}
  	}

  	return expression;
  };

  var readTypeOf, makePrefixSequenceMatcher;

  makePrefixSequenceMatcher = function (symbol, fallthrough) {
  	return function (parser) {
  		var expression;

  		if (expression = fallthrough(parser)) {
  			return expression;
  		}

  		if (!parser.matchString(symbol)) {
  			return null;
  		}

  		parser.allowWhitespace();

  		expression = converters_readExpression(parser);
  		if (!expression) {
  			parser.error(expectedExpression);
  		}

  		return {
  			s: symbol,
  			o: expression,
  			t: PREFIX_OPERATOR
  		};
  	};
  };

  // create all prefix sequence matchers, return readTypeOf
  (function () {
  	var i, len, matcher, prefixOperators, fallthrough;

  	prefixOperators = "! ~ + - typeof".split(" ");

  	fallthrough = readMemberOrInvocation;
  	for (i = 0, len = prefixOperators.length; i < len; i += 1) {
  		matcher = makePrefixSequenceMatcher(prefixOperators[i], fallthrough);
  		fallthrough = matcher;
  	}

  	// typeof operator is higher precedence than multiplication, so provides the
  	// fallthrough for the multiplication sequence matcher we're about to create
  	// (we're skipping void and delete)
  	readTypeOf = fallthrough;
  })();

  var readTypeof = readTypeOf;

  var readLogicalOr, makeInfixSequenceMatcher;

  makeInfixSequenceMatcher = function (symbol, fallthrough) {
  	return function (parser) {
  		var start, left, right;

  		left = fallthrough(parser);
  		if (!left) {
  			return null;
  		}

  		// Loop to handle left-recursion in a case like `a * b * c` and produce
  		// left association, i.e. `(a * b) * c`.  The matcher can't call itself
  		// to parse `left` because that would be infinite regress.
  		while (true) {
  			start = parser.pos;

  			parser.allowWhitespace();

  			if (!parser.matchString(symbol)) {
  				parser.pos = start;
  				return left;
  			}

  			// special case - in operator must not be followed by [a-zA-Z_$0-9]
  			if (symbol === "in" && /[a-zA-Z_$0-9]/.test(parser.remaining().charAt(0))) {
  				parser.pos = start;
  				return left;
  			}

  			parser.allowWhitespace();

  			// right operand must also consist of only higher-precedence operators
  			right = fallthrough(parser);
  			if (!right) {
  				parser.pos = start;
  				return left;
  			}

  			left = {
  				t: INFIX_OPERATOR,
  				s: symbol,
  				o: [left, right]
  			};

  			// Loop back around.  If we don't see another occurrence of the symbol,
  			// we'll return left.
  		}
  	};
  };

  // create all infix sequence matchers, and return readLogicalOr
  (function () {
  	var i, len, matcher, infixOperators, fallthrough;

  	// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)
  	// Each sequence matcher will initially fall through to its higher precedence
  	// neighbour, and only attempt to match if one of the higher precedence operators
  	// (or, ultimately, a literal, reference, or bracketed expression) already matched
  	infixOperators = "* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||".split(" ");

  	// A typeof operator is higher precedence than multiplication
  	fallthrough = readTypeof;
  	for (i = 0, len = infixOperators.length; i < len; i += 1) {
  		matcher = makeInfixSequenceMatcher(infixOperators[i], fallthrough);
  		fallthrough = matcher;
  	}

  	// Logical OR is the fallthrough for the conditional matcher
  	readLogicalOr = fallthrough;
  })();

  var expressions_readLogicalOr = readLogicalOr;

  // The conditional operator is the lowest precedence operator, so we start here
  var readConditional = getConditional;
  function getConditional(parser) {
  	var start, expression, ifTrue, ifFalse;

  	expression = expressions_readLogicalOr(parser);
  	if (!expression) {
  		return null;
  	}

  	start = parser.pos;

  	parser.allowWhitespace();

  	if (!parser.matchString("?")) {
  		parser.pos = start;
  		return expression;
  	}

  	parser.allowWhitespace();

  	ifTrue = converters_readExpression(parser);
  	if (!ifTrue) {
  		parser.error(expectedExpression);
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString(":")) {
  		parser.error("Expected \":\"");
  	}

  	parser.allowWhitespace();

  	ifFalse = converters_readExpression(parser);
  	if (!ifFalse) {
  		parser.error(expectedExpression);
  	}

  	return {
  		t: CONDITIONAL,
  		o: [expression, ifTrue, ifFalse]
  	};
  }

  var converters_readExpression = readExpression;
  function readExpression(parser) {
  	// The conditional operator is the lowest precedence operator (except yield,
  	// assignment operators, and commas, none of which are supported), so we
  	// start there. If it doesn't match, it 'falls through' to progressively
  	// higher precedence operators, until it eventually matches (or fails to
  	// match) a 'primary' - a literal or a reference. This way, the abstract syntax
  	// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.
  	return readConditional(parser);
  }

  var utils_flattenExpression = flattenExpression;

  function flattenExpression(expression) {
  	var refs;

  	extractRefs(expression, refs = []);

  	return {
  		r: refs,
  		s: stringify(expression)
  	};

  	function stringify(node) {
  		switch (node.t) {
  			case BOOLEAN_LITERAL:
  			case GLOBAL:
  			case NUMBER_LITERAL:
  			case REGEXP_LITERAL:
  				return node.v;

  			case STRING_LITERAL:
  				return JSON.stringify(String(node.v));

  			case ARRAY_LITERAL:
  				return "[" + (node.m ? node.m.map(stringify).join(",") : "") + "]";

  			case OBJECT_LITERAL:
  				return "{" + (node.m ? node.m.map(stringify).join(",") : "") + "}";

  			case KEY_VALUE_PAIR:
  				return node.k + ":" + stringify(node.v);

  			case PREFIX_OPERATOR:
  				return (node.s === "typeof" ? "typeof " : node.s) + stringify(node.o);

  			case INFIX_OPERATOR:
  				return stringify(node.o[0]) + (node.s.substr(0, 2) === "in" ? " " + node.s + " " : node.s) + stringify(node.o[1]);

  			case INVOCATION:
  				return stringify(node.x) + "(" + (node.o ? node.o.map(stringify).join(",") : "") + ")";

  			case BRACKETED:
  				return "(" + stringify(node.x) + ")";

  			case MEMBER:
  				return stringify(node.x) + stringify(node.r);

  			case REFINEMENT:
  				return node.n ? "." + node.n : "[" + stringify(node.x) + "]";

  			case CONDITIONAL:
  				return stringify(node.o[0]) + "?" + stringify(node.o[1]) + ":" + stringify(node.o[2]);

  			case REFERENCE:
  				return "_" + refs.indexOf(node.n);

  			default:
  				throw new Error("Expected legal JavaScript");
  		}
  	}
  }

  // TODO maybe refactor this?
  function extractRefs(node, refs) {
  	var i, list;

  	if (node.t === REFERENCE) {
  		if (refs.indexOf(node.n) === -1) {
  			refs.unshift(node.n);
  		}
  	}

  	list = node.o || node.m;
  	if (list) {
  		if (isObject(list)) {
  			extractRefs(list, refs);
  		} else {
  			i = list.length;
  			while (i--) {
  				extractRefs(list[i], refs);
  			}
  		}
  	}

  	if (node.x) {
  		extractRefs(node.x, refs);
  	}

  	if (node.r) {
  		extractRefs(node.r, refs);
  	}

  	if (node.v) {
  		extractRefs(node.v, refs);
  	}
  }

  var utils_refineExpression = refineExpression;

  var arrayMemberPattern = /^[0-9][1-9]*$/;
  function refineExpression(expression, mustache) {
  	var referenceExpression;

  	if (expression) {
  		while (expression.t === BRACKETED && expression.x) {
  			expression = expression.x;
  		}

  		// special case - integers should be treated as array members references,
  		// rather than as expressions in their own right
  		if (expression.t === REFERENCE) {
  			mustache.r = expression.n;
  		} else {
  			if (expression.t === NUMBER_LITERAL && arrayMemberPattern.test(expression.v)) {
  				mustache.r = expression.v;
  			} else if (referenceExpression = getReferenceExpression(expression)) {
  				mustache.rx = referenceExpression;
  			} else {
  				mustache.x = utils_flattenExpression(expression);
  			}
  		}

  		return mustache;
  	}
  }

  // TODO refactor this! it's bewildering
  function getReferenceExpression(expression) {
  	var members = [],
  	    refinement;

  	while (expression.t === MEMBER && expression.r.t === REFINEMENT) {
  		refinement = expression.r;

  		if (refinement.x) {
  			if (refinement.x.t === REFERENCE) {
  				members.unshift(refinement.x);
  			} else {
  				members.unshift(utils_flattenExpression(refinement.x));
  			}
  		} else {
  			members.unshift(refinement.n);
  		}

  		expression = expression.x;
  	}

  	if (expression.t !== REFERENCE) {
  		return null;
  	}

  	return {
  		r: expression.n,
  		m: members
  	};
  }

  var mustache_readTriple = readTriple;
  function readTriple(parser, tag) {
  	var expression = converters_readExpression(parser),
  	    triple;

  	if (!expression) {
  		return null;
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	triple = { t: TRIPLE };
  	utils_refineExpression(expression, triple); // TODO handle this differently - it's mysterious

  	return triple;
  }

  var mustache_readUnescaped = readUnescaped;
  function readUnescaped(parser, tag) {
  	var expression, triple;

  	if (!parser.matchString("&")) {
  		return null;
  	}

  	parser.allowWhitespace();

  	expression = converters_readExpression(parser);

  	if (!expression) {
  		return null;
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	triple = { t: TRIPLE };
  	utils_refineExpression(expression, triple); // TODO handle this differently - it's mysterious

  	return triple;
  }

  var mustache_readPartial = readPartial;
  function readPartial(parser, tag) {
  	var start, nameStart, expression, context, partial;

  	start = parser.pos;

  	if (!parser.matchString(">")) {
  		return null;
  	}

  	parser.allowWhitespace();
  	nameStart = parser.pos;

  	// Partial names can include hyphens, so we can't use readExpression
  	// blindly. Instead, we use the `relaxedNames` flag to indicate that
  	// `foo-bar` should be read as a single name, rather than 'subtract
  	// bar from foo'
  	parser.relaxedNames = true;
  	expression = converters_readExpression(parser);
  	parser.relaxedNames = false;

  	parser.allowWhitespace();
  	context = converters_readExpression(parser);
  	parser.allowWhitespace();

  	if (!expression) {
  		return null;
  	}

  	partial = { t: PARTIAL };
  	utils_refineExpression(expression, partial); // TODO...

  	parser.allowWhitespace();

  	// if we have another expression - e.g. `{{>foo bar}}` - then
  	// we turn it into `{{#with bar}}{{>foo}}{{/with}}`
  	if (context) {
  		partial = {
  			t: SECTION,
  			n: SECTION_WITH,
  			f: [partial]
  		};

  		utils_refineExpression(context, partial);
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	return partial;
  }

  var readMustacheComment = readComment;
  function readComment(parser, tag) {
  	var index;

  	if (!parser.matchString("!")) {
  		return null;
  	}

  	index = parser.remaining().indexOf(tag.close);

  	if (index !== -1) {
  		parser.pos += index + tag.close.length;
  		return { t: COMMENT };
  	}
  }

  var converters_readExpressionOrReference = readExpressionOrReference;
  function readExpressionOrReference(parser, expectedFollowers) {
  	var start, expression, i;

  	start = parser.pos;
  	expression = converters_readExpression(parser);

  	if (!expression) {
  		return null;
  	}

  	for (i = 0; i < expectedFollowers.length; i += 1) {
  		if (parser.remaining().substr(0, expectedFollowers[i].length) === expectedFollowers[i]) {
  			return expression;
  		}
  	}

  	parser.pos = start;
  	return primary_readReference(parser);
  }

  var mustache_readInterpolator = readInterpolator;
  function readInterpolator(parser, tag) {
  	var start, expression, interpolator, err;

  	start = parser.pos;

  	// TODO would be good for perf if we could do away with the try-catch
  	try {
  		expression = converters_readExpressionOrReference(parser, [tag.close]);
  	} catch (e) {
  		err = e;
  	}

  	if (!expression) {
  		if (parser.str.charAt(start) === "!") {
  			// special case - comment
  			parser.pos = start;
  			return null;
  		}

  		if (err) {
  			throw err;
  		}
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "' after reference");

  		if (!expression) {
  			// special case - comment
  			if (parser.nextChar() === "!") {
  				return null;
  			}

  			parser.error("Expected expression or legal reference");
  		}
  	}

  	interpolator = { t: INTERPOLATOR };
  	utils_refineExpression(expression, interpolator); // TODO handle this differently - it's mysterious

  	return interpolator;
  }

  var mustache_readYielder = readYielder;
  var yieldPattern = /^yield\s*/;
  function readYielder(parser, tag) {
  	var start, name, yielder;

  	if (!parser.matchPattern(yieldPattern)) {
  		return null;
  	}

  	start = parser.pos;
  	name = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\-]*/);

  	parser.allowWhitespace();

  	if (!parser.matchString(tag.close)) {
  		parser.error("expected legal partial name");
  	}

  	yielder = { t: YIELDER };

  	if (name) {
  		yielder.n = name;
  	}

  	return yielder;
  }

  var section_readClosing = readClosing;
  function readClosing(parser, tag) {
  	var start, remaining, index, closing;

  	start = parser.pos;

  	if (!parser.matchString(tag.open)) {
  		return null;
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString("/")) {
  		parser.pos = start;
  		return null;
  	}

  	parser.allowWhitespace();

  	remaining = parser.remaining();
  	index = remaining.indexOf(tag.close);

  	if (index !== -1) {
  		closing = {
  			t: CLOSING,
  			r: remaining.substr(0, index).split(" ")[0]
  		};

  		parser.pos += index;

  		if (!parser.matchString(tag.close)) {
  			parser.error("Expected closing delimiter '" + tag.close + "'");
  		}

  		return closing;
  	}

  	parser.pos = start;
  	return null;
  }

  var section_readElse = section_readElse__readElse;
  var section_readElse__elsePattern = /^\s*else\s*/;
  function section_readElse__readElse(parser, tag) {
  	var start = parser.pos;

  	if (!parser.matchString(tag.open)) {
  		return null;
  	}

  	if (!parser.matchPattern(section_readElse__elsePattern)) {
  		parser.pos = start;
  		return null;
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	return {
  		t: ELSE
  	};
  }

  var readElseIf = readElseIf__readElse;
  var readElseIf__elsePattern = /^\s*elseif\s+/;
  function readElseIf__readElse(parser, tag) {
  	var start = parser.pos,
  	    expression;

  	if (!parser.matchString(tag.open)) {
  		return null;
  	}

  	if (!parser.matchPattern(readElseIf__elsePattern)) {
  		parser.pos = start;
  		return null;
  	}

  	expression = converters_readExpression(parser);

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	return {
  		t: ELSEIF,
  		x: expression
  	};
  }

  var handlebarsBlockCodes = {
  	each: SECTION_EACH,
  	"if": SECTION_IF,
  	"if-with": SECTION_IF_WITH,
  	"with": SECTION_WITH,
  	unless: SECTION_UNLESS
  };

  var mustache_readSection = readSection;

  var indexRefPattern = /^\s*:\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,
      keyIndexRefPattern = /^\s*,\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,
      handlebarsBlockPattern = new RegExp("^(" + Object.keys(handlebarsBlockCodes).join("|") + ")\\b");
  function readSection(parser, tag) {
  	var start, expression, section, child, children, hasElse, block, unlessBlock, conditions, closed, i, expectedClose;

  	start = parser.pos;

  	if (parser.matchString("^")) {
  		section = { t: SECTION, f: [], n: SECTION_UNLESS };
  	} else if (parser.matchString("#")) {
  		section = { t: SECTION, f: [] };

  		if (parser.matchString("partial")) {
  			parser.pos = start - parser.standardDelimiters[0].length;
  			parser.error("Partial definitions can only be at the top level of the template, or immediately inside components");
  		}

  		if (block = parser.matchPattern(handlebarsBlockPattern)) {
  			expectedClose = block;
  			section.n = handlebarsBlockCodes[block];
  		}
  	} else {
  		return null;
  	}

  	parser.allowWhitespace();

  	expression = converters_readExpression(parser);

  	if (!expression) {
  		parser.error("Expected expression");
  	}

  	// optional index and key references
  	if (i = parser.matchPattern(indexRefPattern)) {
  		var extra = undefined;

  		if (extra = parser.matchPattern(keyIndexRefPattern)) {
  			section.i = i + "," + extra;
  		} else {
  			section.i = i;
  		}
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	parser.sectionDepth += 1;
  	children = section.f;

  	conditions = [];

  	do {
  		if (child = section_readClosing(parser, tag)) {
  			if (expectedClose && child.r !== expectedClose) {
  				parser.error("Expected " + tag.open + "/" + expectedClose + "" + tag.close);
  			}

  			parser.sectionDepth -= 1;
  			closed = true;
  		} else if (child = readElseIf(parser, tag)) {
  			if (section.n === SECTION_UNLESS) {
  				parser.error("{{else}} not allowed in {{#unless}}");
  			}

  			if (hasElse) {
  				parser.error("illegal {{elseif...}} after {{else}}");
  			}

  			if (!unlessBlock) {
  				unlessBlock = createUnlessBlock(expression, section.n);
  			}

  			unlessBlock.f.push({
  				t: SECTION,
  				n: SECTION_IF,
  				x: utils_flattenExpression(mustache_readSection__combine(conditions.concat(child.x))),
  				f: children = []
  			});

  			conditions.push(invert(child.x));
  		} else if (child = section_readElse(parser, tag)) {
  			if (section.n === SECTION_UNLESS) {
  				parser.error("{{else}} not allowed in {{#unless}}");
  			}

  			if (hasElse) {
  				parser.error("there can only be one {{else}} block, at the end of a section");
  			}

  			hasElse = true;

  			// use an unless block if there's no elseif
  			if (!unlessBlock) {
  				unlessBlock = createUnlessBlock(expression, section.n);
  				children = unlessBlock.f;
  			} else {
  				unlessBlock.f.push({
  					t: SECTION,
  					n: SECTION_IF,
  					x: utils_flattenExpression(mustache_readSection__combine(conditions)),
  					f: children = []
  				});
  			}
  		} else {
  			child = parser.read(READERS);

  			if (!child) {
  				break;
  			}

  			children.push(child);
  		}
  	} while (!closed);

  	if (unlessBlock) {
  		// special case - `with` should become `if-with` (TODO is this right?
  		// seems to me that `with` ought to behave consistently, regardless
  		// of the presence/absence of `else`. In other words should always
  		// be `if-with`
  		if (section.n === SECTION_WITH) {
  			section.n = SECTION_IF_WITH;
  		}

  		section.l = unlessBlock;
  	}

  	utils_refineExpression(expression, section);

  	// TODO if a section is empty it should be discarded. Don't do
  	// that here though - we need to clean everything up first, as
  	// it may contain removeable whitespace. As a temporary measure,
  	// to pass the existing tests, remove empty `f` arrays
  	if (!section.f.length) {
  		delete section.f;
  	}

  	return section;
  }

  function createUnlessBlock(expression, sectionType) {
  	var unlessBlock;

  	if (sectionType === SECTION_WITH) {
  		// special case - a `{{#with foo}}` section will render if `foo` is
  		// truthy, so the `{{else}}` section needs to render if `foo` is falsy,
  		// rather than adhering to the normal `{{#unless foo}}` logic (which
  		// treats empty arrays/objects as falsy)
  		unlessBlock = {
  			t: SECTION,
  			n: SECTION_IF,
  			f: []
  		};

  		utils_refineExpression(invert(expression), unlessBlock);
  	} else {
  		unlessBlock = {
  			t: SECTION,
  			n: SECTION_UNLESS,
  			f: []
  		};

  		utils_refineExpression(expression, unlessBlock);
  	}

  	return unlessBlock;
  }

  function invert(expression) {
  	if (expression.t === PREFIX_OPERATOR && expression.s === "!") {
  		return expression.o;
  	}

  	return {
  		t: PREFIX_OPERATOR,
  		s: "!",
  		o: parensIfNecessary(expression)
  	};
  }

  function mustache_readSection__combine(expressions) {
  	if (expressions.length === 1) {
  		return expressions[0];
  	}

  	return {
  		t: INFIX_OPERATOR,
  		s: "&&",
  		o: [parensIfNecessary(expressions[0]), parensIfNecessary(mustache_readSection__combine(expressions.slice(1)))]
  	};
  }

  function parensIfNecessary(expression) {
  	// TODO only wrap if necessary
  	return {
  		t: BRACKETED,
  		x: expression
  	};
  }

  var converters_readHtmlComment = readHtmlComment;
  var OPEN_COMMENT = "<!--",
      CLOSE_COMMENT = "-->";
  function readHtmlComment(parser) {
  	var start, content, remaining, endIndex, comment;

  	start = parser.pos;

  	if (!parser.matchString(OPEN_COMMENT)) {
  		return null;
  	}

  	remaining = parser.remaining();
  	endIndex = remaining.indexOf(CLOSE_COMMENT);

  	if (endIndex === -1) {
  		parser.error("Illegal HTML - expected closing comment sequence ('-->')");
  	}

  	content = remaining.substr(0, endIndex);
  	parser.pos += endIndex + 3;

  	comment = {
  		t: COMMENT,
  		c: content
  	};

  	if (parser.includeLinePositions) {
  		comment.p = parser.getLinePos(start);
  	}

  	return comment;
  }

  var booleanAttributes, voidElementNames, htmlEntities, controlCharacters, entityPattern, lessThan, greaterThan, amp;

  // https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316
  booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;
  voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;

  htmlEntities = { quot: 34, amp: 38, apos: 39, lt: 60, gt: 62, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, int: 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830 };
  controlCharacters = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376];
  entityPattern = new RegExp("&(#?(?:x[\\w\\d]+|\\d+|" + Object.keys(htmlEntities).join("|") + "));?", "g");

  function decodeCharacterReferences(html) {
  	return html.replace(entityPattern, function (match, entity) {
  		var code;

  		// Handle named entities
  		if (entity[0] !== "#") {
  			code = htmlEntities[entity];
  		} else if (entity[1] === "x") {
  			code = parseInt(entity.substring(2), 16);
  		} else {
  			code = parseInt(entity.substring(1), 10);
  		}

  		if (!code) {
  			return match;
  		}

  		return String.fromCharCode(validateCode(code));
  	});
  }

  // some code points are verboten. If we were inserting HTML, the browser would replace the illegal
  // code points with alternatives in some cases - since we're bypassing that mechanism, we need
  // to replace them ourselves
  //
  // Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters
  function validateCode(code) {
  	if (!code) {
  		return 65533;
  	}

  	// line feed becomes generic whitespace
  	if (code === 10) {
  		return 32;
  	}

  	// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
  	if (code < 128) {
  		return code;
  	}

  	// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
  	// to correct the mistake or we'll end up with missing € signs and so on
  	if (code <= 159) {
  		return controlCharacters[code - 128];
  	}

  	// basic multilingual plane
  	if (code < 55296) {
  		return code;
  	}

  	// UTF-16 surrogate halves
  	if (code <= 57343) {
  		return 65533;
  	}

  	// rest of the basic multilingual plane
  	if (code <= 65535) {
  		return code;
  	}

  	return 65533;
  }

  lessThan = /</g;
  greaterThan = />/g;
  amp = /&/g;

  function escapeHtml(str) {
  	return str.replace(amp, "&amp;").replace(lessThan, "&lt;").replace(greaterThan, "&gt;");
  }

  var leadingLinebreak = /^\s*\r?\n/,
      trailingLinebreak = /\r?\n\s*$/;

  var stripStandalones = function (items) {
  	var i, current, backOne, backTwo, lastSectionItem;

  	for (i = 1; i < items.length; i += 1) {
  		current = items[i];
  		backOne = items[i - 1];
  		backTwo = items[i - 2];

  		// if we're at the end of a [text][comment][text] sequence...
  		if (isString(current) && isComment(backOne) && isString(backTwo)) {

  			// ... and the comment is a standalone (i.e. line breaks either side)...
  			if (trailingLinebreak.test(backTwo) && leadingLinebreak.test(current)) {

  				// ... then we want to remove the whitespace after the first line break
  				items[i - 2] = backTwo.replace(trailingLinebreak, "\n");

  				// and the leading line break of the second text token
  				items[i] = current.replace(leadingLinebreak, "");
  			}
  		}

  		// if the current item is a section, and it is preceded by a linebreak, and
  		// its first item is a linebreak...
  		if (isSection(current) && isString(backOne)) {
  			if (trailingLinebreak.test(backOne) && isString(current.f[0]) && leadingLinebreak.test(current.f[0])) {
  				items[i - 1] = backOne.replace(trailingLinebreak, "\n");
  				current.f[0] = current.f[0].replace(leadingLinebreak, "");
  			}
  		}

  		// if the last item was a section, and it is followed by a linebreak, and
  		// its last item is a linebreak...
  		if (isString(current) && isSection(backOne)) {
  			lastSectionItem = lastItem(backOne.f);

  			if (isString(lastSectionItem) && trailingLinebreak.test(lastSectionItem) && leadingLinebreak.test(current)) {
  				backOne.f[backOne.f.length - 1] = lastSectionItem.replace(trailingLinebreak, "\n");
  				items[i] = current.replace(leadingLinebreak, "");
  			}
  		}
  	}

  	return items;
  };

  function isString(item) {
  	return typeof item === "string";
  }

  function isComment(item) {
  	return item.t === COMMENT || item.t === DELIMCHANGE;
  }

  function isSection(item) {
  	return (item.t === SECTION || item.t === INVERTED) && item.f;
  }

  var trimWhitespace = function (items, leadingPattern, trailingPattern) {
  	var item;

  	if (leadingPattern) {
  		item = items[0];
  		if (typeof item === "string") {
  			item = item.replace(leadingPattern, "");

  			if (!item) {
  				items.shift();
  			} else {
  				items[0] = item;
  			}
  		}
  	}

  	if (trailingPattern) {
  		item = lastItem(items);
  		if (typeof item === "string") {
  			item = item.replace(trailingPattern, "");

  			if (!item) {
  				items.pop();
  			} else {
  				items[items.length - 1] = item;
  			}
  		}
  	}
  };

  var utils_cleanup = cleanup;
  var contiguousWhitespace = /[ \t\f\r\n]+/g;
  var preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i;
  var utils_cleanup__leadingWhitespace = /^[ \t\f\r\n]+/;
  var trailingWhitespace = /[ \t\f\r\n]+$/;
  var leadingNewLine = /^(?:\r\n|\r|\n)/;
  var trailingNewLine = /(?:\r\n|\r|\n)$/;
  function cleanup(items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace) {
  	var i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, key;

  	// First pass - remove standalones and comments etc
  	stripStandalones(items);

  	i = items.length;
  	while (i--) {
  		item = items[i];

  		// Remove delimiter changes, unsafe elements etc
  		if (item.exclude) {
  			items.splice(i, 1);
  		}

  		// Remove comments, unless we want to keep them
  		else if (stripComments && item.t === COMMENT) {
  			items.splice(i, 1);
  		}
  	}

  	// If necessary, remove leading and trailing whitespace
  	trimWhitespace(items, removeLeadingWhitespace ? utils_cleanup__leadingWhitespace : null, removeTrailingWhitespace ? trailingWhitespace : null);

  	i = items.length;
  	while (i--) {
  		item = items[i];

  		// Recurse
  		if (item.f) {
  			var isPreserveWhitespaceElement = item.t === ELEMENT && preserveWhitespaceElements.test(item.e);
  			preserveWhitespaceInsideFragment = preserveWhitespace || isPreserveWhitespaceElement;

  			if (!preserveWhitespace && isPreserveWhitespaceElement) {
  				trimWhitespace(item.f, leadingNewLine, trailingNewLine);
  			}

  			if (!preserveWhitespaceInsideFragment) {
  				previousItem = items[i - 1];
  				nextItem = items[i + 1];

  				// if the previous item was a text item with trailing whitespace,
  				// remove leading whitespace inside the fragment
  				if (!previousItem || typeof previousItem === "string" && trailingWhitespace.test(previousItem)) {
  					removeLeadingWhitespaceInsideFragment = true;
  				}

  				// and vice versa
  				if (!nextItem || typeof nextItem === "string" && utils_cleanup__leadingWhitespace.test(nextItem)) {
  					removeTrailingWhitespaceInsideFragment = true;
  				}
  			}

  			cleanup(item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  		}

  		// Split if-else blocks into two (an if, and an unless)
  		if (item.l) {
  			cleanup(item.l.f, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);

  			items.splice(i + 1, 0, item.l);
  			delete item.l; // TODO would be nice if there was a way around this
  		}

  		// Clean up element attributes
  		if (item.a) {
  			for (key in item.a) {
  				if (item.a.hasOwnProperty(key) && typeof item.a[key] !== "string") {
  					cleanup(item.a[key], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  				}
  			}
  		}

  		// Clean up conditional attributes
  		if (item.m) {
  			cleanup(item.m, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  		}

  		// Clean up event handlers
  		if (item.v) {
  			for (key in item.v) {
  				if (item.v.hasOwnProperty(key)) {
  					// clean up names
  					if (isArray(item.v[key].n)) {
  						cleanup(item.v[key].n, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  					}

  					// clean up params
  					if (isArray(item.v[key].d)) {
  						cleanup(item.v[key].d, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  					}
  				}
  			}
  		}
  	}

  	// final pass - fuse text nodes together
  	i = items.length;
  	while (i--) {
  		if (typeof items[i] === "string") {
  			if (typeof items[i + 1] === "string") {
  				items[i] = items[i] + items[i + 1];
  				items.splice(i + 1, 1);
  			}

  			if (!preserveWhitespace) {
  				items[i] = items[i].replace(contiguousWhitespace, " ");
  			}

  			if (items[i] === "") {
  				items.splice(i, 1);
  			}
  		}
  	}
  }

  var element_readClosingTag = readClosingTag;
  var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\-]*)\s*\>/;
  function readClosingTag(parser) {
  	var start, tag;

  	start = parser.pos;

  	// are we looking at a closing tag?
  	if (!parser.matchString("</")) {
  		return null;
  	}

  	if (tag = parser.matchPattern(closingTagPattern)) {
  		if (parser.inside && tag !== parser.inside) {
  			parser.pos = start;
  			return null;
  		}

  		return {
  			t: CLOSING_TAG,
  			e: tag
  		};
  	}

  	// We have an illegal closing tag, report it
  	parser.pos -= 2;
  	parser.error("Illegal closing tag");
  }

  var getLowestIndex = function (haystack, needles) {
  	var i, index, lowest;

  	i = needles.length;
  	while (i--) {
  		index = haystack.indexOf(needles[i]);

  		// short circuit
  		if (!index) {
  			return 0;
  		}

  		if (index === -1) {
  			continue;
  		}

  		if (!lowest || index < lowest) {
  			lowest = index;
  		}
  	}

  	return lowest || -1;
  };

  var element_readAttribute = readAttribute;

  var attributeNamePattern = /^[^\s"'>\/=]+/,
      unquotedAttributeValueTextPattern = /^[^\s"'=<>`]+/;
  function readAttribute(parser) {
  	var attr, name, value;

  	parser.allowWhitespace();

  	name = parser.matchPattern(attributeNamePattern);
  	if (!name) {
  		return null;
  	}

  	attr = { name: name };

  	value = readAttributeValue(parser);
  	if (value != null) {
  		// not null/undefined
  		attr.value = value;
  	}

  	return attr;
  }

  function readAttributeValue(parser) {
  	var start, valueStart, startDepth, value;

  	start = parser.pos;

  	// next character must be `=`, `/`, `>` or whitespace
  	if (!/[=\/>\s]/.test(parser.nextChar())) {
  		parser.error("Expected `=`, `/`, `>` or whitespace");
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString("=")) {
  		parser.pos = start;
  		return null;
  	}

  	parser.allowWhitespace();

  	valueStart = parser.pos;
  	startDepth = parser.sectionDepth;

  	value = readQuotedAttributeValue(parser, "'") || readQuotedAttributeValue(parser, "\"") || readUnquotedAttributeValue(parser);

  	if (value === null) {
  		parser.error("Expected valid attribute value");
  	}

  	if (parser.sectionDepth !== startDepth) {
  		parser.pos = valueStart;
  		parser.error("An attribute value must contain as many opening section tags as closing section tags");
  	}

  	if (!value.length) {
  		return "";
  	}

  	if (value.length === 1 && typeof value[0] === "string") {
  		return decodeCharacterReferences(value[0]);
  	}

  	return value;
  }

  function readUnquotedAttributeValueToken(parser) {
  	var start, text, haystack, needles, index;

  	start = parser.pos;

  	text = parser.matchPattern(unquotedAttributeValueTextPattern);

  	if (!text) {
  		return null;
  	}

  	haystack = text;
  	needles = parser.tags.map(function (t) {
  		return t.open;
  	}); // TODO refactor... we do this in readText.js as well

  	if ((index = getLowestIndex(haystack, needles)) !== -1) {
  		text = text.substr(0, index);
  		parser.pos = start + text.length;
  	}

  	return text;
  }

  function readUnquotedAttributeValue(parser) {
  	var tokens, token;

  	parser.inAttribute = true;

  	tokens = [];

  	token = converters_readMustache(parser) || readUnquotedAttributeValueToken(parser);
  	while (token !== null) {
  		tokens.push(token);
  		token = converters_readMustache(parser) || readUnquotedAttributeValueToken(parser);
  	}

  	if (!tokens.length) {
  		return null;
  	}

  	parser.inAttribute = false;
  	return tokens;
  }

  function readQuotedAttributeValue(parser, quoteMark) {
  	var start, tokens, token;

  	start = parser.pos;

  	if (!parser.matchString(quoteMark)) {
  		return null;
  	}

  	parser.inAttribute = quoteMark;

  	tokens = [];

  	token = converters_readMustache(parser) || readQuotedStringToken(parser, quoteMark);
  	while (token !== null) {
  		tokens.push(token);
  		token = converters_readMustache(parser) || readQuotedStringToken(parser, quoteMark);
  	}

  	if (!parser.matchString(quoteMark)) {
  		parser.pos = start;
  		return null;
  	}

  	parser.inAttribute = false;

  	return tokens;
  }

  function readQuotedStringToken(parser, quoteMark) {
  	var start, index, haystack, needles;

  	start = parser.pos;
  	haystack = parser.remaining();

  	needles = parser.tags.map(function (t) {
  		return t.open;
  	}); // TODO refactor... we do this in readText.js as well
  	needles.push(quoteMark);

  	index = getLowestIndex(haystack, needles);

  	if (index === -1) {
  		parser.error("Quoted attribute value must have a closing quote");
  	}

  	if (!index) {
  		return null;
  	}

  	parser.pos += index;
  	return haystack.substr(0, index);
  }

  var JsonParser, specials, specialsPattern, parseJSON__numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;

  specials = {
  	"true": true,
  	"false": false,
  	undefined: undefined,
  	"null": null
  };

  specialsPattern = new RegExp("^(?:" + Object.keys(specials).join("|") + ")");
  parseJSON__numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
  placeholderPattern = /\$\{([^\}]+)\}/g;
  placeholderAtStartPattern = /^\$\{([^\}]+)\}/;
  onlyWhitespace = /^\s*$/;

  JsonParser = parse_Parser.extend({
  	init: function (str, options) {
  		this.values = options.values;
  		this.allowWhitespace();
  	},

  	postProcess: function (result) {
  		if (result.length !== 1 || !onlyWhitespace.test(this.leftover)) {
  			return null;
  		}

  		return { value: result[0].v };
  	},

  	converters: [function getPlaceholder(parser) {
  		var placeholder;

  		if (!parser.values) {
  			return null;
  		}

  		placeholder = parser.matchPattern(placeholderAtStartPattern);

  		if (placeholder && parser.values.hasOwnProperty(placeholder)) {
  			return { v: parser.values[placeholder] };
  		}
  	}, function getSpecial(parser) {
  		var special;

  		if (special = parser.matchPattern(specialsPattern)) {
  			return { v: specials[special] };
  		}
  	}, function getNumber(parser) {
  		var number;

  		if (number = parser.matchPattern(parseJSON__numberPattern)) {
  			return { v: +number };
  		}
  	}, function getString(parser) {
  		var stringLiteral = readStringLiteral(parser),
  		    values;

  		if (stringLiteral && (values = parser.values)) {
  			return {
  				v: stringLiteral.v.replace(placeholderPattern, function (match, $1) {
  					return $1 in values ? values[$1] : $1;
  				})
  			};
  		}

  		return stringLiteral;
  	}, function getObject(parser) {
  		var result, pair;

  		if (!parser.matchString("{")) {
  			return null;
  		}

  		result = {};

  		parser.allowWhitespace();

  		if (parser.matchString("}")) {
  			return { v: result };
  		}

  		while (pair = getKeyValuePair(parser)) {
  			result[pair.key] = pair.value;

  			parser.allowWhitespace();

  			if (parser.matchString("}")) {
  				return { v: result };
  			}

  			if (!parser.matchString(",")) {
  				return null;
  			}
  		}

  		return null;
  	}, function getArray(parser) {
  		var result, valueToken;

  		if (!parser.matchString("[")) {
  			return null;
  		}

  		result = [];

  		parser.allowWhitespace();

  		if (parser.matchString("]")) {
  			return { v: result };
  		}

  		while (valueToken = parser.read()) {
  			result.push(valueToken.v);

  			parser.allowWhitespace();

  			if (parser.matchString("]")) {
  				return { v: result };
  			}

  			if (!parser.matchString(",")) {
  				return null;
  			}

  			parser.allowWhitespace();
  		}

  		return null;
  	}]
  });

  function getKeyValuePair(parser) {
  	var key, valueToken, pair;

  	parser.allowWhitespace();

  	key = shared_readKey(parser);

  	if (!key) {
  		return null;
  	}

  	pair = { key: key };

  	parser.allowWhitespace();
  	if (!parser.matchString(":")) {
  		return null;
  	}
  	parser.allowWhitespace();

  	valueToken = parser.read();
  	if (!valueToken) {
  		return null;
  	}

  	pair.value = valueToken.v;

  	return pair;
  }

  var parseJSON = function (str, values) {
  	var parser = new JsonParser(str, {
  		values: values
  	});

  	return parser.result;
  };

  // TODO clean this up, it's shocking
  var element_processDirective = processDirective;
  var methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\(/,
      methodCallExcessPattern = /\)\s*$/,
      ExpressionParser;

  ExpressionParser = parse_Parser.extend({
  	converters: [converters_readExpression]
  });
  function processDirective(tokens, parentParser) {
  	var result, match, parser, args, token, colonIndex, directiveName, directiveArgs, parsed;

  	if (typeof tokens === "string") {
  		if (match = methodCallPattern.exec(tokens)) {
  			var end = tokens.lastIndexOf(")");

  			// check for invalid method calls
  			if (!methodCallExcessPattern.test(tokens)) {
  				parentParser.error("Invalid input after method call expression '" + tokens.slice(end + 1) + "'");
  			}

  			result = { m: match[1] };
  			args = "[" + tokens.slice(result.m.length + 1, end) + "]";

  			parser = new ExpressionParser(args);
  			result.a = utils_flattenExpression(parser.result[0]);

  			return result;
  		}

  		if (tokens.indexOf(":") === -1) {
  			return tokens.trim();
  		}

  		tokens = [tokens];
  	}

  	result = {};

  	directiveName = [];
  	directiveArgs = [];

  	if (tokens) {
  		while (tokens.length) {
  			token = tokens.shift();

  			if (typeof token === "string") {
  				colonIndex = token.indexOf(":");

  				if (colonIndex === -1) {
  					directiveName.push(token);
  				} else {

  					// is the colon the first character?
  					if (colonIndex) {
  						// no
  						directiveName.push(token.substr(0, colonIndex));
  					}

  					// if there is anything after the colon in this token, treat
  					// it as the first token of the directiveArgs fragment
  					if (token.length > colonIndex + 1) {
  						directiveArgs[0] = token.substring(colonIndex + 1);
  					}

  					break;
  				}
  			} else {
  				directiveName.push(token);
  			}
  		}

  		directiveArgs = directiveArgs.concat(tokens);
  	}

  	if (!directiveName.length) {
  		result = "";
  	} else if (directiveArgs.length || typeof directiveName !== "string") {
  		result = {
  			// TODO is this really necessary? just use the array
  			n: directiveName.length === 1 && typeof directiveName[0] === "string" ? directiveName[0] : directiveName
  		};

  		if (directiveArgs.length === 1 && typeof directiveArgs[0] === "string") {
  			parsed = parseJSON("[" + directiveArgs[0] + "]");
  			result.a = parsed ? parsed.value : directiveArgs[0].trim();
  		} else {
  			result.d = directiveArgs;
  		}
  	} else {
  		result = directiveName;
  	}

  	return result;
  }

  var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/,
      validTagNameFollower = /^[\s\n\/>]/,
      onPattern = /^on/,
      proxyEventPattern = /^on-([a-zA-Z\\*\\.$_][a-zA-Z\\*\\.$_0-9\-]+)$/,
      reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/,
      directives = { "intro-outro": "t0", intro: "t1", outro: "t2", decorator: "o" },
      exclude = { exclude: true },
      disallowedContents;

  // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
  disallowedContents = {
  	li: ["li"],
  	dt: ["dt", "dd"],
  	dd: ["dt", "dd"],
  	p: "address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul".split(" "),
  	rt: ["rt", "rp"],
  	rp: ["rt", "rp"],
  	optgroup: ["optgroup"],
  	option: ["option", "optgroup"],
  	thead: ["tbody", "tfoot"],
  	tbody: ["tbody", "tfoot"],
  	tfoot: ["tbody"],
  	tr: ["tr", "tbody"],
  	td: ["td", "th", "tr"],
  	th: ["td", "th", "tr"]
  };

  var converters_readElement = readElement;

  function readElement(parser) {
  	var start, element, directiveName, match, addProxyEvent, attribute, directive, selfClosing, children, partials, hasPartials, child, closed, pos, remaining, closingTag;

  	start = parser.pos;

  	if (parser.inside || parser.inAttribute) {
  		return null;
  	}

  	if (!parser.matchString("<")) {
  		return null;
  	}

  	// if this is a closing tag, abort straight away
  	if (parser.nextChar() === "/") {
  		return null;
  	}

  	element = {};
  	if (parser.includeLinePositions) {
  		element.p = parser.getLinePos(start);
  	}

  	if (parser.matchString("!")) {
  		element.t = DOCTYPE;
  		if (!parser.matchPattern(/^doctype/i)) {
  			parser.error("Expected DOCTYPE declaration");
  		}

  		element.a = parser.matchPattern(/^(.+?)>/);
  		return element;
  	}

  	element.t = ELEMENT;

  	// element name
  	element.e = parser.matchPattern(tagNamePattern);
  	if (!element.e) {
  		return null;
  	}

  	// next character must be whitespace, closing solidus or '>'
  	if (!validTagNameFollower.test(parser.nextChar())) {
  		parser.error("Illegal tag name");
  	}

  	addProxyEvent = function (name, directive) {
  		var directiveName = directive.n || directive;

  		if (reservedEventNames.test(directiveName)) {
  			parser.pos -= directiveName.length;
  			parser.error("Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)");
  		}

  		element.v[name] = directive;
  	};

  	parser.allowWhitespace();

  	// directives and attributes
  	while (attribute = converters_readMustache(parser) || element_readAttribute(parser)) {
  		// regular attributes
  		if (attribute.name) {
  			// intro, outro, decorator
  			if (directiveName = directives[attribute.name]) {
  				element[directiveName] = element_processDirective(attribute.value, parser);
  			}

  			// on-click etc
  			else if (match = proxyEventPattern.exec(attribute.name)) {
  				if (!element.v) element.v = {};
  				directive = element_processDirective(attribute.value, parser);
  				addProxyEvent(match[1], directive);
  			} else {
  				if (!parser.sanitizeEventAttributes || !onPattern.test(attribute.name)) {
  					if (!element.a) element.a = {};
  					element.a[attribute.name] = attribute.value || (attribute.value === "" ? "" : 0);
  				}
  			}
  		}

  		// {{#if foo}}class='foo'{{/if}}
  		else {
  			if (!element.m) element.m = [];
  			element.m.push(attribute);
  		}

  		parser.allowWhitespace();
  	}

  	// allow whitespace before closing solidus
  	parser.allowWhitespace();

  	// self-closing solidus?
  	if (parser.matchString("/")) {
  		selfClosing = true;
  	}

  	// closing angle bracket
  	if (!parser.matchString(">")) {
  		return null;
  	}

  	var lowerCaseName = element.e.toLowerCase();
  	var preserveWhitespace = parser.preserveWhitespace;

  	if (!selfClosing && !voidElementNames.test(element.e)) {
  		parser.elementStack.push(lowerCaseName);

  		// Special case - if we open a script element, further tags should
  		// be ignored unless they're a closing script element
  		if (lowerCaseName === "script" || lowerCaseName === "style") {
  			parser.inside = lowerCaseName;
  		}

  		children = [];
  		partials = create(null);

  		do {
  			pos = parser.pos;
  			remaining = parser.remaining();

  			// if for example we're in an <li> element, and we see another
  			// <li> tag, close the first so they become siblings
  			if (!canContain(lowerCaseName, remaining)) {
  				closed = true;
  			}

  			// closing tag
  			else if (closingTag = element_readClosingTag(parser)) {
  				closed = true;

  				var closingTagName = closingTag.e.toLowerCase();

  				// if this *isn't* the closing tag for the current element...
  				if (closingTagName !== lowerCaseName) {
  					// rewind parser
  					parser.pos = pos;

  					// if it doesn't close a parent tag, error
  					if (! ~parser.elementStack.indexOf(closingTagName)) {
  						var errorMessage = "Unexpected closing tag";

  						// add additional help for void elements, since component names
  						// might clash with them
  						if (voidElementNames.test(closingTagName)) {
  							errorMessage += " (<" + closingTagName + "> is a void element - it cannot contain children)";
  						}

  						parser.error(errorMessage);
  					}
  				}
  			}

  			// implicit close by closing section tag. TODO clean this up
  			else if (child = section_readClosing(parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] })) {
  				closed = true;
  				parser.pos = pos;
  			} else {
  				if (child = parser.read(PARTIAL_READERS)) {
  					if (partials[child.n]) {
  						parser.pos = pos;
  						parser.error("Duplicate partial definition");
  					}

  					utils_cleanup(child.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);

  					partials[child.n] = child.f;
  					hasPartials = true;
  				} else {
  					if (child = parser.read(READERS)) {
  						children.push(child);
  					} else {
  						closed = true;
  					}
  				}
  			}
  		} while (!closed);

  		if (children.length) {
  			element.f = children;
  		}

  		if (hasPartials) {
  			element.p = partials;
  		}

  		parser.elementStack.pop();
  	}

  	parser.inside = null;

  	if (parser.sanitizeElements && parser.sanitizeElements.indexOf(lowerCaseName) !== -1) {
  		return exclude;
  	}

  	return element;
  }

  function canContain(name, remaining) {
  	var match, disallowed;

  	match = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec(remaining);
  	disallowed = disallowedContents[name];

  	if (!match || !disallowed) {
  		return true;
  	}

  	return ! ~disallowed.indexOf(match[1].toLowerCase());
  }

  var converters_readText = readText;
  function readText(parser) {
  	var index, remaining, disallowed, barrier;

  	remaining = parser.remaining();

  	barrier = parser.inside ? "</" + parser.inside : "<";

  	if (parser.inside && !parser.interpolate[parser.inside]) {
  		index = remaining.indexOf(barrier);
  	} else {
  		disallowed = parser.tags.map(function (t) {
  			return t.open;
  		});
  		disallowed = disallowed.concat(parser.tags.map(function (t) {
  			return "\\" + t.open;
  		}));

  		// http://developers.whatwg.org/syntax.html#syntax-attributes
  		if (parser.inAttribute === true) {
  			// we're inside an unquoted attribute value
  			disallowed.push("\"", "'", "=", "<", ">", "`");
  		} else if (parser.inAttribute) {
  			// quoted attribute value
  			disallowed.push(parser.inAttribute);
  		} else {
  			disallowed.push(barrier);
  		}

  		index = getLowestIndex(remaining, disallowed);
  	}

  	if (!index) {
  		return null;
  	}

  	if (index === -1) {
  		index = remaining.length;
  	}

  	parser.pos += index;

  	return parser.inside ? remaining.substr(0, index) : decodeCharacterReferences(remaining.substr(0, index));
  }

  var utils_escapeRegExp = escapeRegExp;
  var utils_escapeRegExp__pattern = /[-/\\^$*+?.()|[\]{}]/g;
  function escapeRegExp(str) {
  	return str.replace(utils_escapeRegExp__pattern, "\\$&");
  }

  var converters_readPartialDefinitionComment = readPartialDefinitionComment;

  var startPattern = /^<!--\s*/,
      namePattern = /s*>\s*([a-zA-Z_$][-a-zA-Z_$0-9]*)\s*/,
      finishPattern = /\s*-->/,
      child;

  function readPartialDefinitionComment(parser) {
  	var firstPos = parser.pos,
  	    open = parser.standardDelimiters[0],
  	    close = parser.standardDelimiters[1],
  	    content = undefined,
  	    closed = undefined;

  	if (!parser.matchPattern(startPattern) || !parser.matchString(open)) {
  		parser.pos = firstPos;
  		return null;
  	}

  	var name = parser.matchPattern(namePattern);

  	warnOnceIfDebug("Inline partial comments are deprecated.\nUse this...\n  {{#partial " + name + "}} ... {{/partial}}\n\n...instead of this:\n  <!-- {{>" + name + "}} --> ... <!-- {{/" + name + "}} -->'");

  	// make sure the rest of the comment is in the correct place
  	if (!parser.matchString(close) || !parser.matchPattern(finishPattern)) {
  		parser.pos = firstPos;
  		return null;
  	}

  	content = [];

  	var endPattern = new RegExp("^<!--\\s*" + utils_escapeRegExp(open) + "\\s*\\/\\s*" + name + "\\s*" + utils_escapeRegExp(close) + "\\s*-->");

  	do {
  		if (parser.matchPattern(endPattern)) {
  			closed = true;
  		} else {
  			child = parser.read(READERS);
  			if (!child) {
  				parser.error("expected closing comment ('<!-- " + open + "/" + name + "" + close + " -->')");
  			}

  			content.push(child);
  		}
  	} while (!closed);

  	return {
  		t: INLINE_PARTIAL,
  		f: content,
  		n: name
  	};
  }

  var converters_readPartialDefinitionSection = readPartialDefinitionSection;
  var partialDefinitionSectionPattern = /^#\s*partial\s+/;
  function readPartialDefinitionSection(parser) {
  	var start, name, content, child, closed;

  	start = parser.pos;

  	var delimiters = parser.standardDelimiters;

  	if (!parser.matchString(delimiters[0])) {
  		return null;
  	}

  	if (!parser.matchPattern(partialDefinitionSectionPattern)) {
  		parser.pos = start;
  		return null;
  	}

  	name = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\-]*/);

  	if (!name) {
  		parser.error("expected legal partial name");
  	}

  	if (!parser.matchString(delimiters[1])) {
  		parser.error("Expected closing delimiter '" + delimiters[1] + "'");
  	}

  	content = [];

  	do {
  		// TODO clean this up
  		if (child = section_readClosing(parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] })) {
  			if (!child.r === "partial") {
  				parser.error("Expected " + delimiters[0] + "/partial" + delimiters[1]);
  			}

  			closed = true;
  		} else {
  			child = parser.read(READERS);

  			if (!child) {
  				parser.error("Expected " + delimiters[0] + "/partial" + delimiters[1]);
  			}

  			content.push(child);
  		}
  	} while (!closed);

  	return {
  		t: INLINE_PARTIAL,
  		n: name,
  		f: content
  	};
  }

  var converters_readTemplate = readTemplate;
  function readTemplate(parser) {
  	var fragment = [];
  	var partials = create(null);
  	var hasPartials = false;

  	var preserveWhitespace = parser.preserveWhitespace;

  	while (parser.pos < parser.str.length) {
  		var pos = parser.pos,
  		    item = undefined,
  		    partial = undefined;

  		if (partial = parser.read(PARTIAL_READERS)) {
  			if (partials[partial.n]) {
  				parser.pos = pos;
  				parser.error("Duplicated partial definition");
  			}

  			utils_cleanup(partial.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);

  			partials[partial.n] = partial.f;
  			hasPartials = true;
  		} else if (item = parser.read(READERS)) {
  			fragment.push(item);
  		} else {
  			parser.error("Unexpected template content");
  		}
  	}

  	var result = {
  		v: TEMPLATE_VERSION,
  		t: fragment
  	};

  	if (hasPartials) {
  		result.p = partials;
  	}

  	return result;
  }

  var _parse = parse;

  var STANDARD_READERS = [mustache_readPartial, mustache_readUnescaped, mustache_readSection, mustache_readYielder, mustache_readInterpolator, readMustacheComment];
  var TRIPLE_READERS = [mustache_readTriple];
  var STATIC_READERS = [mustache_readUnescaped, mustache_readSection, mustache_readInterpolator]; // TODO does it make sense to have a static section?

  var StandardParser = undefined;
  function parse(template, options) {
  	return new StandardParser(template, options || {}).result;
  }

  var READERS = [converters_readMustache, converters_readHtmlComment, converters_readElement, converters_readText];
  var PARTIAL_READERS = [converters_readPartialDefinitionComment, converters_readPartialDefinitionSection];

  StandardParser = parse_Parser.extend({
  	init: function (str, options) {
  		var tripleDelimiters = options.tripleDelimiters || ["{{{", "}}}"],
  		    staticDelimiters = options.staticDelimiters || ["[[", "]]"],
  		    staticTripleDelimiters = options.staticTripleDelimiters || ["[[[", "]]]"];

  		this.standardDelimiters = options.delimiters || ["{{", "}}"];

  		this.tags = [{ isStatic: false, isTriple: false, open: this.standardDelimiters[0], close: this.standardDelimiters[1], readers: STANDARD_READERS }, { isStatic: false, isTriple: true, open: tripleDelimiters[0], close: tripleDelimiters[1], readers: TRIPLE_READERS }, { isStatic: true, isTriple: false, open: staticDelimiters[0], close: staticDelimiters[1], readers: STATIC_READERS }, { isStatic: true, isTriple: true, open: staticTripleDelimiters[0], close: staticTripleDelimiters[1], readers: TRIPLE_READERS }];

  		this.sortMustacheTags();

  		this.sectionDepth = 0;
  		this.elementStack = [];

  		this.interpolate = {
  			script: !options.interpolate || options.interpolate.script !== false,
  			style: !options.interpolate || options.interpolate.style !== false
  		};

  		if (options.sanitize === true) {
  			options.sanitize = {
  				// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json
  				elements: "applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title".split(" "),
  				eventAttributes: true
  			};
  		}

  		this.stripComments = options.stripComments !== false;
  		this.preserveWhitespace = options.preserveWhitespace;
  		this.sanitizeElements = options.sanitize && options.sanitize.elements;
  		this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;
  		this.includeLinePositions = options.includeLinePositions;
  	},

  	postProcess: function (result) {
  		// special case - empty string
  		if (!result.length) {
  			return { t: [], v: TEMPLATE_VERSION };
  		}

  		if (this.sectionDepth > 0) {
  			this.error("A section was left open");
  		}

  		utils_cleanup(result[0].t, this.stripComments, this.preserveWhitespace, !this.preserveWhitespace, !this.preserveWhitespace);

  		return result[0];
  	},

  	converters: [converters_readTemplate],

  	sortMustacheTags: function () {
  		// Sort in order of descending opening delimiter length (longer first),
  		// to protect against opening delimiters being substrings of each other
  		this.tags.sort(function (a, b) {
  			return b.open.length - a.open.length;
  		});
  	}
  });

  var parseOptions = ["preserveWhitespace", "sanitize", "stripComments", "delimiters", "tripleDelimiters", "interpolate"];

  var parser = {
  	fromId: fromId, isHashedId: isHashedId, isParsed: isParsed, getParseOptions: getParseOptions, createHelper: template_parser__createHelper,
  	parse: doParse
  };

  function template_parser__createHelper(parseOptions) {
  	var helper = create(parser);
  	helper.parse = function (template, options) {
  		return doParse(template, options || parseOptions);
  	};
  	return helper;
  }

  function doParse(template, parseOptions) {
  	if (!_parse) {
  		throw new Error("Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser");
  	}

  	return _parse(template, parseOptions || this.options);
  }

  function fromId(id, options) {
  	var template;

  	if (!isClient) {
  		if (options && options.noThrow) {
  			return;
  		}
  		throw new Error("Cannot retrieve template #" + id + " as Ractive is not running in a browser.");
  	}

  	if (isHashedId(id)) {
  		id = id.substring(1);
  	}

  	if (!(template = document.getElementById(id))) {
  		if (options && options.noThrow) {
  			return;
  		}
  		throw new Error("Could not find template element with id #" + id);
  	}

  	if (template.tagName.toUpperCase() !== "SCRIPT") {
  		if (options && options.noThrow) {
  			return;
  		}
  		throw new Error("Template element with id #" + id + ", must be a <script> element");
  	}

  	return "textContent" in template ? template.textContent : template.innerHTML;
  }

  function isHashedId(id) {
  	return id && id[0] === "#";
  }

  function isParsed(template) {
  	return !(typeof template === "string");
  }

  function getParseOptions(ractive) {
  	// Could be Ractive or a Component
  	if (ractive.defaults) {
  		ractive = ractive.defaults;
  	}

  	return parseOptions.reduce(function (val, key) {
  		val[key] = ractive[key];
  		return val;
  	}, {});
  }

  var template_parser = parser;

  var templateConfigurator = {
  	name: "template",

  	extend: function extend(Parent, proto, options) {
  		var template;

  		// only assign if exists
  		if ("template" in options) {
  			template = options.template;

  			if (typeof template === "function") {
  				proto.template = template;
  			} else {
  				proto.template = parseIfString(template, proto);
  			}
  		}
  	},

  	init: function init(Parent, ractive, options) {
  		var template, fn;

  		// TODO because of prototypal inheritance, we might just be able to use
  		// ractive.template, and not bother passing through the Parent object.
  		// At present that breaks the test mocks' expectations
  		template = "template" in options ? options.template : Parent.prototype.template;

  		if (typeof template === "function") {
  			fn = template;
  			template = getDynamicTemplate(ractive, fn);

  			ractive._config.template = {
  				fn: fn,
  				result: template
  			};
  		}

  		template = parseIfString(template, ractive);

  		// TODO the naming of this is confusing - ractive.template refers to [...],
  		// but Component.prototype.template refers to {v:1,t:[],p:[]}...
  		// it's unnecessary, because the developer never needs to access
  		// ractive.template
  		ractive.template = template.t;

  		if (template.p) {
  			extendPartials(ractive.partials, template.p);
  		}
  	},

  	reset: function (ractive) {
  		var result = resetValue(ractive),
  		    parsed;

  		if (result) {
  			parsed = parseIfString(result, ractive);

  			ractive.template = parsed.t;
  			extendPartials(ractive.partials, parsed.p, true);

  			return true;
  		}
  	}
  };

  function resetValue(ractive) {
  	var initial = ractive._config.template,
  	    result;

  	// If this isn't a dynamic template, there's nothing to do
  	if (!initial || !initial.fn) {
  		return;
  	}

  	result = getDynamicTemplate(ractive, initial.fn);

  	// TODO deep equality check to prevent unnecessary re-rendering
  	// in the case of already-parsed templates
  	if (result !== initial.result) {
  		initial.result = result;
  		result = parseIfString(result, ractive);
  		return result;
  	}
  }

  function getDynamicTemplate(ractive, fn) {
  	var helper = template_template__createHelper(template_parser.getParseOptions(ractive));
  	return fn.call(ractive, helper);
  }

  function template_template__createHelper(parseOptions) {
  	var helper = create(template_parser);
  	helper.parse = function (template, options) {
  		return template_parser.parse(template, options || parseOptions);
  	};
  	return helper;
  }

  function parseIfString(template, ractive) {
  	if (typeof template === "string") {
  		// ID of an element containing the template?
  		if (template[0] === "#") {
  			template = template_parser.fromId(template);
  		}

  		template = _parse(template, template_parser.getParseOptions(ractive));
  	}

  	// Check that the template even exists
  	else if (template == undefined) {
  		throw new Error("The template cannot be " + template + ".");
  	}

  	// Check the parsed template has a version at all
  	else if (typeof template.v !== "number") {
  		throw new Error("The template parser was passed a non-string template, but the template doesn't have a version.  Make sure you're passing in the template you think you are.");
  	}

  	// Check we're using the correct version
  	else if (template.v !== TEMPLATE_VERSION) {
  		throw new Error("Mismatched template version (expected " + TEMPLATE_VERSION + ", got " + template.v + ") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app");
  	}

  	return template;
  }

  function extendPartials(existingPartials, newPartials, overwrite) {
  	if (!newPartials) return;

  	// TODO there's an ambiguity here - we need to overwrite in the `reset()`
  	// case, but not initially...

  	for (var key in newPartials) {
  		if (overwrite || !existingPartials.hasOwnProperty(key)) {
  			existingPartials[key] = newPartials[key];
  		}
  	}
  }

  var template_template = templateConfigurator;

  var config_registries__registryNames, Registry, registries;

  config_registries__registryNames = ["adaptors", "components", "computed", "decorators", "easing", "events", "interpolators", "partials", "transitions"];

  Registry = function (name, useDefaults) {
  	this.name = name;
  	this.useDefaults = useDefaults;
  };

  Registry.prototype = {
  	constructor: Registry,

  	extend: function (Parent, proto, options) {
  		this.configure(this.useDefaults ? Parent.defaults : Parent, this.useDefaults ? proto : proto.constructor, options);
  	},

  	init: function () {},

  	configure: function (Parent, target, options) {
  		var name = this.name,
  		    option = options[name],
  		    registry;

  		registry = create(Parent[name]);

  		for (var key in option) {
  			registry[key] = option[key];
  		}

  		target[name] = registry;
  	},

  	reset: function (ractive) {
  		var registry = ractive[this.name];
  		var changed = false;
  		Object.keys(registry).forEach(function (key) {
  			var item = registry[key];
  			if (item._fn) {
  				if (item._fn.isOwner) {
  					registry[key] = item._fn;
  				} else {
  					delete registry[key];
  				}
  				changed = true;
  			}
  		});
  		return changed;
  	}
  };

  registries = config_registries__registryNames.map(function (name) {
  	return new Registry(name, name === "computed");
  });

  var config_registries = registries;

  /*this.configure(
  	this.useDefaults ? Parent.defaults : Parent,
  	ractive,
  	options );*/

  var wrapPrototype = wrap;

  function wrap(parent, name, method) {
  	if (!/_super/.test(method)) {
  		return method;
  	}

  	var wrapper = function wrapSuper() {
  		var superMethod = getSuperMethod(wrapper._parent, name),
  		    hasSuper = ("_super" in this),
  		    oldSuper = this._super,
  		    result;

  		this._super = superMethod;

  		result = method.apply(this, arguments);

  		if (hasSuper) {
  			this._super = oldSuper;
  		} else {
  			delete this._super;
  		}

  		return result;
  	};

  	wrapper._parent = parent;
  	wrapper._method = method;

  	return wrapper;
  }

  function getSuperMethod(parent, name) {
  	var value, method;

  	if (name in parent) {
  		value = parent[name];

  		if (typeof value === "function") {
  			method = value;
  		} else {
  			method = function returnValue() {
  				return value;
  			};
  		}
  	} else {
  		method = noop;
  	}

  	return method;
  }

  var config_deprecate = deprecate;
  function getMessage(deprecated, correct, isError) {
  	return "options." + deprecated + " has been deprecated in favour of options." + correct + "." + (isError ? " You cannot specify both options, please use options." + correct + "." : "");
  }

  function deprecateOption(options, deprecatedOption, correct) {
  	if (deprecatedOption in options) {
  		if (!(correct in options)) {
  			warnIfDebug(getMessage(deprecatedOption, correct));
  			options[correct] = options[deprecatedOption];
  		} else {
  			throw new Error(getMessage(deprecatedOption, correct, true));
  		}
  	}
  }
  function deprecate(options) {
  	deprecateOption(options, "beforeInit", "onconstruct");
  	deprecateOption(options, "init", "onrender");
  	deprecateOption(options, "complete", "oncomplete");
  	deprecateOption(options, "eventDefinitions", "events");

  	// Using extend with Component instead of options,
  	// like Human.extend( Spider ) means adaptors as a registry
  	// gets copied to options. So we have to check if actually an array
  	if (isArray(options.adaptors)) {
  		deprecateOption(options, "adaptors", "adapt");
  	}
  }

  var config, order, defaultKeys, custom, isBlacklisted, isStandardKey;

  custom = {
  	adapt: custom_adapt,
  	css: css_css,
  	data: custom_data,
  	template: template_template
  };

  defaultKeys = Object.keys(config_defaults);

  isStandardKey = makeObj(defaultKeys.filter(function (key) {
  	return !custom[key];
  }));

  // blacklisted keys that we don't double extend
  isBlacklisted = makeObj(defaultKeys.concat(config_registries.map(function (r) {
  	return r.name;
  })));

  order = [].concat(defaultKeys.filter(function (key) {
  	return !config_registries[key] && !custom[key];
  }), config_registries, custom.data, custom.template, custom.css);

  config = {
  	extend: function (Parent, proto, options) {
  		return configure("extend", Parent, proto, options);
  	},

  	init: function (Parent, ractive, options) {
  		return configure("init", Parent, ractive, options);
  	},

  	reset: function (ractive) {
  		return order.filter(function (c) {
  			return c.reset && c.reset(ractive);
  		}).map(function (c) {
  			return c.name;
  		});
  	},

  	// this defines the order. TODO this isn't used anywhere in the codebase,
  	// only in the test suite - should get rid of it
  	order: order };

  function configure(method, Parent, target, options) {
  	config_deprecate(options);

  	for (var key in options) {
  		if (isStandardKey.hasOwnProperty(key)) {
  			var value = options[key];

  			// warn the developer if they passed a function and ignore its value

  			// NOTE: we allow some functions on "el" because we duck type element lists
  			// and some libraries or ef'ed-up virtual browsers (phantomJS) return a
  			// function object as the result of querySelector methods
  			if (key !== "el" && typeof value === "function") {
  				warnIfDebug("" + key + " is a Ractive option that does not expect a function and will be ignored", method === "init" ? target : null);
  			} else {
  				target[key] = value;
  			}
  		}
  	}

  	config_registries.forEach(function (registry) {
  		registry[method](Parent, target, options);
  	});

  	custom_adapt[method](Parent, target, options);
  	template_template[method](Parent, target, options);
  	css_css[method](Parent, target, options);

  	extendOtherMethods(Parent.prototype, target, options);
  }

  function extendOtherMethods(parent, target, options) {
  	for (var key in options) {
  		if (!isBlacklisted[key] && options.hasOwnProperty(key)) {
  			var member = options[key];

  			// if this is a method that overwrites a method, wrap it:
  			if (typeof member === "function") {
  				member = wrapPrototype(parent, key, member);
  			}

  			target[key] = member;
  		}
  	}
  }

  function makeObj(array) {
  	var obj = {};
  	array.forEach(function (x) {
  		return obj[x] = true;
  	});
  	return obj;
  }

  var config_config = config;

  var prototype_bubble = Fragment$bubble;

  function Fragment$bubble() {
  	this.dirtyValue = this.dirtyArgs = true;

  	if (this.bound && typeof this.owner.bubble === "function") {
  		this.owner.bubble();
  	}
  }

  var Fragment_prototype_detach = Fragment$detach;

  function Fragment$detach() {
  	var docFrag;

  	if (this.items.length === 1) {
  		return this.items[0].detach();
  	}

  	docFrag = document.createDocumentFragment();

  	this.items.forEach(function (item) {
  		var node = item.detach();

  		// TODO The if {...} wasn't previously required - it is now, because we're
  		// forcibly detaching everything to reorder sections after an update. That's
  		// a non-ideal brute force approach, implemented to get all the tests to pass
  		// - as soon as it's replaced with something more elegant, this should
  		// revert to `docFrag.appendChild( item.detach() )`
  		if (node) {
  			docFrag.appendChild(node);
  		}
  	});

  	return docFrag;
  }

  var Fragment_prototype_find = Fragment$find;

  function Fragment$find(selector) {
  	var i, len, item, queryResult;

  	if (this.items) {
  		len = this.items.length;
  		for (i = 0; i < len; i += 1) {
  			item = this.items[i];

  			if (item.find && (queryResult = item.find(selector))) {
  				return queryResult;
  			}
  		}

  		return null;
  	}
  }

  var Fragment_prototype_findAll = Fragment$findAll;

  function Fragment$findAll(selector, query) {
  	var i, len, item;

  	if (this.items) {
  		len = this.items.length;
  		for (i = 0; i < len; i += 1) {
  			item = this.items[i];

  			if (item.findAll) {
  				item.findAll(selector, query);
  			}
  		}
  	}

  	return query;
  }

  var Fragment_prototype_findAllComponents = Fragment$findAllComponents;

  function Fragment$findAllComponents(selector, query) {
  	var i, len, item;

  	if (this.items) {
  		len = this.items.length;
  		for (i = 0; i < len; i += 1) {
  			item = this.items[i];

  			if (item.findAllComponents) {
  				item.findAllComponents(selector, query);
  			}
  		}
  	}

  	return query;
  }

  var Fragment_prototype_findComponent = Fragment$findComponent;

  function Fragment$findComponent(selector) {
  	var len, i, item, queryResult;

  	if (this.items) {
  		len = this.items.length;
  		for (i = 0; i < len; i += 1) {
  			item = this.items[i];

  			if (item.findComponent && (queryResult = item.findComponent(selector))) {
  				return queryResult;
  			}
  		}

  		return null;
  	}
  }

  var prototype_findNextNode = Fragment$findNextNode;

  function Fragment$findNextNode(item) {
  	var index = item.index,
  	    node;

  	if (this.items[index + 1]) {
  		node = this.items[index + 1].firstNode();
  	}

  	// if this is the root fragment, and there are no more items,
  	// it means we're at the end...
  	else if (this.owner === this.root) {
  		if (!this.owner.component) {
  			// TODO but something else could have been appended to
  			// this.root.el, no?
  			node = null;
  		}

  		// ...unless this is a component
  		else {
  			node = this.owner.component.findNextNode();
  		}
  	} else {
  		node = this.owner.findNextNode(this);
  	}

  	return node;
  }

  var prototype_firstNode = Fragment$firstNode;

  function Fragment$firstNode() {
  	if (this.items && this.items[0]) {
  		return this.items[0].firstNode();
  	}

  	return null;
  }

  var shared_processItems = processItems;

  function processItems(items, values, guid, counter) {
  	counter = counter || 0;

  	return items.map(function (item) {
  		var placeholderId, wrapped, value;

  		if (item.text) {
  			return item.text;
  		}

  		if (item.fragments) {
  			return item.fragments.map(function (fragment) {
  				return processItems(fragment.items, values, guid, counter);
  			}).join("");
  		}

  		placeholderId = guid + "-" + counter++;

  		if (item.keypath && (wrapped = item.root.viewmodel.wrapped[item.keypath.str])) {
  			value = wrapped.value;
  		} else {
  			value = item.getValue();
  		}

  		values[placeholderId] = value;

  		return "${" + placeholderId + "}";
  	}).join("");
  }

  var getArgsList = Fragment$getArgsList;
  function Fragment$getArgsList() {
  	var values, source, parsed, result;

  	if (this.dirtyArgs) {
  		source = shared_processItems(this.items, values = {}, this.root._guid);
  		parsed = parseJSON("[" + source + "]", values);

  		if (!parsed) {
  			result = [this.toString()];
  		} else {
  			result = parsed.value;
  		}

  		this.argsList = result;
  		this.dirtyArgs = false;
  	}

  	return this.argsList;
  }

  var getNode = Fragment$getNode;

  function Fragment$getNode() {
  	var fragment = this;

  	do {
  		if (fragment.pElement) {
  			return fragment.pElement.node;
  		}
  	} while (fragment = fragment.parent);

  	return this.root.detached || this.root.el;
  }

  var prototype_getValue = Fragment$getValue;
  function Fragment$getValue() {
  	var values, source, parsed, result;

  	if (this.dirtyValue) {
  		source = shared_processItems(this.items, values = {}, this.root._guid);
  		parsed = parseJSON(source, values);

  		if (!parsed) {
  			result = this.toString();
  		} else {
  			result = parsed.value;
  		}

  		this.value = result;
  		this.dirtyValue = false;
  	}

  	return this.value;
  }

  var shared_detach = function () {
  	return detachNode(this.node);
  };

  var Text = function (options) {
  	this.type = TEXT;
  	this.text = options.template;
  };

  Text.prototype = {
  	detach: shared_detach,

  	firstNode: function () {
  		return this.node;
  	},

  	render: function () {
  		if (!this.node) {
  			this.node = document.createTextNode(this.text);
  		}

  		return this.node;
  	},

  	toString: function (escape) {
  		return escape ? escapeHtml(this.text) : this.text;
  	},

  	unrender: function (shouldDestroy) {
  		if (shouldDestroy) {
  			return this.detach();
  		}
  	}
  };

  var items_Text = Text;

  var shared_unbind = shared_unbind__unbind;

  function shared_unbind__unbind() {
  	if (this.registered) {
  		// this was registered as a dependant
  		this.root.viewmodel.unregister(this.keypath, this);
  	}

  	if (this.resolver) {
  		this.resolver.unbind();
  	}
  }

  var Mustache_getValue = Mustache$getValue;

  function Mustache$getValue() {
  	return this.value;
  }

  var ReferenceResolver = function (owner, ref, callback) {
  	var keypath;

  	this.ref = ref;
  	this.resolved = false;

  	this.root = owner.root;
  	this.parentFragment = owner.parentFragment;
  	this.callback = callback;

  	keypath = shared_resolveRef(owner.root, ref, owner.parentFragment);
  	if (keypath != undefined) {
  		this.resolve(keypath);
  	} else {
  		global_runloop.addUnresolved(this);
  	}
  };

  ReferenceResolver.prototype = {
  	resolve: function (keypath) {
  		if (this.keypath && !keypath) {
  			// it was resolved, and now it's not. Can happen if e.g. `bar` in
  			// `{{foo[bar]}}` becomes undefined
  			global_runloop.addUnresolved(this);
  		}

  		this.resolved = true;

  		this.keypath = keypath;
  		this.callback(keypath);
  	},

  	forceResolution: function () {
  		this.resolve(getKeypath(this.ref));
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		var keypath;

  		if (this.keypath != undefined) {
  			keypath = this.keypath.replace(oldKeypath, newKeypath);
  			// was a new keypath created?
  			if (keypath !== undefined) {
  				// resolve it
  				this.resolve(keypath);
  			}
  		}
  	},

  	unbind: function () {
  		if (!this.resolved) {
  			global_runloop.removeUnresolved(this);
  		}
  	}
  };

  var Resolvers_ReferenceResolver = ReferenceResolver;

  var SpecialResolver = function (owner, ref, callback) {
  	this.parentFragment = owner.parentFragment;
  	this.ref = ref;
  	this.callback = callback;

  	this.rebind();
  };

  var props = {
  	"@keypath": { prefix: "c", prop: ["context"] },
  	"@index": { prefix: "i", prop: ["index"] },
  	"@key": { prefix: "k", prop: ["key", "index"] }
  };

  function getProp(target, prop) {
  	var value;
  	for (var i = 0; i < prop.prop.length; i++) {
  		if ((value = target[prop.prop[i]]) !== undefined) {
  			return value;
  		}
  	}
  }

  SpecialResolver.prototype = {
  	rebind: function () {
  		var ref = this.ref,
  		    fragment = this.parentFragment,
  		    prop = props[ref],
  		    value;

  		if (!prop) {
  			throw new Error("Unknown special reference \"" + ref + "\" - valid references are @index, @key and @keypath");
  		}

  		// have we already found the nearest parent?
  		if (this.cached) {
  			return this.callback(getKeypath("@" + prop.prefix + getProp(this.cached, prop)));
  		}

  		// special case for indices, which may cross component boundaries
  		if (prop.prop.indexOf("index") !== -1 || prop.prop.indexOf("key") !== -1) {
  			while (fragment) {
  				if (fragment.owner.currentSubtype === SECTION_EACH && (value = getProp(fragment, prop)) !== undefined) {
  					this.cached = fragment;

  					fragment.registerIndexRef(this);

  					return this.callback(getKeypath("@" + prop.prefix + value));
  				}

  				// watch for component boundaries
  				if (!fragment.parent && fragment.owner && fragment.owner.component && fragment.owner.component.parentFragment && !fragment.owner.component.instance.isolated) {
  					fragment = fragment.owner.component.parentFragment;
  				} else {
  					fragment = fragment.parent;
  				}
  			}
  		} else {
  			while (fragment) {
  				if ((value = getProp(fragment, prop)) !== undefined) {
  					return this.callback(getKeypath("@" + prop.prefix + value.str));
  				}

  				fragment = fragment.parent;
  			}
  		}
  	},

  	unbind: function () {
  		if (this.cached) {
  			this.cached.unregisterIndexRef(this);
  		}
  	}
  };

  var Resolvers_SpecialResolver = SpecialResolver;

  var IndexResolver = function (owner, ref, callback) {
  	this.parentFragment = owner.parentFragment;
  	this.ref = ref;
  	this.callback = callback;

  	ref.ref.fragment.registerIndexRef(this);

  	this.rebind();
  };

  IndexResolver.prototype = {
  	rebind: function () {
  		var index,
  		    ref = this.ref.ref;

  		if (ref.ref.t === "k") {
  			index = "k" + ref.fragment.key;
  		} else {
  			index = "i" + ref.fragment.index;
  		}

  		if (index !== undefined) {
  			this.callback(getKeypath("@" + index));
  		}
  	},

  	unbind: function () {
  		this.ref.ref.fragment.unregisterIndexRef(this);
  	}
  };

  var Resolvers_IndexResolver = IndexResolver;

  var Resolvers_findIndexRefs = findIndexRefs;

  function findIndexRefs(fragment, refName) {
  	var result = {},
  	    refs,
  	    fragRefs,
  	    ref,
  	    i,
  	    owner,
  	    hit = false;

  	if (!refName) {
  		result.refs = refs = {};
  	}

  	while (fragment) {
  		if ((owner = fragment.owner) && (fragRefs = owner.indexRefs)) {

  			// we're looking for a particular ref, and it's here
  			if (refName && (ref = owner.getIndexRef(refName))) {
  				result.ref = {
  					fragment: fragment,
  					ref: ref
  				};
  				return result;
  			}

  			// we're collecting refs up-tree
  			else if (!refName) {
  				for (i in fragRefs) {
  					ref = fragRefs[i];

  					// don't overwrite existing refs - they should shadow parents
  					if (!refs[ref.n]) {
  						hit = true;
  						refs[ref.n] = {
  							fragment: fragment,
  							ref: ref
  						};
  					}
  				}
  			}
  		}

  		// watch for component boundaries
  		if (!fragment.parent && fragment.owner && fragment.owner.component && fragment.owner.component.parentFragment && !fragment.owner.component.instance.isolated) {
  			result.componentBoundary = true;
  			fragment = fragment.owner.component.parentFragment;
  		} else {
  			fragment = fragment.parent;
  		}
  	}

  	if (!hit) {
  		return undefined;
  	} else {
  		return result;
  	}
  }

  findIndexRefs.resolve = function resolve(indices) {
  	var refs = {},
  	    k,
  	    ref;

  	for (k in indices.refs) {
  		ref = indices.refs[k];
  		refs[ref.ref.n] = ref.ref.t === "k" ? ref.fragment.key : ref.fragment.index;
  	}

  	return refs;
  };

  var Resolvers_createReferenceResolver = createReferenceResolver;
  function createReferenceResolver(owner, ref, callback) {
  	var indexRef;

  	if (ref.charAt(0) === "@") {
  		return new Resolvers_SpecialResolver(owner, ref, callback);
  	}

  	if (indexRef = Resolvers_findIndexRefs(owner.parentFragment, ref)) {
  		return new Resolvers_IndexResolver(owner, indexRef, callback);
  	}

  	return new Resolvers_ReferenceResolver(owner, ref, callback);
  }

  var shared_getFunctionFromString = getFunctionFromString;
  var cache = {};
  function getFunctionFromString(str, i) {
  	var fn, args;

  	if (cache[str]) {
  		return cache[str];
  	}

  	args = [];
  	while (i--) {
  		args[i] = "_" + i;
  	}

  	fn = new Function(args.join(","), "return(" + str + ")");

  	cache[str] = fn;
  	return fn;
  }

  var ExpressionResolver,
      Resolvers_ExpressionResolver__bind = Function.prototype.bind;

  ExpressionResolver = function (owner, parentFragment, expression, callback) {
  	var _this = this;

  	var ractive;

  	ractive = owner.root;

  	this.root = ractive;
  	this.parentFragment = parentFragment;
  	this.callback = callback;
  	this.owner = owner;
  	this.str = expression.s;
  	this.keypaths = [];

  	// Create resolvers for each reference
  	this.pending = expression.r.length;
  	this.refResolvers = expression.r.map(function (ref, i) {
  		return Resolvers_createReferenceResolver(_this, ref, function (keypath) {
  			_this.resolve(i, keypath);
  		});
  	});

  	this.ready = true;
  	this.bubble();
  };

  ExpressionResolver.prototype = {
  	bubble: function () {
  		if (!this.ready) {
  			return;
  		}

  		this.uniqueString = getUniqueString(this.str, this.keypaths);
  		this.keypath = createExpressionKeypath(this.uniqueString);

  		this.createEvaluator();
  		this.callback(this.keypath);
  	},

  	unbind: function () {
  		var resolver;

  		while (resolver = this.refResolvers.pop()) {
  			resolver.unbind();
  		}
  	},

  	resolve: function (index, keypath) {
  		this.keypaths[index] = keypath;
  		this.bubble();
  	},

  	createEvaluator: function () {
  		var _this = this;

  		var computation, valueGetters, signature, keypath, fn;

  		keypath = this.keypath;
  		computation = this.root.viewmodel.computations[keypath.str];

  		// only if it doesn't exist yet!
  		if (!computation) {
  			fn = shared_getFunctionFromString(this.str, this.refResolvers.length);

  			valueGetters = this.keypaths.map(function (keypath) {
  				var value;

  				if (keypath === "undefined") {
  					return function () {
  						return undefined;
  					};
  				}

  				// 'special' keypaths encode a value
  				if (keypath.isSpecial) {
  					value = keypath.value;
  					return function () {
  						return value;
  					};
  				}

  				return function () {
  					var value = _this.root.viewmodel.get(keypath, { noUnwrap: true, fullRootGet: true });
  					if (typeof value === "function") {
  						value = wrapFunction(value, _this.root);
  					}
  					return value;
  				};
  			});

  			signature = {
  				deps: this.keypaths.filter(isValidDependency),
  				getter: function () {
  					var args = valueGetters.map(call);
  					return fn.apply(null, args);
  				}
  			};

  			computation = this.root.viewmodel.compute(keypath, signature);
  		} else {
  			this.root.viewmodel.mark(keypath);
  		}
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		// TODO only bubble once, no matter how many references are affected by the rebind
  		this.refResolvers.forEach(function (r) {
  			return r.rebind(oldKeypath, newKeypath);
  		});
  	}
  };

  var Resolvers_ExpressionResolver = ExpressionResolver;

  function call(value) {
  	return value.call();
  }

  function getUniqueString(str, keypaths) {
  	// get string that is unique to this expression
  	return str.replace(/_([0-9]+)/g, function (match, $1) {
  		var keypath, value;

  		// make sure we're not replacing a non-keypath _[0-9]
  		if (+$1 >= keypaths.length) {
  			return "_" + $1;
  		}

  		keypath = keypaths[$1];

  		if (keypath === undefined) {
  			return "undefined";
  		}

  		if (keypath.isSpecial) {
  			value = keypath.value;
  			return typeof value === "number" ? value : "\"" + value + "\"";
  		}

  		return keypath.str;
  	});
  }

  function createExpressionKeypath(uniqueString) {
  	// Sanitize by removing any periods or square brackets. Otherwise
  	// we can't split the keypath into keys!
  	// Remove asterisks too, since they mess with pattern observers
  	return getKeypath("${" + uniqueString.replace(/[\.\[\]]/g, "-").replace(/\*/, "#MUL#") + "}");
  }

  function isValidDependency(keypath) {
  	return keypath !== undefined && keypath[0] !== "@";
  }

  function wrapFunction(fn, ractive) {
  	var wrapped, prop, key;

  	if (fn.__ractive_nowrap) {
  		return fn;
  	}

  	prop = "__ractive_" + ractive._guid;
  	wrapped = fn[prop];

  	if (wrapped) {
  		return wrapped;
  	} else if (/this/.test(fn.toString())) {
  		defineProperty(fn, prop, {
  			value: Resolvers_ExpressionResolver__bind.call(fn, ractive),
  			configurable: true
  		});

  		// Add properties/methods to wrapped function
  		for (key in fn) {
  			if (fn.hasOwnProperty(key)) {
  				fn[prop][key] = fn[key];
  			}
  		}

  		ractive._boundFunctions.push({
  			fn: fn,
  			prop: prop
  		});

  		return fn[prop];
  	}

  	defineProperty(fn, "__ractive_nowrap", {
  		value: fn
  	});

  	return fn.__ractive_nowrap;
  }

  var MemberResolver = function (template, resolver, parentFragment) {
  	var _this = this;

  	this.resolver = resolver;
  	this.root = resolver.root;
  	this.parentFragment = parentFragment;
  	this.viewmodel = resolver.root.viewmodel;

  	if (typeof template === "string") {
  		this.value = template;
  	}

  	// Simple reference?
  	else if (template.t === REFERENCE) {
  		this.refResolver = Resolvers_createReferenceResolver(this, template.n, function (keypath) {
  			_this.resolve(keypath);
  		});
  	}

  	// Otherwise we have an expression in its own right
  	else {
  		new Resolvers_ExpressionResolver(resolver, parentFragment, template, function (keypath) {
  			_this.resolve(keypath);
  		});
  	}
  };

  MemberResolver.prototype = {
  	resolve: function (keypath) {
  		if (this.keypath) {
  			this.viewmodel.unregister(this.keypath, this);
  		}

  		this.keypath = keypath;
  		this.value = this.viewmodel.get(keypath);

  		this.bind();

  		this.resolver.bubble();
  	},

  	bind: function () {
  		this.viewmodel.register(this.keypath, this);
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		if (this.refResolver) {
  			this.refResolver.rebind(oldKeypath, newKeypath);
  		}
  	},

  	setValue: function (value) {
  		this.value = value;
  		this.resolver.bubble();
  	},

  	unbind: function () {
  		if (this.keypath) {
  			this.viewmodel.unregister(this.keypath, this);
  		}

  		if (this.refResolver) {
  			this.refResolver.unbind();
  		}
  	},

  	forceResolution: function () {
  		if (this.refResolver) {
  			this.refResolver.forceResolution();
  		}
  	}
  };

  var ReferenceExpressionResolver_MemberResolver = MemberResolver;

  var ReferenceExpressionResolver = function (mustache, template, callback) {
  	var _this = this;

  	var ractive, ref, keypath, parentFragment;

  	this.parentFragment = parentFragment = mustache.parentFragment;
  	this.root = ractive = mustache.root;
  	this.mustache = mustache;

  	this.ref = ref = template.r;
  	this.callback = callback;

  	this.unresolved = [];

  	// Find base keypath
  	if (keypath = shared_resolveRef(ractive, ref, parentFragment)) {
  		this.base = keypath;
  	} else {
  		this.baseResolver = new Resolvers_ReferenceResolver(this, ref, function (keypath) {
  			_this.base = keypath;
  			_this.baseResolver = null;
  			_this.bubble();
  		});
  	}

  	// Find values for members, or mark them as unresolved
  	this.members = template.m.map(function (template) {
  		return new ReferenceExpressionResolver_MemberResolver(template, _this, parentFragment);
  	});

  	this.ready = true;
  	this.bubble(); // trigger initial resolution if possible
  };

  ReferenceExpressionResolver.prototype = {
  	getKeypath: function () {
  		var values = this.members.map(ReferenceExpressionResolver_ReferenceExpressionResolver__getValue);

  		if (!values.every(isDefined) || this.baseResolver) {
  			return null;
  		}

  		return this.base.join(values.join("."));
  	},

  	bubble: function () {
  		if (!this.ready || this.baseResolver) {
  			return;
  		}

  		this.callback(this.getKeypath());
  	},

  	unbind: function () {
  		this.members.forEach(methodCallers__unbind);
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		var changed;

  		if (this.base) {
  			var newBase = this.base.replace(oldKeypath, newKeypath);
  			if (newBase && newBase !== this.base) {
  				this.base = newBase;
  				changed = true;
  			}
  		}

  		this.members.forEach(function (members) {
  			if (members.rebind(oldKeypath, newKeypath)) {
  				changed = true;
  			}
  		});

  		if (changed) {
  			this.bubble();
  		}
  	},

  	forceResolution: function () {
  		if (this.baseResolver) {
  			this.base = getKeypath(this.ref);

  			this.baseResolver.unbind();
  			this.baseResolver = null;
  		}

  		this.members.forEach(forceResolution);
  		this.bubble();
  	}
  };

  function ReferenceExpressionResolver_ReferenceExpressionResolver__getValue(member) {
  	return member.value;
  }

  function isDefined(value) {
  	return value != undefined;
  }

  function forceResolution(member) {
  	member.forceResolution();
  }

  var ReferenceExpressionResolver_ReferenceExpressionResolver = ReferenceExpressionResolver;

  var Mustache_initialise = Mustache$init;
  function Mustache$init(mustache, options) {

  	var ref, parentFragment, template;

  	parentFragment = options.parentFragment;
  	template = options.template;

  	mustache.root = parentFragment.root;
  	mustache.parentFragment = parentFragment;
  	mustache.pElement = parentFragment.pElement;

  	mustache.template = options.template;
  	mustache.index = options.index || 0;
  	mustache.isStatic = options.template.s;

  	mustache.type = options.template.t;

  	mustache.registered = false;

  	// if this is a simple mustache, with a reference, we just need to resolve
  	// the reference to a keypath
  	if (ref = template.r) {
  		mustache.resolver = Resolvers_createReferenceResolver(mustache, ref, resolve);
  	}

  	// if it's an expression, we have a bit more work to do
  	if (options.template.x) {
  		mustache.resolver = new Resolvers_ExpressionResolver(mustache, parentFragment, options.template.x, resolveAndRebindChildren);
  	}

  	if (options.template.rx) {
  		mustache.resolver = new ReferenceExpressionResolver_ReferenceExpressionResolver(mustache, options.template.rx, resolveAndRebindChildren);
  	}

  	// Special case - inverted sections
  	if (mustache.template.n === SECTION_UNLESS && !mustache.hasOwnProperty("value")) {
  		mustache.setValue(undefined);
  	}

  	function resolve(keypath) {
  		mustache.resolve(keypath);
  	}

  	function resolveAndRebindChildren(newKeypath) {
  		var oldKeypath = mustache.keypath;

  		if (newKeypath != oldKeypath) {
  			mustache.resolve(newKeypath);

  			if (oldKeypath !== undefined) {
  				mustache.fragments && mustache.fragments.forEach(function (f) {
  					f.rebind(oldKeypath, newKeypath);
  				});
  			}
  		}
  	}
  }

  var Mustache_resolve = Mustache$resolve;

  function Mustache$resolve(keypath) {
  	var wasResolved, value, twowayBinding;

  	// 'Special' keypaths, e.g. @foo or @7, encode a value
  	if (keypath && keypath.isSpecial) {
  		this.keypath = keypath;
  		this.setValue(keypath.value);
  		return;
  	}

  	// If we resolved previously, we need to unregister
  	if (this.registered) {
  		// undefined or null
  		this.root.viewmodel.unregister(this.keypath, this);
  		this.registered = false;

  		wasResolved = true;
  	}

  	this.keypath = keypath;

  	// If the new keypath exists, we need to register
  	// with the viewmodel
  	if (keypath != undefined) {
  		// undefined or null
  		value = this.root.viewmodel.get(keypath);
  		this.root.viewmodel.register(keypath, this);

  		this.registered = true;
  	}

  	// Either way we need to queue up a render (`value`
  	// will be `undefined` if there's no keypath)
  	this.setValue(value);

  	// Two-way bindings need to point to their new target keypath
  	if (wasResolved && (twowayBinding = this.twowayBinding)) {
  		twowayBinding.rebound();
  	}
  }

  var Mustache_rebind = Mustache$rebind;

  function Mustache$rebind(oldKeypath, newKeypath) {
  	// Children first
  	if (this.fragments) {
  		this.fragments.forEach(function (f) {
  			return f.rebind(oldKeypath, newKeypath);
  		});
  	}

  	// Expression mustache?
  	if (this.resolver) {
  		this.resolver.rebind(oldKeypath, newKeypath);
  	}
  }

  var Mustache = {
  	getValue: Mustache_getValue,
  	init: Mustache_initialise,
  	resolve: Mustache_resolve,
  	rebind: Mustache_rebind
  };

  var Interpolator = function (options) {
  	this.type = INTERPOLATOR;
  	Mustache.init(this, options);
  };

  Interpolator.prototype = {
  	update: function () {
  		this.node.data = this.value == undefined ? "" : this.value;
  	},
  	resolve: Mustache.resolve,
  	rebind: Mustache.rebind,
  	detach: shared_detach,

  	unbind: shared_unbind,

  	render: function () {
  		if (!this.node) {
  			this.node = document.createTextNode(safeToStringValue(this.value));
  		}

  		return this.node;
  	},

  	unrender: function (shouldDestroy) {
  		if (shouldDestroy) {
  			detachNode(this.node);
  		}
  	},

  	getValue: Mustache.getValue,

  	// TEMP
  	setValue: function (value) {
  		var wrapper;

  		// TODO is there a better way to approach this?
  		if (this.keypath && (wrapper = this.root.viewmodel.wrapped[this.keypath.str])) {
  			value = wrapper.get();
  		}

  		if (!isEqual(value, this.value)) {
  			this.value = value;
  			this.parentFragment.bubble();

  			if (this.node) {
  				global_runloop.addView(this);
  			}
  		}
  	},

  	firstNode: function () {
  		return this.node;
  	},

  	toString: function (escape) {
  		var string = "" + safeToStringValue(this.value);
  		return escape ? escapeHtml(string) : string;
  	}
  };

  var items_Interpolator = Interpolator;

  var Section_prototype_bubble = Section$bubble;

  function Section$bubble() {
  	this.parentFragment.bubble();
  }

  var Section_prototype_detach = Section$detach;

  function Section$detach() {
  	var docFrag;

  	if (this.fragments.length === 1) {
  		return this.fragments[0].detach();
  	}

  	docFrag = document.createDocumentFragment();

  	this.fragments.forEach(function (item) {
  		docFrag.appendChild(item.detach());
  	});

  	return docFrag;
  }

  var find = Section$find;

  function Section$find(selector) {
  	var i, len, queryResult;

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		if (queryResult = this.fragments[i].find(selector)) {
  			return queryResult;
  		}
  	}

  	return null;
  }

  var findAll = Section$findAll;

  function Section$findAll(selector, query) {
  	var i, len;

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		this.fragments[i].findAll(selector, query);
  	}
  }

  var findAllComponents = Section$findAllComponents;

  function Section$findAllComponents(selector, query) {
  	var i, len;

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		this.fragments[i].findAllComponents(selector, query);
  	}
  }

  var findComponent = Section$findComponent;

  function Section$findComponent(selector) {
  	var i, len, queryResult;

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		if (queryResult = this.fragments[i].findComponent(selector)) {
  			return queryResult;
  		}
  	}

  	return null;
  }

  var findNextNode = Section$findNextNode;

  function Section$findNextNode(fragment) {
  	if (this.fragments[fragment.index + 1]) {
  		return this.fragments[fragment.index + 1].firstNode();
  	}

  	return this.parentFragment.findNextNode(this);
  }

  var firstNode = Section$firstNode;

  function Section$firstNode() {
  	var len, i, node;

  	if (len = this.fragments.length) {
  		for (i = 0; i < len; i += 1) {
  			if (node = this.fragments[i].firstNode()) {
  				return node;
  			}
  		}
  	}

  	return this.parentFragment.findNextNode(this);
  }

  var shuffle = Section$shuffle;

  function Section$shuffle(newIndices) {
  	var _this = this;

  	var parentFragment, firstChange, i, newLength, reboundFragments, fragmentOptions, fragment;

  	// short circuit any double-updates, and ensure that this isn't applied to
  	// non-list sections
  	if (this.shuffling || this.unbound || this.currentSubtype !== SECTION_EACH) {
  		return;
  	}

  	this.shuffling = true;
  	global_runloop.scheduleTask(function () {
  		return _this.shuffling = false;
  	});

  	parentFragment = this.parentFragment;

  	reboundFragments = [];

  	// TODO: need to update this
  	// first, rebind existing fragments
  	newIndices.forEach(function (newIndex, oldIndex) {
  		var fragment, by, oldKeypath, newKeypath, deps;

  		if (newIndex === oldIndex) {
  			reboundFragments[newIndex] = _this.fragments[oldIndex];
  			return;
  		}

  		fragment = _this.fragments[oldIndex];

  		if (firstChange === undefined) {
  			firstChange = oldIndex;
  		}

  		// does this fragment need to be torn down?
  		if (newIndex === -1) {
  			_this.fragmentsToUnrender.push(fragment);
  			fragment.unbind();
  			return;
  		}

  		// Otherwise, it needs to be rebound to a new index
  		by = newIndex - oldIndex;
  		oldKeypath = _this.keypath.join(oldIndex);
  		newKeypath = _this.keypath.join(newIndex);

  		fragment.index = newIndex;

  		// notify any registered index refs directly
  		if (deps = fragment.registeredIndexRefs) {
  			deps.forEach(shuffle__blindRebind);
  		}

  		fragment.rebind(oldKeypath, newKeypath);
  		reboundFragments[newIndex] = fragment;
  	});

  	newLength = this.root.viewmodel.get(this.keypath).length;

  	// If nothing changed with the existing fragments, then we start adding
  	// new fragments at the end...
  	if (firstChange === undefined) {
  		// ...unless there are no new fragments to add
  		if (this.length === newLength) {
  			return;
  		}

  		firstChange = this.length;
  	}

  	this.length = this.fragments.length = newLength;

  	if (this.rendered) {
  		global_runloop.addView(this);
  	}

  	// Prepare new fragment options
  	fragmentOptions = {
  		template: this.template.f,
  		root: this.root,
  		owner: this
  	};

  	// Add as many new fragments as we need to, or add back existing
  	// (detached) fragments
  	for (i = firstChange; i < newLength; i += 1) {
  		fragment = reboundFragments[i];

  		if (!fragment) {
  			this.fragmentsToCreate.push(i);
  		}

  		this.fragments[i] = fragment;
  	}
  }

  function shuffle__blindRebind(dep) {
  	// the keypath doesn't actually matter here as it won't have changed
  	dep.rebind("", "");
  }

  var prototype_rebind = function (oldKeypath, newKeypath) {
  	Mustache.rebind.call(this, oldKeypath, newKeypath);
  };

  var Section_prototype_render = Section$render;

  function Section$render() {
  	var _this = this;

  	this.docFrag = document.createDocumentFragment();

  	this.fragments.forEach(function (f) {
  		return _this.docFrag.appendChild(f.render());
  	});

  	this.renderedFragments = this.fragments.slice();
  	this.fragmentsToRender = [];

  	this.rendered = true;
  	return this.docFrag;
  }

  var setValue = Section$setValue;

  function Section$setValue(value) {
  	var _this = this;

  	var wrapper, fragmentOptions;

  	if (this.updating) {
  		// If a child of this section causes a re-evaluation - for example, an
  		// expression refers to a function that mutates the array that this
  		// section depends on - we'll end up with a double rendering bug (see
  		// https://github.com/ractivejs/ractive/issues/748). This prevents it.
  		return;
  	}

  	this.updating = true;

  	// with sections, we need to get the fake value if we have a wrapped object
  	if (this.keypath && (wrapper = this.root.viewmodel.wrapped[this.keypath.str])) {
  		value = wrapper.get();
  	}

  	// If any fragments are awaiting creation after a splice,
  	// this is the place to do it
  	if (this.fragmentsToCreate.length) {
  		fragmentOptions = {
  			template: this.template.f || [],
  			root: this.root,
  			pElement: this.pElement,
  			owner: this
  		};

  		this.fragmentsToCreate.forEach(function (index) {
  			var fragment;

  			fragmentOptions.context = _this.keypath.join(index);
  			fragmentOptions.index = index;

  			fragment = new virtualdom_Fragment(fragmentOptions);
  			_this.fragmentsToRender.push(_this.fragments[index] = fragment);
  		});

  		this.fragmentsToCreate.length = 0;
  	} else if (reevaluateSection(this, value)) {
  		this.bubble();

  		if (this.rendered) {
  			global_runloop.addView(this);
  		}
  	}

  	this.value = value;
  	this.updating = false;
  }

  function changeCurrentSubtype(section, value, obj) {
  	if (value === SECTION_EACH) {
  		// make sure ref type is up to date for key or value indices
  		if (section.indexRefs && section.indexRefs[0]) {
  			var ref = section.indexRefs[0];

  			// when switching flavors, make sure the section gets updated
  			if (obj && ref.t === "i" || !obj && ref.t === "k") {
  				// if switching from object to list, unbind all of the old fragments
  				if (!obj) {
  					section.length = 0;
  					section.fragmentsToUnrender = section.fragments.slice(0);
  					section.fragmentsToUnrender.forEach(function (f) {
  						return f.unbind();
  					});
  				}
  			}

  			ref.t = obj ? "k" : "i";
  		}
  	}

  	section.currentSubtype = value;
  }

  function reevaluateSection(section, value) {
  	var fragmentOptions = {
  		template: section.template.f || [],
  		root: section.root,
  		pElement: section.parentFragment.pElement,
  		owner: section
  	};

  	section.hasContext = true;

  	// If we already know the section type, great
  	// TODO can this be optimised? i.e. pick an reevaluateSection function during init
  	// and avoid doing this each time?
  	if (section.subtype) {
  		switch (section.subtype) {
  			case SECTION_IF:
  				section.hasContext = false;
  				return reevaluateConditionalSection(section, value, false, fragmentOptions);

  			case SECTION_UNLESS:
  				section.hasContext = false;
  				return reevaluateConditionalSection(section, value, true, fragmentOptions);

  			case SECTION_WITH:
  				return reevaluateContextSection(section, fragmentOptions);

  			case SECTION_IF_WITH:
  				return reevaluateConditionalContextSection(section, value, fragmentOptions);

  			case SECTION_EACH:
  				if (isObject(value)) {
  					changeCurrentSubtype(section, section.subtype, true);
  					return reevaluateListObjectSection(section, value, fragmentOptions);
  				}

  				// Fallthrough - if it's a conditional or an array we need to continue
  		}
  	}

  	// Otherwise we need to work out what sort of section we're dealing with
  	section.ordered = !!isArrayLike(value);

  	// Ordered list section
  	if (section.ordered) {
  		changeCurrentSubtype(section, SECTION_EACH, false);
  		return reevaluateListSection(section, value, fragmentOptions);
  	}

  	// Unordered list, or context
  	if (isObject(value) || typeof value === "function") {
  		// Index reference indicates section should be treated as a list
  		if (section.template.i) {
  			changeCurrentSubtype(section, SECTION_EACH, true);
  			return reevaluateListObjectSection(section, value, fragmentOptions);
  		}

  		// Otherwise, object provides context for contents
  		changeCurrentSubtype(section, SECTION_WITH, false);
  		return reevaluateContextSection(section, fragmentOptions);
  	}

  	// Conditional section
  	changeCurrentSubtype(section, SECTION_IF, false);
  	section.hasContext = false;
  	return reevaluateConditionalSection(section, value, false, fragmentOptions);
  }

  function reevaluateListSection(section, value, fragmentOptions) {
  	var i, length, fragment;

  	length = value.length;

  	if (length === section.length) {
  		// Nothing to do
  		return false;
  	}

  	// if the array is shorter than it was previously, remove items
  	if (length < section.length) {
  		section.fragmentsToUnrender = section.fragments.splice(length, section.length - length);
  		section.fragmentsToUnrender.forEach(methodCallers__unbind);
  	}

  	// otherwise...
  	else {
  		if (length > section.length) {
  			// add any new ones
  			for (i = section.length; i < length; i += 1) {
  				// append list item to context stack
  				fragmentOptions.context = section.keypath.join(i);
  				fragmentOptions.index = i;

  				fragment = new virtualdom_Fragment(fragmentOptions);
  				section.fragmentsToRender.push(section.fragments[i] = fragment);
  			}
  		}
  	}

  	section.length = length;
  	return true;
  }

  function reevaluateListObjectSection(section, value, fragmentOptions) {
  	var id, i, hasKey, fragment, changed, deps;

  	hasKey = section.hasKey || (section.hasKey = {});

  	// remove any fragments that should no longer exist
  	i = section.fragments.length;
  	while (i--) {
  		fragment = section.fragments[i];

  		if (!(fragment.key in value)) {
  			changed = true;

  			fragment.unbind();
  			section.fragmentsToUnrender.push(fragment);
  			section.fragments.splice(i, 1);

  			hasKey[fragment.key] = false;
  		}
  	}

  	// notify any dependents about changed indices
  	i = section.fragments.length;
  	while (i--) {
  		fragment = section.fragments[i];

  		if (fragment.index !== i) {
  			fragment.index = i;
  			if (deps = fragment.registeredIndexRefs) {
  				deps.forEach(setValue__blindRebind);
  			}
  		}
  	}

  	// add any that haven't been created yet
  	i = section.fragments.length;
  	for (id in value) {
  		if (!hasKey[id]) {
  			changed = true;

  			fragmentOptions.context = section.keypath.join(id);
  			fragmentOptions.key = id;
  			fragmentOptions.index = i++;

  			fragment = new virtualdom_Fragment(fragmentOptions);

  			section.fragmentsToRender.push(fragment);
  			section.fragments.push(fragment);
  			hasKey[id] = true;
  		}
  	}

  	section.length = section.fragments.length;
  	return changed;
  }

  function reevaluateConditionalContextSection(section, value, fragmentOptions) {
  	if (value) {
  		return reevaluateContextSection(section, fragmentOptions);
  	} else {
  		return removeSectionFragments(section);
  	}
  }

  function reevaluateContextSection(section, fragmentOptions) {
  	var fragment;

  	// ...then if it isn't rendered, render it, adding section.keypath to the context stack
  	// (if it is already rendered, then any children dependent on the context stack
  	// will update themselves without any prompting)
  	if (!section.length) {
  		// append this section to the context stack
  		fragmentOptions.context = section.keypath;
  		fragmentOptions.index = 0;

  		fragment = new virtualdom_Fragment(fragmentOptions);

  		section.fragmentsToRender.push(section.fragments[0] = fragment);
  		section.length = 1;

  		return true;
  	}
  }

  function reevaluateConditionalSection(section, value, inverted, fragmentOptions) {
  	var doRender, emptyArray, emptyObject, fragment, name;

  	emptyArray = isArrayLike(value) && value.length === 0;
  	emptyObject = false;
  	if (!isArrayLike(value) && isObject(value)) {
  		emptyObject = true;
  		for (name in value) {
  			emptyObject = false;
  			break;
  		}
  	}

  	if (inverted) {
  		doRender = emptyArray || emptyObject || !value;
  	} else {
  		doRender = value && !emptyArray && !emptyObject;
  	}

  	if (doRender) {
  		if (!section.length) {
  			// no change to context stack
  			fragmentOptions.index = 0;

  			fragment = new virtualdom_Fragment(fragmentOptions);
  			section.fragmentsToRender.push(section.fragments[0] = fragment);
  			section.length = 1;

  			return true;
  		}

  		if (section.length > 1) {
  			section.fragmentsToUnrender = section.fragments.splice(1);
  			section.fragmentsToUnrender.forEach(methodCallers__unbind);

  			return true;
  		}
  	} else {
  		return removeSectionFragments(section);
  	}
  }

  function removeSectionFragments(section) {
  	if (section.length) {
  		section.fragmentsToUnrender = section.fragments.splice(0, section.fragments.length).filter(isRendered);
  		section.fragmentsToUnrender.forEach(methodCallers__unbind);
  		section.length = section.fragmentsToRender.length = 0;
  		return true;
  	}
  }

  function isRendered(fragment) {
  	return fragment.rendered;
  }

  function setValue__blindRebind(dep) {
  	// the keypath doesn't actually matter here as it won't have changed
  	dep.rebind("", "");
  }

  var prototype_toString = Section$toString;

  function Section$toString(escape) {
  	var str, i, len;

  	str = "";

  	i = 0;
  	len = this.length;

  	for (i = 0; i < len; i += 1) {
  		str += this.fragments[i].toString(escape);
  	}

  	return str;
  }

  var prototype_unbind = Section$unbind;
  function Section$unbind() {
  	var _this = this;

  	this.fragments.forEach(methodCallers__unbind);
  	this.fragmentsToRender.forEach(function (f) {
  		return removeFromArray(_this.fragments, f);
  	});
  	this.fragmentsToRender = [];
  	shared_unbind.call(this);

  	this.length = 0;
  	this.unbound = true;
  }

  var prototype_unrender = Section$unrender;

  function Section$unrender(shouldDestroy) {
  	this.fragments.forEach(shouldDestroy ? unrenderAndDestroy : prototype_unrender__unrender);
  	this.renderedFragments = [];
  	this.rendered = false;
  }

  function unrenderAndDestroy(fragment) {
  	fragment.unrender(true);
  }

  function prototype_unrender__unrender(fragment) {
  	fragment.unrender(false);
  }

  var prototype_update = Section$update;

  function Section$update() {
  	var fragment, renderIndex, renderedFragments, anchor, target, i, len;

  	// `this.renderedFragments` is in the order of the previous render.
  	// If fragments have shuffled about, this allows us to quickly
  	// reinsert them in the correct place
  	renderedFragments = this.renderedFragments;

  	// Remove fragments that have been marked for destruction
  	while (fragment = this.fragmentsToUnrender.pop()) {
  		fragment.unrender(true);
  		renderedFragments.splice(renderedFragments.indexOf(fragment), 1);
  	}

  	// Render new fragments (but don't insert them yet)
  	while (fragment = this.fragmentsToRender.shift()) {
  		fragment.render();
  	}

  	if (this.rendered) {
  		target = this.parentFragment.getNode();
  	}

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		fragment = this.fragments[i];
  		renderIndex = renderedFragments.indexOf(fragment, i); // search from current index - it's guaranteed to be the same or higher

  		if (renderIndex === i) {
  			// already in the right place. insert accumulated nodes (if any) and carry on
  			if (this.docFrag.childNodes.length) {
  				anchor = fragment.firstNode();
  				target.insertBefore(this.docFrag, anchor);
  			}

  			continue;
  		}

  		this.docFrag.appendChild(fragment.detach());

  		// update renderedFragments
  		if (renderIndex !== -1) {
  			renderedFragments.splice(renderIndex, 1);
  		}
  		renderedFragments.splice(i, 0, fragment);
  	}

  	if (this.rendered && this.docFrag.childNodes.length) {
  		anchor = this.parentFragment.findNextNode(this);
  		target.insertBefore(this.docFrag, anchor);
  	}

  	// Save the rendering order for next time
  	this.renderedFragments = this.fragments.slice();
  }

  var Section = function (options) {
  	this.type = SECTION;
  	this.subtype = this.currentSubtype = options.template.n;
  	this.inverted = this.subtype === SECTION_UNLESS;

  	this.pElement = options.pElement;

  	this.fragments = [];
  	this.fragmentsToCreate = [];
  	this.fragmentsToRender = [];
  	this.fragmentsToUnrender = [];

  	if (options.template.i) {
  		this.indexRefs = options.template.i.split(",").map(function (k, i) {
  			return { n: k, t: i === 0 ? "k" : "i" };
  		});
  	}

  	this.renderedFragments = [];

  	this.length = 0; // number of times this section is rendered

  	Mustache.init(this, options);
  };

  Section.prototype = {
  	bubble: Section_prototype_bubble,
  	detach: Section_prototype_detach,
  	find: find,
  	findAll: findAll,
  	findAllComponents: findAllComponents,
  	findComponent: findComponent,
  	findNextNode: findNextNode,
  	firstNode: firstNode,
  	getIndexRef: function (name) {
  		if (this.indexRefs) {
  			var i = this.indexRefs.length;
  			while (i--) {
  				var ref = this.indexRefs[i];
  				if (ref.n === name) {
  					return ref;
  				}
  			}
  		}
  	},
  	getValue: Mustache.getValue,
  	shuffle: shuffle,
  	rebind: prototype_rebind,
  	render: Section_prototype_render,
  	resolve: Mustache.resolve,
  	setValue: setValue,
  	toString: prototype_toString,
  	unbind: prototype_unbind,
  	unrender: prototype_unrender,
  	update: prototype_update
  };

  var _Section = Section;

  var Triple_prototype_detach = Triple$detach;

  function Triple$detach() {
  	var len, i;

  	if (this.docFrag) {
  		len = this.nodes.length;
  		for (i = 0; i < len; i += 1) {
  			this.docFrag.appendChild(this.nodes[i]);
  		}

  		return this.docFrag;
  	}
  }

  var Triple_prototype_find = Triple$find;
  function Triple$find(selector) {
  	var i, len, node, queryResult;

  	len = this.nodes.length;
  	for (i = 0; i < len; i += 1) {
  		node = this.nodes[i];

  		if (node.nodeType !== 1) {
  			continue;
  		}

  		if (matches(node, selector)) {
  			return node;
  		}

  		if (queryResult = node.querySelector(selector)) {
  			return queryResult;
  		}
  	}

  	return null;
  }

  var Triple_prototype_findAll = Triple$findAll;
  function Triple$findAll(selector, queryResult) {
  	var i, len, node, queryAllResult, numNodes, j;

  	len = this.nodes.length;
  	for (i = 0; i < len; i += 1) {
  		node = this.nodes[i];

  		if (node.nodeType !== 1) {
  			continue;
  		}

  		if (matches(node, selector)) {
  			queryResult.push(node);
  		}

  		if (queryAllResult = node.querySelectorAll(selector)) {
  			numNodes = queryAllResult.length;
  			for (j = 0; j < numNodes; j += 1) {
  				queryResult.push(queryAllResult[j]);
  			}
  		}
  	}
  }

  var Triple_prototype_firstNode = Triple$firstNode;

  function Triple$firstNode() {
  	if (this.rendered && this.nodes[0]) {
  		return this.nodes[0];
  	}

  	return this.parentFragment.findNextNode(this);
  }

  var elementCache = {},
      ieBug,
      ieBlacklist;

  try {
  	createElement("table").innerHTML = "foo";
  } catch (err) {
  	ieBug = true;

  	ieBlacklist = {
  		TABLE: ["<table class=\"x\">", "</table>"],
  		THEAD: ["<table><thead class=\"x\">", "</thead></table>"],
  		TBODY: ["<table><tbody class=\"x\">", "</tbody></table>"],
  		TR: ["<table><tr class=\"x\">", "</tr></table>"],
  		SELECT: ["<select class=\"x\">", "</select>"]
  	};
  }

  var insertHtml = function (html, node, docFrag) {
  	var container,
  	    nodes = [],
  	    wrapper,
  	    selectedOption,
  	    child,
  	    i;

  	// render 0 and false
  	if (html != null && html !== "") {
  		if (ieBug && (wrapper = ieBlacklist[node.tagName])) {
  			container = element("DIV");
  			container.innerHTML = wrapper[0] + html + wrapper[1];
  			container = container.querySelector(".x");

  			if (container.tagName === "SELECT") {
  				selectedOption = container.options[container.selectedIndex];
  			}
  		} else if (node.namespaceURI === namespaces.svg) {
  			container = element("DIV");
  			container.innerHTML = "<svg class=\"x\">" + html + "</svg>";
  			container = container.querySelector(".x");
  		} else {
  			container = element(node.tagName);
  			container.innerHTML = html;

  			if (container.tagName === "SELECT") {
  				selectedOption = container.options[container.selectedIndex];
  			}
  		}

  		while (child = container.firstChild) {
  			nodes.push(child);
  			docFrag.appendChild(child);
  		}

  		// This is really annoying. Extracting <option> nodes from the
  		// temporary container <select> causes the remaining ones to
  		// become selected. So now we have to deselect them. IE8, you
  		// amaze me. You really do
  		// ...and now Chrome too
  		if (node.tagName === "SELECT") {
  			i = nodes.length;
  			while (i--) {
  				if (nodes[i] !== selectedOption) {
  					nodes[i].selected = false;
  				}
  			}
  		}
  	}

  	return nodes;
  };

  function element(tagName) {
  	return elementCache[tagName] || (elementCache[tagName] = createElement(tagName));
  }

  var helpers_updateSelect = updateSelect;

  function updateSelect(parentElement) {
  	var selectedOptions, option, value;

  	if (!parentElement || parentElement.name !== "select" || !parentElement.binding) {
  		return;
  	}

  	selectedOptions = toArray(parentElement.node.options).filter(isSelected);

  	// If one of them had a `selected` attribute, we need to sync
  	// the model to the view
  	if (parentElement.getAttribute("multiple")) {
  		value = selectedOptions.map(function (o) {
  			return o.value;
  		});
  	} else if (option = selectedOptions[0]) {
  		value = option.value;
  	}

  	if (value !== undefined) {
  		parentElement.binding.setValue(value);
  	}

  	parentElement.bubble();
  }

  function isSelected(option) {
  	return option.selected;
  }

  var Triple_prototype_render = Triple$render;
  function Triple$render() {
  	if (this.rendered) {
  		throw new Error("Attempted to render an item that was already rendered");
  	}

  	this.docFrag = document.createDocumentFragment();
  	this.nodes = insertHtml(this.value, this.parentFragment.getNode(), this.docFrag);

  	// Special case - we're inserting the contents of a <select>
  	helpers_updateSelect(this.pElement);

  	this.rendered = true;
  	return this.docFrag;
  }

  var prototype_setValue = Triple$setValue;
  function Triple$setValue(value) {
  	var wrapper;

  	// TODO is there a better way to approach this?
  	if (wrapper = this.root.viewmodel.wrapped[this.keypath.str]) {
  		value = wrapper.get();
  	}

  	if (value !== this.value) {
  		this.value = value;
  		this.parentFragment.bubble();

  		if (this.rendered) {
  			global_runloop.addView(this);
  		}
  	}
  }

  var Triple_prototype_toString = Triple$toString;
  function Triple$toString() {
  	return this.value != undefined ? decodeCharacterReferences("" + this.value) : "";
  }

  var Triple_prototype_unrender = Triple$unrender;
  function Triple$unrender(shouldDestroy) {
  	if (this.rendered && shouldDestroy) {
  		this.nodes.forEach(detachNode);
  		this.rendered = false;
  	}

  	// TODO update live queries
  }

  var Triple_prototype_update = Triple$update;
  function Triple$update() {
  	var node, parentNode;

  	if (!this.rendered) {
  		return;
  	}

  	// Remove existing nodes
  	while (this.nodes && this.nodes.length) {
  		node = this.nodes.pop();
  		node.parentNode.removeChild(node);
  	}

  	// Insert new nodes
  	parentNode = this.parentFragment.getNode();

  	this.nodes = insertHtml(this.value, parentNode, this.docFrag);
  	parentNode.insertBefore(this.docFrag, this.parentFragment.findNextNode(this));

  	// Special case - we're inserting the contents of a <select>
  	helpers_updateSelect(this.pElement);
  }

  var Triple = function (options) {
  	this.type = TRIPLE;
  	Mustache.init(this, options);
  };

  Triple.prototype = {
  	detach: Triple_prototype_detach,
  	find: Triple_prototype_find,
  	findAll: Triple_prototype_findAll,
  	firstNode: Triple_prototype_firstNode,
  	getValue: Mustache.getValue,
  	rebind: Mustache.rebind,
  	render: Triple_prototype_render,
  	resolve: Mustache.resolve,
  	setValue: prototype_setValue,
  	toString: Triple_prototype_toString,
  	unbind: shared_unbind,
  	unrender: Triple_prototype_unrender,
  	update: Triple_prototype_update
  };

  var _Triple = Triple;

  var Element_prototype_bubble = function () {
  	this.parentFragment.bubble();
  };

  var Element_prototype_detach = Element$detach;

  function Element$detach() {
  	var node = this.node,
  	    parentNode;

  	if (node) {
  		// need to check for parent node - DOM may have been altered
  		// by something other than Ractive! e.g. jQuery UI...
  		if (parentNode = node.parentNode) {
  			parentNode.removeChild(node);
  		}

  		return node;
  	}
  }

  var Element_prototype_find = function (selector) {
  	if (!this.node) {
  		// this element hasn't been rendered yet
  		return null;
  	}

  	if (matches(this.node, selector)) {
  		return this.node;
  	}

  	if (this.fragment && this.fragment.find) {
  		return this.fragment.find(selector);
  	}
  };

  var Element_prototype_findAll = function (selector, query) {
  	// Add this node to the query, if applicable, and register the
  	// query on this element
  	if (query._test(this, true) && query.live) {
  		(this.liveQueries || (this.liveQueries = [])).push(query);
  	}

  	if (this.fragment) {
  		this.fragment.findAll(selector, query);
  	}
  };

  var Element_prototype_findAllComponents = function (selector, query) {
  	if (this.fragment) {
  		this.fragment.findAllComponents(selector, query);
  	}
  };

  var Element_prototype_findComponent = function (selector) {
  	if (this.fragment) {
  		return this.fragment.findComponent(selector);
  	}
  };

  var Element_prototype_findNextNode = Element$findNextNode;

  function Element$findNextNode() {
  	return null;
  }

  var Element_prototype_firstNode = Element$firstNode;

  function Element$firstNode() {
  	return this.node;
  }

  var getAttribute = Element$getAttribute;

  function Element$getAttribute(name) {
  	if (!this.attributes || !this.attributes[name]) {
  		return;
  	}

  	return this.attributes[name].value;
  }

  var truthy = /^true|on|yes|1$/i;
  var processBindingAttributes__isNumeric = /^[0-9]+$/;

  var processBindingAttributes = function (element, template) {
  	var val, attrs, attributes;

  	attributes = template.a || {};
  	attrs = {};

  	// attributes that are present but don't have a value (=)
  	// will be set to the number 0, which we condider to be true
  	// the string '0', however is false

  	val = attributes.twoway;
  	if (val !== undefined) {
  		attrs.twoway = val === 0 || truthy.test(val);
  	}

  	val = attributes.lazy;
  	if (val !== undefined) {
  		// check for timeout value
  		if (val !== 0 && processBindingAttributes__isNumeric.test(val)) {
  			attrs.lazy = parseInt(val);
  		} else {
  			attrs.lazy = val === 0 || truthy.test(val);
  		}
  	}

  	return attrs;
  };

  var Attribute_prototype_bubble = Attribute$bubble;
  function Attribute$bubble() {
  	var value = this.useProperty || !this.rendered ? this.fragment.getValue() : this.fragment.toString();

  	// TODO this can register the attribute multiple times (see render test
  	// 'Attribute with nested mustaches')
  	if (!isEqual(value, this.value)) {

  		// Need to clear old id from ractive.nodes
  		if (this.name === "id" && this.value) {
  			delete this.root.nodes[this.value];
  		}

  		this.value = value;

  		if (this.name === "value" && this.node) {
  			// We need to store the value on the DOM like this so we
  			// can retrieve it later without it being coerced to a string
  			this.node._ractive.value = value;
  		}

  		if (this.rendered) {
  			global_runloop.addView(this);
  		}
  	}
  }

  var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;
  svgCamelCaseElements = "altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern".split(" ");
  svgCamelCaseAttributes = "attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan".split(" ");

  createMap = function (items) {
  	var map = {},
  	    i = items.length;
  	while (i--) {
  		map[items[i].toLowerCase()] = items[i];
  	}
  	return map;
  };

  map = createMap(svgCamelCaseElements.concat(svgCamelCaseAttributes));

  var enforceCase = function (elementName) {
  	var lowerCaseElementName = elementName.toLowerCase();
  	return map[lowerCaseElementName] || lowerCaseElementName;
  };

  var determineNameAndNamespace = function (attribute, name) {
  	var colonIndex, namespacePrefix;

  	// are we dealing with a namespaced attribute, e.g. xlink:href?
  	colonIndex = name.indexOf(":");
  	if (colonIndex !== -1) {

  		// looks like we are, yes...
  		namespacePrefix = name.substr(0, colonIndex);

  		// ...unless it's a namespace *declaration*, which we ignore (on the assumption
  		// that only valid namespaces will be used)
  		if (namespacePrefix !== "xmlns") {
  			name = name.substring(colonIndex + 1);

  			attribute.name = enforceCase(name);
  			attribute.namespace = namespaces[namespacePrefix.toLowerCase()];
  			attribute.namespacePrefix = namespacePrefix;

  			if (!attribute.namespace) {
  				throw "Unknown namespace (\"" + namespacePrefix + "\")";
  			}

  			return;
  		}
  	}

  	// SVG attribute names are case sensitive
  	attribute.name = attribute.element.namespace !== namespaces.html ? enforceCase(name) : name;
  };

  var helpers_getInterpolator = getInterpolator;
  function getInterpolator(attribute) {
  	var items = attribute.fragment.items;

  	if (items.length !== 1) {
  		return;
  	}

  	if (items[0].type === INTERPOLATOR) {
  		return items[0];
  	}
  }

  var prototype_init = Attribute$init;
  function Attribute$init(options) {
  	this.type = ATTRIBUTE;
  	this.element = options.element;
  	this.root = options.root;

  	determineNameAndNamespace(this, options.name);
  	this.isBoolean = booleanAttributes.test(this.name);

  	// if it's an empty attribute, or just a straight key-value pair, with no
  	// mustache shenanigans, set the attribute accordingly and go home
  	if (!options.value || typeof options.value === "string") {
  		this.value = this.isBoolean ? true : options.value || "";
  		return;
  	}

  	// otherwise we need to do some work

  	// share parentFragment with parent element
  	this.parentFragment = this.element.parentFragment;

  	this.fragment = new virtualdom_Fragment({
  		template: options.value,
  		root: this.root,
  		owner: this
  	});

  	// TODO can we use this.fragment.toString() in some cases? It's quicker
  	this.value = this.fragment.getValue();

  	// Store a reference to this attribute's interpolator, if its fragment
  	// takes the form `{{foo}}`. This is necessary for two-way binding and
  	// for correctly rendering HTML later
  	this.interpolator = helpers_getInterpolator(this);
  	this.isBindable = !!this.interpolator && !this.interpolator.isStatic;

  	// mark as ready
  	this.ready = true;
  }

  var Attribute_prototype_rebind = Attribute$rebind;

  function Attribute$rebind(oldKeypath, newKeypath) {
  	if (this.fragment) {
  		this.fragment.rebind(oldKeypath, newKeypath);
  	}
  }

  var Attribute_prototype_render = Attribute$render;
  var propertyNames = {
  	"accept-charset": "acceptCharset",
  	accesskey: "accessKey",
  	bgcolor: "bgColor",
  	"class": "className",
  	codebase: "codeBase",
  	colspan: "colSpan",
  	contenteditable: "contentEditable",
  	datetime: "dateTime",
  	dirname: "dirName",
  	"for": "htmlFor",
  	"http-equiv": "httpEquiv",
  	ismap: "isMap",
  	maxlength: "maxLength",
  	novalidate: "noValidate",
  	pubdate: "pubDate",
  	readonly: "readOnly",
  	rowspan: "rowSpan",
  	tabindex: "tabIndex",
  	usemap: "useMap"
  };
  function Attribute$render(node) {
  	var propertyName;

  	this.node = node;

  	// should we use direct property access, or setAttribute?
  	if (!node.namespaceURI || node.namespaceURI === namespaces.html) {
  		propertyName = propertyNames[this.name] || this.name;

  		if (node[propertyName] !== undefined) {
  			this.propertyName = propertyName;
  		}

  		// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
  		// node.selected = true rather than node.setAttribute( 'selected', '' )
  		if (this.isBoolean || this.isTwoway) {
  			this.useProperty = true;
  		}

  		if (propertyName === "value") {
  			node._ractive.value = this.value;
  		}
  	}

  	this.rendered = true;
  	this.update();
  }

  var Attribute_prototype_toString = Attribute$toString;

  function Attribute$toString() {
  	var _ref = this;

  	var name = _ref.name;
  	var namespacePrefix = _ref.namespacePrefix;
  	var value = _ref.value;
  	var interpolator = _ref.interpolator;
  	var fragment = _ref.fragment;

  	// Special case - select and textarea values (should not be stringified)
  	if (name === "value" && (this.element.name === "select" || this.element.name === "textarea")) {
  		return;
  	}

  	// Special case - content editable
  	if (name === "value" && this.element.getAttribute("contenteditable") !== undefined) {
  		return;
  	}

  	// Special case - radio names
  	if (name === "name" && this.element.name === "input" && interpolator) {
  		return "name={{" + (interpolator.keypath.str || interpolator.ref) + "}}";
  	}

  	// Boolean attributes
  	if (this.isBoolean) {
  		return value ? name : "";
  	}

  	if (fragment) {
  		// special case - this catches undefined/null values (#1211)
  		if (fragment.items.length === 1 && fragment.items[0].value == null) {
  			return "";
  		}

  		value = fragment.toString();
  	}

  	if (namespacePrefix) {
  		name = namespacePrefix + ":" + name;
  	}

  	return value ? name + "=\"" + Attribute_prototype_toString__escape(value) + "\"" : name;
  }

  function Attribute_prototype_toString__escape(value) {
  	return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
  }

  var Attribute_prototype_unbind = Attribute$unbind;

  function Attribute$unbind() {
  	// ignore non-dynamic attributes
  	if (this.fragment) {
  		this.fragment.unbind();
  	}

  	if (this.name === "id") {
  		delete this.root.nodes[this.value];
  	}
  }

  var updateSelectValue = Attribute$updateSelect;

  function Attribute$updateSelect() {
  	var value = this.value,
  	    options,
  	    option,
  	    optionValue,
  	    i;

  	if (!this.locked) {
  		this.node._ractive.value = value;

  		options = this.node.options;
  		i = options.length;

  		while (i--) {
  			option = options[i];
  			optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive

  			if (optionValue == value) {
  				// double equals as we may be comparing numbers with strings
  				option.selected = true;
  				break;
  			}
  		}
  	}

  	// if we're still here, it means the new value didn't match any of the options...
  	// TODO figure out what to do in this situation
  }

  var updateMultipleSelectValue = Attribute$updateMultipleSelect;
  function Attribute$updateMultipleSelect() {
  	var value = this.value,
  	    options,
  	    i,
  	    option,
  	    optionValue;

  	if (!isArray(value)) {
  		value = [value];
  	}

  	options = this.node.options;
  	i = options.length;

  	while (i--) {
  		option = options[i];
  		optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive
  		option.selected = arrayContains(value, optionValue);
  	}
  }

  var updateRadioName = Attribute$updateRadioName;

  function Attribute$updateRadioName() {
  	var _ref = this;

  	var node = _ref.node;
  	var value = _ref.value;

  	node.checked = value == node._ractive.value;
  }

  var updateRadioValue = Attribute$updateRadioValue;
  function Attribute$updateRadioValue() {
  	var wasChecked,
  	    node = this.node,
  	    binding,
  	    bindings,
  	    i;

  	wasChecked = node.checked;

  	node.value = this.element.getAttribute("value");
  	node.checked = this.element.getAttribute("value") === this.element.getAttribute("name");

  	// This is a special case - if the input was checked, and the value
  	// changed so that it's no longer checked, the twoway binding is
  	// most likely out of date. To fix it we have to jump through some
  	// hoops... this is a little kludgy but it works
  	if (wasChecked && !node.checked && this.element.binding) {
  		bindings = this.element.binding.siblings;

  		if (i = bindings.length) {
  			while (i--) {
  				binding = bindings[i];

  				if (!binding.element.node) {
  					// this is the initial render, siblings are still rendering!
  					// we'll come back later...
  					return;
  				}

  				if (binding.element.node.checked) {
  					global_runloop.addRactive(binding.root);
  					return binding.handleChange();
  				}
  			}

  			this.root.viewmodel.set(binding.keypath, undefined);
  		}
  	}
  }

  var updateCheckboxName = Attribute$updateCheckboxName;
  function Attribute$updateCheckboxName() {
  	var _ref = this;

  	var element = _ref.element;
  	var node = _ref.node;
  	var value = _ref.value;var binding = element.binding;var valueAttribute;var i;

  	valueAttribute = element.getAttribute("value");

  	if (!isArray(value)) {
  		binding.isChecked = node.checked = value == valueAttribute;
  	} else {
  		i = value.length;
  		while (i--) {
  			if (valueAttribute == value[i]) {
  				binding.isChecked = node.checked = true;
  				return;
  			}
  		}
  		binding.isChecked = node.checked = false;
  	}
  }

  var updateClassName = Attribute$updateClassName;
  function Attribute$updateClassName() {
  	this.node.className = safeToStringValue(this.value);
  }

  var updateIdAttribute = Attribute$updateIdAttribute;

  function Attribute$updateIdAttribute() {
  	var _ref = this;

  	var node = _ref.node;
  	var value = _ref.value;

  	this.root.nodes[value] = node;
  	node.id = value;
  }

  var updateIEStyleAttribute = Attribute$updateIEStyleAttribute;

  function Attribute$updateIEStyleAttribute() {
  	var node, value;

  	node = this.node;
  	value = this.value;

  	if (value === undefined) {
  		value = "";
  	}

  	node.style.setAttribute("cssText", value);
  }

  var updateContentEditableValue = Attribute$updateContentEditableValue;

  function Attribute$updateContentEditableValue() {
  	var value = this.value;

  	if (value === undefined) {
  		value = "";
  	}

  	if (!this.locked) {
  		this.node.innerHTML = value;
  	}
  }

  var updateValue = Attribute$updateValue;

  function Attribute$updateValue() {
  	var _ref = this;

  	var node = _ref.node;
  	var value = _ref.value;

  	// store actual value, so it doesn't get coerced to a string
  	node._ractive.value = value;

  	// with two-way binding, only update if the change wasn't initiated by the user
  	// otherwise the cursor will often be sent to the wrong place
  	if (!this.locked) {
  		node.value = value == undefined ? "" : value;
  	}
  }

  var updateBoolean = Attribute$updateBooleanAttribute;

  function Attribute$updateBooleanAttribute() {
  	// with two-way binding, only update if the change wasn't initiated by the user
  	// otherwise the cursor will often be sent to the wrong place
  	if (!this.locked) {
  		this.node[this.propertyName] = this.value;
  	}
  }

  var updateEverythingElse = Attribute$updateEverythingElse;

  function Attribute$updateEverythingElse() {
  	var _ref = this;

  	var node = _ref.node;
  	var namespace = _ref.namespace;
  	var name = _ref.name;
  	var value = _ref.value;
  	var fragment = _ref.fragment;

  	if (namespace) {
  		node.setAttributeNS(namespace, name, (fragment || value).toString());
  	} else if (!this.isBoolean) {
  		if (value == null) {
  			node.removeAttribute(name);
  		} else {
  			node.setAttribute(name, (fragment || value).toString());
  		}
  	}

  	// Boolean attributes - truthy becomes '', falsy means 'remove attribute'
  	else {
  		if (value) {
  			node.setAttribute(name, "");
  		} else {
  			node.removeAttribute(name);
  		}
  	}
  }

  // There are a few special cases when it comes to updating attributes. For this reason,
  // the prototype .update() method points to this method, which waits until the
  // attribute has finished initialising, then replaces the prototype method with a more
  // suitable one. That way, we save ourselves doing a bunch of tests on each call
  var Attribute_prototype_update = Attribute$update;
  function Attribute$update() {
  	var _ref = this;

  	var name = _ref.name;
  	var element = _ref.element;
  	var node = _ref.node;var type;var updateMethod;

  	if (name === "id") {
  		updateMethod = updateIdAttribute;
  	} else if (name === "value") {
  		// special case - selects
  		if (element.name === "select" && name === "value") {
  			updateMethod = element.getAttribute("multiple") ? updateMultipleSelectValue : updateSelectValue;
  		} else if (element.name === "textarea") {
  			updateMethod = updateValue;
  		}

  		// special case - contenteditable
  		else if (element.getAttribute("contenteditable") != null) {
  			updateMethod = updateContentEditableValue;
  		}

  		// special case - <input>
  		else if (element.name === "input") {
  			type = element.getAttribute("type");

  			// type='file' value='{{fileList}}'>
  			if (type === "file") {
  				updateMethod = noop; // read-only
  			}

  			// type='radio' name='{{twoway}}'
  			else if (type === "radio" && element.binding && element.binding.name === "name") {
  				updateMethod = updateRadioValue;
  			} else {
  				updateMethod = updateValue;
  			}
  		}
  	}

  	// special case - <input type='radio' name='{{twoway}}' value='foo'>
  	else if (this.isTwoway && name === "name") {
  		if (node.type === "radio") {
  			updateMethod = updateRadioName;
  		} else if (node.type === "checkbox") {
  			updateMethod = updateCheckboxName;
  		}
  	}

  	// special case - style attributes in Internet Exploder
  	else if (name === "style" && node.style.setAttribute) {
  		updateMethod = updateIEStyleAttribute;
  	}

  	// special case - class names. IE fucks things up, again
  	else if (name === "class" && (!node.namespaceURI || node.namespaceURI === namespaces.html)) {
  		updateMethod = updateClassName;
  	} else if (this.useProperty) {
  		updateMethod = updateBoolean;
  	}

  	if (!updateMethod) {
  		updateMethod = updateEverythingElse;
  	}

  	this.update = updateMethod;
  	this.update();
  }

  var Attribute = function (options) {
  	this.init(options);
  };

  Attribute.prototype = {
  	bubble: Attribute_prototype_bubble,
  	init: prototype_init,
  	rebind: Attribute_prototype_rebind,
  	render: Attribute_prototype_render,
  	toString: Attribute_prototype_toString,
  	unbind: Attribute_prototype_unbind,
  	update: Attribute_prototype_update
  };

  var _Attribute = Attribute;

  var createAttributes = function (element, attributes) {
  	var name,
  	    attribute,
  	    result = [];

  	for (name in attributes) {
  		// skip binding attributes
  		if (name === "twoway" || name === "lazy") {
  			continue;
  		}

  		if (attributes.hasOwnProperty(name)) {
  			attribute = new _Attribute({
  				element: element,
  				name: name,
  				value: attributes[name],
  				root: element.root
  			});

  			result[name] = attribute;

  			if (name !== "value") {
  				result.push(attribute);
  			}
  		}
  	}

  	// value attribute goes last. This is because it
  	// may get clamped on render otherwise, e.g. in
  	// `<input type='range' value='999' min='0' max='1000'>`
  	// since default max is 100
  	if (attribute = result.value) {
  		result.push(attribute);
  	}

  	return result;
  };

  var _ConditionalAttribute__div;

  if (typeof document !== "undefined") {
  	_ConditionalAttribute__div = createElement("div");
  }

  var ConditionalAttribute = function (element, template) {
  	this.element = element;
  	this.root = element.root;
  	this.parentFragment = element.parentFragment;

  	this.attributes = [];

  	this.fragment = new virtualdom_Fragment({
  		root: element.root,
  		owner: this,
  		template: [template]
  	});
  };

  ConditionalAttribute.prototype = {
  	bubble: function () {
  		if (this.node) {
  			this.update();
  		}

  		this.element.bubble();
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		this.fragment.rebind(oldKeypath, newKeypath);
  	},

  	render: function (node) {
  		this.node = node;
  		this.isSvg = node.namespaceURI === namespaces.svg;

  		this.update();
  	},

  	unbind: function () {
  		this.fragment.unbind();
  	},

  	update: function () {
  		var _this = this;

  		var str, attrs;

  		str = this.fragment.toString();
  		attrs = parseAttributes(str, this.isSvg);

  		// any attributes that previously existed but no longer do
  		// must be removed
  		this.attributes.filter(function (a) {
  			return notIn(attrs, a);
  		}).forEach(function (a) {
  			_this.node.removeAttribute(a.name);
  		});

  		attrs.forEach(function (a) {
  			_this.node.setAttribute(a.name, a.value);
  		});

  		this.attributes = attrs;
  	},

  	toString: function () {
  		return this.fragment.toString();
  	}
  };

  var _ConditionalAttribute = ConditionalAttribute;

  function parseAttributes(str, isSvg) {
  	var tag = isSvg ? "svg" : "div";
  	_ConditionalAttribute__div.innerHTML = "<" + tag + " " + str + "></" + tag + ">";

  	return toArray(_ConditionalAttribute__div.childNodes[0].attributes);
  }

  function notIn(haystack, needle) {
  	var i = haystack.length;

  	while (i--) {
  		if (haystack[i].name === needle.name) {
  			return false;
  		}
  	}

  	return true;
  }

  var createConditionalAttributes = function (element, attributes) {
  	if (!attributes) {
  		return [];
  	}

  	return attributes.map(function (a) {
  		return new _ConditionalAttribute(element, a);
  	});
  };

  var Binding = function (element) {
  	var interpolator, keypath, value, parentForm;

  	this.element = element;
  	this.root = element.root;
  	this.attribute = element.attributes[this.name || "value"];

  	interpolator = this.attribute.interpolator;
  	interpolator.twowayBinding = this;

  	if (keypath = interpolator.keypath) {
  		if (keypath.str.slice(-1) === "}") {
  			warnOnceIfDebug("Two-way binding does not work with expressions (`%s` on <%s>)", interpolator.resolver.uniqueString, element.name, { ractive: this.root });
  			return false;
  		}

  		if (keypath.isSpecial) {
  			warnOnceIfDebug("Two-way binding does not work with %s", interpolator.resolver.ref, { ractive: this.root });
  			return false;
  		}
  	} else {
  		// A mustache may be *ambiguous*. Let's say we were given
  		// `value="{{bar}}"`. If the context was `foo`, and `foo.bar`
  		// *wasn't* `undefined`, the keypath would be `foo.bar`.
  		// Then, any user input would result in `foo.bar` being updated.
  		//
  		// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be
  		// left with an unresolved partial keypath - so we are forced to make an
  		// assumption. That assumption is that the input in question should
  		// be forced to resolve to `bar`, and any user input would affect `bar`
  		// and not `foo.bar`.
  		//
  		// Did that make any sense? No? Oh. Sorry. Well the moral of the story is
  		// be explicit when using two-way data-binding about what keypath you're
  		// updating. Using it in lists is probably a recipe for confusion...
  		var ref = interpolator.template.r ? "'" + interpolator.template.r + "' reference" : "expression";
  		warnIfDebug("The %s being used for two-way binding is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity", ref, { ractive: this.root });
  		interpolator.resolver.forceResolution();
  		keypath = interpolator.keypath;
  	}

  	this.attribute.isTwoway = true;
  	this.keypath = keypath;

  	// initialise value, if it's undefined
  	value = this.root.viewmodel.get(keypath);

  	if (value === undefined && this.getInitialValue) {
  		value = this.getInitialValue();

  		if (value !== undefined) {
  			this.root.viewmodel.set(keypath, value);
  		}
  	}

  	if (parentForm = findParentForm(element)) {
  		this.resetValue = value;
  		parentForm.formBindings.push(this);
  	}
  };

  Binding.prototype = {
  	handleChange: function () {
  		var _this = this;

  		global_runloop.start(this.root);
  		this.attribute.locked = true;
  		this.root.viewmodel.set(this.keypath, this.getValue());
  		global_runloop.scheduleTask(function () {
  			return _this.attribute.locked = false;
  		});
  		global_runloop.end();
  	},

  	rebound: function () {
  		var bindings, oldKeypath, newKeypath;

  		oldKeypath = this.keypath;
  		newKeypath = this.attribute.interpolator.keypath;

  		// The attribute this binding is linked to has already done the work
  		if (oldKeypath === newKeypath) {
  			return;
  		}

  		removeFromArray(this.root._twowayBindings[oldKeypath.str], this);

  		this.keypath = newKeypath;

  		bindings = this.root._twowayBindings[newKeypath.str] || (this.root._twowayBindings[newKeypath.str] = []);
  		bindings.push(this);
  	},

  	unbind: function () {}
  };

  Binding.extend = function (properties) {
  	var Parent = this,
  	    SpecialisedBinding;

  	SpecialisedBinding = function (element) {
  		Binding.call(this, element);

  		if (this.init) {
  			this.init();
  		}
  	};

  	SpecialisedBinding.prototype = create(Parent.prototype);
  	utils_object__extend(SpecialisedBinding.prototype, properties);

  	SpecialisedBinding.extend = Binding.extend;

  	return SpecialisedBinding;
  };

  var Binding_Binding = Binding;

  function findParentForm(element) {
  	while (element = element.parent) {
  		if (element.name === "form") {
  			return element;
  		}
  	}
  }

  // this is called when the element is unbound.
  // Specialised bindings can override it

  // This is the handler for DOM events that would lead to a change in the model
  // (i.e. change, sometimes, input, and occasionally click and keyup)
  var handleDomEvent = handleChange;

  function handleChange() {
  	this._ractive.binding.handleChange();
  }

  var GenericBinding;

  GenericBinding = Binding_Binding.extend({
  	getInitialValue: function () {
  		return "";
  	},

  	getValue: function () {
  		return this.element.node.value;
  	},

  	render: function () {
  		var node = this.element.node,
  		    lazy,
  		    timeout = false;
  		this.rendered = true;

  		// any lazy setting for this element overrides the root
  		// if the value is a number, it's a timeout
  		lazy = this.root.lazy;
  		if (this.element.lazy === true) {
  			lazy = true;
  		} else if (this.element.lazy === false) {
  			lazy = false;
  		} else if (is__isNumeric(this.element.lazy)) {
  			lazy = false;
  			timeout = +this.element.lazy;
  		} else if (is__isNumeric(lazy || "")) {
  			timeout = +lazy;
  			lazy = false;

  			// make sure the timeout is available to the handler
  			this.element.lazy = timeout;
  		}

  		this.handler = timeout ? handleDelay : handleDomEvent;

  		node.addEventListener("change", handleDomEvent, false);

  		if (!lazy) {
  			node.addEventListener("input", this.handler, false);

  			if (node.attachEvent) {
  				node.addEventListener("keyup", this.handler, false);
  			}
  		}

  		node.addEventListener("blur", handleBlur, false);
  	},

  	unrender: function () {
  		var node = this.element.node;
  		this.rendered = false;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("input", this.handler, false);
  		node.removeEventListener("keyup", this.handler, false);
  		node.removeEventListener("blur", handleBlur, false);
  	}
  });

  var Binding_GenericBinding = GenericBinding;

  function handleBlur() {
  	var value;

  	handleDomEvent.call(this);

  	value = this._ractive.root.viewmodel.get(this._ractive.binding.keypath);
  	this.value = value == undefined ? "" : value;
  }

  function handleDelay() {
  	var binding = this._ractive.binding,
  	    el = this;

  	if (!!binding._timeout) clearTimeout(binding._timeout);

  	binding._timeout = setTimeout(function () {
  		if (binding.rendered) handleDomEvent.call(el);
  		binding._timeout = undefined;
  	}, binding.element.lazy);
  }

  var ContentEditableBinding = Binding_GenericBinding.extend({
  	getInitialValue: function () {
  		return this.element.fragment ? this.element.fragment.toString() : "";
  	},

  	getValue: function () {
  		return this.element.node.innerHTML;
  	}
  });

  var Binding_ContentEditableBinding = ContentEditableBinding;

  var shared_getSiblings = getSiblings;
  var sets = {};
  function getSiblings(id, group, keypath) {
  	var hash = id + group + keypath;
  	return sets[hash] || (sets[hash] = []);
  }

  var RadioBinding = Binding_Binding.extend({
  	name: "checked",

  	init: function () {
  		this.siblings = shared_getSiblings(this.root._guid, "radio", this.element.getAttribute("name"));
  		this.siblings.push(this);
  	},

  	render: function () {
  		var node = this.element.node;

  		node.addEventListener("change", handleDomEvent, false);

  		if (node.attachEvent) {
  			node.addEventListener("click", handleDomEvent, false);
  		}
  	},

  	unrender: function () {
  		var node = this.element.node;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("click", handleDomEvent, false);
  	},

  	handleChange: function () {
  		global_runloop.start(this.root);

  		this.siblings.forEach(function (binding) {
  			binding.root.viewmodel.set(binding.keypath, binding.getValue());
  		});

  		global_runloop.end();
  	},

  	getValue: function () {
  		return this.element.node.checked;
  	},

  	unbind: function () {
  		removeFromArray(this.siblings, this);
  	}
  });

  var Binding_RadioBinding = RadioBinding;

  var RadioNameBinding = Binding_Binding.extend({
  	name: "name",

  	init: function () {
  		this.siblings = shared_getSiblings(this.root._guid, "radioname", this.keypath.str);
  		this.siblings.push(this);

  		this.radioName = true; // so that ractive.updateModel() knows what to do with this
  	},

  	getInitialValue: function () {
  		if (this.element.getAttribute("checked")) {
  			return this.element.getAttribute("value");
  		}
  	},

  	render: function () {
  		var node = this.element.node;

  		node.name = "{{" + this.keypath.str + "}}";
  		node.checked = this.root.viewmodel.get(this.keypath) == this.element.getAttribute("value");

  		node.addEventListener("change", handleDomEvent, false);

  		if (node.attachEvent) {
  			node.addEventListener("click", handleDomEvent, false);
  		}
  	},

  	unrender: function () {
  		var node = this.element.node;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("click", handleDomEvent, false);
  	},

  	getValue: function () {
  		var node = this.element.node;
  		return node._ractive ? node._ractive.value : node.value;
  	},

  	handleChange: function () {
  		// If this <input> is the one that's checked, then the value of its
  		// `name` keypath gets set to its value
  		if (this.element.node.checked) {
  			Binding_Binding.prototype.handleChange.call(this);
  		}
  	},

  	rebound: function (oldKeypath, newKeypath) {
  		var node;

  		Binding_Binding.prototype.rebound.call(this, oldKeypath, newKeypath);

  		if (node = this.element.node) {
  			node.name = "{{" + this.keypath.str + "}}";
  		}
  	},

  	unbind: function () {
  		removeFromArray(this.siblings, this);
  	}
  });

  var Binding_RadioNameBinding = RadioNameBinding;

  var CheckboxNameBinding = Binding_Binding.extend({
  	name: "name",

  	getInitialValue: function () {
  		// This only gets called once per group (of inputs that
  		// share a name), because it only gets called if there
  		// isn't an initial value. By the same token, we can make
  		// a note of that fact that there was no initial value,
  		// and populate it using any `checked` attributes that
  		// exist (which users should avoid, but which we should
  		// support anyway to avoid breaking expectations)
  		this.noInitialValue = true;
  		return [];
  	},

  	init: function () {
  		var existingValue, bindingValue;

  		this.checkboxName = true; // so that ractive.updateModel() knows what to do with this

  		// Each input has a reference to an array containing it and its
  		// siblings, as two-way binding depends on being able to ascertain
  		// the status of all inputs within the group
  		this.siblings = shared_getSiblings(this.root._guid, "checkboxes", this.keypath.str);
  		this.siblings.push(this);

  		if (this.noInitialValue) {
  			this.siblings.noInitialValue = true;
  		}

  		// If no initial value was set, and this input is checked, we
  		// update the model
  		if (this.siblings.noInitialValue && this.element.getAttribute("checked")) {
  			existingValue = this.root.viewmodel.get(this.keypath);
  			bindingValue = this.element.getAttribute("value");

  			existingValue.push(bindingValue);
  		}
  	},

  	unbind: function () {
  		removeFromArray(this.siblings, this);
  	},

  	render: function () {
  		var node = this.element.node,
  		    existingValue,
  		    bindingValue;

  		existingValue = this.root.viewmodel.get(this.keypath);
  		bindingValue = this.element.getAttribute("value");

  		if (isArray(existingValue)) {
  			this.isChecked = arrayContains(existingValue, bindingValue);
  		} else {
  			this.isChecked = existingValue == bindingValue;
  		}

  		node.name = "{{" + this.keypath.str + "}}";
  		node.checked = this.isChecked;

  		node.addEventListener("change", handleDomEvent, false);

  		// in case of IE emergency, bind to click event as well
  		if (node.attachEvent) {
  			node.addEventListener("click", handleDomEvent, false);
  		}
  	},

  	unrender: function () {
  		var node = this.element.node;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("click", handleDomEvent, false);
  	},

  	changed: function () {
  		var wasChecked = !!this.isChecked;
  		this.isChecked = this.element.node.checked;
  		return this.isChecked === wasChecked;
  	},

  	handleChange: function () {
  		this.isChecked = this.element.node.checked;
  		Binding_Binding.prototype.handleChange.call(this);
  	},

  	getValue: function () {
  		return this.siblings.filter(isChecked).map(Binding_CheckboxNameBinding__getValue);
  	}
  });

  function isChecked(binding) {
  	return binding.isChecked;
  }

  function Binding_CheckboxNameBinding__getValue(binding) {
  	return binding.element.getAttribute("value");
  }

  var Binding_CheckboxNameBinding = CheckboxNameBinding;

  var CheckboxBinding = Binding_Binding.extend({
  	name: "checked",

  	render: function () {
  		var node = this.element.node;

  		node.addEventListener("change", handleDomEvent, false);

  		if (node.attachEvent) {
  			node.addEventListener("click", handleDomEvent, false);
  		}
  	},

  	unrender: function () {
  		var node = this.element.node;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("click", handleDomEvent, false);
  	},

  	getValue: function () {
  		return this.element.node.checked;
  	}
  });

  var Binding_CheckboxBinding = CheckboxBinding;

  var SelectBinding = Binding_Binding.extend({
  	getInitialValue: function () {
  		var options = this.element.options,
  		    len,
  		    i,
  		    value,
  		    optionWasSelected;

  		if (this.element.getAttribute("value") !== undefined) {
  			return;
  		}

  		i = len = options.length;

  		if (!len) {
  			return;
  		}

  		// take the final selected option...
  		while (i--) {
  			if (options[i].getAttribute("selected")) {
  				value = options[i].getAttribute("value");
  				optionWasSelected = true;
  				break;
  			}
  		}

  		// or the first non-disabled option, if none are selected
  		if (!optionWasSelected) {
  			while (++i < len) {
  				if (!options[i].getAttribute("disabled")) {
  					value = options[i].getAttribute("value");
  					break;
  				}
  			}
  		}

  		// This is an optimisation (aka hack) that allows us to forgo some
  		// other more expensive work
  		if (value !== undefined) {
  			this.element.attributes.value.value = value;
  		}

  		return value;
  	},

  	render: function () {
  		this.element.node.addEventListener("change", handleDomEvent, false);
  	},

  	unrender: function () {
  		this.element.node.removeEventListener("change", handleDomEvent, false);
  	},

  	// TODO this method is an anomaly... is it necessary?
  	setValue: function (value) {
  		this.root.viewmodel.set(this.keypath, value);
  	},

  	getValue: function () {
  		var options, i, len, option, optionValue;

  		options = this.element.node.options;
  		len = options.length;

  		for (i = 0; i < len; i += 1) {
  			option = options[i];

  			if (options[i].selected) {
  				optionValue = option._ractive ? option._ractive.value : option.value;
  				return optionValue;
  			}
  		}
  	},

  	forceUpdate: function () {
  		var _this = this;

  		var value = this.getValue();

  		if (value !== undefined) {
  			this.attribute.locked = true;
  			global_runloop.scheduleTask(function () {
  				return _this.attribute.locked = false;
  			});
  			this.root.viewmodel.set(this.keypath, value);
  		}
  	}
  });

  var Binding_SelectBinding = SelectBinding;

  var MultipleSelectBinding = Binding_SelectBinding.extend({
  	getInitialValue: function () {
  		return this.element.options.filter(function (option) {
  			return option.getAttribute("selected");
  		}).map(function (option) {
  			return option.getAttribute("value");
  		});
  	},

  	render: function () {
  		var valueFromModel;

  		this.element.node.addEventListener("change", handleDomEvent, false);

  		valueFromModel = this.root.viewmodel.get(this.keypath);

  		if (valueFromModel === undefined) {
  			// get value from DOM, if possible
  			this.handleChange();
  		}
  	},

  	unrender: function () {
  		this.element.node.removeEventListener("change", handleDomEvent, false);
  	},

  	setValue: function () {
  		throw new Error("TODO not implemented yet");
  	},

  	getValue: function () {
  		var selectedValues, options, i, len, option, optionValue;

  		selectedValues = [];
  		options = this.element.node.options;
  		len = options.length;

  		for (i = 0; i < len; i += 1) {
  			option = options[i];

  			if (option.selected) {
  				optionValue = option._ractive ? option._ractive.value : option.value;
  				selectedValues.push(optionValue);
  			}
  		}

  		return selectedValues;
  	},

  	handleChange: function () {
  		var attribute, previousValue, value;

  		attribute = this.attribute;
  		previousValue = attribute.value;

  		value = this.getValue();

  		if (previousValue === undefined || !arrayContentsMatch(value, previousValue)) {
  			Binding_SelectBinding.prototype.handleChange.call(this);
  		}

  		return this;
  	},

  	forceUpdate: function () {
  		var _this = this;

  		var value = this.getValue();

  		if (value !== undefined) {
  			this.attribute.locked = true;
  			global_runloop.scheduleTask(function () {
  				return _this.attribute.locked = false;
  			});
  			this.root.viewmodel.set(this.keypath, value);
  		}
  	},

  	updateModel: function () {
  		if (this.attribute.value === undefined || !this.attribute.value.length) {
  			this.root.viewmodel.set(this.keypath, this.initialValue);
  		}
  	}
  });

  var Binding_MultipleSelectBinding = MultipleSelectBinding;

  var FileListBinding = Binding_Binding.extend({
  	render: function () {
  		this.element.node.addEventListener("change", handleDomEvent, false);
  	},

  	unrender: function () {
  		this.element.node.removeEventListener("change", handleDomEvent, false);
  	},

  	getValue: function () {
  		return this.element.node.files;
  	}
  });

  var Binding_FileListBinding = FileListBinding;

  var NumericBinding = Binding_GenericBinding.extend({
  	getInitialValue: function () {
  		return undefined;
  	},

  	getValue: function () {
  		var value = parseFloat(this.element.node.value);
  		return isNaN(value) ? undefined : value;
  	}
  });

  var init_createTwowayBinding = createTwowayBinding;

  function createTwowayBinding(element) {
  	var attributes = element.attributes,
  	    type,
  	    Binding,
  	    bindName,
  	    bindChecked,
  	    binding;

  	// if this is a late binding, and there's already one, it
  	// needs to be torn down
  	if (element.binding) {
  		element.binding.teardown();
  		element.binding = null;
  	}

  	// contenteditable
  	if (
  	// if the contenteditable attribute is true or is bindable and may thus become true
  	(element.getAttribute("contenteditable") || !!attributes.contenteditable && isBindable(attributes.contenteditable)) && isBindable(attributes.value)) {
  		Binding = Binding_ContentEditableBinding;
  	}

  	// <input>
  	else if (element.name === "input") {
  		type = element.getAttribute("type");

  		if (type === "radio" || type === "checkbox") {
  			bindName = isBindable(attributes.name);
  			bindChecked = isBindable(attributes.checked);

  			// we can either bind the name attribute, or the checked attribute - not both
  			if (bindName && bindChecked) {
  				warnIfDebug("A radio input can have two-way binding on its name attribute, or its checked attribute - not both", { ractive: element.root });
  			}

  			if (bindName) {
  				Binding = type === "radio" ? Binding_RadioNameBinding : Binding_CheckboxNameBinding;
  			} else if (bindChecked) {
  				Binding = type === "radio" ? Binding_RadioBinding : Binding_CheckboxBinding;
  			}
  		} else if (type === "file" && isBindable(attributes.value)) {
  			Binding = Binding_FileListBinding;
  		} else if (isBindable(attributes.value)) {
  			Binding = type === "number" || type === "range" ? NumericBinding : Binding_GenericBinding;
  		}
  	}

  	// <select>
  	else if (element.name === "select" && isBindable(attributes.value)) {
  		Binding = element.getAttribute("multiple") ? Binding_MultipleSelectBinding : Binding_SelectBinding;
  	}

  	// <textarea>
  	else if (element.name === "textarea" && isBindable(attributes.value)) {
  		Binding = Binding_GenericBinding;
  	}

  	if (Binding && (binding = new Binding(element)) && binding.keypath) {
  		return binding;
  	}
  }

  function isBindable(attribute) {
  	return attribute && attribute.isBindable;
  }

  // and this element also has a value attribute to bind

  var EventHandler_prototype_bubble = EventHandler$bubble;

  function EventHandler$bubble() {
  	var hasAction = this.getAction();

  	if (hasAction && !this.hasListener) {
  		this.listen();
  	} else if (!hasAction && this.hasListener) {
  		this.unrender();
  	}
  }

  // This function may be overwritten, if the event directive
  // includes parameters
  var EventHandler_prototype_fire = EventHandler$fire;
  function EventHandler$fire(event) {
  	shared_fireEvent(this.root, this.getAction(), { event: event });
  }

  var getAction = EventHandler$getAction;

  function EventHandler$getAction() {
  	return this.action.toString().trim();
  }

  var EventHandler_prototype_init = EventHandler$init;

  var eventPattern = /^event(?:\.(.+))?/;
  function EventHandler$init(element, name, template) {
  	var _this = this;

  	var action, refs, ractive;

  	this.element = element;
  	this.root = element.root;
  	this.parentFragment = element.parentFragment;
  	this.name = name;

  	if (name.indexOf("*") !== -1) {
  		fatal("Only component proxy-events may contain \"*\" wildcards, <%s on-%s=\"...\"/> is not valid", element.name, name);
  		this.invalid = true;
  	}

  	if (template.m) {
  		refs = template.a.r;

  		// This is a method call
  		this.method = template.m;
  		this.keypaths = [];
  		this.fn = shared_getFunctionFromString(template.a.s, refs.length);

  		this.parentFragment = element.parentFragment;
  		ractive = this.root;

  		// Create resolvers for each reference
  		this.refResolvers = [];
  		refs.forEach(function (ref, i) {
  			var match = undefined;

  			// special case - the `event` object
  			if (match = eventPattern.exec(ref)) {
  				_this.keypaths[i] = {
  					eventObject: true,
  					refinements: match[1] ? match[1].split(".") : []
  				};
  			} else {
  				_this.refResolvers.push(Resolvers_createReferenceResolver(_this, ref, function (keypath) {
  					return _this.resolve(i, keypath);
  				}));
  			}
  		});

  		this.fire = fireMethodCall;
  	} else {
  		// Get action ('foo' in 'on-click='foo')
  		action = template.n || template;
  		if (typeof action !== "string") {
  			action = new virtualdom_Fragment({
  				template: action,
  				root: this.root,
  				owner: this
  			});
  		}

  		this.action = action;

  		// Get parameters
  		if (template.d) {
  			this.dynamicParams = new virtualdom_Fragment({
  				template: template.d,
  				root: this.root,
  				owner: this.element
  			});

  			this.fire = fireEventWithDynamicParams;
  		} else if (template.a) {
  			this.params = template.a;
  			this.fire = fireEventWithParams;
  		}
  	}
  }

  function fireMethodCall(event) {
  	var ractive, values, args;

  	ractive = this.root;

  	if (typeof ractive[this.method] !== "function") {
  		throw new Error("Attempted to call a non-existent method (\"" + this.method + "\")");
  	}

  	values = this.keypaths.map(function (keypath) {
  		var value, len, i;

  		if (keypath === undefined) {
  			// not yet resolved
  			return undefined;
  		}

  		// TODO the refinements stuff would be better handled at parse time
  		if (keypath.eventObject) {
  			value = event;

  			if (len = keypath.refinements.length) {
  				for (i = 0; i < len; i += 1) {
  					value = value[keypath.refinements[i]];
  				}
  			}
  		} else {
  			value = ractive.viewmodel.get(keypath);
  		}

  		return value;
  	});

  	shared_eventStack.enqueue(ractive, event);

  	args = this.fn.apply(null, values);
  	ractive[this.method].apply(ractive, args);

  	shared_eventStack.dequeue(ractive);
  }

  function fireEventWithParams(event) {
  	shared_fireEvent(this.root, this.getAction(), { event: event, args: this.params });
  }

  function fireEventWithDynamicParams(event) {
  	var args = this.dynamicParams.getArgsList();

  	// need to strip [] from ends if a string!
  	if (typeof args === "string") {
  		args = args.substr(1, args.length - 2);
  	}

  	shared_fireEvent(this.root, this.getAction(), { event: event, args: args });
  }

  var shared_genericHandler = genericHandler;
  function genericHandler(event) {
  	var storage,
  	    handler,
  	    indices,
  	    index = {};

  	storage = this._ractive;
  	handler = storage.events[event.type];

  	if (indices = Resolvers_findIndexRefs(handler.element.parentFragment)) {
  		index = Resolvers_findIndexRefs.resolve(indices);
  	}

  	handler.fire({
  		node: this,
  		original: event,
  		index: index,
  		keypath: storage.keypath.str,
  		context: storage.root.viewmodel.get(storage.keypath)
  	});
  }

  var listen = EventHandler$listen;

  var customHandlers = {},
      touchEvents = {
  	touchstart: true,
  	touchmove: true,
  	touchend: true,
  	touchcancel: true,
  	//not w3c, but supported in some browsers
  	touchleave: true
  };
  function EventHandler$listen() {
  	var definition,
  	    name = this.name;

  	if (this.invalid) {
  		return;
  	}

  	if (definition = findInViewHierarchy("events", this.root, name)) {
  		this.custom = definition(this.node, getCustomHandler(name));
  	} else {
  		// Looks like we're dealing with a standard DOM event... but let's check
  		if (!("on" + name in this.node) && !(window && "on" + name in window) && !isJsdom) {

  			// okay to use touch events if this browser doesn't support them
  			if (!touchEvents[name]) {
  				warnOnceIfDebug(missingPlugin(name, "event"), { node: this.node });
  			}

  			return;
  		}

  		this.node.addEventListener(name, shared_genericHandler, false);
  	}

  	this.hasListener = true;
  }

  function getCustomHandler(name) {
  	if (!customHandlers[name]) {
  		customHandlers[name] = function (event) {
  			var storage = event.node._ractive;

  			event.index = storage.index;
  			event.keypath = storage.keypath.str;
  			event.context = storage.root.viewmodel.get(storage.keypath);

  			storage.events[name].fire(event);
  		};
  	}

  	return customHandlers[name];
  }

  var EventHandler_prototype_rebind = EventHandler$rebind;

  function EventHandler$rebind(oldKeypath, newKeypath) {
  	var fragment;
  	if (this.method) {
  		fragment = this.element.parentFragment;
  		this.refResolvers.forEach(rebind);

  		return;
  	}

  	if (typeof this.action !== "string") {
  		rebind(this.action);
  	}

  	if (this.dynamicParams) {
  		rebind(this.dynamicParams);
  	}

  	function rebind(thing) {
  		thing && thing.rebind(oldKeypath, newKeypath);
  	}
  }

  var EventHandler_prototype_render = EventHandler$render;

  function EventHandler$render() {
  	this.node = this.element.node;
  	// store this on the node itself, so it can be retrieved by a
  	// universal handler
  	this.node._ractive.events[this.name] = this;

  	if (this.method || this.getAction()) {
  		this.listen();
  	}
  }

  var prototype_resolve = EventHandler$resolve;

  function EventHandler$resolve(index, keypath) {
  	this.keypaths[index] = keypath;
  }

  var EventHandler_prototype_unbind = EventHandler$unbind;
  function EventHandler$unbind() {
  	if (this.method) {
  		this.refResolvers.forEach(methodCallers__unbind);
  		return;
  	}

  	// Tear down dynamic name
  	if (typeof this.action !== "string") {
  		this.action.unbind();
  	}

  	// Tear down dynamic parameters
  	if (this.dynamicParams) {
  		this.dynamicParams.unbind();
  	}
  }

  var EventHandler_prototype_unrender = EventHandler$unrender;
  function EventHandler$unrender() {

  	if (this.custom) {
  		this.custom.teardown();
  	} else {
  		this.node.removeEventListener(this.name, shared_genericHandler, false);
  	}

  	this.hasListener = false;
  }

  var EventHandler = function (element, name, template) {
  	this.init(element, name, template);
  };

  EventHandler.prototype = {
  	bubble: EventHandler_prototype_bubble,
  	fire: EventHandler_prototype_fire,
  	getAction: getAction,
  	init: EventHandler_prototype_init,
  	listen: listen,
  	rebind: EventHandler_prototype_rebind,
  	render: EventHandler_prototype_render,
  	resolve: prototype_resolve,
  	unbind: EventHandler_prototype_unbind,
  	unrender: EventHandler_prototype_unrender
  };

  var _EventHandler = EventHandler;

  var createEventHandlers = function (element, template) {
  	var i,
  	    name,
  	    names,
  	    handler,
  	    result = [];

  	for (name in template) {
  		if (template.hasOwnProperty(name)) {
  			names = name.split("-");
  			i = names.length;

  			while (i--) {
  				handler = new _EventHandler(element, names[i], template[name]);
  				result.push(handler);
  			}
  		}
  	}

  	return result;
  };

  var Decorator = function (element, template) {
  	var self = this,
  	    ractive,
  	    name,
  	    fragment;

  	this.element = element;
  	this.root = ractive = element.root;

  	name = template.n || template;

  	if (typeof name !== "string") {
  		fragment = new virtualdom_Fragment({
  			template: name,
  			root: ractive,
  			owner: element
  		});

  		name = fragment.toString();
  		fragment.unbind();

  		if (name === "") {
  			// empty string okay, just no decorator
  			return;
  		}
  	}

  	if (template.a) {
  		this.params = template.a;
  	} else if (template.d) {
  		this.fragment = new virtualdom_Fragment({
  			template: template.d,
  			root: ractive,
  			owner: element
  		});

  		this.params = this.fragment.getArgsList();

  		this.fragment.bubble = function () {
  			this.dirtyArgs = this.dirtyValue = true;
  			self.params = this.getArgsList();

  			if (self.ready) {
  				self.update();
  			}
  		};
  	}

  	this.fn = findInViewHierarchy("decorators", ractive, name);

  	if (!this.fn) {
  		fatal(missingPlugin(name, "decorator"));
  	}
  };

  Decorator.prototype = {
  	init: function () {
  		var node, result, args;

  		node = this.element.node;

  		if (this.params) {
  			args = [node].concat(this.params);
  			result = this.fn.apply(this.root, args);
  		} else {
  			result = this.fn.call(this.root, node);
  		}

  		if (!result || !result.teardown) {
  			throw new Error("Decorator definition must return an object with a teardown method");
  		}

  		// TODO does this make sense?
  		this.actual = result;
  		this.ready = true;
  	},

  	update: function () {
  		if (this.actual.update) {
  			this.actual.update.apply(this.root, this.params);
  		} else {
  			this.actual.teardown(true);
  			this.init();
  		}
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		if (this.fragment) {
  			this.fragment.rebind(oldKeypath, newKeypath);
  		}
  	},

  	teardown: function (updating) {
  		this.torndown = true;
  		if (this.ready) {
  			this.actual.teardown();
  		}

  		if (!updating && this.fragment) {
  			this.fragment.unbind();
  		}
  	}
  };

  var _Decorator = Decorator;

  function select__bubble() {
  	var _this = this;

  	if (!this.dirty) {
  		this.dirty = true;

  		global_runloop.scheduleTask(function () {
  			sync(_this);
  			_this.dirty = false;
  		});
  	}

  	this.parentFragment.bubble(); // default behaviour
  }

  function sync(selectElement) {
  	var selectNode, selectValue, isMultiple, options, optionWasSelected;

  	selectNode = selectElement.node;

  	if (!selectNode) {
  		return;
  	}

  	options = toArray(selectNode.options);

  	selectValue = selectElement.getAttribute("value");
  	isMultiple = selectElement.getAttribute("multiple");

  	// If the <select> has a specified value, that should override
  	// these options
  	if (selectValue !== undefined) {
  		options.forEach(function (o) {
  			var optionValue, shouldSelect;

  			optionValue = o._ractive ? o._ractive.value : o.value;
  			shouldSelect = isMultiple ? valueContains(selectValue, optionValue) : selectValue == optionValue;

  			if (shouldSelect) {
  				optionWasSelected = true;
  			}

  			o.selected = shouldSelect;
  		});

  		if (!optionWasSelected) {
  			if (options[0]) {
  				options[0].selected = true;
  			}

  			if (selectElement.binding) {
  				selectElement.binding.forceUpdate();
  			}
  		}
  	}

  	// Otherwise the value should be initialised according to which
  	// <option> element is selected, if twoway binding is in effect
  	else if (selectElement.binding) {
  		selectElement.binding.forceUpdate();
  	}
  }

  function valueContains(selectValue, optionValue) {
  	var i = selectValue.length;
  	while (i--) {
  		if (selectValue[i] == optionValue) {
  			return true;
  		}
  	}
  }

  function special_option__init(option, template) {
  	option.select = findParentSelect(option.parent);

  	// we might be inside a <datalist> element
  	if (!option.select) {
  		return;
  	}

  	option.select.options.push(option);

  	// If the value attribute is missing, use the element's content
  	if (!template.a) {
  		template.a = {};
  	}

  	// ...as long as it isn't disabled
  	if (template.a.value === undefined && !template.a.hasOwnProperty("disabled")) {
  		template.a.value = template.f;
  	}

  	// If there is a `selected` attribute, but the <select>
  	// already has a value, delete it
  	if ("selected" in template.a && option.select.getAttribute("value") !== undefined) {
  		delete template.a.selected;
  	}
  }

  function special_option__unbind(option) {
  	if (option.select) {
  		removeFromArray(option.select.options, option);
  	}
  }

  function findParentSelect(element) {
  	if (!element) {
  		return;
  	}

  	do {
  		if (element.name === "select") {
  			return element;
  		}
  	} while (element = element.parent);
  }

  var Element_prototype_init = Element$init;
  function Element$init(options) {
  	var parentFragment, template, ractive, binding, bindings, twoway, bindingAttrs;

  	this.type = ELEMENT;

  	// stuff we'll need later
  	parentFragment = this.parentFragment = options.parentFragment;
  	template = this.template = options.template;

  	this.parent = options.pElement || parentFragment.pElement;

  	this.root = ractive = parentFragment.root;
  	this.index = options.index;
  	this.key = options.key;

  	this.name = enforceCase(template.e);

  	// Special case - <option> elements
  	if (this.name === "option") {
  		special_option__init(this, template);
  	}

  	// Special case - <select> elements
  	if (this.name === "select") {
  		this.options = [];
  		this.bubble = select__bubble; // TODO this is a kludge
  	}

  	// Special case - <form> elements
  	if (this.name === "form") {
  		this.formBindings = [];
  	}

  	// handle binding attributes first (twoway, lazy)
  	bindingAttrs = processBindingAttributes(this, template);

  	// create attributes
  	this.attributes = createAttributes(this, template.a);
  	this.conditionalAttributes = createConditionalAttributes(this, template.m);

  	// append children, if there are any
  	if (template.f) {
  		this.fragment = new virtualdom_Fragment({
  			template: template.f,
  			root: ractive,
  			owner: this,
  			pElement: this,
  			cssIds: null
  		});
  	}

  	// the element setting should override the ractive setting
  	twoway = ractive.twoway;
  	if (bindingAttrs.twoway === false) twoway = false;else if (bindingAttrs.twoway === true) twoway = true;

  	this.twoway = twoway;
  	this.lazy = bindingAttrs.lazy;

  	// create twoway binding
  	if (twoway && (binding = init_createTwowayBinding(this, template.a))) {
  		this.binding = binding;

  		// register this with the root, so that we can do ractive.updateModel()
  		bindings = this.root._twowayBindings[binding.keypath.str] || (this.root._twowayBindings[binding.keypath.str] = []);
  		bindings.push(binding);
  	}

  	// create event proxies
  	if (template.v) {
  		this.eventHandlers = createEventHandlers(this, template.v);
  	}

  	// create decorator
  	if (template.o) {
  		this.decorator = new _Decorator(this, template.o);
  	}

  	// create transitions
  	this.intro = template.t0 || template.t1;
  	this.outro = template.t0 || template.t2;
  }

  var Element_prototype_rebind = Element$rebind;
  function Element$rebind(oldKeypath, newKeypath) {
  	var i, storage, liveQueries, ractive;

  	if (this.attributes) {
  		this.attributes.forEach(rebind);
  	}

  	if (this.conditionalAttributes) {
  		this.conditionalAttributes.forEach(rebind);
  	}

  	if (this.eventHandlers) {
  		this.eventHandlers.forEach(rebind);
  	}

  	if (this.decorator) {
  		rebind(this.decorator);
  	}

  	// rebind children
  	if (this.fragment) {
  		rebind(this.fragment);
  	}

  	// Update live queries, if necessary
  	if (liveQueries = this.liveQueries) {
  		ractive = this.root;

  		i = liveQueries.length;
  		while (i--) {
  			liveQueries[i]._makeDirty();
  		}
  	}

  	if (this.node && (storage = this.node._ractive)) {

  		// adjust keypath if needed
  		assignNewKeypath(storage, "keypath", oldKeypath, newKeypath);
  	}

  	function rebind(thing) {
  		thing.rebind(oldKeypath, newKeypath);
  	}
  }

  function special_img__render(img) {
  	var loadHandler;

  	// if this is an <img>, and we're in a crap browser, we may need to prevent it
  	// from overriding width and height when it loads the src
  	if (img.attributes.width || img.attributes.height) {
  		img.node.addEventListener("load", loadHandler = function () {
  			var width = img.getAttribute("width"),
  			    height = img.getAttribute("height");

  			if (width !== undefined) {
  				img.node.setAttribute("width", width);
  			}

  			if (height !== undefined) {
  				img.node.setAttribute("height", height);
  			}

  			img.node.removeEventListener("load", loadHandler, false);
  		}, false);
  	}
  }

  function form__render(element) {
  	element.node.addEventListener("reset", handleReset, false);
  }

  function form__unrender(element) {
  	element.node.removeEventListener("reset", handleReset, false);
  }

  function handleReset() {
  	var element = this._ractive.proxy;

  	global_runloop.start();
  	element.formBindings.forEach(updateModel);
  	global_runloop.end();
  }

  function updateModel(binding) {
  	binding.root.viewmodel.set(binding.keypath, binding.resetValue);
  }

  var Transition_prototype_init = Transition$init;
  function Transition$init(element, template, isIntro) {
  	var ractive, name, fragment;

  	this.element = element;
  	this.root = ractive = element.root;
  	this.isIntro = isIntro;

  	name = template.n || template;

  	if (typeof name !== "string") {
  		fragment = new virtualdom_Fragment({
  			template: name,
  			root: ractive,
  			owner: element
  		});

  		name = fragment.toString();
  		fragment.unbind();

  		if (name === "") {
  			// empty string okay, just no transition
  			return;
  		}
  	}

  	this.name = name;

  	if (template.a) {
  		this.params = template.a;
  	} else if (template.d) {
  		// TODO is there a way to interpret dynamic arguments without all the
  		// 'dependency thrashing'?
  		fragment = new virtualdom_Fragment({
  			template: template.d,
  			root: ractive,
  			owner: element
  		});

  		this.params = fragment.getArgsList();
  		fragment.unbind();
  	}

  	this._fn = findInViewHierarchy("transitions", ractive, name);

  	if (!this._fn) {
  		warnOnceIfDebug(missingPlugin(name, "transition"), { ractive: this.root });
  	}
  }

  var camelCase = function (hyphenatedStr) {
  	return hyphenatedStr.replace(/-([a-zA-Z])/g, function (match, $1) {
  		return $1.toUpperCase();
  	});
  };

  var helpers_prefix__prefix, prefixCache, helpers_prefix__testStyle;

  if (!isClient) {
  	helpers_prefix__prefix = null;
  } else {
  	prefixCache = {};
  	helpers_prefix__testStyle = createElement("div").style;

  	helpers_prefix__prefix = function (prop) {
  		var i, vendor, capped;

  		prop = camelCase(prop);

  		if (!prefixCache[prop]) {
  			if (helpers_prefix__testStyle[prop] !== undefined) {
  				prefixCache[prop] = prop;
  			} else {
  				// test vendors...
  				capped = prop.charAt(0).toUpperCase() + prop.substring(1);

  				i = vendors.length;
  				while (i--) {
  					vendor = vendors[i];
  					if (helpers_prefix__testStyle[vendor + capped] !== undefined) {
  						prefixCache[prop] = vendor + capped;
  						break;
  					}
  				}
  			}
  		}

  		return prefixCache[prop];
  	};
  }

  var helpers_prefix = helpers_prefix__prefix;

  var getStyle, prototype_getStyle__getComputedStyle;

  if (!isClient) {
  	getStyle = null;
  } else {
  	prototype_getStyle__getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;

  	getStyle = function (props) {
  		var computedStyle, styles, i, prop, value;

  		computedStyle = prototype_getStyle__getComputedStyle(this.node);

  		if (typeof props === "string") {
  			value = computedStyle[helpers_prefix(props)];
  			if (value === "0px") {
  				value = 0;
  			}
  			return value;
  		}

  		if (!isArray(props)) {
  			throw new Error("Transition$getStyle must be passed a string, or an array of strings representing CSS properties");
  		}

  		styles = {};

  		i = props.length;
  		while (i--) {
  			prop = props[i];
  			value = computedStyle[helpers_prefix(prop)];
  			if (value === "0px") {
  				value = 0;
  			}
  			styles[prop] = value;
  		}

  		return styles;
  	};
  }

  var prototype_getStyle = getStyle;

  var setStyle = function (style, value) {
  	var prop;

  	if (typeof style === "string") {
  		this.node.style[helpers_prefix(style)] = value;
  	} else {
  		for (prop in style) {
  			if (style.hasOwnProperty(prop)) {
  				this.node.style[helpers_prefix(prop)] = style[prop];
  			}
  		}
  	}

  	return this;
  };

  var Ticker = function (options) {
  	var easing;

  	this.duration = options.duration;
  	this.step = options.step;
  	this.complete = options.complete;

  	// easing
  	if (typeof options.easing === "string") {
  		easing = options.root.easing[options.easing];

  		if (!easing) {
  			warnOnceIfDebug(missingPlugin(options.easing, "easing"));
  			easing = linear;
  		}
  	} else if (typeof options.easing === "function") {
  		easing = options.easing;
  	} else {
  		easing = linear;
  	}

  	this.easing = easing;

  	this.start = utils_getTime();
  	this.end = this.start + this.duration;

  	this.running = true;
  	shared_animations.add(this);
  };

  Ticker.prototype = {
  	tick: function (now) {
  		var elapsed, eased;

  		if (!this.running) {
  			return false;
  		}

  		if (now > this.end) {
  			if (this.step) {
  				this.step(1);
  			}

  			if (this.complete) {
  				this.complete(1);
  			}

  			return false;
  		}

  		elapsed = now - this.start;
  		eased = this.easing(elapsed / this.duration);

  		if (this.step) {
  			this.step(eased);
  		}

  		return true;
  	},

  	stop: function () {
  		if (this.abort) {
  			this.abort();
  		}

  		this.running = false;
  	}
  };

  var shared_Ticker = Ticker;
  function linear(t) {
  	return t;
  }

  var unprefixPattern = new RegExp("^-(?:" + vendors.join("|") + ")-");

  var unprefix = function (prop) {
  	return prop.replace(unprefixPattern, "");
  };

  var vendorPattern = new RegExp("^(?:" + vendors.join("|") + ")([A-Z])");

  var hyphenate = function (str) {
  	var hyphenated;

  	if (!str) {
  		return ""; // edge case
  	}

  	if (vendorPattern.test(str)) {
  		str = "-" + str;
  	}

  	hyphenated = str.replace(/[A-Z]/g, function (match) {
  		return "-" + match.toLowerCase();
  	});

  	return hyphenated;
  };

  var createTransitions,
      animateStyle_createTransitions__testStyle,
      TRANSITION,
      TRANSITIONEND,
      CSS_TRANSITIONS_ENABLED,
      TRANSITION_DURATION,
      TRANSITION_PROPERTY,
      TRANSITION_TIMING_FUNCTION,
      canUseCssTransitions = {},
      cannotUseCssTransitions = {};

  if (!isClient) {
  	createTransitions = null;
  } else {
  	animateStyle_createTransitions__testStyle = createElement("div").style;

  	// determine some facts about our environment
  	(function () {
  		if (animateStyle_createTransitions__testStyle.transition !== undefined) {
  			TRANSITION = "transition";
  			TRANSITIONEND = "transitionend";
  			CSS_TRANSITIONS_ENABLED = true;
  		} else if (animateStyle_createTransitions__testStyle.webkitTransition !== undefined) {
  			TRANSITION = "webkitTransition";
  			TRANSITIONEND = "webkitTransitionEnd";
  			CSS_TRANSITIONS_ENABLED = true;
  		} else {
  			CSS_TRANSITIONS_ENABLED = false;
  		}
  	})();

  	if (TRANSITION) {
  		TRANSITION_DURATION = TRANSITION + "Duration";
  		TRANSITION_PROPERTY = TRANSITION + "Property";
  		TRANSITION_TIMING_FUNCTION = TRANSITION + "TimingFunction";
  	}

  	createTransitions = function (t, to, options, changedProperties, resolve) {

  		// Wait a beat (otherwise the target styles will be applied immediately)
  		// TODO use a fastdom-style mechanism?
  		setTimeout(function () {

  			var hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;

  			checkComplete = function () {
  				if (jsTransitionsComplete && cssTransitionsComplete) {
  					// will changes to events and fire have an unexpected consequence here?
  					t.root.fire(t.name + ":end", t.node, t.isIntro);
  					resolve();
  				}
  			};

  			// this is used to keep track of which elements can use CSS to animate
  			// which properties
  			hashPrefix = (t.node.namespaceURI || "") + t.node.tagName;

  			t.node.style[TRANSITION_PROPERTY] = changedProperties.map(helpers_prefix).map(hyphenate).join(",");
  			t.node.style[TRANSITION_TIMING_FUNCTION] = hyphenate(options.easing || "linear");
  			t.node.style[TRANSITION_DURATION] = options.duration / 1000 + "s";

  			transitionEndHandler = function (event) {
  				var index;

  				index = changedProperties.indexOf(camelCase(unprefix(event.propertyName)));
  				if (index !== -1) {
  					changedProperties.splice(index, 1);
  				}

  				if (changedProperties.length) {
  					// still transitioning...
  					return;
  				}

  				t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);

  				cssTransitionsComplete = true;
  				checkComplete();
  			};

  			t.node.addEventListener(TRANSITIONEND, transitionEndHandler, false);

  			setTimeout(function () {
  				var i = changedProperties.length,
  				    hash,
  				    originalValue,
  				    index,
  				    propertiesToTransitionInJs = [],
  				    prop,
  				    suffix;

  				while (i--) {
  					prop = changedProperties[i];
  					hash = hashPrefix + prop;

  					if (CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[hash]) {
  						t.node.style[helpers_prefix(prop)] = to[prop];

  						// If we're not sure if CSS transitions are supported for
  						// this tag/property combo, find out now
  						if (!canUseCssTransitions[hash]) {
  							originalValue = t.getStyle(prop);

  							// if this property is transitionable in this browser,
  							// the current style will be different from the target style
  							canUseCssTransitions[hash] = t.getStyle(prop) != to[prop];
  							cannotUseCssTransitions[hash] = !canUseCssTransitions[hash];

  							// Reset, if we're going to use timers after all
  							if (cannotUseCssTransitions[hash]) {
  								t.node.style[helpers_prefix(prop)] = originalValue;
  							}
  						}
  					}

  					if (!CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[hash]) {
  						// we need to fall back to timer-based stuff
  						if (originalValue === undefined) {
  							originalValue = t.getStyle(prop);
  						}

  						// need to remove this from changedProperties, otherwise transitionEndHandler
  						// will get confused
  						index = changedProperties.indexOf(prop);
  						if (index === -1) {
  							warnIfDebug("Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!", { node: t.node });
  						} else {
  							changedProperties.splice(index, 1);
  						}

  						// TODO Determine whether this property is animatable at all

  						suffix = /[^\d]*$/.exec(to[prop])[0];

  						// ...then kick off a timer-based transition
  						propertiesToTransitionInJs.push({
  							name: helpers_prefix(prop),
  							interpolator: shared_interpolate(parseFloat(originalValue), parseFloat(to[prop])),
  							suffix: suffix
  						});
  					}
  				}

  				// javascript transitions
  				if (propertiesToTransitionInJs.length) {
  					new shared_Ticker({
  						root: t.root,
  						duration: options.duration,
  						easing: camelCase(options.easing || ""),
  						step: function (pos) {
  							var prop, i;

  							i = propertiesToTransitionInJs.length;
  							while (i--) {
  								prop = propertiesToTransitionInJs[i];
  								t.node.style[prop.name] = prop.interpolator(pos) + prop.suffix;
  							}
  						},
  						complete: function () {
  							jsTransitionsComplete = true;
  							checkComplete();
  						}
  					});
  				} else {
  					jsTransitionsComplete = true;
  				}

  				if (!changedProperties.length) {
  					// We need to cancel the transitionEndHandler, and deal with
  					// the fact that it will never fire
  					t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);
  					cssTransitionsComplete = true;
  					checkComplete();
  				}
  			}, 0);
  		}, options.delay || 0);
  	};
  }

  var animateStyle_createTransitions = createTransitions;

  var hidden, vendor, animateStyle_visibility__prefix, animateStyle_visibility__i, visibility;

  if (typeof document !== "undefined") {
  	hidden = "hidden";

  	visibility = {};

  	if (hidden in document) {
  		animateStyle_visibility__prefix = "";
  	} else {
  		animateStyle_visibility__i = vendors.length;
  		while (animateStyle_visibility__i--) {
  			vendor = vendors[animateStyle_visibility__i];
  			hidden = vendor + "Hidden";

  			if (hidden in document) {
  				animateStyle_visibility__prefix = vendor;
  			}
  		}
  	}

  	if (animateStyle_visibility__prefix !== undefined) {
  		document.addEventListener(animateStyle_visibility__prefix + "visibilitychange", onChange);

  		// initialise
  		onChange();
  	} else {
  		// gah, we're in an old browser
  		if ("onfocusout" in document) {
  			document.addEventListener("focusout", onHide);
  			document.addEventListener("focusin", onShow);
  		} else {
  			window.addEventListener("pagehide", onHide);
  			window.addEventListener("blur", onHide);

  			window.addEventListener("pageshow", onShow);
  			window.addEventListener("focus", onShow);
  		}

  		visibility.hidden = false; // until proven otherwise. Not ideal but hey
  	}
  }

  function onChange() {
  	visibility.hidden = document[hidden];
  }

  function onHide() {
  	visibility.hidden = true;
  }

  function onShow() {
  	visibility.hidden = false;
  }

  var animateStyle_visibility = visibility;

  var animateStyle, _animateStyle__getComputedStyle, resolved;

  if (!isClient) {
  	animateStyle = null;
  } else {
  	_animateStyle__getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;

  	animateStyle = function (style, value, options) {
  		var _this = this;

  		var to;

  		if (arguments.length === 4) {
  			throw new Error("t.animateStyle() returns a promise - use .then() instead of passing a callback");
  		}

  		// Special case - page isn't visible. Don't animate anything, because
  		// that way you'll never get CSS transitionend events
  		if (animateStyle_visibility.hidden) {
  			this.setStyle(style, value);
  			return resolved || (resolved = utils_Promise.resolve());
  		}

  		if (typeof style === "string") {
  			to = {};
  			to[style] = value;
  		} else {
  			to = style;

  			// shuffle arguments
  			options = value;
  		}

  		// As of 0.3.9, transition authors should supply an `option` object with
  		// `duration` and `easing` properties (and optional `delay`), plus a
  		// callback function that gets called after the animation completes

  		// TODO remove this check in a future version
  		if (!options) {
  			warnOnceIfDebug("The \"%s\" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340", this.name);
  			options = this;
  		}

  		var promise = new utils_Promise(function (resolve) {
  			var propertyNames, changedProperties, computedStyle, current, from, i, prop;

  			// Edge case - if duration is zero, set style synchronously and complete
  			if (!options.duration) {
  				_this.setStyle(to);
  				resolve();
  				return;
  			}

  			// Get a list of the properties we're animating
  			propertyNames = Object.keys(to);
  			changedProperties = [];

  			// Store the current styles
  			computedStyle = _animateStyle__getComputedStyle(_this.node);

  			from = {};
  			i = propertyNames.length;
  			while (i--) {
  				prop = propertyNames[i];
  				current = computedStyle[helpers_prefix(prop)];

  				if (current === "0px") {
  					current = 0;
  				}

  				// we need to know if we're actually changing anything
  				if (current != to[prop]) {
  					// use != instead of !==, so we can compare strings with numbers
  					changedProperties.push(prop);

  					// make the computed style explicit, so we can animate where
  					// e.g. height='auto'
  					_this.node.style[helpers_prefix(prop)] = current;
  				}
  			}

  			// If we're not actually changing anything, the transitionend event
  			// will never fire! So we complete early
  			if (!changedProperties.length) {
  				resolve();
  				return;
  			}

  			animateStyle_createTransitions(_this, to, options, changedProperties, resolve);
  		});

  		return promise;
  	};
  }

  var _animateStyle = animateStyle;

  var processParams = function (params, defaults) {
  	if (typeof params === "number") {
  		params = { duration: params };
  	} else if (typeof params === "string") {
  		if (params === "slow") {
  			params = { duration: 600 };
  		} else if (params === "fast") {
  			params = { duration: 200 };
  		} else {
  			params = { duration: 400 };
  		}
  	} else if (!params) {
  		params = {};
  	}

  	return fillGaps({}, params, defaults);
  };

  var prototype_start = Transition$start;

  function Transition$start() {
  	var _this = this;

  	var node, originalStyle, completed;

  	node = this.node = this.element.node;
  	originalStyle = node.getAttribute("style");

  	// create t.complete() - we don't want this on the prototype,
  	// because we don't want `this` silliness when passing it as
  	// an argument
  	this.complete = function (noReset) {
  		if (completed) {
  			return;
  		}

  		if (!noReset && _this.isIntro) {
  			resetStyle(node, originalStyle);
  		}

  		node._ractive.transition = null;
  		_this._manager.remove(_this);

  		completed = true;
  	};

  	// If the transition function doesn't exist, abort
  	if (!this._fn) {
  		this.complete();
  		return;
  	}

  	this._fn.apply(this.root, [this].concat(this.params));
  }

  function resetStyle(node, style) {
  	if (style) {
  		node.setAttribute("style", style);
  	} else {

  		// Next line is necessary, to remove empty style attribute!
  		// See http://stackoverflow.com/a/7167553
  		node.getAttribute("style");
  		node.removeAttribute("style");
  	}
  }

  var Transition = function (owner, template, isIntro) {
  	this.init(owner, template, isIntro);
  };

  Transition.prototype = {
  	init: Transition_prototype_init,
  	start: prototype_start,
  	getStyle: prototype_getStyle,
  	setStyle: setStyle,
  	animateStyle: _animateStyle,
  	processParams: processParams
  };

  var _Transition = Transition;

  var Element_prototype_render = Element$render;

  var updateCss, updateScript;

  updateCss = function () {
  	var node = this.node,
  	    content = this.fragment.toString(false);

  	// IE8 has no styleSheet unless there's a type text/css
  	if (window && window.appearsToBeIELessEqual8) {
  		node.type = "text/css";
  	}

  	if (node.styleSheet) {
  		node.styleSheet.cssText = content;
  	} else {

  		while (node.hasChildNodes()) {
  			node.removeChild(node.firstChild);
  		}

  		node.appendChild(document.createTextNode(content));
  	}
  };

  updateScript = function () {
  	if (!this.node.type || this.node.type === "text/javascript") {
  		warnIfDebug("Script tag was updated. This does not cause the code to be re-evaluated!", { ractive: this.root });
  		// As it happens, we ARE in a position to re-evaluate the code if we wanted
  		// to - we could eval() it, or insert it into a fresh (temporary) script tag.
  		// But this would be a terrible idea with unpredictable results, so let's not.
  	}

  	this.node.text = this.fragment.toString(false);
  };
  function Element$render() {
  	var _this = this;

  	var root = this.root,
  	    namespace,
  	    node,
  	    transition;

  	namespace = getNamespace(this);
  	node = this.node = createElement(this.name, namespace);

  	// Is this a top-level node of a component? If so, we may need to add
  	// a data-ractive-css attribute, for CSS encapsulation
  	if (this.parentFragment.cssIds) {
  		this.node.setAttribute("data-ractive-css", this.parentFragment.cssIds.map(function (x) {
  			return "{" + x + "}";
  		}).join(" "));
  	}

  	// Add _ractive property to the node - we use this object to store stuff
  	// related to proxy events, two-way bindings etc
  	defineProperty(this.node, "_ractive", {
  		value: {
  			proxy: this,
  			keypath: getInnerContext(this.parentFragment),
  			events: create(null),
  			root: root
  		}
  	});

  	// Render attributes
  	this.attributes.forEach(function (a) {
  		return a.render(node);
  	});
  	this.conditionalAttributes.forEach(function (a) {
  		return a.render(node);
  	});

  	// Render children
  	if (this.fragment) {
  		// Special case - <script> element
  		if (this.name === "script") {
  			this.bubble = updateScript;
  			this.node.text = this.fragment.toString(false); // bypass warning initially
  			this.fragment.unrender = noop; // TODO this is a kludge
  		}

  		// Special case - <style> element
  		else if (this.name === "style") {
  			this.bubble = updateCss;
  			this.bubble();
  			this.fragment.unrender = noop;
  		}

  		// Special case - contenteditable
  		else if (this.binding && this.getAttribute("contenteditable")) {
  			this.fragment.unrender = noop;
  		} else {
  			this.node.appendChild(this.fragment.render());
  		}
  	}

  	// deal with two-way bindings
  	if (this.binding) {
  		this.binding.render();
  		this.node._ractive.binding = this.binding;
  	}

  	// Add proxy event handlers
  	if (this.eventHandlers) {
  		this.eventHandlers.forEach(function (h) {
  			return h.render();
  		});
  	}

  	if (this.name === "option") {
  		processOption(this);
  	}

  	// Special cases
  	if (this.name === "img") {
  		// if this is an <img>, and we're in a crap browser, we may
  		// need to prevent it from overriding width and height when
  		// it loads the src
  		special_img__render(this);
  	} else if (this.name === "form") {
  		// forms need to keep track of their bindings, in case of reset
  		form__render(this);
  	} else if (this.name === "input" || this.name === "textarea") {
  		// inputs and textareas should store their initial value as
  		// `defaultValue` in case of reset
  		this.node.defaultValue = this.node.value;
  	} else if (this.name === "option") {
  		// similarly for option nodes
  		this.node.defaultSelected = this.node.selected;
  	}

  	// apply decorator(s)
  	if (this.decorator && this.decorator.fn) {
  		global_runloop.scheduleTask(function () {
  			if (!_this.decorator.torndown) {
  				_this.decorator.init();
  			}
  		}, true);
  	}

  	// trigger intro transition
  	if (root.transitionsEnabled && this.intro) {
  		transition = new _Transition(this, this.intro, true);
  		global_runloop.registerTransition(transition);
  		global_runloop.scheduleTask(function () {
  			return transition.start();
  		}, true);

  		this.transition = transition;
  	}

  	if (this.node.autofocus) {
  		// Special case. Some browsers (*cough* Firefix *cough*) have a problem
  		// with dynamically-generated elements having autofocus, and they won't
  		// allow you to programmatically focus the element until it's in the DOM
  		global_runloop.scheduleTask(function () {
  			return _this.node.focus();
  		}, true);
  	}

  	updateLiveQueries(this);
  	return this.node;
  }

  function getNamespace(element) {
  	var namespace, xmlns, parent;

  	// Use specified namespace...
  	if (xmlns = element.getAttribute("xmlns")) {
  		namespace = xmlns;
  	}

  	// ...or SVG namespace, if this is an <svg> element
  	else if (element.name === "svg") {
  		namespace = namespaces.svg;
  	} else if (parent = element.parent) {
  		// ...or HTML, if the parent is a <foreignObject>
  		if (parent.name === "foreignObject") {
  			namespace = namespaces.html;
  		}

  		// ...or inherit from the parent node
  		else {
  			namespace = parent.node.namespaceURI;
  		}
  	} else {
  		namespace = element.root.el.namespaceURI;
  	}

  	return namespace;
  }

  function processOption(option) {
  	var optionValue, selectValue, i;

  	if (!option.select) {
  		return;
  	}

  	selectValue = option.select.getAttribute("value");
  	if (selectValue === undefined) {
  		return;
  	}

  	optionValue = option.getAttribute("value");

  	if (option.select.node.multiple && isArray(selectValue)) {
  		i = selectValue.length;
  		while (i--) {
  			if (optionValue == selectValue[i]) {
  				option.node.selected = true;
  				break;
  			}
  		}
  	} else {
  		option.node.selected = optionValue == selectValue;
  	}
  }

  function updateLiveQueries(element) {
  	var instance, liveQueries, i, selector, query;

  	// Does this need to be added to any live queries?
  	instance = element.root;

  	do {
  		liveQueries = instance._liveQueries;

  		i = liveQueries.length;
  		while (i--) {
  			selector = liveQueries[i];
  			query = liveQueries["_" + selector];

  			if (query._test(element)) {
  				// keep register of applicable selectors, for when we teardown
  				(element.liveQueries || (element.liveQueries = [])).push(query);
  			}
  		}
  	} while (instance = instance.parent);
  }

  var Element_prototype_toString = function () {
  	var str, escape;

  	if (this.template.y) {
  		// DOCTYPE declaration
  		return "<!DOCTYPE" + this.template.dd + ">";
  	}

  	str = "<" + this.template.e;

  	str += this.attributes.map(stringifyAttribute).join("") + this.conditionalAttributes.map(stringifyAttribute).join("");

  	// Special case - selected options
  	if (this.name === "option" && optionIsSelected(this)) {
  		str += " selected";
  	}

  	// Special case - two-way radio name bindings
  	if (this.name === "input" && inputIsCheckedRadio(this)) {
  		str += " checked";
  	}

  	str += ">";

  	// Special case - textarea
  	if (this.name === "textarea" && this.getAttribute("value") !== undefined) {
  		str += escapeHtml(this.getAttribute("value"));
  	}

  	// Special case - contenteditable
  	else if (this.getAttribute("contenteditable") !== undefined) {
  		str += this.getAttribute("value") || "";
  	}

  	if (this.fragment) {
  		escape = this.name !== "script" && this.name !== "style";
  		str += this.fragment.toString(escape);
  	}

  	// add a closing tag if this isn't a void element
  	if (!voidElementNames.test(this.template.e)) {
  		str += "</" + this.template.e + ">";
  	}

  	return str;
  };

  function optionIsSelected(element) {
  	var optionValue, selectValue, i;

  	optionValue = element.getAttribute("value");

  	if (optionValue === undefined || !element.select) {
  		return false;
  	}

  	selectValue = element.select.getAttribute("value");

  	if (selectValue == optionValue) {
  		return true;
  	}

  	if (element.select.getAttribute("multiple") && isArray(selectValue)) {
  		i = selectValue.length;
  		while (i--) {
  			if (selectValue[i] == optionValue) {
  				return true;
  			}
  		}
  	}
  }

  function inputIsCheckedRadio(element) {
  	var attributes, typeAttribute, valueAttribute, nameAttribute;

  	attributes = element.attributes;

  	typeAttribute = attributes.type;
  	valueAttribute = attributes.value;
  	nameAttribute = attributes.name;

  	if (!typeAttribute || typeAttribute.value !== "radio" || !valueAttribute || !nameAttribute.interpolator) {
  		return;
  	}

  	if (valueAttribute.value === nameAttribute.interpolator.value) {
  		return true;
  	}
  }

  function stringifyAttribute(attribute) {
  	var str = attribute.toString();
  	return str ? " " + str : "";
  }

  var Element_prototype_unbind = Element$unbind;
  function Element$unbind() {
  	if (this.fragment) {
  		this.fragment.unbind();
  	}

  	if (this.binding) {
  		this.binding.unbind();
  	}

  	if (this.eventHandlers) {
  		this.eventHandlers.forEach(methodCallers__unbind);
  	}

  	// Special case - <option>
  	if (this.name === "option") {
  		special_option__unbind(this);
  	}

  	this.attributes.forEach(methodCallers__unbind);
  	this.conditionalAttributes.forEach(methodCallers__unbind);
  }

  var Element_prototype_unrender = Element$unrender;

  function Element$unrender(shouldDestroy) {
  	var binding, bindings, transition;

  	if (transition = this.transition) {
  		transition.complete();
  	}

  	// Detach as soon as we can
  	if (this.name === "option") {
  		// <option> elements detach immediately, so that
  		// their parent <select> element syncs correctly, and
  		// since option elements can't have transitions anyway
  		this.detach();
  	} else if (shouldDestroy) {
  		global_runloop.detachWhenReady(this);
  	}

  	// Children first. that way, any transitions on child elements will be
  	// handled by the current transitionManager
  	if (this.fragment) {
  		this.fragment.unrender(false);
  	}

  	if (binding = this.binding) {
  		this.binding.unrender();

  		this.node._ractive.binding = null;
  		bindings = this.root._twowayBindings[binding.keypath.str];
  		bindings.splice(bindings.indexOf(binding), 1);
  	}

  	// Remove event handlers
  	if (this.eventHandlers) {
  		this.eventHandlers.forEach(methodCallers__unrender);
  	}

  	if (this.decorator) {
  		global_runloop.registerDecorator(this.decorator);
  	}

  	// trigger outro transition if necessary
  	if (this.root.transitionsEnabled && this.outro) {
  		transition = new _Transition(this, this.outro, false);
  		global_runloop.registerTransition(transition);
  		global_runloop.scheduleTask(function () {
  			return transition.start();
  		});
  	}

  	// Remove this node from any live queries
  	if (this.liveQueries) {
  		removeFromLiveQueries(this);
  	}

  	if (this.name === "form") {
  		form__unrender(this);
  	}
  }

  function removeFromLiveQueries(element) {
  	var query, selector, i;

  	i = element.liveQueries.length;
  	while (i--) {
  		query = element.liveQueries[i];
  		selector = query.selector;

  		query._remove(element.node);
  	}
  }

  var Element = function (options) {
  	this.init(options);
  };

  Element.prototype = {
  	bubble: Element_prototype_bubble,
  	detach: Element_prototype_detach,
  	find: Element_prototype_find,
  	findAll: Element_prototype_findAll,
  	findAllComponents: Element_prototype_findAllComponents,
  	findComponent: Element_prototype_findComponent,
  	findNextNode: Element_prototype_findNextNode,
  	firstNode: Element_prototype_firstNode,
  	getAttribute: getAttribute,
  	init: Element_prototype_init,
  	rebind: Element_prototype_rebind,
  	render: Element_prototype_render,
  	toString: Element_prototype_toString,
  	unbind: Element_prototype_unbind,
  	unrender: Element_prototype_unrender
  };

  var _Element = Element;

  var deIndent__empty = /^\s*$/,
      deIndent__leadingWhitespace = /^\s*/;

  var deIndent = function (str) {
  	var lines, firstLine, lastLine, minIndent;

  	lines = str.split("\n");

  	// remove first and last line, if they only contain whitespace
  	firstLine = lines[0];
  	if (firstLine !== undefined && deIndent__empty.test(firstLine)) {
  		lines.shift();
  	}

  	lastLine = lastItem(lines);
  	if (lastLine !== undefined && deIndent__empty.test(lastLine)) {
  		lines.pop();
  	}

  	minIndent = lines.reduce(reducer, null);

  	if (minIndent) {
  		str = lines.map(function (line) {
  			return line.replace(minIndent, "");
  		}).join("\n");
  	}

  	return str;
  };

  function reducer(previous, line) {
  	var lineIndent = deIndent__leadingWhitespace.exec(line)[0];

  	if (previous === null || lineIndent.length < previous.length) {
  		return lineIndent;
  	}

  	return previous;
  }

  var Partial_getPartialTemplate = getPartialTemplate;

  function getPartialTemplate(ractive, name, parentFragment) {
  	var partial;

  	// If the partial in instance or view heirarchy instances, great
  	if (partial = getPartialFromRegistry(ractive, name, parentFragment || {})) {
  		return partial;
  	}

  	// Does it exist on the page as a script tag?
  	partial = template_parser.fromId(name, { noThrow: true });

  	if (partial) {
  		// is this necessary?
  		partial = deIndent(partial);

  		// parse and register to this ractive instance
  		var parsed = template_parser.parse(partial, template_parser.getParseOptions(ractive));

  		// register (and return main partial if there are others in the template)
  		return ractive.partials[name] = parsed.t;
  	}
  }

  function getPartialFromRegistry(ractive, name, parentFragment) {
  	var fn = undefined,
  	    partial = findParentPartial(name, parentFragment.owner);

  	// if there was an instance up-hierarchy, cool
  	if (partial) return partial;

  	// find first instance in the ractive or view hierarchy that has this partial
  	var instance = findInstance("partials", ractive, name);

  	if (!instance) {
  		return;
  	}

  	partial = instance.partials[name];

  	// partial is a function?
  	if (typeof partial === "function") {
  		fn = partial.bind(instance);
  		fn.isOwner = instance.partials.hasOwnProperty(name);
  		partial = fn.call(ractive, template_parser);
  	}

  	if (!partial && partial !== "") {
  		warnIfDebug(noRegistryFunctionReturn, name, "partial", "partial", { ractive: ractive });
  		return;
  	}

  	// If this was added manually to the registry,
  	// but hasn't been parsed, parse it now
  	if (!template_parser.isParsed(partial)) {

  		// use the parseOptions of the ractive instance on which it was found
  		var parsed = template_parser.parse(partial, template_parser.getParseOptions(instance));

  		// Partials cannot contain nested partials!
  		// TODO add a test for this
  		if (parsed.p) {
  			warnIfDebug("Partials ({{>%s}}) cannot contain nested inline partials", name, { ractive: ractive });
  		}

  		// if fn, use instance to store result, otherwise needs to go
  		// in the correct point in prototype chain on instance or constructor
  		var target = fn ? instance : findOwner(instance, name);

  		// may be a template with partials, which need to be registered and main template extracted
  		target.partials[name] = partial = parsed.t;
  	}

  	// store for reset
  	if (fn) {
  		partial._fn = fn;
  	}

  	return partial.v ? partial.t : partial;
  }

  function findOwner(ractive, key) {
  	return ractive.partials.hasOwnProperty(key) ? ractive : findConstructor(ractive.constructor, key);
  }

  function findConstructor(constructor, key) {
  	if (!constructor) {
  		return;
  	}
  	return constructor.partials.hasOwnProperty(key) ? constructor : findConstructor(constructor._Parent, key);
  }

  function findParentPartial(name, parent) {
  	if (parent) {
  		if (parent.template && parent.template.p && parent.template.p[name]) {
  			return parent.template.p[name];
  		} else if (parent.parentFragment && parent.parentFragment.owner) {
  			return findParentPartial(name, parent.parentFragment.owner);
  		}
  	}
  }

  var applyIndent = function (string, indent) {
  	var indented;

  	if (!indent) {
  		return string;
  	}

  	indented = string.split("\n").map(function (line, notFirstLine) {
  		return notFirstLine ? indent + line : line;
  	}).join("\n");

  	return indented;
  };

  var missingPartialMessage = "Could not find template for partial \"%s\"";

  var Partial = function (options) {
  	var parentFragment, template;

  	parentFragment = this.parentFragment = options.parentFragment;

  	this.root = parentFragment.root;
  	this.type = PARTIAL;
  	this.index = options.index;
  	this.name = options.template.r;
  	this.rendered = false;

  	this.fragment = this.fragmentToRender = this.fragmentToUnrender = null;

  	Mustache.init(this, options);

  	// If this didn't resolve, it most likely means we have a named partial
  	// (i.e. `{{>foo}}` means 'use the foo partial', not 'use the partial
  	// whose name is the value of `foo`')
  	if (!this.keypath) {
  		if (template = Partial_getPartialTemplate(this.root, this.name, parentFragment)) {
  			shared_unbind.call(this); // prevent any further changes
  			this.isNamed = true;
  			this.setTemplate(template);
  		} else {
  			warnOnceIfDebug(missingPartialMessage, this.name);
  		}
  	}
  };

  Partial.prototype = {
  	bubble: function () {
  		this.parentFragment.bubble();
  	},

  	detach: function () {
  		return this.fragment.detach();
  	},

  	find: function (selector) {
  		return this.fragment.find(selector);
  	},

  	findAll: function (selector, query) {
  		return this.fragment.findAll(selector, query);
  	},

  	findComponent: function (selector) {
  		return this.fragment.findComponent(selector);
  	},

  	findAllComponents: function (selector, query) {
  		return this.fragment.findAllComponents(selector, query);
  	},

  	firstNode: function () {
  		return this.fragment.firstNode();
  	},

  	findNextNode: function () {
  		return this.parentFragment.findNextNode(this);
  	},

  	getPartialName: function () {
  		if (this.isNamed && this.name) return this.name;else if (this.value === undefined) return this.name;else return this.value;
  	},

  	getValue: function () {
  		return this.fragment.getValue();
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		// named partials aren't bound, so don't rebind
  		if (!this.isNamed) {
  			Mustache_rebind.call(this, oldKeypath, newKeypath);
  		}

  		if (this.fragment) {
  			this.fragment.rebind(oldKeypath, newKeypath);
  		}
  	},

  	render: function () {
  		this.docFrag = document.createDocumentFragment();
  		this.update();

  		this.rendered = true;
  		return this.docFrag;
  	},

  	resolve: Mustache.resolve,

  	setValue: function (value) {
  		var template;

  		if (value !== undefined && value === this.value) {
  			// nothing has changed, so no work to be done
  			return;
  		}

  		if (value !== undefined) {
  			template = Partial_getPartialTemplate(this.root, "" + value, this.parentFragment);
  		}

  		// we may be here if we have a partial like `{{>foo}}` and `foo` is the
  		// name of both a data property (whose value ISN'T the name of a partial)
  		// and a partial. In those cases, this becomes a named partial
  		if (!template && this.name && (template = Partial_getPartialTemplate(this.root, this.name, this.parentFragment))) {
  			shared_unbind.call(this);
  			this.isNamed = true;
  		}

  		if (!template) {
  			warnOnceIfDebug(missingPartialMessage, this.name, { ractive: this.root });
  		}

  		this.value = value;

  		this.setTemplate(template || []);

  		this.bubble();

  		if (this.rendered) {
  			global_runloop.addView(this);
  		}
  	},

  	setTemplate: function (template) {
  		if (this.fragment) {
  			this.fragment.unbind();
  			if (this.rendered) {
  				this.fragmentToUnrender = this.fragment;
  			}
  		}

  		this.fragment = new virtualdom_Fragment({
  			template: template,
  			root: this.root,
  			owner: this,
  			pElement: this.parentFragment.pElement
  		});

  		this.fragmentToRender = this.fragment;
  	},

  	toString: function (toString) {
  		var string, previousItem, lastLine, match;

  		string = this.fragment.toString(toString);

  		previousItem = this.parentFragment.items[this.index - 1];

  		if (!previousItem || previousItem.type !== TEXT) {
  			return string;
  		}

  		lastLine = previousItem.text.split("\n").pop();

  		if (match = /^\s+$/.exec(lastLine)) {
  			return applyIndent(string, match[0]);
  		}

  		return string;
  	},

  	unbind: function () {
  		if (!this.isNamed) {
  			// dynamic partial - need to unbind self
  			shared_unbind.call(this);
  		}

  		if (this.fragment) {
  			this.fragment.unbind();
  		}
  	},

  	unrender: function (shouldDestroy) {
  		if (this.rendered) {
  			if (this.fragment) {
  				this.fragment.unrender(shouldDestroy);
  			}
  			this.rendered = false;
  		}
  	},

  	update: function () {
  		var target, anchor;

  		if (this.fragmentToUnrender) {
  			this.fragmentToUnrender.unrender(true);
  			this.fragmentToUnrender = null;
  		}

  		if (this.fragmentToRender) {
  			this.docFrag.appendChild(this.fragmentToRender.render());
  			this.fragmentToRender = null;
  		}

  		if (this.rendered) {
  			target = this.parentFragment.getNode();
  			anchor = this.parentFragment.findNextNode(this);
  			target.insertBefore(this.docFrag, anchor);
  		}
  	}
  };

  var _Partial = Partial;

  // finds the component constructor in the registry or view hierarchy registries

  var Component_getComponent = getComponent;
  function getComponent(ractive, name) {

  	var Component,
  	    instance = findInstance("components", ractive, name);

  	if (instance) {
  		Component = instance.components[name];

  		// best test we have for not Ractive.extend
  		if (!Component._Parent) {
  			// function option, execute and store for reset
  			var fn = Component.bind(instance);
  			fn.isOwner = instance.components.hasOwnProperty(name);
  			Component = fn();

  			if (!Component) {
  				warnIfDebug(noRegistryFunctionReturn, name, "component", "component", { ractive: ractive });

  				return;
  			}

  			if (typeof Component === "string") {
  				// allow string lookup
  				Component = getComponent(ractive, Component);
  			}

  			Component._fn = fn;
  			instance.components[name] = Component;
  		}
  	}

  	return Component;
  }

  var Component_prototype_detach = Component$detach;
  var Component_prototype_detach__detachHook = new hooks_Hook("detach");
  function Component$detach() {
  	var detached = this.instance.fragment.detach();
  	Component_prototype_detach__detachHook.fire(this.instance);
  	return detached;
  }

  var Component_prototype_find = Component$find;

  function Component$find(selector) {
  	return this.instance.fragment.find(selector);
  }

  var Component_prototype_findAll = Component$findAll;

  function Component$findAll(selector, query) {
  	return this.instance.fragment.findAll(selector, query);
  }

  var Component_prototype_findAllComponents = Component$findAllComponents;

  function Component$findAllComponents(selector, query) {
  	query._test(this, true);

  	if (this.instance.fragment) {
  		this.instance.fragment.findAllComponents(selector, query);
  	}
  }

  var Component_prototype_findComponent = Component$findComponent;

  function Component$findComponent(selector) {
  	if (!selector || selector === this.name) {
  		return this.instance;
  	}

  	if (this.instance.fragment) {
  		return this.instance.fragment.findComponent(selector);
  	}

  	return null;
  }

  var Component_prototype_findNextNode = Component$findNextNode;

  function Component$findNextNode() {
  	return this.parentFragment.findNextNode(this);
  }

  var Component_prototype_firstNode = Component$firstNode;

  function Component$firstNode() {
  	if (this.rendered) {
  		return this.instance.fragment.firstNode();
  	}

  	return null;
  }

  var processWrapper = function (wrapper, array, methodName, newIndices) {
  	var root = wrapper.root;
  	var keypath = wrapper.keypath;

  	if (!!newIndices) {
  		root.viewmodel.smartUpdate(keypath, array, newIndices);
  	} else {
  		// If this is a sort or reverse, we just do root.set()...
  		// TODO use merge logic?
  		root.viewmodel.mark(keypath);
  	}
  };

  var patchedArrayProto = [],
      mutatorMethods = ["pop", "push", "reverse", "shift", "sort", "splice", "unshift"],
      testObj,
      patchArrayMethods,
      unpatchArrayMethods;

  mutatorMethods.forEach(function (methodName) {
  	var method = function () {
  		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
  			args[_key] = arguments[_key];
  		}

  		var newIndices, result, wrapper, i;

  		newIndices = shared_getNewIndices(this, methodName, args);

  		// apply the underlying method
  		result = Array.prototype[methodName].apply(this, arguments);

  		// trigger changes
  		global_runloop.start();

  		this._ractive.setting = true;
  		i = this._ractive.wrappers.length;
  		while (i--) {
  			wrapper = this._ractive.wrappers[i];

  			global_runloop.addRactive(wrapper.root);
  			processWrapper(wrapper, this, methodName, newIndices);
  		}

  		global_runloop.end();

  		this._ractive.setting = false;
  		return result;
  	};

  	defineProperty(patchedArrayProto, methodName, {
  		value: method
  	});
  });

  // can we use prototype chain injection?
  // http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection
  testObj = {};

  if (testObj.__proto__) {
  	// yes, we can
  	patchArrayMethods = function (array) {
  		array.__proto__ = patchedArrayProto;
  	};

  	unpatchArrayMethods = function (array) {
  		array.__proto__ = Array.prototype;
  	};
  } else {
  	// no, we can't
  	patchArrayMethods = function (array) {
  		var i, methodName;

  		i = mutatorMethods.length;
  		while (i--) {
  			methodName = mutatorMethods[i];
  			defineProperty(array, methodName, {
  				value: patchedArrayProto[methodName],
  				configurable: true
  			});
  		}
  	};

  	unpatchArrayMethods = function (array) {
  		var i;

  		i = mutatorMethods.length;
  		while (i--) {
  			delete array[mutatorMethods[i]];
  		}
  	};
  }

  patchArrayMethods.unpatch = unpatchArrayMethods;
  var patch = patchArrayMethods;

  var arrayAdaptor,

  // helpers
  ArrayWrapper, array_index__errorMessage;

  arrayAdaptor = {
  	filter: function (object) {
  		// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,
  		// or the array didn't trigger the get() itself
  		return isArray(object) && (!object._ractive || !object._ractive.setting);
  	},
  	wrap: function (ractive, array, keypath) {
  		return new ArrayWrapper(ractive, array, keypath);
  	}
  };

  ArrayWrapper = function (ractive, array, keypath) {
  	this.root = ractive;
  	this.value = array;
  	this.keypath = getKeypath(keypath);

  	// if this array hasn't already been ractified, ractify it
  	if (!array._ractive) {

  		// define a non-enumerable _ractive property to store the wrappers
  		defineProperty(array, "_ractive", {
  			value: {
  				wrappers: [],
  				instances: [],
  				setting: false
  			},
  			configurable: true
  		});

  		patch(array);
  	}

  	// store the ractive instance, so we can handle transitions later
  	if (!array._ractive.instances[ractive._guid]) {
  		array._ractive.instances[ractive._guid] = 0;
  		array._ractive.instances.push(ractive);
  	}

  	array._ractive.instances[ractive._guid] += 1;
  	array._ractive.wrappers.push(this);
  };

  ArrayWrapper.prototype = {
  	get: function () {
  		return this.value;
  	},
  	teardown: function () {
  		var array, storage, wrappers, instances, index;

  		array = this.value;
  		storage = array._ractive;
  		wrappers = storage.wrappers;
  		instances = storage.instances;

  		// if teardown() was invoked because we're clearing the cache as a result of
  		// a change that the array itself triggered, we can save ourselves the teardown
  		// and immediate setup
  		if (storage.setting) {
  			return false; // so that we don't remove it from this.root.viewmodel.wrapped
  		}

  		index = wrappers.indexOf(this);
  		if (index === -1) {
  			throw new Error(array_index__errorMessage);
  		}

  		wrappers.splice(index, 1);

  		// if nothing else depends on this array, we can revert it to its
  		// natural state
  		if (!wrappers.length) {
  			delete array._ractive;
  			patch.unpatch(this.value);
  		} else {
  			// remove ractive instance if possible
  			instances[this.root._guid] -= 1;
  			if (!instances[this.root._guid]) {
  				index = instances.indexOf(this.root);

  				if (index === -1) {
  					throw new Error(array_index__errorMessage);
  				}

  				instances.splice(index, 1);
  			}
  		}
  	}
  };

  array_index__errorMessage = "Something went wrong in a rather interesting way";
  var array_index = arrayAdaptor;

  var numeric = /^\s*[0-9]+\s*$/;

  var createBranch = function (key) {
  	return numeric.test(key) ? [] : {};
  };

  var magicAdaptor, MagicWrapper;

  try {
  	Object.defineProperty({}, "test", { value: 0 });

  	magicAdaptor = {
  		filter: function (object, keypath, ractive) {
  			var parentWrapper, parentValue;

  			if (!keypath) {
  				return false;
  			}

  			keypath = getKeypath(keypath);

  			// If the parent value is a wrapper, other than a magic wrapper,
  			// we shouldn't wrap this property
  			if ((parentWrapper = ractive.viewmodel.wrapped[keypath.parent.str]) && !parentWrapper.magic) {
  				return false;
  			}

  			parentValue = ractive.viewmodel.get(keypath.parent);

  			// if parentValue is an array that doesn't include this member,
  			// we should return false otherwise lengths will get messed up
  			if (isArray(parentValue) && /^[0-9]+$/.test(keypath.lastKey)) {
  				return false;
  			}

  			return parentValue && (typeof parentValue === "object" || typeof parentValue === "function");
  		},
  		wrap: function (ractive, property, keypath) {
  			return new MagicWrapper(ractive, property, keypath);
  		}
  	};

  	MagicWrapper = function (ractive, value, keypath) {
  		var objKeypath, template, siblings;

  		keypath = getKeypath(keypath);

  		this.magic = true;

  		this.ractive = ractive;
  		this.keypath = keypath;
  		this.value = value;

  		this.prop = keypath.lastKey;

  		objKeypath = keypath.parent;
  		this.obj = objKeypath.isRoot ? ractive.viewmodel.data : ractive.viewmodel.get(objKeypath);

  		template = this.originalDescriptor = Object.getOwnPropertyDescriptor(this.obj, this.prop);

  		// Has this property already been wrapped?
  		if (template && template.set && (siblings = template.set._ractiveWrappers)) {

  			// Yes. Register this wrapper to this property, if it hasn't been already
  			if (siblings.indexOf(this) === -1) {
  				siblings.push(this);
  			}

  			return; // already wrapped
  		}

  		// No, it hasn't been wrapped
  		createAccessors(this, value, template);
  	};

  	MagicWrapper.prototype = {
  		get: function () {
  			return this.value;
  		},
  		reset: function (value) {
  			if (this.updating) {
  				return;
  			}

  			this.updating = true;
  			this.obj[this.prop] = value; // trigger set() accessor
  			global_runloop.addRactive(this.ractive);
  			this.ractive.viewmodel.mark(this.keypath, { keepExistingWrapper: true });
  			this.updating = false;
  			return true;
  		},
  		set: function (key, value) {
  			if (this.updating) {
  				return;
  			}

  			if (!this.obj[this.prop]) {
  				this.updating = true;
  				this.obj[this.prop] = createBranch(key);
  				this.updating = false;
  			}

  			this.obj[this.prop][key] = value;
  		},
  		teardown: function () {
  			var template, set, value, wrappers, index;

  			// If this method was called because the cache was being cleared as a
  			// result of a set()/update() call made by this wrapper, we return false
  			// so that it doesn't get torn down
  			if (this.updating) {
  				return false;
  			}

  			template = Object.getOwnPropertyDescriptor(this.obj, this.prop);
  			set = template && template.set;

  			if (!set) {
  				// most likely, this was an array member that was spliced out
  				return;
  			}

  			wrappers = set._ractiveWrappers;

  			index = wrappers.indexOf(this);
  			if (index !== -1) {
  				wrappers.splice(index, 1);
  			}

  			// Last one out, turn off the lights
  			if (!wrappers.length) {
  				value = this.obj[this.prop];

  				Object.defineProperty(this.obj, this.prop, this.originalDescriptor || {
  					writable: true,
  					enumerable: true,
  					configurable: true
  				});

  				this.obj[this.prop] = value;
  			}
  		}
  	};
  } catch (err) {
  	magicAdaptor = false; // no magic in this browser
  }

  var adaptors_magic = magicAdaptor;

  function createAccessors(originalWrapper, value, template) {

  	var object, property, oldGet, oldSet, get, set;

  	object = originalWrapper.obj;
  	property = originalWrapper.prop;

  	// Is this template configurable?
  	if (template && !template.configurable) {
  		// Special case - array length
  		if (property === "length") {
  			return;
  		}

  		throw new Error("Cannot use magic mode with property \"" + property + "\" - object is not configurable");
  	}

  	// Time to wrap this property
  	if (template) {
  		oldGet = template.get;
  		oldSet = template.set;
  	}

  	get = oldGet || function () {
  		return value;
  	};

  	set = function (v) {
  		if (oldSet) {
  			oldSet(v);
  		}

  		value = oldGet ? oldGet() : v;
  		set._ractiveWrappers.forEach(updateWrapper);
  	};

  	function updateWrapper(wrapper) {
  		var keypath, ractive;

  		wrapper.value = value;

  		if (wrapper.updating) {
  			return;
  		}

  		ractive = wrapper.ractive;
  		keypath = wrapper.keypath;

  		wrapper.updating = true;
  		global_runloop.start(ractive);

  		ractive.viewmodel.mark(keypath);

  		global_runloop.end();
  		wrapper.updating = false;
  	}

  	// Create an array of wrappers, in case other keypaths/ractives depend on this property.
  	// Handily, we can store them as a property of the set function. Yay JavaScript.
  	set._ractiveWrappers = [originalWrapper];
  	Object.defineProperty(object, property, { get: get, set: set, enumerable: true, configurable: true });
  }

  var magicArrayAdaptor, MagicArrayWrapper;

  if (adaptors_magic) {
  	magicArrayAdaptor = {
  		filter: function (object, keypath, ractive) {
  			return adaptors_magic.filter(object, keypath, ractive) && array_index.filter(object);
  		},

  		wrap: function (ractive, array, keypath) {
  			return new MagicArrayWrapper(ractive, array, keypath);
  		}
  	};

  	MagicArrayWrapper = function (ractive, array, keypath) {
  		this.value = array;

  		this.magic = true;

  		this.magicWrapper = adaptors_magic.wrap(ractive, array, keypath);
  		this.arrayWrapper = array_index.wrap(ractive, array, keypath);
  	};

  	MagicArrayWrapper.prototype = {
  		get: function () {
  			return this.value;
  		},
  		teardown: function () {
  			this.arrayWrapper.teardown();
  			this.magicWrapper.teardown();
  		},
  		reset: function (value) {
  			return this.magicWrapper.reset(value);
  		}
  	};
  }

  var magicArray = magicArrayAdaptor;

  var prototype_adapt = Viewmodel$adapt;

  var prefixers = {};
  function Viewmodel$adapt(keypath, value) {
  	var len, i, adaptor, wrapped;

  	if (!this.adaptors) return;

  	// Do we have an adaptor for this value?
  	len = this.adaptors.length;
  	for (i = 0; i < len; i += 1) {
  		adaptor = this.adaptors[i];

  		if (adaptor.filter(value, keypath, this.ractive)) {
  			wrapped = this.wrapped[keypath] = adaptor.wrap(this.ractive, value, keypath, getPrefixer(keypath));
  			wrapped.value = value;
  			return;
  		}
  	}
  }

  function prefixKeypath(obj, prefix) {
  	var prefixed = {},
  	    key;

  	if (!prefix) {
  		return obj;
  	}

  	prefix += ".";

  	for (key in obj) {
  		if (obj.hasOwnProperty(key)) {
  			prefixed[prefix + key] = obj[key];
  		}
  	}

  	return prefixed;
  }

  function getPrefixer(rootKeypath) {
  	var rootDot;

  	if (!prefixers[rootKeypath]) {
  		rootDot = rootKeypath ? rootKeypath + "." : "";

  		prefixers[rootKeypath] = function (relativeKeypath, value) {
  			var obj;

  			if (typeof relativeKeypath === "string") {
  				obj = {};
  				obj[rootDot + relativeKeypath] = value;
  				return obj;
  			}

  			if (typeof relativeKeypath === "object") {
  				// 'relativeKeypath' is in fact a hash, not a keypath
  				return rootDot ? prefixKeypath(relativeKeypath, rootKeypath) : relativeKeypath;
  			}
  		};
  	}

  	return prefixers[rootKeypath];
  }

  // TEMP

  var helpers_getUpstreamChanges = getUpstreamChanges;
  function getUpstreamChanges(changes) {
  	var upstreamChanges = [rootKeypath],
  	    i,
  	    keypath;

  	i = changes.length;
  	while (i--) {
  		keypath = changes[i].parent;

  		while (keypath && !keypath.isRoot) {
  			if (changes.indexOf(keypath) === -1) {
  				addToArray(upstreamChanges, keypath);
  			}
  			keypath = keypath.parent;
  		}
  	}

  	return upstreamChanges;
  }

  var applyChanges_notifyPatternObservers = notifyPatternObservers;

  function notifyPatternObservers(viewmodel, keypath, onlyDirect) {
  	var potentialWildcardMatches;

  	updateMatchingPatternObservers(viewmodel, keypath);

  	if (onlyDirect) {
  		return;
  	}

  	potentialWildcardMatches = keypath.wildcardMatches();
  	potentialWildcardMatches.forEach(function (upstreamPattern) {
  		cascade(viewmodel, upstreamPattern, keypath);
  	});
  }

  function cascade(viewmodel, upstreamPattern, keypath) {
  	var group, map, actualChildKeypath;

  	// TODO should be one or the other
  	upstreamPattern = upstreamPattern.str || upstreamPattern;

  	group = viewmodel.depsMap.patternObservers;
  	map = group && group[upstreamPattern];

  	if (!map) {
  		return;
  	}

  	map.forEach(function (childKeypath) {
  		actualChildKeypath = keypath.join(childKeypath.lastKey); // 'foo.bar.baz'

  		updateMatchingPatternObservers(viewmodel, actualChildKeypath);
  		cascade(viewmodel, childKeypath, actualChildKeypath);
  	});
  }

  function updateMatchingPatternObservers(viewmodel, keypath) {
  	viewmodel.patternObservers.forEach(function (observer) {
  		if (observer.regex.test(keypath.str)) {
  			observer.update(keypath);
  		}
  	});
  }

  var applyChanges = Viewmodel$applyChanges;

  function Viewmodel$applyChanges() {
  	var _this = this;

  	var self = this,
  	    changes,
  	    upstreamChanges,
  	    hash = {},
  	    bindings;

  	changes = this.changes;

  	if (!changes.length) {
  		// TODO we end up here on initial render. Perhaps we shouldn't?
  		return;
  	}

  	function invalidateComputation(computation) {
  		var key = computation.key;

  		if (computation.viewmodel === self) {
  			self.clearCache(key.str);
  			computation.invalidate();

  			changes.push(key);
  			cascade(key);
  		} else {
  			computation.viewmodel.mark(key);
  		}
  	}

  	function cascade(keypath) {
  		var map, computations;

  		if (self.noCascade.hasOwnProperty(keypath.str)) {
  			return;
  		}

  		if (computations = self.deps.computed[keypath.str]) {
  			computations.forEach(invalidateComputation);
  		}

  		if (map = self.depsMap.computed[keypath.str]) {
  			map.forEach(cascade);
  		}
  	}

  	changes.slice().forEach(cascade);

  	upstreamChanges = helpers_getUpstreamChanges(changes);
  	upstreamChanges.forEach(function (keypath) {
  		var computations;

  		// make sure we haven't already been down this particular keypath in this turn
  		if (changes.indexOf(keypath) === -1 && (computations = self.deps.computed[keypath.str])) {
  			computations.forEach(invalidateComputation);
  		}
  	});

  	this.changes = [];

  	// Pattern observers are a weird special case
  	if (this.patternObservers.length) {
  		upstreamChanges.forEach(function (keypath) {
  			return applyChanges_notifyPatternObservers(_this, keypath, true);
  		});
  		changes.forEach(function (keypath) {
  			return applyChanges_notifyPatternObservers(_this, keypath);
  		});
  	}

  	if (this.deps.observers) {
  		upstreamChanges.forEach(function (keypath) {
  			return notifyUpstreamDependants(_this, null, keypath, "observers");
  		});
  		notifyAllDependants(this, changes, "observers");
  	}

  	if (this.deps["default"]) {
  		bindings = [];
  		upstreamChanges.forEach(function (keypath) {
  			return notifyUpstreamDependants(_this, bindings, keypath, "default");
  		});

  		if (bindings.length) {
  			notifyBindings(this, bindings, changes);
  		}

  		notifyAllDependants(this, changes, "default");
  	}

  	// Return a hash of keypaths to updated values
  	changes.forEach(function (keypath) {
  		hash[keypath.str] = _this.get(keypath);
  	});

  	this.implicitChanges = {};
  	this.noCascade = {};

  	return hash;
  }

  function notifyUpstreamDependants(viewmodel, bindings, keypath, groupName) {
  	var dependants, value;

  	if (dependants = findDependants(viewmodel, keypath, groupName)) {
  		value = viewmodel.get(keypath);

  		dependants.forEach(function (d) {
  			// don't "set" the parent value, refine it
  			// i.e. not data = value, but data[foo] = fooValue
  			if (bindings && d.refineValue) {
  				bindings.push(d);
  			} else {
  				d.setValue(value);
  			}
  		});
  	}
  }

  function notifyBindings(viewmodel, bindings, changes) {

  	bindings.forEach(function (binding) {
  		var useSet = false,
  		    i = 0,
  		    length = changes.length,
  		    refinements = [];

  		while (i < length) {
  			var keypath = changes[i];

  			if (keypath === binding.keypath) {
  				useSet = true;
  				break;
  			}

  			if (keypath.slice(0, binding.keypath.length) === binding.keypath) {
  				refinements.push(keypath);
  			}

  			i++;
  		}

  		if (useSet) {
  			binding.setValue(viewmodel.get(binding.keypath));
  		}

  		if (refinements.length) {
  			binding.refineValue(refinements);
  		}
  	});
  }

  function notifyAllDependants(viewmodel, keypaths, groupName) {
  	var queue = [];

  	addKeypaths(keypaths);
  	queue.forEach(dispatch);

  	function addKeypaths(keypaths) {
  		keypaths.forEach(addKeypath);
  		keypaths.forEach(cascade);
  	}

  	function addKeypath(keypath) {
  		var deps = findDependants(viewmodel, keypath, groupName);

  		if (deps) {
  			queue.push({
  				keypath: keypath,
  				deps: deps
  			});
  		}
  	}

  	function cascade(keypath) {
  		var childDeps;

  		if (childDeps = viewmodel.depsMap[groupName][keypath.str]) {
  			addKeypaths(childDeps);
  		}
  	}

  	function dispatch(set) {
  		var value = viewmodel.get(set.keypath);
  		set.deps.forEach(function (d) {
  			return d.setValue(value);
  		});
  	}
  }

  function findDependants(viewmodel, keypath, groupName) {
  	var group = viewmodel.deps[groupName];
  	return group ? group[keypath.str] : null;
  }

  var capture = Viewmodel$capture;

  function Viewmodel$capture() {
  	this.captureGroups.push([]);
  }

  var clearCache = Viewmodel$clearCache;

  function Viewmodel$clearCache(keypath, keepExistingWrapper) {
  	var cacheMap, wrapper;

  	if (!keepExistingWrapper) {
  		// Is there a wrapped property at this keypath?
  		if (wrapper = this.wrapped[keypath]) {
  			// Did we unwrap it?
  			if (wrapper.teardown() !== false) {
  				// Is this right?
  				// What's the meaning of returning false from teardown?
  				// Could there be a GC ramification if this is a "real" ractive.teardown()?
  				this.wrapped[keypath] = null;
  			}
  		}
  	}

  	this.cache[keypath] = undefined;

  	if (cacheMap = this.cacheMap[keypath]) {
  		while (cacheMap.length) {
  			this.clearCache(cacheMap.pop());
  		}
  	}
  }

  var UnresolvedDependency = function (computation, ref) {
  	this.computation = computation;
  	this.viewmodel = computation.viewmodel;
  	this.ref = ref;

  	// TODO this seems like a red flag!
  	this.root = this.viewmodel.ractive;
  	this.parentFragment = this.root.component && this.root.component.parentFragment;
  };

  UnresolvedDependency.prototype = {
  	resolve: function (keypath) {
  		this.computation.softDeps.push(keypath);
  		this.computation.unresolvedDeps[keypath.str] = null;
  		this.viewmodel.register(keypath, this.computation, "computed");
  	}
  };

  var Computation_UnresolvedDependency = UnresolvedDependency;

  var Computation = function (key, signature) {
  	this.key = key;

  	this.getter = signature.getter;
  	this.setter = signature.setter;

  	this.hardDeps = signature.deps || [];
  	this.softDeps = [];
  	this.unresolvedDeps = {};

  	this.depValues = {};

  	this._dirty = this._firstRun = true;
  };

  Computation.prototype = {
  	constructor: Computation,

  	init: function (viewmodel) {
  		var _this = this;

  		var initial;

  		this.viewmodel = viewmodel;
  		this.bypass = true;

  		initial = viewmodel.get(this.key);
  		viewmodel.clearCache(this.key.str);

  		this.bypass = false;

  		if (this.setter && initial !== undefined) {
  			this.set(initial);
  		}

  		if (this.hardDeps) {
  			this.hardDeps.forEach(function (d) {
  				return viewmodel.register(d, _this, "computed");
  			});
  		}
  	},

  	invalidate: function () {
  		this._dirty = true;
  	},

  	get: function () {
  		var _this = this;

  		var newDeps,
  		    dependenciesChanged,
  		    dependencyValuesChanged = false;

  		if (this.getting) {
  			// prevent double-computation (e.g. caused by array mutation inside computation)
  			var msg = "The " + this.key.str + " computation indirectly called itself. This probably indicates a bug in the computation. It is commonly caused by `array.sort(...)` - if that's the case, clone the array first with `array.slice().sort(...)`";
  			warnOnce(msg);
  			return this.value;
  		}

  		this.getting = true;

  		if (this._dirty) {
  			// determine whether the inputs have changed, in case this depends on
  			// other computed values
  			if (this._firstRun || !this.hardDeps.length && !this.softDeps.length) {
  				dependencyValuesChanged = true;
  			} else {
  				[this.hardDeps, this.softDeps].forEach(function (deps) {
  					var keypath, value, i;

  					if (dependencyValuesChanged) {
  						return;
  					}

  					i = deps.length;
  					while (i--) {
  						keypath = deps[i];
  						value = _this.viewmodel.get(keypath);

  						if (!isEqual(value, _this.depValues[keypath.str])) {
  							_this.depValues[keypath.str] = value;
  							dependencyValuesChanged = true;

  							return;
  						}
  					}
  				});
  			}

  			if (dependencyValuesChanged) {
  				this.viewmodel.capture();

  				try {
  					this.value = this.getter();
  				} catch (err) {
  					warnIfDebug("Failed to compute \"%s\"", this.key.str);
  					logIfDebug(err.stack || err);

  					this.value = void 0;
  				}

  				newDeps = this.viewmodel.release();
  				dependenciesChanged = this.updateDependencies(newDeps);

  				if (dependenciesChanged) {
  					[this.hardDeps, this.softDeps].forEach(function (deps) {
  						deps.forEach(function (keypath) {
  							_this.depValues[keypath.str] = _this.viewmodel.get(keypath);
  						});
  					});
  				}
  			}

  			this._dirty = false;
  		}

  		this.getting = this._firstRun = false;
  		return this.value;
  	},

  	set: function (value) {
  		if (this.setting) {
  			this.value = value;
  			return;
  		}

  		if (!this.setter) {
  			throw new Error("Computed properties without setters are read-only. (This may change in a future version of Ractive!)");
  		}

  		this.setter(value);
  	},

  	updateDependencies: function (newDeps) {
  		var i, oldDeps, keypath, dependenciesChanged, unresolved;

  		oldDeps = this.softDeps;

  		// remove dependencies that are no longer used
  		i = oldDeps.length;
  		while (i--) {
  			keypath = oldDeps[i];

  			if (newDeps.indexOf(keypath) === -1) {
  				dependenciesChanged = true;
  				this.viewmodel.unregister(keypath, this, "computed");
  			}
  		}

  		// create references for any new dependencies
  		i = newDeps.length;
  		while (i--) {
  			keypath = newDeps[i];

  			if (oldDeps.indexOf(keypath) === -1 && (!this.hardDeps || this.hardDeps.indexOf(keypath) === -1)) {
  				dependenciesChanged = true;

  				// if this keypath is currently unresolved, we need to mark
  				// it as such. TODO this is a bit muddy...
  				if (isUnresolved(this.viewmodel, keypath) && !this.unresolvedDeps[keypath.str]) {
  					unresolved = new Computation_UnresolvedDependency(this, keypath.str);
  					newDeps.splice(i, 1);

  					this.unresolvedDeps[keypath.str] = unresolved;
  					global_runloop.addUnresolved(unresolved);
  				} else {
  					this.viewmodel.register(keypath, this, "computed");
  				}
  			}
  		}

  		if (dependenciesChanged) {
  			this.softDeps = newDeps.slice();
  		}

  		return dependenciesChanged;
  	}
  };

  function isUnresolved(viewmodel, keypath) {
  	var key = keypath.firstKey;

  	return !(key in viewmodel.data) && !(key in viewmodel.computations) && !(key in viewmodel.mappings);
  }

  var Computation_Computation = Computation;

  var compute = Viewmodel$compute;
  function Viewmodel$compute(key, signature) {
  	var computation = new Computation_Computation(key, signature);

  	if (this.ready) {
  		computation.init(this);
  	}

  	return this.computations[key.str] = computation;
  }

  var FAILED_LOOKUP = { FAILED_LOOKUP: true };

  var viewmodel_prototype_get = Viewmodel$get;

  var viewmodel_prototype_get__empty = {};
  function Viewmodel$get(keypath, options) {
  	var cache = this.cache,
  	    value,
  	    computation,
  	    wrapped,
  	    captureGroup,
  	    keypathStr = keypath.str,
  	    key;

  	options = options || viewmodel_prototype_get__empty;

  	// capture the keypath, if we're inside a computation
  	if (options.capture && (captureGroup = lastItem(this.captureGroups))) {
  		if (! ~captureGroup.indexOf(keypath)) {
  			captureGroup.push(keypath);
  		}
  	}

  	if (hasOwn.call(this.mappings, keypath.firstKey)) {
  		return this.mappings[keypath.firstKey].get(keypath, options);
  	}

  	if (keypath.isSpecial) {
  		return keypath.value;
  	}

  	if (cache[keypathStr] === undefined) {

  		// Is this a computed property?
  		if ((computation = this.computations[keypathStr]) && !computation.bypass) {
  			value = computation.get();
  			this.adapt(keypathStr, value);
  		}

  		// Is this a wrapped property?
  		else if (wrapped = this.wrapped[keypathStr]) {
  			value = wrapped.value;
  		}

  		// Is it the root?
  		else if (keypath.isRoot) {
  			this.adapt("", this.data);
  			value = this.data;
  		}

  		// No? Then we need to retrieve the value one key at a time
  		else {
  			value = retrieve(this, keypath);
  		}

  		cache[keypathStr] = value;
  	} else {
  		value = cache[keypathStr];
  	}

  	if (!options.noUnwrap && (wrapped = this.wrapped[keypathStr])) {
  		value = wrapped.get();
  	}

  	if (keypath.isRoot && options.fullRootGet) {
  		for (key in this.mappings) {
  			value[key] = this.mappings[key].getValue();
  		}
  	}

  	return value === FAILED_LOOKUP ? void 0 : value;
  }

  function retrieve(viewmodel, keypath) {

  	var parentValue, cacheMap, value, wrapped;

  	parentValue = viewmodel.get(keypath.parent);

  	if (wrapped = viewmodel.wrapped[keypath.parent.str]) {
  		parentValue = wrapped.get();
  	}

  	if (parentValue === null || parentValue === undefined) {
  		return;
  	}

  	// update cache map
  	if (!(cacheMap = viewmodel.cacheMap[keypath.parent.str])) {
  		viewmodel.cacheMap[keypath.parent.str] = [keypath.str];
  	} else {
  		if (cacheMap.indexOf(keypath.str) === -1) {
  			cacheMap.push(keypath.str);
  		}
  	}

  	// If this property doesn't exist, we return a sentinel value
  	// so that we know to query parent scope (if such there be)
  	if (typeof parentValue === "object" && !(keypath.lastKey in parentValue)) {
  		return viewmodel.cache[keypath.str] = FAILED_LOOKUP;
  	}

  	value = parentValue[keypath.lastKey];

  	// Do we have an adaptor for this value?
  	viewmodel.adapt(keypath.str, value, false);

  	// Update cache
  	viewmodel.cache[keypath.str] = value;
  	return value;
  }

  var viewmodel_prototype_init = Viewmodel$init;

  function Viewmodel$init() {
  	var key;

  	for (key in this.computations) {
  		this.computations[key].init(this);
  	}
  }

  var prototype_map = Viewmodel$map;

  function Viewmodel$map(key, options) {
  	var mapping = this.mappings[key.str] = new Mapping(key, options);
  	mapping.initViewmodel(this);
  	return mapping;
  }

  var Mapping = function (localKey, options) {
  	this.localKey = localKey;
  	this.keypath = options.keypath;
  	this.origin = options.origin;

  	this.deps = [];
  	this.unresolved = [];

  	this.resolved = false;
  };

  Mapping.prototype = {
  	forceResolution: function () {
  		// TODO warn, as per #1692?
  		this.keypath = this.localKey;
  		this.setup();
  	},

  	get: function (keypath, options) {
  		if (!this.resolved) {
  			return undefined;
  		}
  		return this.origin.get(this.map(keypath), options);
  	},

  	getValue: function () {
  		if (!this.keypath) {
  			return undefined;
  		}
  		return this.origin.get(this.keypath);
  	},

  	initViewmodel: function (viewmodel) {
  		this.local = viewmodel;
  		this.setup();
  	},

  	map: function (keypath) {
  		if (typeof this.keypath === undefined) {
  			return this.localKey;
  		}
  		return keypath.replace(this.localKey, this.keypath);
  	},

  	register: function (keypath, dependant, group) {
  		this.deps.push({ keypath: keypath, dep: dependant, group: group });

  		if (this.resolved) {
  			this.origin.register(this.map(keypath), dependant, group);
  		}
  	},

  	resolve: function (keypath) {
  		if (this.keypath !== undefined) {
  			this.unbind(true);
  		}

  		this.keypath = keypath;
  		this.setup();
  	},

  	set: function (keypath, value) {
  		if (!this.resolved) {
  			this.forceResolution();
  		}

  		this.origin.set(this.map(keypath), value);
  	},

  	setup: function () {
  		var _this = this;

  		if (this.keypath === undefined) {
  			return;
  		}

  		this.resolved = true;

  		// accumulated dependants can now be registered
  		if (this.deps.length) {
  			this.deps.forEach(function (d) {
  				var keypath = _this.map(d.keypath);
  				_this.origin.register(keypath, d.dep, d.group);

  				// TODO this is a bit of a red flag... all deps should be the same?
  				if (d.dep.setValue) {
  					d.dep.setValue(_this.origin.get(keypath));
  				} else if (d.dep.invalidate) {
  					d.dep.invalidate();
  				} else {
  					throw new Error("An unexpected error occurred. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!");
  				}
  			});

  			this.origin.mark(this.keypath);
  		}
  	},

  	setValue: function (value) {
  		if (!this.keypath) {
  			throw new Error("Mapping does not have keypath, cannot set value. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!");
  		}

  		this.origin.set(this.keypath, value);
  	},

  	unbind: function (keepLocal) {
  		var _this = this;

  		if (!keepLocal) {
  			delete this.local.mappings[this.localKey];
  		}

  		if (!this.resolved) {
  			return;
  		}

  		this.deps.forEach(function (d) {
  			_this.origin.unregister(_this.map(d.keypath), d.dep, d.group);
  		});

  		if (this.tracker) {
  			this.origin.unregister(this.keypath, this.tracker);
  		}
  	},

  	unregister: function (keypath, dependant, group) {
  		var deps, i;

  		if (!this.resolved) {
  			return;
  		}

  		deps = this.deps;
  		i = deps.length;

  		while (i--) {
  			if (deps[i].dep === dependant) {
  				deps.splice(i, 1);
  				break;
  			}
  		}
  		this.origin.unregister(this.map(keypath), dependant, group);
  	}
  };

  var mark = Viewmodel$mark;

  function Viewmodel$mark(keypath, options) {
  	var computation,
  	    keypathStr = keypath.str;

  	// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)
  	// should not be picked up by pattern observers
  	if (options) {
  		if (options.implicit) {
  			this.implicitChanges[keypathStr] = true;
  		}
  		if (options.noCascade) {
  			this.noCascade[keypathStr] = true;
  		}
  	}

  	if (computation = this.computations[keypathStr]) {
  		computation.invalidate();
  	}

  	if (this.changes.indexOf(keypath) === -1) {
  		this.changes.push(keypath);
  	}

  	// pass on keepExistingWrapper, if we can
  	var keepExistingWrapper = options ? options.keepExistingWrapper : false;

  	this.clearCache(keypathStr, keepExistingWrapper);

  	if (this.ready) {
  		this.onchange();
  	}
  }

  var mapOldToNewIndex = function (oldArray, newArray) {
  	var usedIndices, firstUnusedIndex, newIndices, changed;

  	usedIndices = {};
  	firstUnusedIndex = 0;

  	newIndices = oldArray.map(function (item, i) {
  		var index, start, len;

  		start = firstUnusedIndex;
  		len = newArray.length;

  		do {
  			index = newArray.indexOf(item, start);

  			if (index === -1) {
  				changed = true;
  				return -1;
  			}

  			start = index + 1;
  		} while (usedIndices[index] && start < len);

  		// keep track of the first unused index, so we don't search
  		// the whole of newArray for each item in oldArray unnecessarily
  		if (index === firstUnusedIndex) {
  			firstUnusedIndex += 1;
  		}

  		if (index !== i) {
  			changed = true;
  		}

  		usedIndices[index] = true;
  		return index;
  	});

  	return newIndices;
  };

  var merge = Viewmodel$merge;

  var comparators = {};
  function Viewmodel$merge(keypath, currentArray, array, options) {
  	var oldArray, newArray, comparator, newIndices;

  	this.mark(keypath);

  	if (options && options.compare) {

  		comparator = getComparatorFunction(options.compare);

  		try {
  			oldArray = currentArray.map(comparator);
  			newArray = array.map(comparator);
  		} catch (err) {
  			// fallback to an identity check - worst case scenario we have
  			// to do more DOM manipulation than we thought...
  			warnIfDebug("merge(): \"%s\" comparison failed. Falling back to identity checking", keypath);

  			oldArray = currentArray;
  			newArray = array;
  		}
  	} else {
  		oldArray = currentArray;
  		newArray = array;
  	}

  	// find new indices for members of oldArray
  	newIndices = mapOldToNewIndex(oldArray, newArray);

  	this.smartUpdate(keypath, array, newIndices, currentArray.length !== array.length);
  }

  function stringify(item) {
  	return JSON.stringify(item);
  }

  function getComparatorFunction(comparator) {
  	// If `compare` is `true`, we use JSON.stringify to compare
  	// objects that are the same shape, but non-identical - i.e.
  	// { foo: 'bar' } !== { foo: 'bar' }
  	if (comparator === true) {
  		return stringify;
  	}

  	if (typeof comparator === "string") {
  		if (!comparators[comparator]) {
  			comparators[comparator] = function (item) {
  				return item[comparator];
  			};
  		}

  		return comparators[comparator];
  	}

  	if (typeof comparator === "function") {
  		return comparator;
  	}

  	throw new Error("The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)");
  }

  var register = Viewmodel$register;

  function Viewmodel$register(keypath, dependant) {
  	var group = arguments[2] === undefined ? "default" : arguments[2];

  	var mapping, depsByKeypath, deps;

  	if (dependant.isStatic) {
  		return; // TODO we should never get here if a dependant is static...
  	}

  	if (mapping = this.mappings[keypath.firstKey]) {
  		mapping.register(keypath, dependant, group);
  	} else {
  		depsByKeypath = this.deps[group] || (this.deps[group] = {});
  		deps = depsByKeypath[keypath.str] || (depsByKeypath[keypath.str] = []);

  		deps.push(dependant);

  		if (!this.depsMap[group]) {
  			this.depsMap[group] = {};
  		}

  		if (!keypath.isRoot) {
  			register__updateDependantsMap(this, keypath, group);
  		}
  	}
  }

  function register__updateDependantsMap(viewmodel, keypath, group) {
  	var map, parent, keypathStr;

  	// update dependants map
  	while (!keypath.isRoot) {
  		map = viewmodel.depsMap[group];
  		parent = map[keypath.parent.str] || (map[keypath.parent.str] = []);

  		keypathStr = keypath.str;

  		// TODO find an alternative to this nasty approach
  		if (parent["_" + keypathStr] === undefined) {
  			parent["_" + keypathStr] = 0;
  			parent.push(keypath);
  		}

  		parent["_" + keypathStr] += 1;
  		keypath = keypath.parent;
  	}
  }

  var release = Viewmodel$release;

  function Viewmodel$release() {
  	return this.captureGroups.pop();
  }

  var reset = Viewmodel$reset;

  function Viewmodel$reset(data) {
  	this.data = data;
  	this.clearCache("");
  }

  var prototype_set = Viewmodel$set;

  function Viewmodel$set(keypath, value) {
  	var options = arguments[2] === undefined ? {} : arguments[2];

  	var mapping, computation, wrapper, keepExistingWrapper;

  	// unless data is being set for data tracking purposes
  	if (!options.noMapping) {
  		// If this data belongs to a different viewmodel,
  		// pass the change along
  		if (mapping = this.mappings[keypath.firstKey]) {
  			return mapping.set(keypath, value);
  		}
  	}

  	computation = this.computations[keypath.str];
  	if (computation) {
  		if (computation.setting) {
  			// let the other computation set() handle things...
  			return;
  		}
  		computation.set(value);
  		value = computation.get();
  	}

  	if (isEqual(this.cache[keypath.str], value)) {
  		return;
  	}

  	wrapper = this.wrapped[keypath.str];

  	// If we have a wrapper with a `reset()` method, we try and use it. If the
  	// `reset()` method returns false, the wrapper should be torn down, and
  	// (most likely) a new one should be created later
  	if (wrapper && wrapper.reset) {
  		keepExistingWrapper = wrapper.reset(value) !== false;

  		if (keepExistingWrapper) {
  			value = wrapper.get();
  		}
  	}

  	if (!computation && !keepExistingWrapper) {
  		resolveSet(this, keypath, value);
  	}

  	if (!options.silent) {
  		this.mark(keypath);
  	} else {
  		// We're setting a parent of the original target keypath (i.e.
  		// creating a fresh branch) - we need to clear the cache, but
  		// not mark it as a change
  		this.clearCache(keypath.str);
  	}
  }

  function resolveSet(viewmodel, keypath, value) {
  	var wrapper, parentValue, wrapperSet, valueSet;

  	wrapperSet = function () {
  		if (wrapper.set) {
  			wrapper.set(keypath.lastKey, value);
  		} else {
  			parentValue = wrapper.get();
  			valueSet();
  		}
  	};

  	valueSet = function () {
  		if (!parentValue) {
  			parentValue = createBranch(keypath.lastKey);
  			viewmodel.set(keypath.parent, parentValue, { silent: true });
  		}
  		parentValue[keypath.lastKey] = value;
  	};

  	wrapper = viewmodel.wrapped[keypath.parent.str];

  	if (wrapper) {
  		wrapperSet();
  	} else {
  		parentValue = viewmodel.get(keypath.parent);

  		// may have been wrapped via the above .get()
  		// call on viewmodel if this is first access via .set()!
  		if (wrapper = viewmodel.wrapped[keypath.parent.str]) {
  			wrapperSet();
  		} else {
  			valueSet();
  		}
  	}
  }

  var smartUpdate = Viewmodel$smartUpdate;

  var implicitOption = { implicit: true },
      noCascadeOption = { noCascade: true };
  function Viewmodel$smartUpdate(keypath, array, newIndices) {
  	var _this = this;

  	var dependants, oldLength, i;

  	oldLength = newIndices.length;

  	// Indices that are being removed should be marked as dirty
  	newIndices.forEach(function (newIndex, oldIndex) {
  		if (newIndex === -1) {
  			_this.mark(keypath.join(oldIndex), noCascadeOption);
  		}
  	});

  	// Update the model
  	// TODO allow existing array to be updated in place, rather than replaced?
  	this.set(keypath, array, { silent: true });

  	if (dependants = this.deps["default"][keypath.str]) {
  		dependants.filter(canShuffle).forEach(function (d) {
  			return d.shuffle(newIndices, array);
  		});
  	}

  	if (oldLength !== array.length) {
  		this.mark(keypath.join("length"), implicitOption);

  		for (i = newIndices.touchedFrom; i < array.length; i += 1) {
  			this.mark(keypath.join(i));
  		}

  		// don't allow removed indexes beyond end of new array to trigger recomputations
  		// TODO is this still necessary, now that computations are lazy?
  		for (i = array.length; i < oldLength; i += 1) {
  			this.mark(keypath.join(i), noCascadeOption);
  		}
  	}
  }

  function canShuffle(dependant) {
  	return typeof dependant.shuffle === "function";
  }

  var prototype_teardown = Viewmodel$teardown;

  function Viewmodel$teardown() {
  	var _this = this;

  	var unresolvedImplicitDependency;

  	// Clear entire cache - this has the desired side-effect
  	// of unwrapping adapted values (e.g. arrays)
  	Object.keys(this.cache).forEach(function (keypath) {
  		return _this.clearCache(keypath);
  	});

  	// Teardown any failed lookups - we don't need them to resolve any more
  	while (unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop()) {
  		unresolvedImplicitDependency.teardown();
  	}
  }

  var unregister = Viewmodel$unregister;

  function Viewmodel$unregister(keypath, dependant) {
  	var group = arguments[2] === undefined ? "default" : arguments[2];

  	var mapping, deps, index;

  	if (dependant.isStatic) {
  		return;
  	}

  	if (mapping = this.mappings[keypath.firstKey]) {
  		return mapping.unregister(keypath, dependant, group);
  	}

  	deps = this.deps[group][keypath.str];
  	index = deps.indexOf(dependant);

  	if (index === -1) {
  		throw new Error("Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks");
  	}

  	deps.splice(index, 1);

  	if (keypath.isRoot) {
  		return;
  	}

  	unregister__updateDependantsMap(this, keypath, group);
  }

  function unregister__updateDependantsMap(viewmodel, keypath, group) {
  	var map, parent;

  	// update dependants map
  	while (!keypath.isRoot) {
  		map = viewmodel.depsMap[group];
  		parent = map[keypath.parent.str];

  		parent["_" + keypath.str] -= 1;

  		if (!parent["_" + keypath.str]) {
  			// remove from parent deps map
  			removeFromArray(parent, keypath);
  			parent["_" + keypath.str] = undefined;
  		}

  		keypath = keypath.parent;
  	}
  }

  var Viewmodel = function (options) {
  	var adapt = options.adapt;
  	var data = options.data;
  	var ractive = options.ractive;
  	var computed = options.computed;
  	var mappings = options.mappings;
  	var key;
  	var mapping;

  	// TODO is it possible to remove this reference?
  	this.ractive = ractive;

  	this.adaptors = adapt;
  	this.onchange = options.onchange;

  	this.cache = {}; // we need to be able to use hasOwnProperty, so can't inherit from null
  	this.cacheMap = create(null);

  	this.deps = {
  		computed: create(null),
  		"default": create(null)
  	};
  	this.depsMap = {
  		computed: create(null),
  		"default": create(null)
  	};

  	this.patternObservers = [];

  	this.specials = create(null);

  	this.wrapped = create(null);
  	this.computations = create(null);

  	this.captureGroups = [];
  	this.unresolvedImplicitDependencies = [];

  	this.changes = [];
  	this.implicitChanges = {};
  	this.noCascade = {};

  	this.data = data;

  	// set up explicit mappings
  	this.mappings = create(null);
  	for (key in mappings) {
  		this.map(getKeypath(key), mappings[key]);
  	}

  	if (data) {
  		// if data exists locally, but is missing on the parent,
  		// we transfer ownership to the parent
  		for (key in data) {
  			if ((mapping = this.mappings[key]) && mapping.getValue() === undefined) {
  				mapping.setValue(data[key]);
  			}
  		}
  	}

  	for (key in computed) {
  		if (mappings && key in mappings) {
  			fatal("Cannot map to a computed property ('%s')", key);
  		}

  		this.compute(getKeypath(key), computed[key]);
  	}

  	this.ready = true;
  };

  Viewmodel.prototype = {
  	adapt: prototype_adapt,
  	applyChanges: applyChanges,
  	capture: capture,
  	clearCache: clearCache,
  	compute: compute,
  	get: viewmodel_prototype_get,
  	init: viewmodel_prototype_init,
  	map: prototype_map,
  	mark: mark,
  	merge: merge,
  	register: register,
  	release: release,
  	reset: reset,
  	set: prototype_set,
  	smartUpdate: smartUpdate,
  	teardown: prototype_teardown,
  	unregister: unregister
  };

  var viewmodel_Viewmodel = Viewmodel;

  function HookQueue(event) {
  	this.hook = new hooks_Hook(event);
  	this.inProcess = {};
  	this.queue = {};
  }

  HookQueue.prototype = {

  	constructor: HookQueue,

  	begin: function (ractive) {
  		this.inProcess[ractive._guid] = true;
  	},

  	end: function (ractive) {

  		var parent = ractive.parent;

  		// If this is *isn't* a child of a component that's in process,
  		// it should call methods or fire at this point
  		if (!parent || !this.inProcess[parent._guid]) {
  			fire(this, ractive);
  		}
  		// elsewise, handoff to parent to fire when ready
  		else {
  			getChildQueue(this.queue, parent).push(ractive);
  		}

  		delete this.inProcess[ractive._guid];
  	}
  };

  function getChildQueue(queue, ractive) {
  	return queue[ractive._guid] || (queue[ractive._guid] = []);
  }

  function fire(hookQueue, ractive) {

  	var childQueue = getChildQueue(hookQueue.queue, ractive);

  	hookQueue.hook.fire(ractive);

  	// queue is "live" because components can end up being
  	// added while hooks fire on parents that modify data values.
  	while (childQueue.length) {
  		fire(hookQueue, childQueue.shift());
  	}

  	delete hookQueue.queue[ractive._guid];
  }

  var hooks_HookQueue = HookQueue;

  var helpers_getComputationSignatures = getComputationSignatures;

  var helpers_getComputationSignatures__pattern = /\$\{([^\}]+)\}/g;
  function getComputationSignatures(ractive, computed) {
  	var signatures = {},
  	    key;

  	for (key in computed) {
  		signatures[key] = getComputationSignature(ractive, key, computed[key]);
  	}

  	return signatures;
  }

  function getComputationSignature(ractive, key, signature) {
  	var getter, setter;

  	if (typeof signature === "function") {
  		getter = helpers_getComputationSignatures__bind(signature, ractive);
  	}

  	if (typeof signature === "string") {
  		getter = createFunctionFromString(ractive, signature);
  	}

  	if (typeof signature === "object") {
  		if (typeof signature.get === "string") {
  			getter = createFunctionFromString(ractive, signature.get);
  		} else if (typeof signature.get === "function") {
  			getter = helpers_getComputationSignatures__bind(signature.get, ractive);
  		} else {
  			fatal("`%s` computation must have a `get()` method", key);
  		}

  		if (typeof signature.set === "function") {
  			setter = helpers_getComputationSignatures__bind(signature.set, ractive);
  		}
  	}

  	return { getter: getter, setter: setter };
  }

  function createFunctionFromString(ractive, str) {
  	var functionBody, hasThis, fn;

  	functionBody = "return (" + str.replace(helpers_getComputationSignatures__pattern, function (match, keypath) {
  		hasThis = true;
  		return "__ractive.get(\"" + keypath + "\")";
  	}) + ");";

  	if (hasThis) {
  		functionBody = "var __ractive = this; " + functionBody;
  	}

  	fn = new Function(functionBody);
  	return hasThis ? fn.bind(ractive) : fn;
  }

  function helpers_getComputationSignatures__bind(fn, context) {
  	return /this/.test(fn.toString()) ? fn.bind(context) : fn;
  }

  var constructHook = new hooks_Hook("construct");
  var configHook = new hooks_Hook("config");
  var initHook = new hooks_HookQueue("init");
  var initialise__uid = 0;

  var initialise__registryNames = ["adaptors", "components", "decorators", "easing", "events", "interpolators", "partials", "transitions"];

  var initialise = initialiseRactiveInstance;

  function initialiseRactiveInstance(ractive) {
  	var userOptions = arguments[1] === undefined ? {} : arguments[1];
  	var options = arguments[2] === undefined ? {} : arguments[2];

  	var el, viewmodel;

  	if (_Ractive.DEBUG) {
  		welcome();
  	}

  	initialiseProperties(ractive, options);

  	// TODO remove this, eventually
  	defineProperty(ractive, "data", { get: deprecateRactiveData });

  	// TODO don't allow `onconstruct` with `new Ractive()`, there's no need for it
  	constructHook.fire(ractive, userOptions);

  	// Add registries
  	initialise__registryNames.forEach(function (name) {
  		ractive[name] = utils_object__extend(create(ractive.constructor[name] || null), userOptions[name]);
  	});

  	// Create a viewmodel
  	viewmodel = new viewmodel_Viewmodel({
  		adapt: getAdaptors(ractive, ractive.adapt, userOptions),
  		data: custom_data.init(ractive.constructor, ractive, userOptions),
  		computed: helpers_getComputationSignatures(ractive, utils_object__extend(create(ractive.constructor.prototype.computed), userOptions.computed)),
  		mappings: options.mappings,
  		ractive: ractive,
  		onchange: function () {
  			return global_runloop.addRactive(ractive);
  		}
  	});

  	ractive.viewmodel = viewmodel;

  	// This can't happen earlier, because computed properties may call `ractive.get()`, etc
  	viewmodel.init();

  	// init config from Parent and options
  	config_config.init(ractive.constructor, ractive, userOptions);

  	configHook.fire(ractive);
  	initHook.begin(ractive);

  	// // If this is a component with a function `data` property, call the function
  	// // with `ractive` as context (unless the child was also a function)
  	// if ( typeof ractive.constructor.prototype.data === 'function' && typeof userOptions.data !== 'function' ) {
  	// 	viewmodel.reset( ractive.constructor.prototype.data.call( ractive ) || fatal( '`data` functions must return a data object' ) );
  	// }

  	// Render virtual DOM
  	if (ractive.template) {
  		var cssIds = undefined;

  		if (options.cssIds || ractive.cssId) {
  			cssIds = options.cssIds ? options.cssIds.slice() : [];

  			if (ractive.cssId) {
  				cssIds.push(ractive.cssId);
  			}
  		}

  		ractive.fragment = new virtualdom_Fragment({
  			template: ractive.template,
  			root: ractive,
  			owner: ractive, // saves doing `if ( this.parent ) { /*...*/ }` later on
  			cssIds: cssIds
  		});
  	}

  	initHook.end(ractive);

  	// render automatically ( if `el` is specified )
  	if (el = getElement(ractive.el)) {
  		var promise = ractive.render(el, ractive.append);

  		if (_Ractive.DEBUG_PROMISES) {
  			promise["catch"](function (err) {
  				warnOnceIfDebug("Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\n  Ractive.DEBUG_PROMISES = false;");
  				warnIfDebug("An error happened during rendering", { ractive: ractive });
  				err.stack && logIfDebug(err.stack);

  				throw err;
  			});
  		}
  	}
  }

  function getAdaptors(ractive, protoAdapt, userOptions) {
  	var adapt, magic, modifyArrays;

  	protoAdapt = protoAdapt.map(lookup);
  	adapt = ensureArray(userOptions.adapt).map(lookup);

  	adapt = initialise__combine(protoAdapt, adapt);

  	magic = "magic" in userOptions ? userOptions.magic : ractive.magic;
  	modifyArrays = "modifyArrays" in userOptions ? userOptions.modifyArrays : ractive.modifyArrays;

  	if (magic) {
  		if (!environment__magic) {
  			throw new Error("Getters and setters (magic mode) are not supported in this browser");
  		}

  		if (modifyArrays) {
  			adapt.push(magicArray);
  		}

  		adapt.push(adaptors_magic);
  	}

  	if (modifyArrays) {
  		adapt.push(array_index);
  	}

  	return adapt;

  	function lookup(adaptor) {
  		if (typeof adaptor === "string") {
  			adaptor = findInViewHierarchy("adaptors", ractive, adaptor);

  			if (!adaptor) {
  				fatal(missingPlugin(adaptor, "adaptor"));
  			}
  		}

  		return adaptor;
  	}
  }

  function initialise__combine(a, b) {
  	var c = a.slice(),
  	    i = b.length;

  	while (i--) {
  		if (! ~c.indexOf(b[i])) {
  			c.push(b[i]);
  		}
  	}

  	return c;
  }

  function initialiseProperties(ractive, options) {
  	// Generate a unique identifier, for places where you'd use a weak map if it
  	// existed
  	ractive._guid = "r-" + initialise__uid++;

  	// events
  	ractive._subs = create(null);

  	// storage for item configuration from instantiation to reset,
  	// like dynamic functions or original values
  	ractive._config = {};

  	// two-way bindings
  	ractive._twowayBindings = create(null);

  	// animations (so we can stop any in progress at teardown)
  	ractive._animations = [];

  	// nodes registry
  	ractive.nodes = {};

  	// live queries
  	ractive._liveQueries = [];
  	ractive._liveComponentQueries = [];

  	// bound data functions
  	ractive._boundFunctions = [];

  	// observers
  	ractive._observers = [];

  	// properties specific to inline components
  	if (options.component) {
  		ractive.parent = options.parent;
  		ractive.container = options.container || null;
  		ractive.root = ractive.parent.root;

  		ractive.component = options.component;
  		options.component.instance = ractive;

  		// for hackability, this could be an open option
  		// for any ractive instance, but for now, just
  		// for components and just for ractive...
  		ractive._inlinePartials = options.inlinePartials;
  	} else {
  		ractive.root = ractive;
  		ractive.parent = ractive.container = null;
  	}
  }

  function deprecateRactiveData() {
  	throw new Error("Using `ractive.data` is no longer supported - you must use the `ractive.get()` API instead");
  }

  function ComplexParameter(component, template, callback) {
  	this.parentFragment = component.parentFragment;
  	this.callback = callback;

  	this.fragment = new virtualdom_Fragment({
  		template: template,
  		root: component.root,
  		owner: this
  	});

  	this.update();
  }

  var initialise_ComplexParameter = ComplexParameter;

  ComplexParameter.prototype = {
  	bubble: function () {
  		if (!this.dirty) {
  			this.dirty = true;
  			global_runloop.addView(this);
  		}
  	},

  	update: function () {
  		this.callback(this.fragment.getValue());
  		this.dirty = false;
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		this.fragment.rebind(oldKeypath, newKeypath);
  	},

  	unbind: function () {
  		this.fragment.unbind();
  	}
  };

  var createInstance = function (component, Component, attributes, yieldTemplate, partials) {
  	var instance,
  	    parentFragment,
  	    ractive,
  	    fragment,
  	    container,
  	    inlinePartials = {},
  	    data = {},
  	    mappings = {},
  	    ready,
  	    resolvers = [];

  	parentFragment = component.parentFragment;
  	ractive = component.root;

  	partials = partials || {};
  	utils_object__extend(inlinePartials, partials);

  	// Make contents available as a {{>content}} partial
  	partials.content = yieldTemplate || [];

  	// set a default partial for yields with no name
  	inlinePartials[""] = partials.content;

  	if (Component.defaults.el) {
  		warnIfDebug("The <%s/> component has a default `el` property; it has been disregarded", component.name);
  	}

  	// find container
  	fragment = parentFragment;
  	while (fragment) {
  		if (fragment.owner.type === YIELDER) {
  			container = fragment.owner.container;
  			break;
  		}

  		fragment = fragment.parent;
  	}

  	// each attribute represents either a) data or b) a mapping
  	if (attributes) {
  		Object.keys(attributes).forEach(function (key) {
  			var attribute = attributes[key],
  			    parsed,
  			    resolver;

  			if (typeof attribute === "string") {
  				// it's static data
  				parsed = parseJSON(attribute);
  				data[key] = parsed ? parsed.value : attribute;
  			} else if (attribute === 0) {
  				// it had no '=', so we'll call it true
  				data[key] = true;
  			} else if (isArray(attribute)) {
  				// this represents dynamic data
  				if (isSingleInterpolator(attribute)) {
  					mappings[key] = {
  						origin: component.root.viewmodel,
  						keypath: undefined
  					};

  					resolver = createResolver(component, attribute[0], function (keypath) {
  						if (keypath.isSpecial) {
  							if (ready) {
  								instance.set(key, keypath.value); // TODO use viewmodel?
  							} else {
  								data[key] = keypath.value;

  								// TODO errr.... would be better if we didn't have to do this
  								delete mappings[key];
  							}
  						} else {
  							if (ready) {
  								instance.viewmodel.mappings[key].resolve(keypath);
  							} else {
  								// resolved immediately
  								mappings[key].keypath = keypath;
  							}
  						}
  					});
  				} else {
  					resolver = new initialise_ComplexParameter(component, attribute, function (value) {
  						if (ready) {
  							instance.set(key, value); // TODO use viewmodel?
  						} else {
  							data[key] = value;
  						}
  					});
  				}

  				resolvers.push(resolver);
  			} else {
  				throw new Error("erm wut");
  			}
  		});
  	}

  	instance = create(Component.prototype);

  	initialise(instance, {
  		el: null,
  		append: true,
  		data: data,
  		partials: partials,
  		magic: ractive.magic || Component.defaults.magic,
  		modifyArrays: ractive.modifyArrays,
  		// need to inherit runtime parent adaptors
  		adapt: ractive.adapt
  	}, {
  		parent: ractive,
  		component: component,
  		container: container,
  		mappings: mappings,
  		inlinePartials: inlinePartials,
  		cssIds: parentFragment.cssIds
  	});

  	ready = true;
  	component.resolvers = resolvers;

  	return instance;
  };

  function createResolver(component, template, callback) {
  	var resolver;

  	if (template.r) {
  		resolver = Resolvers_createReferenceResolver(component, template.r, callback);
  	} else if (template.x) {
  		resolver = new Resolvers_ExpressionResolver(component, component.parentFragment, template.x, callback);
  	} else if (template.rx) {
  		resolver = new ReferenceExpressionResolver_ReferenceExpressionResolver(component, template.rx, callback);
  	}

  	return resolver;
  }

  function isSingleInterpolator(template) {
  	return template.length === 1 && template[0].t === INTERPOLATOR;
  }

  // TODO how should event arguments be handled? e.g.
  // <widget on-foo='bar:1,2,3'/>
  // The event 'bar' will be fired on the parent instance
  // when 'foo' fires on the child, but the 1,2,3 arguments
  // will be lost

  var initialise_propagateEvents = propagateEvents;

  function propagateEvents(component, eventsDescriptor) {
  	var eventName;

  	for (eventName in eventsDescriptor) {
  		if (eventsDescriptor.hasOwnProperty(eventName)) {
  			propagateEvent(component.instance, component.root, eventName, eventsDescriptor[eventName]);
  		}
  	}
  }

  function propagateEvent(childInstance, parentInstance, eventName, proxyEventName) {
  	if (typeof proxyEventName !== "string") {
  		fatal("Components currently only support simple events - you cannot include arguments. Sorry!");
  	}

  	childInstance.on(eventName, function () {
  		var event, args;

  		// semi-weak test, but what else? tag the event obj ._isEvent ?
  		if (arguments.length && arguments[0] && arguments[0].node) {
  			event = Array.prototype.shift.call(arguments);
  		}

  		args = Array.prototype.slice.call(arguments);

  		shared_fireEvent(parentInstance, proxyEventName, { event: event, args: args });

  		// cancel bubbling
  		return false;
  	});
  }

  var initialise_updateLiveQueries = function (component) {
  	var ancestor, query;

  	// If there's a live query for this component type, add it
  	ancestor = component.root;
  	while (ancestor) {
  		if (query = ancestor._liveComponentQueries["_" + component.name]) {
  			query.push(component.instance);
  		}

  		ancestor = ancestor.parent;
  	}
  };

  var Component_prototype_init = Component$init;
  function Component$init(options, Component) {
  	var parentFragment, root;

  	if (!Component) {
  		throw new Error("Component \"" + this.name + "\" not found");
  	}

  	parentFragment = this.parentFragment = options.parentFragment;
  	root = parentFragment.root;

  	this.root = root;
  	this.type = COMPONENT;
  	this.name = options.template.e;
  	this.index = options.index;
  	this.indexRefBindings = {};
  	this.yielders = {};
  	this.resolvers = [];

  	createInstance(this, Component, options.template.a, options.template.f, options.template.p);
  	initialise_propagateEvents(this, options.template.v);

  	// intro, outro and decorator directives have no effect
  	if (options.template.t0 || options.template.t1 || options.template.t2 || options.template.o) {
  		warnIfDebug("The \"intro\", \"outro\" and \"decorator\" directives have no effect on components", { ractive: this.instance });
  	}

  	initialise_updateLiveQueries(this);
  }

  var Component_prototype_rebind = Component$rebind;

  function Component$rebind(oldKeypath, newKeypath) {
  	var query;

  	this.resolvers.forEach(rebind);

  	for (var k in this.yielders) {
  		if (this.yielders[k][0]) {
  			rebind(this.yielders[k][0]);
  		}
  	}

  	if (query = this.root._liveComponentQueries["_" + this.name]) {
  		query._makeDirty();
  	}

  	function rebind(x) {
  		x.rebind(oldKeypath, newKeypath);
  	}
  }

  var Component_prototype_render = Component$render;

  function Component$render() {
  	var instance = this.instance;

  	instance.render(this.parentFragment.getNode());

  	this.rendered = true;
  	return instance.fragment.detach();
  }

  var Component_prototype_toString = Component$toString;

  function Component$toString() {
  	return this.instance.fragment.toString();
  }

  var Component_prototype_unbind = Component$unbind;

  var Component_prototype_unbind__teardownHook = new hooks_Hook("teardown");
  function Component$unbind() {
  	var instance = this.instance;

  	this.resolvers.forEach(methodCallers__unbind);

  	removeFromLiveComponentQueries(this);

  	instance._observers.forEach(cancel);

  	// teardown the instance
  	instance.fragment.unbind();
  	instance.viewmodel.teardown();

  	if (instance.fragment.rendered && instance.el.__ractive_instances__) {
  		removeFromArray(instance.el.__ractive_instances__, instance);
  	}

  	Component_prototype_unbind__teardownHook.fire(instance);
  }

  function removeFromLiveComponentQueries(component) {
  	var instance, query;

  	instance = component.root;

  	do {
  		if (query = instance._liveComponentQueries["_" + component.name]) {
  			query._remove(component);
  		}
  	} while (instance = instance.parent);
  }

  var Component_prototype_unrender = Component$unrender;

  function Component$unrender(shouldDestroy) {
  	this.shouldDestroy = shouldDestroy;
  	this.instance.unrender();
  }

  var Component = function (options, Constructor) {
  	this.init(options, Constructor);
  };

  Component.prototype = {
  	detach: Component_prototype_detach,
  	find: Component_prototype_find,
  	findAll: Component_prototype_findAll,
  	findAllComponents: Component_prototype_findAllComponents,
  	findComponent: Component_prototype_findComponent,
  	findNextNode: Component_prototype_findNextNode,
  	firstNode: Component_prototype_firstNode,
  	init: Component_prototype_init,
  	rebind: Component_prototype_rebind,
  	render: Component_prototype_render,
  	toString: Component_prototype_toString,
  	unbind: Component_prototype_unbind,
  	unrender: Component_prototype_unrender
  };

  var _Component = Component;

  var Comment = function (options) {
  	this.type = COMMENT;
  	this.value = options.template.c;
  };

  Comment.prototype = {
  	detach: shared_detach,

  	firstNode: function () {
  		return this.node;
  	},

  	render: function () {
  		if (!this.node) {
  			this.node = document.createComment(this.value);
  		}

  		return this.node;
  	},

  	toString: function () {
  		return "<!--" + this.value + "-->";
  	},

  	unrender: function (shouldDestroy) {
  		if (shouldDestroy) {
  			this.node.parentNode.removeChild(this.node);
  		}
  	}
  };

  var items_Comment = Comment;

  var Yielder = function (options) {
  	var container, component;

  	this.type = YIELDER;

  	this.container = container = options.parentFragment.root;
  	this.component = component = container.component;

  	this.container = container;
  	this.containerFragment = options.parentFragment;
  	this.parentFragment = component.parentFragment;

  	var name = this.name = options.template.n || "";

  	var template = container._inlinePartials[name];

  	if (!template) {
  		warnIfDebug("Could not find template for partial \"" + name + "\"", { ractive: options.root });
  		template = [];
  	}

  	this.fragment = new virtualdom_Fragment({
  		owner: this,
  		root: container.parent,
  		template: template,
  		pElement: this.containerFragment.pElement
  	});

  	// even though only one yielder is allowed, we need to have an array of them
  	// as it's possible to cause a yielder to be created before the last one
  	// was destroyed in the same turn of the runloop
  	if (!isArray(component.yielders[name])) {
  		component.yielders[name] = [this];
  	} else {
  		component.yielders[name].push(this);
  	}

  	global_runloop.scheduleTask(function () {
  		if (component.yielders[name].length > 1) {
  			throw new Error("A component template can only have one {{yield" + (name ? " " + name : "") + "}} declaration at a time");
  		}
  	});
  };

  Yielder.prototype = {
  	detach: function () {
  		return this.fragment.detach();
  	},

  	find: function (selector) {
  		return this.fragment.find(selector);
  	},

  	findAll: function (selector, query) {
  		return this.fragment.findAll(selector, query);
  	},

  	findComponent: function (selector) {
  		return this.fragment.findComponent(selector);
  	},

  	findAllComponents: function (selector, query) {
  		return this.fragment.findAllComponents(selector, query);
  	},

  	findNextNode: function () {
  		return this.containerFragment.findNextNode(this);
  	},

  	firstNode: function () {
  		return this.fragment.firstNode();
  	},

  	getValue: function (options) {
  		return this.fragment.getValue(options);
  	},

  	render: function () {
  		return this.fragment.render();
  	},

  	unbind: function () {
  		this.fragment.unbind();
  	},

  	unrender: function (shouldDestroy) {
  		this.fragment.unrender(shouldDestroy);
  		removeFromArray(this.component.yielders[this.name], this);
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		this.fragment.rebind(oldKeypath, newKeypath);
  	},

  	toString: function () {
  		return this.fragment.toString();
  	}
  };

  var items_Yielder = Yielder;

  var Doctype = function (options) {
  	this.declaration = options.template.a;
  };

  Doctype.prototype = {
  	init: noop,
  	render: noop,
  	unrender: noop,
  	teardown: noop,
  	toString: function () {
  		return "<!DOCTYPE" + this.declaration + ">";
  	}
  };

  var items_Doctype = Doctype;

  var Fragment_prototype_init = Fragment$init;

  function Fragment$init(options) {
  	var _this = this;

  	this.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute
  	this.parent = this.owner.parentFragment;

  	// inherited properties
  	this.root = options.root;
  	this.pElement = options.pElement;
  	this.context = options.context;
  	this.index = options.index;
  	this.key = options.key;
  	this.registeredIndexRefs = [];

  	// encapsulated styles should be inherited until they get applied by an element
  	this.cssIds = "cssIds" in options ? options.cssIds : this.parent ? this.parent.cssIds : null;

  	this.items = options.template.map(function (template, i) {
  		return createItem({
  			parentFragment: _this,
  			pElement: options.pElement,
  			template: template,
  			index: i
  		});
  	});

  	this.value = this.argsList = null;
  	this.dirtyArgs = this.dirtyValue = true;

  	this.bound = true;
  }

  function createItem(options) {
  	if (typeof options.template === "string") {
  		return new items_Text(options);
  	}

  	switch (options.template.t) {
  		case YIELDER:
  			return new items_Yielder(options);
  		case INTERPOLATOR:
  			return new items_Interpolator(options);
  		case SECTION:
  			return new _Section(options);
  		case TRIPLE:
  			return new _Triple(options);
  		case ELEMENT:
  			var constructor = undefined;
  			if (constructor = Component_getComponent(options.parentFragment.root, options.template.e)) {
  				return new _Component(options, constructor);
  			}
  			return new _Element(options);
  		case PARTIAL:
  			return new _Partial(options);
  		case COMMENT:
  			return new items_Comment(options);
  		case DOCTYPE:
  			return new items_Doctype(options);

  		default:
  			throw new Error("Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!");
  	}
  }

  var Fragment_prototype_rebind = Fragment$rebind;
  function Fragment$rebind(oldKeypath, newKeypath) {

  	// assign new context keypath if needed
  	if (!this.owner || this.owner.hasContext) {
  		assignNewKeypath(this, "context", oldKeypath, newKeypath);
  	}

  	this.items.forEach(function (item) {
  		if (item.rebind) {
  			item.rebind(oldKeypath, newKeypath);
  		}
  	});
  }

  var Fragment_prototype_render = Fragment$render;

  function Fragment$render() {
  	var result;

  	if (this.items.length === 1) {
  		result = this.items[0].render();
  	} else {
  		result = document.createDocumentFragment();

  		this.items.forEach(function (item) {
  			result.appendChild(item.render());
  		});
  	}

  	this.rendered = true;
  	return result;
  }

  var Fragment_prototype_toString = Fragment$toString;

  function Fragment$toString(escape) {
  	if (!this.items) {
  		return "";
  	}

  	return this.items.map(escape ? toEscapedString : Fragment_prototype_toString__toString).join("");
  }

  function Fragment_prototype_toString__toString(item) {
  	return item.toString();
  }

  function toEscapedString(item) {
  	return item.toString(true);
  }

  var Fragment_prototype_unbind = Fragment$unbind;

  function Fragment$unbind() {
  	if (!this.bound) {
  		return;
  	}

  	this.items.forEach(unbindItem);
  	this.bound = false;
  }

  function unbindItem(item) {
  	if (item.unbind) {
  		item.unbind();
  	}
  }

  var Fragment_prototype_unrender = Fragment$unrender;

  function Fragment$unrender(shouldDestroy) {
  	if (!this.rendered) {
  		throw new Error("Attempted to unrender a fragment that was not rendered");
  	}

  	this.items.forEach(function (i) {
  		return i.unrender(shouldDestroy);
  	});
  	this.rendered = false;
  }

  var Fragment = function (options) {
  	this.init(options);
  };

  Fragment.prototype = {
  	bubble: prototype_bubble,
  	detach: Fragment_prototype_detach,
  	find: Fragment_prototype_find,
  	findAll: Fragment_prototype_findAll,
  	findAllComponents: Fragment_prototype_findAllComponents,
  	findComponent: Fragment_prototype_findComponent,
  	findNextNode: prototype_findNextNode,
  	firstNode: prototype_firstNode,
  	getArgsList: getArgsList,
  	getNode: getNode,
  	getValue: prototype_getValue,
  	init: Fragment_prototype_init,
  	rebind: Fragment_prototype_rebind,
  	registerIndexRef: function (idx) {
  		var idxs = this.registeredIndexRefs;
  		if (idxs.indexOf(idx) === -1) {
  			idxs.push(idx);
  		}
  	},
  	render: Fragment_prototype_render,
  	toString: Fragment_prototype_toString,
  	unbind: Fragment_prototype_unbind,
  	unregisterIndexRef: function (idx) {
  		var idxs = this.registeredIndexRefs;
  		idxs.splice(idxs.indexOf(idx), 1);
  	},
  	unrender: Fragment_prototype_unrender
  };

  var virtualdom_Fragment = Fragment;

  var prototype_reset = Ractive$reset;
  var shouldRerender = ["template", "partials", "components", "decorators", "events"],
      resetHook = new hooks_Hook("reset");
  function Ractive$reset(data) {
  	var promise, wrapper, changes, i, rerender;

  	data = data || {};

  	if (typeof data !== "object") {
  		throw new Error("The reset method takes either no arguments, or an object containing new data");
  	}

  	// If the root object is wrapped, try and use the wrapper's reset value
  	if ((wrapper = this.viewmodel.wrapped[""]) && wrapper.reset) {
  		if (wrapper.reset(data) === false) {
  			// reset was rejected, we need to replace the object
  			this.viewmodel.reset(data);
  		}
  	} else {
  		this.viewmodel.reset(data);
  	}

  	// reset config items and track if need to rerender
  	changes = config_config.reset(this);

  	i = changes.length;
  	while (i--) {
  		if (shouldRerender.indexOf(changes[i]) > -1) {
  			rerender = true;
  			break;
  		}
  	}

  	if (rerender) {
  		var component = undefined;

  		this.viewmodel.mark(rootKeypath);

  		// Is this is a component, we need to set the `shouldDestroy`
  		// flag, otherwise it will assume by default that a parent node
  		// will be detached, and therefore it doesn't need to bother
  		// detaching its own nodes
  		if (component = this.component) {
  			component.shouldDestroy = true;
  		}

  		this.unrender();

  		if (component) {
  			component.shouldDestroy = false;
  		}

  		// If the template changed, we need to destroy the parallel DOM
  		// TODO if we're here, presumably it did?
  		if (this.fragment.template !== this.template) {
  			this.fragment.unbind();

  			this.fragment = new virtualdom_Fragment({
  				template: this.template,
  				root: this,
  				owner: this
  			});
  		}

  		promise = this.render(this.el, this.anchor);
  	} else {
  		promise = global_runloop.start(this, true);
  		this.viewmodel.mark(rootKeypath);
  		global_runloop.end();
  	}

  	resetHook.fire(this, data);

  	return promise;
  }

  var resetPartial = function (name, partial) {
  	var promise,
  	    collection = [];

  	function collect(source, dest, ractive) {
  		// if this is a component and it has its own partial, bail
  		if (ractive && ractive.partials[name]) return;

  		source.forEach(function (item) {
  			// queue to rerender if the item is a partial and the current name matches
  			if (item.type === PARTIAL && item.getPartialName() === name) {
  				dest.push(item);
  			}

  			// if it has a fragment, process its items
  			if (item.fragment) {
  				collect(item.fragment.items, dest, ractive);
  			}

  			// or if it has fragments
  			if (isArray(item.fragments)) {
  				collect(item.fragments, dest, ractive);
  			}

  			// or if it is itself a fragment, process its items
  			else if (isArray(item.items)) {
  				collect(item.items, dest, ractive);
  			}

  			// or if it is a component, step in and process its items
  			else if (item.type === COMPONENT && item.instance) {
  				collect(item.instance.fragment.items, dest, item.instance);
  			}

  			// if the item is an element, process its attributes too
  			if (item.type === ELEMENT) {
  				if (isArray(item.attributes)) {
  					collect(item.attributes, dest, ractive);
  				}

  				if (isArray(item.conditionalAttributes)) {
  					collect(item.conditionalAttributes, dest, ractive);
  				}
  			}
  		});
  	}

  	collect(this.fragment.items, collection);
  	this.partials[name] = partial;

  	promise = global_runloop.start(this, true);

  	collection.forEach(function (item) {
  		item.value = undefined;
  		item.setValue(name);
  	});

  	global_runloop.end();

  	return promise;
  };

  // TODO should resetTemplate be asynchronous? i.e. should it be a case
  // of outro, update template, intro? I reckon probably not, since that
  // could be achieved with unrender-resetTemplate-render. Also, it should
  // conceptually be similar to resetPartial, which couldn't be async

  var resetTemplate = Ractive$resetTemplate;
  function Ractive$resetTemplate(template) {
  	var transitionsEnabled, component;

  	template_template.init(null, this, { template: template });

  	transitionsEnabled = this.transitionsEnabled;
  	this.transitionsEnabled = false;

  	// Is this is a component, we need to set the `shouldDestroy`
  	// flag, otherwise it will assume by default that a parent node
  	// will be detached, and therefore it doesn't need to bother
  	// detaching its own nodes
  	if (component = this.component) {
  		component.shouldDestroy = true;
  	}

  	this.unrender();

  	if (component) {
  		component.shouldDestroy = false;
  	}

  	// remove existing fragment and create new one
  	this.fragment.unbind();
  	this.fragment = new virtualdom_Fragment({
  		template: this.template,
  		root: this,
  		owner: this
  	});

  	this.render(this.el, this.anchor);

  	this.transitionsEnabled = transitionsEnabled;
  }

  var reverse = makeArrayMethod("reverse");

  var Ractive_prototype_set = Ractive$set;

  function Ractive$set(keypath, value) {
  	var map, promise;

  	promise = global_runloop.start(this, true);

  	// Set multiple keypaths in one go
  	if (isObject(keypath)) {
  		map = keypath;

  		for (keypath in map) {
  			if (map.hasOwnProperty(keypath)) {
  				value = map[keypath];
  				set(this, keypath, value);
  			}
  		}
  	}

  	// Set a single keypath
  	else {
  		set(this, keypath, value);
  	}

  	global_runloop.end();

  	return promise;
  }

  function set(ractive, keypath, value) {
  	keypath = getKeypath(normalise(keypath));

  	if (keypath.isPattern) {
  		getMatchingKeypaths(ractive, keypath).forEach(function (keypath) {
  			ractive.viewmodel.set(keypath, value);
  		});
  	} else {
  		ractive.viewmodel.set(keypath, value);
  	}
  }

  var shift = makeArrayMethod("shift");

  var prototype_sort = makeArrayMethod("sort");

  var splice = makeArrayMethod("splice");

  var subtract = Ractive$subtract;
  function Ractive$subtract(keypath, d) {
  	return shared_add(this, keypath, d === undefined ? -1 : -d);
  }

  // Teardown. This goes through the root fragment and all its children, removing observers
  // and generally cleaning up after itself

  var Ractive_prototype_teardown = Ractive$teardown;

  var Ractive_prototype_teardown__teardownHook = new hooks_Hook("teardown");
  function Ractive$teardown() {
  	var promise;

  	this.fragment.unbind();
  	this.viewmodel.teardown();

  	this._observers.forEach(cancel);

  	if (this.fragment.rendered && this.el.__ractive_instances__) {
  		removeFromArray(this.el.__ractive_instances__, this);
  	}

  	this.shouldDestroy = true;
  	promise = this.fragment.rendered ? this.unrender() : utils_Promise.resolve();

  	Ractive_prototype_teardown__teardownHook.fire(this);

  	this._boundFunctions.forEach(deleteFunctionCopy);

  	return promise;
  }

  function deleteFunctionCopy(bound) {
  	delete bound.fn[bound.prop];
  }

  var toggle = Ractive$toggle;
  function Ractive$toggle(keypath) {
  	var _this = this;

  	if (typeof keypath !== "string") {
  		throw new TypeError(badArguments);
  	}

  	var changes = undefined;

  	if (/\*/.test(keypath)) {
  		changes = {};

  		getMatchingKeypaths(this, getKeypath(normalise(keypath))).forEach(function (keypath) {
  			changes[keypath.str] = !_this.viewmodel.get(keypath);
  		});

  		return this.set(changes);
  	}

  	return this.set(keypath, !this.get(keypath));
  }

  var toHTML = Ractive$toHTML;

  function Ractive$toHTML() {
  	return this.fragment.toString(true);
  }

  var Ractive_prototype_unrender = Ractive$unrender;
  var unrenderHook = new hooks_Hook("unrender");
  function Ractive$unrender() {
  	var promise, shouldDestroy;

  	if (!this.fragment.rendered) {
  		warnIfDebug("ractive.unrender() was called on a Ractive instance that was not rendered");
  		return utils_Promise.resolve();
  	}

  	promise = global_runloop.start(this, true);

  	// If this is a component, and the component isn't marked for destruction,
  	// don't detach nodes from the DOM unnecessarily
  	shouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;

  	// Cancel any animations in progress
  	while (this._animations[0]) {
  		this._animations[0].stop(); // it will remove itself from the index
  	}

  	this.fragment.unrender(shouldDestroy);

  	removeFromArray(this.el.__ractive_instances__, this);

  	unrenderHook.fire(this);

  	global_runloop.end();
  	return promise;
  }

  var unshift = makeArrayMethod("unshift");

  var Ractive_prototype_update = Ractive$update;
  var updateHook = new hooks_Hook("update");
  function Ractive$update(keypath) {
  	var promise;

  	keypath = getKeypath(keypath) || rootKeypath;

  	promise = global_runloop.start(this, true);
  	this.viewmodel.mark(keypath);
  	global_runloop.end();

  	updateHook.fire(this, keypath);

  	return promise;
  }

  var prototype_updateModel = Ractive$updateModel;

  function Ractive$updateModel(keypath, cascade) {
  	var values, key, bindings;

  	if (typeof keypath === "string" && !cascade) {
  		bindings = this._twowayBindings[keypath];
  	} else {
  		bindings = [];

  		for (key in this._twowayBindings) {
  			if (!keypath || getKeypath(key).equalsOrStartsWith(keypath)) {
  				// TODO is this right?
  				bindings.push.apply(bindings, this._twowayBindings[key]);
  			}
  		}
  	}

  	values = consolidate(this, bindings);
  	return this.set(values);
  }

  function consolidate(ractive, bindings) {
  	var values = {},
  	    checkboxGroups = [];

  	bindings.forEach(function (b) {
  		var oldValue, newValue;

  		// special case - radio name bindings
  		if (b.radioName && !b.element.node.checked) {
  			return;
  		}

  		// special case - checkbox name bindings come in groups, so
  		// we want to get the value once at most
  		if (b.checkboxName) {
  			if (!checkboxGroups[b.keypath.str] && !b.changed()) {
  				checkboxGroups.push(b.keypath);
  				checkboxGroups[b.keypath.str] = b;
  			}

  			return;
  		}

  		oldValue = b.attribute.value;
  		newValue = b.getValue();

  		if (arrayContentsMatch(oldValue, newValue)) {
  			return;
  		}

  		if (!isEqual(oldValue, newValue)) {
  			values[b.keypath.str] = newValue;
  		}
  	});

  	// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`
  	if (checkboxGroups.length) {
  		checkboxGroups.forEach(function (keypath) {
  			var binding, oldValue, newValue;

  			binding = checkboxGroups[keypath.str]; // one to represent the entire group
  			oldValue = binding.attribute.value;
  			newValue = binding.getValue();

  			if (!arrayContentsMatch(oldValue, newValue)) {
  				values[keypath.str] = newValue;
  			}
  		});
  	}

  	return values;
  }

  var prototype = {
  	add: prototype_add,
  	animate: prototype_animate,
  	detach: prototype_detach,
  	find: prototype_find,
  	findAll: prototype_findAll,
  	findAllComponents: prototype_findAllComponents,
  	findComponent: prototype_findComponent,
  	findContainer: findContainer,
  	findParent: findParent,
  	fire: prototype_fire,
  	get: prototype_get,
  	insert: insert,
  	merge: prototype_merge,
  	observe: observe,
  	observeOnce: observeOnce,
  	off: off,
  	on: on,
  	once: once,
  	pop: pop,
  	push: push,
  	render: prototype_render,
  	reset: prototype_reset,
  	resetPartial: resetPartial,
  	resetTemplate: resetTemplate,
  	reverse: reverse,
  	set: Ractive_prototype_set,
  	shift: shift,
  	sort: prototype_sort,
  	splice: splice,
  	subtract: subtract,
  	teardown: Ractive_prototype_teardown,
  	toggle: toggle,
  	toHTML: toHTML,
  	toHtml: toHTML,
  	unrender: Ractive_prototype_unrender,
  	unshift: unshift,
  	update: Ractive_prototype_update,
  	updateModel: prototype_updateModel
  };

  var wrapMethod = function (method, superMethod, force) {

  	if (force || needsSuper(method, superMethod)) {

  		return function () {

  			var hasSuper = ("_super" in this),
  			    _super = this._super,
  			    result;

  			this._super = superMethod;

  			result = method.apply(this, arguments);

  			if (hasSuper) {
  				this._super = _super;
  			}

  			return result;
  		};
  	} else {
  		return method;
  	}
  };

  function needsSuper(method, superMethod) {
  	return typeof superMethod === "function" && /_super/.test(method);
  }

  var unwrapExtended = unwrap;

  function unwrap(Child) {
  	var options = {};

  	while (Child) {
  		addRegistries(Child, options);
  		addOtherOptions(Child, options);

  		if (Child._Parent !== _Ractive) {
  			Child = Child._Parent;
  		} else {
  			Child = false;
  		}
  	}

  	return options;
  }

  function addRegistries(Child, options) {
  	config_registries.forEach(function (r) {
  		addRegistry(r.useDefaults ? Child.prototype : Child, options, r.name);
  	});
  }

  function addRegistry(target, options, name) {
  	var registry,
  	    keys = Object.keys(target[name]);

  	if (!keys.length) {
  		return;
  	}

  	if (!(registry = options[name])) {
  		registry = options[name] = {};
  	}

  	keys.filter(function (key) {
  		return !(key in registry);
  	}).forEach(function (key) {
  		return registry[key] = target[name][key];
  	});
  }

  function addOtherOptions(Child, options) {
  	Object.keys(Child.prototype).forEach(function (key) {
  		if (key === "computed") {
  			return;
  		}

  		var value = Child.prototype[key];

  		if (!(key in options)) {
  			options[key] = value._method ? value._method : value;
  		}

  		// is it a wrapped function?
  		else if (typeof options[key] === "function" && typeof value === "function" && options[key]._method) {

  			var result = undefined,
  			    needsSuper = value._method;

  			if (needsSuper) {
  				value = value._method;
  			}

  			// rewrap bound directly to parent fn
  			result = wrapMethod(options[key]._method, value);

  			if (needsSuper) {
  				result._method = result;
  			}

  			options[key] = result;
  		}
  	});
  }

  var _extend = _extend__extend;

  function _extend__extend() {
  	for (var _len = arguments.length, options = Array(_len), _key = 0; _key < _len; _key++) {
  		options[_key] = arguments[_key];
  	}

  	if (!options.length) {
  		return extendOne(this);
  	} else {
  		return options.reduce(extendOne, this);
  	}
  }

  function extendOne(Parent) {
  	var options = arguments[1] === undefined ? {} : arguments[1];

  	var Child, proto;

  	// if we're extending with another Ractive instance...
  	//
  	//   var Human = Ractive.extend(...), Spider = Ractive.extend(...);
  	//   var Spiderman = Human.extend( Spider );
  	//
  	// ...inherit prototype methods and default options as well
  	if (options.prototype instanceof _Ractive) {
  		options = unwrapExtended(options);
  	}

  	Child = function (options) {
  		if (!(this instanceof Child)) return new Child(options);
  		initialise(this, options);
  	};

  	proto = create(Parent.prototype);
  	proto.constructor = Child;

  	// Static properties
  	defineProperties(Child, {
  		// alias prototype as defaults
  		defaults: { value: proto },

  		// extendable
  		extend: { value: _extend__extend, writable: true, configurable: true },

  		// Parent - for IE8, can't use Object.getPrototypeOf
  		_Parent: { value: Parent }
  	});

  	// extend configuration
  	config_config.extend(Parent, proto, options);

  	custom_data.extend(Parent, proto, options);

  	if (options.computed) {
  		proto.computed = utils_object__extend(create(Parent.prototype.computed), options.computed);
  	}

  	Child.prototype = proto;

  	return Child;
  }

  var getNodeInfo = function (node) {
  	var info = {},
  	    priv,
  	    indices;

  	if (!node || !(priv = node._ractive)) {
  		return info;
  	}

  	info.ractive = priv.root;
  	info.keypath = priv.keypath.str;
  	info.index = {};

  	// find all index references and resolve them
  	if (indices = Resolvers_findIndexRefs(priv.proxy.parentFragment)) {
  		info.index = Resolvers_findIndexRefs.resolve(indices);
  	}

  	return info;
  };

  var Ractive, properties;

  // Main Ractive required object
  Ractive = function (options) {
  	if (!(this instanceof Ractive)) return new Ractive(options);
  	initialise(this, options);
  };

  // Ractive properties
  properties = {

  	// debug flag
  	DEBUG: { writable: true, value: true },
  	DEBUG_PROMISES: { writable: true, value: true },

  	// static methods:
  	extend: { value: _extend },
  	getNodeInfo: { value: getNodeInfo },
  	parse: { value: _parse },

  	// Namespaced constructors
  	Promise: { value: utils_Promise },

  	// support
  	svg: { value: svg },
  	magic: { value: environment__magic },

  	// version
  	VERSION: { value: "0.7.3" },

  	// Plugins
  	adaptors: { writable: true, value: {} },
  	components: { writable: true, value: {} },
  	decorators: { writable: true, value: {} },
  	easing: { writable: true, value: static_easing },
  	events: { writable: true, value: {} },
  	interpolators: { writable: true, value: static_interpolators },
  	partials: { writable: true, value: {} },
  	transitions: { writable: true, value: {} }
  };

  // Ractive properties
  defineProperties(Ractive, properties);

  Ractive.prototype = utils_object__extend(prototype, config_defaults);

  Ractive.prototype.constructor = Ractive;

  // alias prototype as defaults
  Ractive.defaults = Ractive.prototype;

  // Ractive.js makes liberal use of things like Array.prototype.indexOf. In
  // older browsers, these are made available via a shim - here, we do a quick
  // pre-flight check to make sure that either a) we're not in a shit browser,
  // or b) we're using a Ractive-legacy.js build
  var FUNCTION = "function";

  if (typeof Date.now !== FUNCTION || typeof String.prototype.trim !== FUNCTION || typeof Object.keys !== FUNCTION || typeof Array.prototype.indexOf !== FUNCTION || typeof Array.prototype.forEach !== FUNCTION || typeof Array.prototype.map !== FUNCTION || typeof Array.prototype.filter !== FUNCTION || typeof window !== "undefined" && typeof window.addEventListener !== FUNCTION) {
  	throw new Error("It looks like you're attempting to use Ractive.js in an older browser. You'll need to use one of the 'legacy builds' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.");
  }

  var _Ractive = Ractive;

  return _Ractive;

}));


},{}],27:[function(require,module,exports){
module.exports = function denodeify(fn) {
	return function() {
		var self = this
		var args = Array.prototype.slice.call(arguments)
		return new Promise(function(resolve, reject) {
			args.push(function(err, res) {
				if (err) {
					reject(err)
				} else {
					resolve(res)
				}
			})

			var res = fn.apply(self, args)

			var isPromise = res
				&& (typeof res === 'object' || typeof res === 'function')
				&& typeof res.then === 'function'

			if (isPromise) {
				resolve(res)
			}
		})
	}
}

},{}],28:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],29:[function(require,module,exports){
'use strict';

function time(action, seconds) {
	return { action: action, seconds: seconds };
}
function walk(seconds) {
	return time('walk', seconds);
}
function jog(seconds) {
	return time('jog', seconds);
}
function warmup(seconds) {
	return time('warmup', seconds);
}
function cooldown(seconds) {
	return time('cooldown', seconds);
}

var firstWeek = [warmup(0.05 * 60), jog(60), walk(60), jog(60), walk(60), jog(60), walk(60), jog(60), walk(60), jog(60), walk(60), jog(60), walk(60), jog(60), walk(60), jog(60), walk(60), cooldown(5 * 60)];
var secondWeek = [warmup(5 * 60), jog(90), walk(120), jog(90), walk(120), jog(90), walk(120), jog(90), walk(120), jog(90), walk(120), jog(90), walk(120), cooldown(4 * 60)];
var thirdWeek = [warmup(5 * 60), jog(90), walk(120), jog(90), walk(120), jog(3 * 60), walk(3 * 60), jog(3 * 60), walk(3 * 60), jog(90), walk(120), jog(90), walk(120), jog(3 * 60), walk(3 * 60), jog(3 * 60), walk(3 * 60), cooldown(5 * 60)];
var fourthWeek = [warmup(5 * 60), jog(5 * 60), walk(90), jog(5 * 60), walk(150), jog(3 * 60), walk(90), jog(5 * 60), cooldown(3 * 60 + 30)];
var fifthWeekDayOne = [warmup(5 * 60), jog(5 * 60), walk(3 * 60), jog(5 * 60), walk(3 * 60), jog(5 * 60), cooldown(4 * 60)];
var fifthWeekDayTwo = [warmup(5 * 60), jog(8 * 60), walk(5 * 60), jog(8 * 60), cooldown(4 * 60)];
var fifthWeekDayThree = [warmup(5 * 60), jog(20 * 60), cooldown(5 * 60)];

var sixthWeekDayOne = [warmup(5 * 60), jog(5 * 60), walk(3 * 60), jog(8 * 60), walk(3 * 60), jog(5 * 60), cooldown(4 * 60)];
var sixthWeekDayTwo = [warmup(5 * 60), jog(10 * 60), walk(3 * 60), jog(10 * 60), cooldown(4 * 60)];
var sixthWeekDayThree = [warmup(5 * 60), jog(22 * 60), cooldown(5 * 60)];

var seventhWeek = [warmup(5 * 60), jog(25)];

var eightWeek = [warmup(5 * 60), jog(28)];

var ninthWeek = [warmup(5 * 60), jog(30)];

module.exports = [[firstWeek, firstWeek, firstWeek], [secondWeek, secondWeek, secondWeek], [thirdWeek, thirdWeek, thirdWeek], [fourthWeek, fourthWeek, fourthWeek], [fifthWeekDayOne, fifthWeekDayTwo, fifthWeekDayThree], [sixthWeekDayOne, sixthWeekDayTwo, sixthWeekDayThree], [seventhWeek, seventhWeek, seventhWeek], [eightWeek, eightWeek, eightWeek], [ninthWeek, ninthWeek, ninthWeek]];

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hYnN0cmFjdC1zdGF0ZS1yb3V0ZXIvZGVmYXVsdC1yb3V0ZXItb3B0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9hYnN0cmFjdC1zdGF0ZS1yb3V0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYWJzdHJhY3Qtc3RhdGUtcm91dGVyL2xpYi9jdXJyZW50LXN0YXRlLmpzIiwibm9kZV9tb2R1bGVzL2Fic3RyYWN0LXN0YXRlLXJvdXRlci9saWIvcHJvbWlzZS1tYXAtc2VyaWVzLmpzIiwibm9kZV9tb2R1bGVzL2Fic3RyYWN0LXN0YXRlLXJvdXRlci9saWIvc3RhdGUtY2hhbmdlLWxvZ2ljLmpzIiwibm9kZV9tb2R1bGVzL2Fic3RyYWN0LXN0YXRlLXJvdXRlci9saWIvc3RhdGUtY29tcGFyaXNvbi5qcyIsIm5vZGVfbW9kdWxlcy9hYnN0cmFjdC1zdGF0ZS1yb3V0ZXIvbGliL3N0YXRlLXN0YXRlLmpzIiwibm9kZV9tb2R1bGVzL2Fic3RyYWN0LXN0YXRlLXJvdXRlci9saWIvc3RhdGUtc3RyaW5nLXBhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9hYnN0cmFjdC1zdGF0ZS1yb3V0ZXIvbGliL3N0YXRlLXRyYW5zaXRpb24tbWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9hcnJheS5wcm90b3R5cGUuZmluZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb21iaW5lLWFycmF5cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2hhc2gtYnJvd24tcm91dGVyL2hhc2gtbG9jYXRpb24uanMiLCJub2RlX21vZHVsZXMvaGFzaC1icm93bi1yb3V0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbmF0aXZlLXByb21pc2Utb25seS9ucG8uanMiLCJub2RlX21vZHVsZXMvcGFnZS1wYXRoLWJ1aWxkZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGFnZS1wYXRoLWJ1aWxkZXIvcGF0aC1wYXJzZXIuanMiLCJub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAtd2l0aC1yZXZlcnNpYmxlLWtleXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAtd2l0aC1yZXZlcnNpYmxlLWtleXMvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmFjdGl2ZS1zdGF0ZS1yb3V0ZXIvcmVuZGVyLmpzIiwibm9kZV9tb2R1bGVzL3JhY3RpdmUvcmFjdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy90aGVuLWRlbm9kZWlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy94dGVuZC9pbW11dGFibGUuanMiLCJzY2hlZHVsZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FDQUEsSUFBTSxRQUFRLFFBQVEsWUFBUixDQUFkO0FBQ0EsSUFBTSxxQkFBcUIsUUFBUSxzQkFBUixDQUEzQjtBQUNBLElBQU0sc0JBQXNCLFFBQVEsdUJBQVIsQ0FBNUI7QUFDQSxJQUFNLHVCQUF1QixtQkFBbUIsUUFBUSxTQUFSLENBQW5CLENBQTdCO0FBQ0EsSUFBTSxjQUFjLG9CQUFvQixvQkFBcEIsRUFBMEMsY0FBMUMsQ0FBcEI7O0FBRUEsSUFBTSxTQUFTO0FBQ2QsT0FBTSxNQURRO0FBRWQsV0FBVSxNQUZJO0FBR2QsU0FBUSxPQUhNO0FBSWQsTUFBSztBQUpTLENBQWY7O0FBT0EsWUFBWSxRQUFaLENBQXFCO0FBQ3BCLE9BQU0sZUFEYztBQUVwQixXQUFVLGdCQUZVO0FBR3BCLFFBQU8sU0FIYTtBQUlwQixVQUFTLGlCQUFTLElBQVQsRUFBZSxNQUFmLEVBQXVCLEVBQXZCLEVBQTJCO0FBQ25DLEtBQUcsSUFBSCxFQUFTO0FBQ1IsYUFBVTtBQURGLEdBQVQ7QUFHQSxFQVJtQjtBQVNwQixXQUFVLGtCQUFTLE9BQVQsRUFBa0IsQ0FDM0I7QUFWbUIsQ0FBckI7QUFZQSxZQUFZLFFBQVosQ0FBcUI7QUFDcEIsT0FBTSxPQURjO0FBRXBCLFdBQVU7QUFDVCxZQUFVLFFBREQ7QUFFVCxZQUFVO0FBQ1QsZ0JBQWEsU0FBUyxXQUFULEdBQXVCO0FBQ25DLFdBQU8sS0FBSyxHQUFMLENBQVMsTUFBVCxFQUFpQixLQUFLLEdBQUwsQ0FBUyxhQUFULENBQWpCLENBQVA7QUFDQSxJQUhRO0FBSVQsZUFBWSxTQUFTLFVBQVQsR0FBc0I7QUFDakMsV0FBTyxLQUFLLEdBQUwsQ0FBUyxLQUFLLEdBQUwsQ0FBUyxpQkFBVCxJQUE4QixLQUFLLEdBQUwsQ0FBUyxhQUFULEVBQXdCLE9BQXRELEdBQWdFLEdBQXpFLEVBQThFLEdBQTlFLENBQVA7QUFDQSxJQU5RO0FBT1QsVUFBTyxTQUFTLEtBQVQsR0FBaUI7QUFDdkIsV0FBTyxPQUFPLEtBQUssR0FBTCxDQUFTLGFBQVQsRUFBd0IsTUFBL0IsQ0FBUDtBQUNBO0FBVFE7QUFGRCxFQUZVO0FBZ0JwQixRQUFPLCtCQWhCYTtBQWlCcEIsVUFBUyxpQkFBUyxJQUFULEVBQWUsTUFBZixFQUF1QixFQUF2QixFQUEyQjtBQUNuQyxLQUFHLElBQUgsRUFBUztBQUNSLFNBQU8sTUFBTSxPQUFPLElBQWIsRUFBbUIsT0FBTyxHQUExQixDQURDO0FBRVIsZUFBWSxNQUZKO0FBR1IsZ0JBQWEsQ0FITDtBQUlSLG9CQUFpQjtBQUpULEdBQVQ7QUFNQSxFQXhCbUI7QUF5QnBCLFdBQVUsa0JBQVMsT0FBVCxFQUFrQjtBQUMzQixNQUFJLGNBQWMsWUFBWSxHQUFaLEVBQWxCO0FBQ0EsTUFBTSxVQUFVLFFBQVEsTUFBeEI7O0FBRUEsTUFBTSxXQUFXLFlBQVksb0JBQW9CLFlBQU07QUFDdEQsT0FBTSxtQkFBbUIsUUFBUSxHQUFSLENBQVksaUJBQVosS0FBa0MsUUFBUSxHQUFSLENBQVksYUFBWixFQUEyQixPQUF0RjtBQUNBLE9BQUksZ0JBQUosRUFBc0I7QUFDckIsa0JBQWMsWUFBWSxHQUFaLEVBQWQ7QUFDQSxZQUFRLEdBQVIsQ0FBWTtBQUNYLGtCQUFhLFFBQVEsR0FBUixDQUFZLGFBQVosSUFBNkIsQ0FEL0I7QUFFWCxzQkFBaUI7QUFGTixLQUFaO0FBSUEsSUFORCxNQU1PO0FBQ04sUUFBTSxhQUFhLENBQUMsWUFBWSxHQUFaLEtBQW9CLFdBQXJCLElBQW9DLElBQXZEO0FBQ0EsWUFBUSxHQUFSLENBQVk7QUFDWCxzQkFBaUI7QUFETixLQUFaO0FBR0E7QUFDRCxHQWQ0QixDQUFaLEVBY2IsR0FkYSxDQUFqQjtBQWVBLFVBQVEsRUFBUixDQUFXLFNBQVgsRUFBc0I7QUFBQSxVQUFNLGNBQWMsUUFBZCxDQUFOO0FBQUEsR0FBdEI7QUFDQTtBQTdDbUIsQ0FBckI7O0FBZ0RBLFNBQVMsbUJBQVQsQ0FBNkIsRUFBN0IsRUFBaUM7QUFDaEMsS0FBSSxZQUFZLEtBQWhCO0FBQ0EsUUFBTyxZQUFXO0FBQ2pCLE1BQUksQ0FBQyxTQUFMLEVBQWdCO0FBQ2YsZUFBWSxJQUFaO0FBQ0EsVUFBTyxxQkFBUCxDQUE2QixZQUFNO0FBQ2xDLGdCQUFZLEtBQVo7QUFDQTtBQUNBLElBSEQ7QUFJQTtBQUNELEVBUkQ7QUFTQTs7QUFFRCxZQUFZLG9CQUFaLENBQWlDLGVBQWpDOzs7QUN0RkE7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0T0E7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzdWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkJBLFNBQVMsSUFBVCxDQUFjLE1BQWQsRUFBc0IsT0FBdEIsRUFBK0I7QUFDOUIsUUFBTyxFQUFFLGNBQUYsRUFBVSxnQkFBVixFQUFQO0FBQ0E7QUFDRCxTQUFTLElBQVQsQ0FBYyxPQUFkLEVBQXVCO0FBQ3RCLFFBQU8sS0FBSyxNQUFMLEVBQWEsT0FBYixDQUFQO0FBQ0E7QUFDRCxTQUFTLEdBQVQsQ0FBYSxPQUFiLEVBQXNCO0FBQ3JCLFFBQU8sS0FBSyxLQUFMLEVBQVksT0FBWixDQUFQO0FBQ0E7QUFDRCxTQUFTLE1BQVQsQ0FBZ0IsT0FBaEIsRUFBeUI7QUFDeEIsUUFBTyxLQUFLLFFBQUwsRUFBZSxPQUFmLENBQVA7QUFDQTtBQUNELFNBQVMsUUFBVCxDQUFrQixPQUFsQixFQUEyQjtBQUMxQixRQUFPLEtBQUssVUFBTCxFQUFpQixPQUFqQixDQUFQO0FBQ0E7O0FBRUQsSUFBTSxZQUFZLENBQ2pCLE9BQU8sT0FBTyxFQUFkLENBRGlCLEVBRWpCLElBQUksRUFBSixDQUZpQixFQUVSLEtBQUssRUFBTCxDQUZRLEVBR2pCLElBQUksRUFBSixDQUhpQixFQUdSLEtBQUssRUFBTCxDQUhRLEVBSWpCLElBQUksRUFBSixDQUppQixFQUlSLEtBQUssRUFBTCxDQUpRLEVBS2pCLElBQUksRUFBSixDQUxpQixFQUtSLEtBQUssRUFBTCxDQUxRLEVBTWpCLElBQUksRUFBSixDQU5pQixFQU1SLEtBQUssRUFBTCxDQU5RLEVBT2pCLElBQUksRUFBSixDQVBpQixFQU9SLEtBQUssRUFBTCxDQVBRLEVBUWpCLElBQUksRUFBSixDQVJpQixFQVFSLEtBQUssRUFBTCxDQVJRLEVBU2pCLElBQUksRUFBSixDQVRpQixFQVNSLEtBQUssRUFBTCxDQVRRLEVBVWpCLFNBQVMsSUFBSSxFQUFiLENBVmlCLENBQWxCO0FBWUEsSUFBTSxhQUFhLENBQ2xCLE9BQU8sSUFBSSxFQUFYLENBRGtCLEVBRWxCLElBQUksRUFBSixDQUZrQixFQUVULEtBQUssR0FBTCxDQUZTLEVBR2xCLElBQUksRUFBSixDQUhrQixFQUdULEtBQUssR0FBTCxDQUhTLEVBSWxCLElBQUksRUFBSixDQUprQixFQUlULEtBQUssR0FBTCxDQUpTLEVBS2xCLElBQUksRUFBSixDQUxrQixFQUtULEtBQUssR0FBTCxDQUxTLEVBTWxCLElBQUksRUFBSixDQU5rQixFQU1ULEtBQUssR0FBTCxDQU5TLEVBT2xCLElBQUksRUFBSixDQVBrQixFQU9ULEtBQUssR0FBTCxDQVBTLEVBUWxCLFNBQVMsSUFBSSxFQUFiLENBUmtCLENBQW5CO0FBVUEsSUFBTSxZQUFZLENBQ2pCLE9BQU8sSUFBSSxFQUFYLENBRGlCLEVBRWpCLElBQUksRUFBSixDQUZpQixFQUVSLEtBQUssR0FBTCxDQUZRLEVBR2pCLElBQUksRUFBSixDQUhpQixFQUdSLEtBQUssR0FBTCxDQUhRLEVBSWpCLElBQUksSUFBSSxFQUFSLENBSmlCLEVBSUosS0FBSyxJQUFJLEVBQVQsQ0FKSSxFQUtqQixJQUFJLElBQUksRUFBUixDQUxpQixFQUtKLEtBQUssSUFBSSxFQUFULENBTEksRUFNakIsSUFBSSxFQUFKLENBTmlCLEVBTVIsS0FBSyxHQUFMLENBTlEsRUFPakIsSUFBSSxFQUFKLENBUGlCLEVBT1IsS0FBSyxHQUFMLENBUFEsRUFRakIsSUFBSSxJQUFJLEVBQVIsQ0FSaUIsRUFRSixLQUFLLElBQUksRUFBVCxDQVJJLEVBU2pCLElBQUksSUFBSSxFQUFSLENBVGlCLEVBU0osS0FBSyxJQUFJLEVBQVQsQ0FUSSxFQVVqQixTQUFTLElBQUksRUFBYixDQVZpQixDQUFsQjtBQVlBLElBQU0sYUFBYSxDQUNsQixPQUFPLElBQUksRUFBWCxDQURrQixFQUVsQixJQUFJLElBQUksRUFBUixDQUZrQixFQUVMLEtBQUssRUFBTCxDQUZLLEVBR2xCLElBQUksSUFBSSxFQUFSLENBSGtCLEVBR0wsS0FBSyxHQUFMLENBSEssRUFJbEIsSUFBSSxJQUFJLEVBQVIsQ0FKa0IsRUFJTCxLQUFLLEVBQUwsQ0FKSyxFQUtsQixJQUFJLElBQUksRUFBUixDQUxrQixFQU1sQixTQUFTLElBQUksRUFBSixHQUFTLEVBQWxCLENBTmtCLENBQW5CO0FBUUEsSUFBTSxrQkFBa0IsQ0FDdkIsT0FBTyxJQUFJLEVBQVgsQ0FEdUIsRUFFdkIsSUFBSSxJQUFJLEVBQVIsQ0FGdUIsRUFFVixLQUFLLElBQUksRUFBVCxDQUZVLEVBR3ZCLElBQUksSUFBSSxFQUFSLENBSHVCLEVBR1YsS0FBSyxJQUFJLEVBQVQsQ0FIVSxFQUl2QixJQUFJLElBQUksRUFBUixDQUp1QixFQUt2QixTQUFTLElBQUksRUFBYixDQUx1QixDQUF4QjtBQU9BLElBQU0sa0JBQWtCLENBQ3ZCLE9BQU8sSUFBSSxFQUFYLENBRHVCLEVBRXZCLElBQUksSUFBSSxFQUFSLENBRnVCLEVBRVYsS0FBSyxJQUFJLEVBQVQsQ0FGVSxFQUd2QixJQUFJLElBQUksRUFBUixDQUh1QixFQUl2QixTQUFTLElBQUksRUFBYixDQUp1QixDQUF4QjtBQU1BLElBQU0sb0JBQW9CLENBQ3pCLE9BQU8sSUFBSSxFQUFYLENBRHlCLEVBRXpCLElBQUksS0FBSyxFQUFULENBRnlCLEVBR3pCLFNBQVMsSUFBSSxFQUFiLENBSHlCLENBQTFCOztBQU1BLElBQU0sa0JBQWtCLENBQ3ZCLE9BQU8sSUFBSSxFQUFYLENBRHVCLEVBRXZCLElBQUksSUFBSSxFQUFSLENBRnVCLEVBRVYsS0FBSyxJQUFJLEVBQVQsQ0FGVSxFQUd2QixJQUFJLElBQUksRUFBUixDQUh1QixFQUdWLEtBQUssSUFBSSxFQUFULENBSFUsRUFJdkIsSUFBSSxJQUFJLEVBQVIsQ0FKdUIsRUFLdkIsU0FBUyxJQUFJLEVBQWIsQ0FMdUIsQ0FBeEI7QUFPQSxJQUFNLGtCQUFrQixDQUN2QixPQUFPLElBQUksRUFBWCxDQUR1QixFQUV2QixJQUFJLEtBQUssRUFBVCxDQUZ1QixFQUVULEtBQUssSUFBSSxFQUFULENBRlMsRUFHdkIsSUFBSSxLQUFLLEVBQVQsQ0FIdUIsRUFJdkIsU0FBUyxJQUFJLEVBQWIsQ0FKdUIsQ0FBeEI7QUFNQSxJQUFNLG9CQUFvQixDQUN6QixPQUFPLElBQUksRUFBWCxDQUR5QixFQUV6QixJQUFJLEtBQUssRUFBVCxDQUZ5QixFQUd6QixTQUFTLElBQUksRUFBYixDQUh5QixDQUExQjs7QUFNQSxJQUFNLGNBQWMsQ0FDbkIsT0FBTyxJQUFJLEVBQVgsQ0FEbUIsRUFFbkIsSUFBSSxFQUFKLENBRm1CLENBQXBCOztBQUtBLElBQU0sWUFBWSxDQUNqQixPQUFPLElBQUksRUFBWCxDQURpQixFQUVqQixJQUFJLEVBQUosQ0FGaUIsQ0FBbEI7O0FBS0EsSUFBTSxZQUFZLENBQ2pCLE9BQU8sSUFBSSxFQUFYLENBRGlCLEVBRWpCLElBQUksRUFBSixDQUZpQixDQUFsQjs7QUFLQSxPQUFPLE9BQVAsR0FBaUIsQ0FDaEIsQ0FBQyxTQUFELEVBQVksU0FBWixFQUF1QixTQUF2QixDQURnQixFQUVoQixDQUFDLFVBQUQsRUFBYSxVQUFiLEVBQXlCLFVBQXpCLENBRmdCLEVBR2hCLENBQUMsU0FBRCxFQUFZLFNBQVosRUFBdUIsU0FBdkIsQ0FIZ0IsRUFJaEIsQ0FBQyxVQUFELEVBQWEsVUFBYixFQUF5QixVQUF6QixDQUpnQixFQUtoQixDQUFDLGVBQUQsRUFBa0IsZUFBbEIsRUFBbUMsaUJBQW5DLENBTGdCLEVBTWhCLENBQUMsZUFBRCxFQUFrQixlQUFsQixFQUFtQyxpQkFBbkMsQ0FOZ0IsRUFPaEIsQ0FBQyxXQUFELEVBQWMsV0FBZCxFQUEyQixXQUEzQixDQVBnQixFQVFoQixDQUFDLFNBQUQsRUFBWSxTQUFaLEVBQXVCLFNBQXZCLENBUmdCLEVBU2hCLENBQUMsU0FBRCxFQUFZLFNBQVosRUFBdUIsU0FBdkIsQ0FUZ0IsQ0FBakIiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiY29uc3Qgd2Vla3MgPSByZXF1aXJlKCcuL3NjaGVkdWxlJylcbmNvbnN0IHJhY3RpdmVTdGF0ZVJvdXRlciA9IHJlcXVpcmUoJ3JhY3RpdmUtc3RhdGUtcm91dGVyJylcbmNvbnN0IGFic3RyYWN0U3RhdGVSb3V0ZXIgPSByZXF1aXJlKCdhYnN0cmFjdC1zdGF0ZS1yb3V0ZXInKVxuY29uc3QgcmFjdGl2ZVN0YXRlUmVuZGVyZXIgPSByYWN0aXZlU3RhdGVSb3V0ZXIocmVxdWlyZSgncmFjdGl2ZScpKVxuY29uc3Qgc3RhdGVSb3V0ZXIgPSBhYnN0cmFjdFN0YXRlUm91dGVyKHJhY3RpdmVTdGF0ZVJlbmRlcmVyLCAnI2FwcC1jb250ZW50JylcblxuY29uc3QgY29sb3JzID0ge1xuXHR3YWxrOiAnYmx1ZScsXG5cdGNvb2xkb3duOiAnYXF1YScsXG5cdHdhcm11cDogJ29saXZlJyxcblx0am9nOiAnb3JhbmdlJ1xufVxuXG5zdGF0ZVJvdXRlci5hZGRTdGF0ZSh7XG5cdG5hbWU6ICdkYXktc2VsZWN0aW9uJyxcblx0dGVtcGxhdGU6ICcjZGF5LXNlbGVjdGlvbicsXG5cdHJvdXRlOiAnL3NlbGVjdCcsXG5cdHJlc29sdmU6IGZ1bmN0aW9uKGRhdGEsIHBhcmFtcywgY2IpIHtcblx0XHRjYihudWxsLCB7XG5cdFx0XHRhbGxQbGFuczogd2Vla3Ncblx0XHR9KVxuXHR9LFxuXHRhY3RpdmF0ZTogZnVuY3Rpb24oY29udGV4dCkge1xuXHR9XG59KVxuc3RhdGVSb3V0ZXIuYWRkU3RhdGUoe1xuXHRuYW1lOiAndGltZXInLFxuXHR0ZW1wbGF0ZToge1xuXHRcdHRlbXBsYXRlOiAnI3RpbWVyJyxcblx0XHRjb21wdXRlZDoge1xuXHRcdFx0Y3VycmVudFBsYW46IGZ1bmN0aW9uIGN1cnJlbnRQbGFuKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXQoJ3BsYW4nKVt0aGlzLmdldCgnY3VycmVudFN0ZXAnKV1cblx0XHRcdH0sXG5cdFx0XHRwZXJjZW50YWdlOiBmdW5jdGlvbiBwZXJjZW50YWdlKCkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5taW4odGhpcy5nZXQoJ3NlY29uZHNUaGlzU3RlcCcpIC8gdGhpcy5nZXQoJ2N1cnJlbnRQbGFuJykuc2Vjb25kcyAqIDEwMCwgMTAwKVxuXHRcdFx0fSxcblx0XHRcdGNvbG9yOiBmdW5jdGlvbiBjb2xvcigpIHtcblx0XHRcdFx0cmV0dXJuIGNvbG9yc1t0aGlzLmdldCgnY3VycmVudFBsYW4nKS5hY3Rpb25dXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRyb3V0ZTogJy90aW1lci86d2VlayhcXFxcZCspLzpkYXkoXFxcXGQrKScsXG5cdHJlc29sdmU6IGZ1bmN0aW9uKGRhdGEsIHBhcmFtcywgY2IpIHtcblx0XHRjYihudWxsLCB7XG5cdFx0XHRwbGFuOiAgd2Vla3NbcGFyYW1zLndlZWtdW3BhcmFtcy5kYXldLFxuXHRcdFx0cGFyYW1ldGVyczogcGFyYW1zLFxuXHRcdFx0Y3VycmVudFN0ZXA6IDAsXG5cdFx0XHRzZWNvbmRzVGhpc1N0ZXA6IDBcblx0XHR9KVxuXHR9LFxuXHRhY3RpdmF0ZTogZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdGxldCBzdGFydE9mU3RlcCA9IHBlcmZvcm1hbmNlLm5vdygpXG5cdFx0Y29uc3QgcmFjdGl2ZSA9IGNvbnRleHQuZG9tQXBpXG5cblx0XHRjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKGRlYm91bmNlVG9OZXh0RnJhbWUoKCkgPT4ge1xuXHRcdFx0Y29uc3QgZG9uZVdpdGhUaGlzU3RlcCA9IHJhY3RpdmUuZ2V0KCdzZWNvbmRzVGhpc1N0ZXAnKSA+PSByYWN0aXZlLmdldCgnY3VycmVudFBsYW4nKS5zZWNvbmRzXG5cdFx0XHRpZiAoZG9uZVdpdGhUaGlzU3RlcCkge1xuXHRcdFx0XHRzdGFydE9mU3RlcCA9IHBlcmZvcm1hbmNlLm5vdygpXG5cdFx0XHRcdHJhY3RpdmUuc2V0KHtcblx0XHRcdFx0XHRjdXJyZW50U3RlcDogcmFjdGl2ZS5nZXQoJ2N1cnJlbnRTdGVwJykgKyAxLFxuXHRcdFx0XHRcdHNlY29uZHNUaGlzU3RlcDogMFxuXHRcdFx0XHR9KVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgbmV3U2Vjb25kcyA9IChwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0T2ZTdGVwKSAvIDEwMDBcblx0XHRcdFx0cmFjdGl2ZS5zZXQoe1xuXHRcdFx0XHRcdHNlY29uZHNUaGlzU3RlcDogbmV3U2Vjb25kc1xuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdH0pLCAxMDApXG5cdFx0Y29udGV4dC5vbignZGVzdHJveScsICgpID0+IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpKVxuXHR9XG59KVxuXG5mdW5jdGlvbiBkZWJvdW5jZVRvTmV4dEZyYW1lKGZuKSB7XG5cdGxldCBoYXBwZW5pbmcgPSBmYWxzZVxuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCFoYXBwZW5pbmcpIHtcblx0XHRcdGhhcHBlbmluZyA9IHRydWVcblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuXHRcdFx0XHRoYXBwZW5pbmcgPSBmYWxzZVxuXHRcdFx0XHRmbigpXG5cdFx0XHR9KVxuXHRcdH1cblx0fVxufVxuXG5zdGF0ZVJvdXRlci5ldmFsdWF0ZUN1cnJlbnRSb3V0ZSgnZGF5LXNlbGVjdGlvbicpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHsgcmV2ZXJzZTogZmFsc2UgfSIsInZhciBTdGF0ZVN0YXRlID0gcmVxdWlyZSgnLi9saWIvc3RhdGUtc3RhdGUnKVxudmFyIFN0YXRlQ29tcGFyaXNvbiA9IHJlcXVpcmUoJy4vbGliL3N0YXRlLWNvbXBhcmlzb24nKVxudmFyIEN1cnJlbnRTdGF0ZSA9IHJlcXVpcmUoJy4vbGliL2N1cnJlbnQtc3RhdGUnKVxudmFyIHN0YXRlQ2hhbmdlTG9naWMgPSByZXF1aXJlKCcuL2xpYi9zdGF0ZS1jaGFuZ2UtbG9naWMnKVxudmFyIHBhcnNlID0gcmVxdWlyZSgnLi9saWIvc3RhdGUtc3RyaW5nLXBhcnNlcicpXG52YXIgU3RhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vbGliL3N0YXRlLXRyYW5zaXRpb24tbWFuYWdlcicpXG52YXIgZGVmYXVsdFJvdXRlck9wdGlvbnMgPSByZXF1aXJlKCcuL2RlZmF1bHQtcm91dGVyLW9wdGlvbnMuanMnKVxuXG52YXIgc2VyaWVzID0gcmVxdWlyZSgnLi9saWIvcHJvbWlzZS1tYXAtc2VyaWVzJylcbnZhciBkZW5vZGVpZnkgPSByZXF1aXJlKCd0aGVuLWRlbm9kZWlmeScpXG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbnZhciBleHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG52YXIgbmV3SGFzaEJyb3duUm91dGVyID0gcmVxdWlyZSgnaGFzaC1icm93bi1yb3V0ZXInKVxudmFyIGNvbWJpbmUgPSByZXF1aXJlKCdjb21iaW5lLWFycmF5cycpXG52YXIgYnVpbGRQYXRoID0gcmVxdWlyZSgncGFnZS1wYXRoLWJ1aWxkZXInKVxuXG5yZXF1aXJlKCduYXRpdmUtcHJvbWlzZS1vbmx5L25wbycpXG5cbnZhciBleHBlY3RlZFByb3BlcnRpZXNPZkFkZFN0YXRlID0gWyduYW1lJywgJ3JvdXRlJywgJ2RlZmF1bHRDaGlsZCcsICdkYXRhJywgJ3RlbXBsYXRlJywgJ3Jlc29sdmUnLCAnYWN0aXZhdGUnLCAncXVlcnlzdHJpbmdQYXJhbWV0ZXJzJywgJ2RlZmF1bHRRdWVyeXN0cmluZ1BhcmFtZXRlcnMnXVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFN0YXRlUHJvdmlkZXIobWFrZVJlbmRlcmVyLCByb290RWxlbWVudCwgc3RhdGVSb3V0ZXJPcHRpb25zKSB7XG5cdHZhciBwcm90b3R5cGFsU3RhdGVIb2xkZXIgPSBTdGF0ZVN0YXRlKClcblx0dmFyIGxhc3RDb21wbGV0ZWx5TG9hZGVkU3RhdGUgPSBDdXJyZW50U3RhdGUoKVxuXHR2YXIgbGFzdFN0YXRlU3RhcnRlZEFjdGl2YXRpbmcgPSBDdXJyZW50U3RhdGUoKVxuXHR2YXIgc3RhdGVQcm92aWRlckVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKClcblx0U3RhdGVUcmFuc2l0aW9uTWFuYWdlcihzdGF0ZVByb3ZpZGVyRW1pdHRlcilcblx0c3RhdGVSb3V0ZXJPcHRpb25zID0gZXh0ZW5kKHtcblx0XHR0aHJvd09uRXJyb3I6IHRydWUsXG5cdFx0cGF0aFByZWZpeDogJyMnXG5cdH0sIHN0YXRlUm91dGVyT3B0aW9ucylcblxuXHRpZiAoIXN0YXRlUm91dGVyT3B0aW9ucy5yb3V0ZXIpIHtcblx0XHRzdGF0ZVJvdXRlck9wdGlvbnMucm91dGVyID0gbmV3SGFzaEJyb3duUm91dGVyKGRlZmF1bHRSb3V0ZXJPcHRpb25zKVxuXHR9XG5cblx0c3RhdGVSb3V0ZXJPcHRpb25zLnJvdXRlci5zZXREZWZhdWx0KGZ1bmN0aW9uKHJvdXRlLCBwYXJhbWV0ZXJzKSB7XG5cdFx0c3RhdGVQcm92aWRlckVtaXR0ZXIuZW1pdCgncm91dGVOb3RGb3VuZCcsIHJvdXRlLCBwYXJhbWV0ZXJzKVxuXHR9KVxuXG5cdHZhciBkZXN0cm95RG9tID0gbnVsbFxuXHR2YXIgZ2V0RG9tQ2hpbGQgPSBudWxsXG5cdHZhciByZW5kZXJEb20gPSBudWxsXG5cdHZhciByZXNldERvbSA9IG51bGxcblxuXHR2YXIgYWN0aXZlRG9tQXBpcyA9IHt9XG5cdHZhciBhY3RpdmVTdGF0ZVJlc29sdmVDb250ZW50ID0ge31cblx0dmFyIGFjdGl2ZUVtaXR0ZXJzID0ge31cblxuXHRmdW5jdGlvbiBoYW5kbGVFcnJvcihldmVudCwgZXJyKSB7XG5cdFx0cHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdHN0YXRlUHJvdmlkZXJFbWl0dGVyLmVtaXQoZXZlbnQsIGVycilcblx0XHRcdGNvbnNvbGUuZXJyb3IoZXZlbnQgKyAnIC0gJyArIGVyci5tZXNzYWdlKVxuXHRcdFx0aWYgKHN0YXRlUm91dGVyT3B0aW9ucy50aHJvd09uRXJyb3IpIHtcblx0XHRcdFx0dGhyb3cgZXJyXG5cdFx0XHR9XG5cdFx0fSlcblx0fVxuXG5cdGZ1bmN0aW9uIGRlc3Ryb3lTdGF0ZU5hbWUoc3RhdGVOYW1lKSB7XG5cdFx0dmFyIHN0YXRlID0gcHJvdG90eXBhbFN0YXRlSG9sZGVyLmdldChzdGF0ZU5hbWUpXG5cdFx0c3RhdGVQcm92aWRlckVtaXR0ZXIuZW1pdCgnYmVmb3JlRGVzdHJveVN0YXRlJywge1xuXHRcdFx0c3RhdGU6IHN0YXRlLFxuXHRcdFx0ZG9tQXBpOiBhY3RpdmVEb21BcGlzW3N0YXRlTmFtZV1cblx0XHR9KVxuXG5cdFx0YWN0aXZlRW1pdHRlcnNbc3RhdGVOYW1lXS5lbWl0KCdkZXN0cm95Jylcblx0XHRhY3RpdmVFbWl0dGVyc1tzdGF0ZU5hbWVdLnJlbW92ZUFsbExpc3RlbmVycygpXG5cdFx0ZGVsZXRlIGFjdGl2ZUVtaXR0ZXJzW3N0YXRlTmFtZV1cblx0XHRkZWxldGUgYWN0aXZlU3RhdGVSZXNvbHZlQ29udGVudFtzdGF0ZU5hbWVdXG5cblx0XHRyZXR1cm4gZGVzdHJveURvbShhY3RpdmVEb21BcGlzW3N0YXRlTmFtZV0pLnRoZW4oZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgYWN0aXZlRG9tQXBpc1tzdGF0ZU5hbWVdXG5cdFx0XHRzdGF0ZVByb3ZpZGVyRW1pdHRlci5lbWl0KCdhZnRlckRlc3Ryb3lTdGF0ZScsIHtcblx0XHRcdFx0c3RhdGU6IHN0YXRlXG5cdFx0XHR9KVxuXHRcdH0pXG5cdH1cblxuXHRmdW5jdGlvbiByZXNldFN0YXRlTmFtZShwYXJhbWV0ZXJzLCBzdGF0ZU5hbWUpIHtcblx0XHR2YXIgZG9tQXBpID0gYWN0aXZlRG9tQXBpc1tzdGF0ZU5hbWVdXG5cdFx0dmFyIGNvbnRlbnQgPSBnZXRDb250ZW50T2JqZWN0KGFjdGl2ZVN0YXRlUmVzb2x2ZUNvbnRlbnQsIHN0YXRlTmFtZSlcblx0XHR2YXIgc3RhdGUgPSBwcm90b3R5cGFsU3RhdGVIb2xkZXIuZ2V0KHN0YXRlTmFtZSlcblxuXHRcdHN0YXRlUHJvdmlkZXJFbWl0dGVyLmVtaXQoJ2JlZm9yZVJlc2V0U3RhdGUnLCB7XG5cdFx0XHRkb21BcGk6IGRvbUFwaSxcblx0XHRcdGNvbnRlbnQ6IGNvbnRlbnQsXG5cdFx0XHRzdGF0ZTogc3RhdGUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzXG5cdFx0fSlcblxuXHRcdGFjdGl2ZUVtaXR0ZXJzW3N0YXRlTmFtZV0uZW1pdCgnZGVzdHJveScpXG5cdFx0ZGVsZXRlIGFjdGl2ZUVtaXR0ZXJzW3N0YXRlTmFtZV1cblxuXHRcdHJldHVybiByZXNldERvbSh7XG5cdFx0XHRkb21BcGk6IGRvbUFwaSxcblx0XHRcdGNvbnRlbnQ6IGNvbnRlbnQsXG5cdFx0XHR0ZW1wbGF0ZTogc3RhdGUudGVtcGxhdGUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzXG5cdFx0fSkudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdHN0YXRlUHJvdmlkZXJFbWl0dGVyLmVtaXQoJ2FmdGVyUmVzZXRTdGF0ZScsIHtcblx0XHRcdFx0ZG9tQXBpOiBkb21BcGksXG5cdFx0XHRcdGNvbnRlbnQ6IGNvbnRlbnQsXG5cdFx0XHRcdHN0YXRlOiBzdGF0ZSxcblx0XHRcdFx0cGFyYW1ldGVyczogcGFyYW1ldGVyc1xuXHRcdFx0fSlcblx0XHR9KVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q2hpbGRFbGVtZW50Rm9yU3RhdGVOYW1lKHN0YXRlTmFtZSkge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gcHJvdG90eXBhbFN0YXRlSG9sZGVyLmdldFBhcmVudChzdGF0ZU5hbWUpXG5cdFx0XHRpZiAocGFyZW50KSB7XG5cdFx0XHRcdHZhciBwYXJlbnREb21BcGkgPSBhY3RpdmVEb21BcGlzW3BhcmVudC5uYW1lXVxuXHRcdFx0XHRyZXNvbHZlKGdldERvbUNoaWxkKHBhcmVudERvbUFwaSkpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXNvbHZlKHJvb3RFbGVtZW50KVxuXHRcdFx0fVxuXHRcdH0pXG5cdH1cblxuXHRmdW5jdGlvbiByZW5kZXJTdGF0ZU5hbWUocGFyYW1ldGVycywgc3RhdGVOYW1lKSB7XG5cdFx0cmV0dXJuIGdldENoaWxkRWxlbWVudEZvclN0YXRlTmFtZShzdGF0ZU5hbWUpLnRoZW4oZnVuY3Rpb24oY2hpbGRFbGVtZW50KSB7XG5cdFx0XHR2YXIgc3RhdGUgPSBwcm90b3R5cGFsU3RhdGVIb2xkZXIuZ2V0KHN0YXRlTmFtZSlcblx0XHRcdHZhciBjb250ZW50ID0gZ2V0Q29udGVudE9iamVjdChhY3RpdmVTdGF0ZVJlc29sdmVDb250ZW50LCBzdGF0ZU5hbWUpXG5cblx0XHRcdHN0YXRlUHJvdmlkZXJFbWl0dGVyLmVtaXQoJ2JlZm9yZUNyZWF0ZVN0YXRlJywge1xuXHRcdFx0XHRzdGF0ZTogc3RhdGUsXG5cdFx0XHRcdGNvbnRlbnQ6IGNvbnRlbnQsXG5cdFx0XHRcdHBhcmFtZXRlcnM6IHBhcmFtZXRlcnNcblx0XHRcdH0pXG5cblx0XHRcdHJldHVybiByZW5kZXJEb20oe1xuXHRcdFx0XHRlbGVtZW50OiBjaGlsZEVsZW1lbnQsXG5cdFx0XHRcdHRlbXBsYXRlOiBzdGF0ZS50ZW1wbGF0ZSxcblx0XHRcdFx0Y29udGVudDogY29udGVudCxcblx0XHRcdFx0cGFyYW1ldGVyczogcGFyYW1ldGVyc1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbihkb21BcGkpIHtcblx0XHRcdFx0YWN0aXZlRG9tQXBpc1tzdGF0ZU5hbWVdID0gZG9tQXBpXG5cdFx0XHRcdHN0YXRlUHJvdmlkZXJFbWl0dGVyLmVtaXQoJ2FmdGVyQ3JlYXRlU3RhdGUnLCB7XG5cdFx0XHRcdFx0c3RhdGU6IHN0YXRlLFxuXHRcdFx0XHRcdGRvbUFwaTogZG9tQXBpLFxuXHRcdFx0XHRcdGNvbnRlbnQ6IGNvbnRlbnQsXG5cdFx0XHRcdFx0cGFyYW1ldGVyczogcGFyYW1ldGVyc1xuXHRcdFx0XHR9KVxuXHRcdFx0XHRyZXR1cm4gZG9tQXBpXG5cdFx0XHR9KVxuXHRcdH0pXG5cdH1cblxuXHRmdW5jdGlvbiByZW5kZXJBbGwoc3RhdGVOYW1lcywgcGFyYW1ldGVycykge1xuXHRcdHJldHVybiBzZXJpZXMoc3RhdGVOYW1lcywgcmVuZGVyU3RhdGVOYW1lLmJpbmQobnVsbCwgcGFyYW1ldGVycykpXG5cdH1cblxuXHRmdW5jdGlvbiBvblJvdXRlQ2hhbmdlKHN0YXRlLCBwYXJhbWV0ZXJzKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHZhciBmaW5hbERlc3RpbmF0aW9uU3RhdGVOYW1lID0gcHJvdG90eXBhbFN0YXRlSG9sZGVyLmFwcGx5RGVmYXVsdENoaWxkU3RhdGVzKHN0YXRlLm5hbWUpXG5cblx0XHRcdGlmIChmaW5hbERlc3RpbmF0aW9uU3RhdGVOYW1lID09PSBzdGF0ZS5uYW1lKSB7XG5cdFx0XHRcdGVtaXRFdmVudEFuZEF0dGVtcHRTdGF0ZUNoYW5nZShmaW5hbERlc3RpbmF0aW9uU3RhdGVOYW1lLCBwYXJhbWV0ZXJzKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gVGhlcmUgYXJlIGRlZmF1bHQgY2hpbGQgc3RhdGVzIHRoYXQgbmVlZCB0byBiZSBhcHBsaWVkXG5cblx0XHRcdFx0dmFyIHRoZVJvdXRlV2VOZWVkVG9FbmRVcEF0ID0gbWFrZVBhdGgoZmluYWxEZXN0aW5hdGlvblN0YXRlTmFtZSwgcGFyYW1ldGVycylcblx0XHRcdFx0dmFyIGN1cnJlbnRSb3V0ZSA9IHN0YXRlUm91dGVyT3B0aW9ucy5yb3V0ZXIubG9jYXRpb24uZ2V0KClcblxuXHRcdFx0XHRpZiAodGhlUm91dGVXZU5lZWRUb0VuZFVwQXQgPT09IGN1cnJlbnRSb3V0ZSkge1xuXHRcdFx0XHRcdC8vIHRoZSBjaGlsZCBzdGF0ZSBoYXMgdGhlIHNhbWUgcm91dGUgYXMgdGhlIGN1cnJlbnQgb25lLCBqdXN0IHN0YXJ0IG5hdmlnYXRpbmcgdGhlcmVcblx0XHRcdFx0XHRlbWl0RXZlbnRBbmRBdHRlbXB0U3RhdGVDaGFuZ2UoZmluYWxEZXN0aW5hdGlvblN0YXRlTmFtZSwgcGFyYW1ldGVycylcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBjaGFuZ2UgdGhlIHVybCB0byBtYXRjaCB0aGUgZnVsbCBkZWZhdWx0IGNoaWxkIHN0YXRlIHJvdXRlXG5cdFx0XHRcdFx0c3RhdGVQcm92aWRlckVtaXR0ZXIuZ28oZmluYWxEZXN0aW5hdGlvblN0YXRlTmFtZSwgcGFyYW1ldGVycywgeyByZXBsYWNlOiB0cnVlIH0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdGhhbmRsZUVycm9yKCdzdGF0ZUVycm9yJywgZXJyKVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGFkZFN0YXRlKHN0YXRlKSB7XG5cdFx0aWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgXFwnc3RhdGVcXCcgdG8gYmUgcGFzc2VkIGluLicpXG5cdFx0fSBlbHNlIGlmICh0eXBlb2Ygc3RhdGUubmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIFxcJ25hbWVcXCcgb3B0aW9uIHRvIGJlIHBhc3NlZCBpbi4nKVxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHN0YXRlLnRlbXBsYXRlID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgXFwndGVtcGxhdGVcXCcgb3B0aW9uIHRvIGJlIHBhc3NlZCBpbi4nKVxuXHRcdH1cblx0XHRPYmplY3Qua2V5cyhzdGF0ZSkuZmlsdGVyKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0cmV0dXJuIGV4cGVjdGVkUHJvcGVydGllc09mQWRkU3RhdGUuaW5kZXhPZihrZXkpID09PSAtMVxuXHRcdH0pLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1VuZXhwZWN0ZWQgcHJvcGVydHkgcGFzc2VkIHRvIGFkZFN0YXRlOicsIGtleSlcblx0XHR9KVxuXG5cdFx0cHJvdG90eXBhbFN0YXRlSG9sZGVyLmFkZChzdGF0ZS5uYW1lLCBzdGF0ZSlcblxuXHRcdHZhciByb3V0ZSA9IHByb3RvdHlwYWxTdGF0ZUhvbGRlci5idWlsZEZ1bGxTdGF0ZVJvdXRlKHN0YXRlLm5hbWUpXG5cblx0XHRzdGF0ZVJvdXRlck9wdGlvbnMucm91dGVyLmFkZChyb3V0ZSwgb25Sb3V0ZUNoYW5nZS5iaW5kKG51bGwsIHN0YXRlKSlcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFN0YXRlc1RvUmVzb2x2ZShzdGF0ZUNoYW5nZXMpIHtcblx0XHRyZXR1cm4gc3RhdGVDaGFuZ2VzLmNoYW5nZS5jb25jYXQoc3RhdGVDaGFuZ2VzLmNyZWF0ZSkubWFwKHByb3RvdHlwYWxTdGF0ZUhvbGRlci5nZXQpXG5cdH1cblxuXHRmdW5jdGlvbiBlbWl0RXZlbnRBbmRBdHRlbXB0U3RhdGVDaGFuZ2UobmV3U3RhdGVOYW1lLCBwYXJhbWV0ZXJzKSB7XG5cdFx0c3RhdGVQcm92aWRlckVtaXR0ZXIuZW1pdCgnc3RhdGVDaGFuZ2VBdHRlbXB0JywgZnVuY3Rpb24gc3RhdGVHbyh0cmFuc2l0aW9uKSB7XG5cdFx0XHRhdHRlbXB0U3RhdGVDaGFuZ2UobmV3U3RhdGVOYW1lLCBwYXJhbWV0ZXJzLCB0cmFuc2l0aW9uKVxuXHRcdH0pXG5cdH1cblxuXHRmdW5jdGlvbiBhdHRlbXB0U3RhdGVDaGFuZ2UobmV3U3RhdGVOYW1lLCBwYXJhbWV0ZXJzLCB0cmFuc2l0aW9uKSB7XG5cdFx0ZnVuY3Rpb24gaWZOb3RDYW5jZWxsZWQoZm4pIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKHRyYW5zaXRpb24uY2FuY2VsbGVkKSB7XG5cdFx0XHRcdFx0dmFyIGVyciA9IG5ldyBFcnJvcignVGhlIHRyYW5zaXRpb24gdG8gJyArIG5ld1N0YXRlTmFtZSArICd3YXMgY2FuY2VsbGVkJylcblx0XHRcdFx0XHRlcnIud2FzQ2FuY2VsbGVkQnlTb21lb25lRWxzZSA9IHRydWVcblx0XHRcdFx0XHR0aHJvdyBlcnJcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHByb21pc2VNZShwcm90b3R5cGFsU3RhdGVIb2xkZXIuZ3VhcmFudGVlQWxsU3RhdGVzRXhpc3QsIG5ld1N0YXRlTmFtZSlcblx0XHQudGhlbihmdW5jdGlvbiBhcHBseURlZmF1bHRQYXJhbWV0ZXJzKCkge1xuXHRcdFx0dmFyIHN0YXRlID0gcHJvdG90eXBhbFN0YXRlSG9sZGVyLmdldChuZXdTdGF0ZU5hbWUpXG5cdFx0XHR2YXIgZGVmYXVsdFBhcmFtcyA9IHN0YXRlLmRlZmF1bHRRdWVyeXN0cmluZ1BhcmFtZXRlcnMgfHwge31cblx0XHRcdHZhciBuZWVkVG9BcHBseURlZmF1bHRzID0gT2JqZWN0LmtleXMoZGVmYXVsdFBhcmFtcykuc29tZShmdW5jdGlvbiBtaXNzaW5nUGFyYW1ldGVyVmFsdWUocGFyYW0pIHtcblx0XHRcdFx0cmV0dXJuICFwYXJhbWV0ZXJzW3BhcmFtXVxuXHRcdFx0fSlcblxuXHRcdFx0aWYgKG5lZWRUb0FwcGx5RGVmYXVsdHMpIHtcblx0XHRcdFx0dGhyb3cgcmVkaXJlY3RvcihuZXdTdGF0ZU5hbWUsIGV4dGVuZChkZWZhdWx0UGFyYW1zLCBwYXJhbWV0ZXJzKSlcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdGF0ZVxuXHRcdH0pLnRoZW4oaWZOb3RDYW5jZWxsZWQoZnVuY3Rpb24oc3RhdGUpIHtcblx0XHRcdHN0YXRlUHJvdmlkZXJFbWl0dGVyLmVtaXQoJ3N0YXRlQ2hhbmdlU3RhcnQnLCBzdGF0ZSwgcGFyYW1ldGVycylcblx0XHRcdGxhc3RTdGF0ZVN0YXJ0ZWRBY3RpdmF0aW5nLnNldChzdGF0ZS5uYW1lLCBwYXJhbWV0ZXJzKVxuXHRcdH0pKS50aGVuKGZ1bmN0aW9uIGdldFN0YXRlQ2hhbmdlcygpIHtcblx0XHRcdHZhciBzdGF0ZUNvbXBhcmlzb25SZXN1bHRzID0gU3RhdGVDb21wYXJpc29uKHByb3RvdHlwYWxTdGF0ZUhvbGRlcikobGFzdENvbXBsZXRlbHlMb2FkZWRTdGF0ZS5nZXQoKS5uYW1lLCBsYXN0Q29tcGxldGVseUxvYWRlZFN0YXRlLmdldCgpLnBhcmFtZXRlcnMsIG5ld1N0YXRlTmFtZSwgcGFyYW1ldGVycylcblx0XHRcdHJldHVybiBzdGF0ZUNoYW5nZUxvZ2ljKHN0YXRlQ29tcGFyaXNvblJlc3VsdHMpIC8vIHsgZGVzdHJveSwgY2hhbmdlLCBjcmVhdGUgfVxuXHRcdH0pLnRoZW4oaWZOb3RDYW5jZWxsZWQoZnVuY3Rpb24gcmVzb2x2ZURlc3Ryb3lBbmRBY3RpdmF0ZVN0YXRlcyhzdGF0ZUNoYW5nZXMpIHtcblx0XHRcdHJldHVybiByZXNvbHZlU3RhdGVzKGdldFN0YXRlc1RvUmVzb2x2ZShzdGF0ZUNoYW5nZXMpLCBleHRlbmQocGFyYW1ldGVycykpLmNhdGNoKGZ1bmN0aW9uIG9uUmVzb2x2ZUVycm9yKGUpIHtcblx0XHRcdFx0ZS5zdGF0ZUNoYW5nZUVycm9yID0gdHJ1ZVxuXHRcdFx0XHR0aHJvdyBlXG5cdFx0XHR9KS50aGVuKGlmTm90Q2FuY2VsbGVkKGZ1bmN0aW9uIGRlc3Ryb3lBbmRBY3RpdmF0ZShzdGF0ZVJlc29sdmVSZXN1bHRzT2JqZWN0KSB7XG5cdFx0XHRcdHRyYW5zaXRpb24uY2FuY2VsbGFibGUgPSBmYWxzZVxuXG5cdFx0XHRcdGZ1bmN0aW9uIGFjdGl2YXRlQWxsKCkge1xuXHRcdFx0XHRcdHZhciBzdGF0ZXNUb0FjdGl2YXRlID0gc3RhdGVDaGFuZ2VzLmNoYW5nZS5jb25jYXQoc3RhdGVDaGFuZ2VzLmNyZWF0ZSlcblxuXHRcdFx0XHRcdHJldHVybiBhY3RpdmF0ZVN0YXRlcyhzdGF0ZXNUb0FjdGl2YXRlKVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YWN0aXZlU3RhdGVSZXNvbHZlQ29udGVudCA9IGV4dGVuZChhY3RpdmVTdGF0ZVJlc29sdmVDb250ZW50LCBzdGF0ZVJlc29sdmVSZXN1bHRzT2JqZWN0KVxuXG5cdFx0XHRcdHJldHVybiBzZXJpZXMocmV2ZXJzZShzdGF0ZUNoYW5nZXMuZGVzdHJveSksIGRlc3Ryb3lTdGF0ZU5hbWUpLnRoZW4oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNlcmllcyhyZXZlcnNlKHN0YXRlQ2hhbmdlcy5jaGFuZ2UpLCByZXNldFN0YXRlTmFtZS5iaW5kKG51bGwsIGV4dGVuZChwYXJhbWV0ZXJzKSkpXG5cdFx0XHRcdH0pLnRoZW4oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlbmRlckFsbChzdGF0ZUNoYW5nZXMuY3JlYXRlLCBleHRlbmQocGFyYW1ldGVycykpLnRoZW4oYWN0aXZhdGVBbGwpXG5cdFx0XHRcdH0pXG5cdFx0XHR9KSlcblxuXHRcdFx0ZnVuY3Rpb24gYWN0aXZhdGVTdGF0ZXMoc3RhdGVOYW1lcykge1xuXHRcdFx0XHRyZXR1cm4gc3RhdGVOYW1lcy5tYXAocHJvdG90eXBhbFN0YXRlSG9sZGVyLmdldCkuZm9yRWFjaChmdW5jdGlvbihzdGF0ZSkge1xuXHRcdFx0XHRcdHZhciBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpXG5cdFx0XHRcdFx0dmFyIGNvbnRleHQgPSBPYmplY3QuY3JlYXRlKGVtaXR0ZXIpXG5cdFx0XHRcdFx0Y29udGV4dC5kb21BcGkgPSBhY3RpdmVEb21BcGlzW3N0YXRlLm5hbWVdXG5cdFx0XHRcdFx0Y29udGV4dC5kYXRhID0gc3RhdGUuZGF0YVxuXHRcdFx0XHRcdGNvbnRleHQucGFyYW1ldGVycyA9IHBhcmFtZXRlcnNcblx0XHRcdFx0XHRjb250ZXh0LmNvbnRlbnQgPSBnZXRDb250ZW50T2JqZWN0KGFjdGl2ZVN0YXRlUmVzb2x2ZUNvbnRlbnQsIHN0YXRlLm5hbWUpXG5cdFx0XHRcdFx0YWN0aXZlRW1pdHRlcnNbc3RhdGUubmFtZV0gPSBlbWl0dGVyXG5cblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0c3RhdGUuYWN0aXZhdGUgJiYgc3RhdGUuYWN0aXZhdGUoY29udGV4dClcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBlXG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHR9KSkudGhlbihmdW5jdGlvbiBzdGF0ZUNoYW5nZUNvbXBsZXRlKCkge1xuXHRcdFx0bGFzdENvbXBsZXRlbHlMb2FkZWRTdGF0ZS5zZXQobmV3U3RhdGVOYW1lLCBwYXJhbWV0ZXJzKVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0c3RhdGVQcm92aWRlckVtaXR0ZXIuZW1pdCgnc3RhdGVDaGFuZ2VFbmQnLCBwcm90b3R5cGFsU3RhdGVIb2xkZXIuZ2V0KG5ld1N0YXRlTmFtZSksIHBhcmFtZXRlcnMpXG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGhhbmRsZUVycm9yKCdzdGF0ZUVycm9yJywgZSlcblx0XHRcdH1cblx0XHR9KS5jYXRjaChpZk5vdENhbmNlbGxlZChmdW5jdGlvbiBoYW5kbGVTdGF0ZUNoYW5nZUVycm9yKGVycikge1xuXHRcdFx0aWYgKGVyciAmJiBlcnIucmVkaXJlY3RUbykge1xuXHRcdFx0XHRzdGF0ZVByb3ZpZGVyRW1pdHRlci5lbWl0KCdzdGF0ZUNoYW5nZUNhbmNlbGxlZCcsIGVycilcblx0XHRcdFx0cmV0dXJuIHN0YXRlUHJvdmlkZXJFbWl0dGVyLmdvKGVyci5yZWRpcmVjdFRvLm5hbWUsIGVyci5yZWRpcmVjdFRvLnBhcmFtcywgeyByZXBsYWNlOiB0cnVlIH0pXG5cdFx0XHR9IGVsc2UgaWYgKGVycikge1xuXHRcdFx0XHRoYW5kbGVFcnJvcignc3RhdGVDaGFuZ2VFcnJvcicsIGVycilcblx0XHRcdH1cblx0XHR9KSkuY2F0Y2goZnVuY3Rpb24gaGFuZGxlQ2FuY2VsbGF0aW9uKGVycikge1xuXHRcdFx0aWYgKGVyciAmJiBlcnIud2FzQ2FuY2VsbGVkQnlTb21lb25lRWxzZSkge1xuXHRcdFx0XHQvLyB3ZSBkb24ndCBjYXJlLCB0aGUgc3RhdGUgdHJhbnNpdGlvbiBtYW5hZ2VyIGhhcyBhbHJlYWR5IGVtaXR0ZWQgdGhlIHN0YXRlQ2hhbmdlQ2FuY2VsbGVkIGZvciB1c1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhpcyBwcm9iYWJseSBzaG91bGRuJ3QgaGFwcGVuLCBtYXliZSBmaWxlIGFuIGlzc3VlIG9yIHNvbWV0aGluZyBcIiArIGVycilcblx0XHRcdH1cblx0XHR9KVxuXHR9XG5cblx0ZnVuY3Rpb24gbWFrZVBhdGgoc3RhdGVOYW1lLCBwYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG5cdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbmhlcml0KSB7XG5cdFx0XHRwYXJhbWV0ZXJzID0gZXh0ZW5kKGxhc3RTdGF0ZVN0YXJ0ZWRBY3RpdmF0aW5nLmdldCgpLnBhcmFtZXRlcnMsIHBhcmFtZXRlcnMpXG5cdFx0fVxuXG5cdFx0cHJvdG90eXBhbFN0YXRlSG9sZGVyLmd1YXJhbnRlZUFsbFN0YXRlc0V4aXN0KHN0YXRlTmFtZSlcblx0XHR2YXIgcm91dGUgPSBwcm90b3R5cGFsU3RhdGVIb2xkZXIuYnVpbGRGdWxsU3RhdGVSb3V0ZShzdGF0ZU5hbWUpXG5cdFx0cmV0dXJuIGJ1aWxkUGF0aChyb3V0ZSwgcGFyYW1ldGVycyB8fCB7fSlcblx0fVxuXG5cdHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcblx0XHRyZXBsYWNlOiBmYWxzZVxuXHR9XG5cblx0c3RhdGVQcm92aWRlckVtaXR0ZXIuYWRkU3RhdGUgPSBhZGRTdGF0ZVxuXHRzdGF0ZVByb3ZpZGVyRW1pdHRlci5nbyA9IGZ1bmN0aW9uIGdvKG5ld1N0YXRlTmFtZSwgcGFyYW1ldGVycywgb3B0aW9ucykge1xuXHRcdG9wdGlvbnMgPSBleHRlbmQoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpXG5cdFx0dmFyIGdvRnVuY3Rpb24gPSBvcHRpb25zLnJlcGxhY2UgPyBzdGF0ZVJvdXRlck9wdGlvbnMucm91dGVyLnJlcGxhY2UgOiBzdGF0ZVJvdXRlck9wdGlvbnMucm91dGVyLmdvXG5cblx0XHRyZXR1cm4gcHJvbWlzZU1lKG1ha2VQYXRoLCBuZXdTdGF0ZU5hbWUsIHBhcmFtZXRlcnMsIG9wdGlvbnMpLnRoZW4oZ29GdW5jdGlvbiwgaGFuZGxlRXJyb3IuYmluZChudWxsLCAnc3RhdGVDaGFuZ2VFcnJvcicpKVxuXHR9XG5cdHN0YXRlUHJvdmlkZXJFbWl0dGVyLmV2YWx1YXRlQ3VycmVudFJvdXRlID0gZnVuY3Rpb24gZXZhbHVhdGVDdXJyZW50Um91dGUoZGVmYXVsdFN0YXRlLCBkZWZhdWx0UGFyYW1zKSB7XG5cdFx0cmV0dXJuIHByb21pc2VNZShtYWtlUGF0aCwgZGVmYXVsdFN0YXRlLCBkZWZhdWx0UGFyYW1zKS50aGVuKGZ1bmN0aW9uKGRlZmF1bHRQYXRoKSB7XG5cdFx0XHRzdGF0ZVJvdXRlck9wdGlvbnMucm91dGVyLmV2YWx1YXRlQ3VycmVudChkZWZhdWx0UGF0aClcblx0XHR9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcblx0XHRcdGhhbmRsZUVycm9yKCdzdGF0ZUVycm9yJywgZXJyKVxuXHRcdH0pXG5cdH1cblx0c3RhdGVQcm92aWRlckVtaXR0ZXIubWFrZVBhdGggPSBmdW5jdGlvbiBtYWtlUGF0aEFuZFByZXBlbmRIYXNoKHN0YXRlTmFtZSwgcGFyYW1ldGVycywgb3B0aW9ucykge1xuXHRcdHJldHVybiBzdGF0ZVJvdXRlck9wdGlvbnMucGF0aFByZWZpeCArIG1ha2VQYXRoKHN0YXRlTmFtZSwgcGFyYW1ldGVycywgb3B0aW9ucylcblx0fVxuXHRzdGF0ZVByb3ZpZGVyRW1pdHRlci5zdGF0ZUlzQWN0aXZlID0gZnVuY3Rpb24gc3RhdGVJc0FjdGl2ZShzdGF0ZU5hbWUsIG9wdHMpIHtcblx0XHR2YXIgY3VycmVudFN0YXRlID0gbGFzdENvbXBsZXRlbHlMb2FkZWRTdGF0ZS5nZXQoKVxuXHRcdHJldHVybiAoY3VycmVudFN0YXRlLm5hbWUgPT09IHN0YXRlTmFtZSB8fCBjdXJyZW50U3RhdGUubmFtZS5pbmRleE9mKHN0YXRlTmFtZSArICcuJykgPT09IDApICYmICh0eXBlb2Ygb3B0cyA9PT0gJ3VuZGVmaW5lZCcgfHwgT2JqZWN0LmtleXMob3B0cykuZXZlcnkoZnVuY3Rpb24gbWF0Y2hlcyhrZXkpIHtcblx0XHRcdHJldHVybiBvcHRzW2tleV0gPT09IGN1cnJlbnRTdGF0ZS5wYXJhbWV0ZXJzW2tleV1cblx0XHR9KSlcblx0fVxuXG5cdHZhciByZW5kZXJlciA9IG1ha2VSZW5kZXJlcihzdGF0ZVByb3ZpZGVyRW1pdHRlcilcblxuXHRkZXN0cm95RG9tID0gZGVub2RlaWZ5KHJlbmRlcmVyLmRlc3Ryb3kpXG5cdGdldERvbUNoaWxkID0gZGVub2RlaWZ5KHJlbmRlcmVyLmdldENoaWxkRWxlbWVudClcblx0cmVuZGVyRG9tID0gZGVub2RlaWZ5KHJlbmRlcmVyLnJlbmRlcilcblx0cmVzZXREb20gPSBkZW5vZGVpZnkocmVuZGVyZXIucmVzZXQpXG5cblx0cmV0dXJuIHN0YXRlUHJvdmlkZXJFbWl0dGVyXG59XG5cbmZ1bmN0aW9uIGdldENvbnRlbnRPYmplY3Qoc3RhdGVSZXNvbHZlUmVzdWx0c09iamVjdCwgc3RhdGVOYW1lKSB7XG5cdHZhciBhbGxQb3NzaWJsZVJlc29sdmVkU3RhdGVOYW1lcyA9IHBhcnNlKHN0YXRlTmFtZSlcblxuXHRyZXR1cm4gYWxsUG9zc2libGVSZXNvbHZlZFN0YXRlTmFtZXMuZmlsdGVyKGZ1bmN0aW9uKHN0YXRlTmFtZSkge1xuXHRcdHJldHVybiBzdGF0ZVJlc29sdmVSZXN1bHRzT2JqZWN0W3N0YXRlTmFtZV1cblx0fSkucmVkdWNlKGZ1bmN0aW9uKG9iaiwgc3RhdGVOYW1lKSB7XG5cdFx0cmV0dXJuIGV4dGVuZChvYmosIHN0YXRlUmVzb2x2ZVJlc3VsdHNPYmplY3Rbc3RhdGVOYW1lXSlcblx0fSwge30pXG59XG5cbmZ1bmN0aW9uIHJlZGlyZWN0b3IobmV3U3RhdGVOYW1lLCBwYXJhbWV0ZXJzKSB7XG5cdHJldHVybiB7XG5cdFx0cmVkaXJlY3RUbzoge1xuXHRcdFx0bmFtZTogbmV3U3RhdGVOYW1lLFxuXHRcdFx0cGFyYW1zOiBwYXJhbWV0ZXJzXG5cdFx0fVxuXHR9XG59XG5cbi8vIHsgW3N0YXRlTmFtZV06IHJlc29sdmVSZXN1bHQgfVxuZnVuY3Rpb24gcmVzb2x2ZVN0YXRlcyhzdGF0ZXMsIHBhcmFtZXRlcnMpIHtcblx0dmFyIHN0YXRlc1dpdGhSZXNvbHZlRnVuY3Rpb25zID0gc3RhdGVzLmZpbHRlcihpc0Z1bmN0aW9uKCdyZXNvbHZlJykpXG5cdHZhciBzdGF0ZU5hbWVzV2l0aFJlc29sdmVGdW5jdGlvbnMgPSBzdGF0ZXNXaXRoUmVzb2x2ZUZ1bmN0aW9ucy5tYXAocHJvcGVydHkoJ25hbWUnKSlcblx0dmFyIHJlc29sdmVzID0gUHJvbWlzZS5hbGwoc3RhdGVzV2l0aFJlc29sdmVGdW5jdGlvbnMubWFwKGZ1bmN0aW9uKHN0YXRlKSB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdGZ1bmN0aW9uIHJlc29sdmVDYihlcnIsIGNvbnRlbnQpIHtcblx0XHRcdFx0ZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGNvbnRlbnQpXG5cdFx0XHR9XG5cblx0XHRcdHJlc29sdmVDYi5yZWRpcmVjdCA9IGZ1bmN0aW9uIHJlZGlyZWN0KG5ld1N0YXRlTmFtZSwgcGFyYW1ldGVycykge1xuXHRcdFx0XHRyZWplY3QocmVkaXJlY3RvcihuZXdTdGF0ZU5hbWUsIHBhcmFtZXRlcnMpKVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcmVzID0gc3RhdGUucmVzb2x2ZShzdGF0ZS5kYXRhLCBwYXJhbWV0ZXJzLCByZXNvbHZlQ2IpXG5cdFx0XHRpZiAocmVzICYmICh0eXBlb2YgcmVzID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcmVzID09PSAnZnVuY3Rpb24nKSAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cmVzb2x2ZShyZXMpXG5cdFx0XHR9XG5cdFx0fSlcblx0fSkpXG5cblx0cmV0dXJuIHJlc29sdmVzLnRoZW4oZnVuY3Rpb24ocmVzb2x2ZVJlc3VsdHMpIHtcblx0XHRyZXR1cm4gY29tYmluZSh7XG5cdFx0XHRzdGF0ZU5hbWU6IHN0YXRlTmFtZXNXaXRoUmVzb2x2ZUZ1bmN0aW9ucyxcblx0XHRcdHJlc29sdmVSZXN1bHQ6IHJlc29sdmVSZXN1bHRzXG5cdFx0fSkucmVkdWNlKGZ1bmN0aW9uKG9iaiwgcmVzdWx0KSB7XG5cdFx0XHRvYmpbcmVzdWx0LnN0YXRlTmFtZV0gPSByZXN1bHQucmVzb2x2ZVJlc3VsdFxuXHRcdFx0cmV0dXJuIG9ialxuXHRcdH0sIHt9KVxuXHR9KVxufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eShuYW1lKSB7XG5cdHJldHVybiBmdW5jdGlvbihvYmopIHtcblx0XHRyZXR1cm4gb2JqW25hbWVdXG5cdH1cbn1cblxuZnVuY3Rpb24gcmV2ZXJzZShhcnkpIHtcblx0cmV0dXJuIGFyeS5zbGljZSgpLnJldmVyc2UoKVxufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHByb3BlcnR5KSB7XG5cdHJldHVybiBmdW5jdGlvbihvYmopIHtcblx0XHRyZXR1cm4gdHlwZW9mIG9ialtwcm9wZXJ0eV0gPT09ICdmdW5jdGlvbidcblx0fVxufVxuXG5mdW5jdGlvbiBwcm9taXNlTWUoKSB7XG5cdHZhciBmbiA9IEFycmF5LnByb3RvdHlwZS5zaGlmdC5hcHBseShhcmd1bWVudHMpXG5cdHZhciBhcmdzID0gYXJndW1lbnRzXG5cdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG5cdFx0cmVzb2x2ZShmbi5hcHBseShudWxsLCBhcmdzKSlcblx0fSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gQ3VycmVudFN0YXRlKCkge1xuXHR2YXIgY3VycmVudCA9IHtcblx0XHRuYW1lOiAnJyxcblx0XHRwYXJhbWV0ZXJzOiB7fVxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGN1cnJlbnRcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24obmFtZSwgcGFyYW1ldGVycykge1xuXHRcdFx0Y3VycmVudCA9IHtcblx0XHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdFx0cGFyYW1ldGVyczogcGFyYW1ldGVyc1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuIiwiLy8gUHVsbGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pvbGlzcy9wcm9taXNlLW1hcC1zZXJpZXMgYW5kIHByZXR0aWVkIHVwIGEgYml0XG5cbnZhciBQcm9taXNlID0gcmVxdWlyZSgnbmF0aXZlLXByb21pc2Utb25seS9ucG8nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNlcXVlbmNlKGFycmF5LCBpdGVyYXRvciwgdGhpc0FyZykge1xuXHR2YXIgY3VycmVudCA9IFByb21pc2UucmVzb2x2ZSgpXG5cdHZhciBjYiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gaXRlcmF0b3IuYmluZCh0aGlzQXJnKSA6IGl0ZXJhdG9yXG5cblx0dmFyIHJlc3VsdHMgPSBhcnJheS5tYXAoZnVuY3Rpb24odmFsdWUsIGkpIHtcblx0XHRyZXR1cm4gY3VycmVudCA9IGN1cnJlbnQudGhlbihmdW5jdGlvbihqKSB7XG5cdFx0XHRyZXR1cm4gY2IodmFsdWUsIGosIGFycmF5KVxuXHRcdH0uYmluZChudWxsLCBpKSlcblx0fSlcblxuXHRyZXR1cm4gUHJvbWlzZS5hbGwocmVzdWx0cylcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RhdGVDaGFuZ2VMb2dpYyhzdGF0ZUNvbXBhcmlzb25SZXN1bHRzKSB7XG5cdHZhciBoaXRDaGFuZ2luZ1N0YXRlID0gZmFsc2Vcblx0dmFyIGhpdERlc3Ryb3llZFN0YXRlID0gZmFsc2VcblxuXHR2YXIgb3V0cHV0ID0ge1xuXHRcdGRlc3Ryb3k6IFtdLFxuXHRcdGNoYW5nZTogW10sXG5cdFx0Y3JlYXRlOiBbXVxuXHR9XG5cblx0c3RhdGVDb21wYXJpc29uUmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uKHN0YXRlKSB7XG5cdFx0aGl0Q2hhbmdpbmdTdGF0ZSA9IGhpdENoYW5naW5nU3RhdGUgfHwgc3RhdGUuc3RhdGVQYXJhbWV0ZXJzQ2hhbmdlZFxuXHRcdGhpdERlc3Ryb3llZFN0YXRlID0gaGl0RGVzdHJveWVkU3RhdGUgfHwgc3RhdGUuc3RhdGVOYW1lQ2hhbmdlZFxuXG5cdFx0aWYgKHN0YXRlLm5hbWVCZWZvcmUpIHtcblx0XHRcdGlmIChoaXREZXN0cm95ZWRTdGF0ZSkge1xuXHRcdFx0XHRvdXRwdXQuZGVzdHJveS5wdXNoKHN0YXRlLm5hbWVCZWZvcmUpXG5cdFx0XHR9IGVsc2UgaWYgKGhpdENoYW5naW5nU3RhdGUpIHtcblx0XHRcdFx0b3V0cHV0LmNoYW5nZS5wdXNoKHN0YXRlLm5hbWVCZWZvcmUpXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHN0YXRlLm5hbWVBZnRlciAmJiBoaXREZXN0cm95ZWRTdGF0ZSkge1xuXHRcdFx0b3V0cHV0LmNyZWF0ZS5wdXNoKHN0YXRlLm5hbWVBZnRlcilcblx0XHR9XG5cdH0pXG5cblx0cmV0dXJuIG91dHB1dFxufVxuIiwidmFyIHN0YXRlU3RyaW5nUGFyc2VyID0gcmVxdWlyZSgnLi9zdGF0ZS1zdHJpbmctcGFyc2VyJylcbnZhciBjb21iaW5lID0gcmVxdWlyZSgnY29tYmluZS1hcnJheXMnKVxudmFyIHBhdGhUb1JlZ2V4cCA9IHJlcXVpcmUoJ3BhdGgtdG8tcmVnZXhwLXdpdGgtcmV2ZXJzaWJsZS1rZXlzJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBTdGF0ZUNvbXBhcmlzb24oc3RhdGVTdGF0ZSkge1xuXHR2YXIgZ2V0UGF0aFBhcmFtZXRlcnMgPSBwYXRoUGFyYW1ldGVycygpXG5cblx0dmFyIHBhcmFtZXRlcnNDaGFuZ2VkID0gcGFyYW1ldGVyc1RoYXRNYXR0ZXJXZXJlQ2hhbmdlZC5iaW5kKG51bGwsIHN0YXRlU3RhdGUsIGdldFBhdGhQYXJhbWV0ZXJzKVxuXG5cdHJldHVybiBzdGF0ZUNvbXBhcmlzb24uYmluZChudWxsLCBwYXJhbWV0ZXJzQ2hhbmdlZClcbn1cblxuZnVuY3Rpb24gcGF0aFBhcmFtZXRlcnMoKSB7XG5cdHZhciBwYXJhbWV0ZXJzID0ge31cblxuXHRyZXR1cm4gZnVuY3Rpb24gZ2V0UGF0aFBhcmFtZXRlcnMocGF0aCkge1xuXHRcdGlmICghcGF0aCkge1xuXHRcdFx0cmV0dXJuIFtdXG5cdFx0fVxuXG5cdFx0aWYgKCFwYXJhbWV0ZXJzW3BhdGhdKSB7XG5cdFx0XHRwYXJhbWV0ZXJzW3BhdGhdID0gcGF0aFRvUmVnZXhwKHBhdGgpLmtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0XHRyZXR1cm4ga2V5Lm5hbWVcblx0XHRcdH0pXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhcmFtZXRlcnNbcGF0aF1cblx0fVxufVxuXG5mdW5jdGlvbiBwYXJhbWV0ZXJzVGhhdE1hdHRlcldlcmVDaGFuZ2VkKHN0YXRlU3RhdGUsIGdldFBhdGhQYXJhbWV0ZXJzLCBzdGF0ZU5hbWUsIGZyb21QYXJhbWV0ZXJzLCB0b1BhcmFtZXRlcnMpIHtcblx0dmFyIHN0YXRlID0gc3RhdGVTdGF0ZS5nZXQoc3RhdGVOYW1lKVxuXHR2YXIgcXVlcnlzdHJpbmdQYXJhbWV0ZXJzID0gc3RhdGUucXVlcnlzdHJpbmdQYXJhbWV0ZXJzIHx8IFtdXG5cdHZhciBwYXJhbWV0ZXJzID0gZ2V0UGF0aFBhcmFtZXRlcnMoc3RhdGUucm91dGUpLmNvbmNhdChxdWVyeXN0cmluZ1BhcmFtZXRlcnMpXG5cblx0cmV0dXJuIEFycmF5LmlzQXJyYXkocGFyYW1ldGVycykgJiYgcGFyYW1ldGVycy5zb21lKGZ1bmN0aW9uKGtleSkge1xuXHRcdHJldHVybiBmcm9tUGFyYW1ldGVyc1trZXldICE9PSB0b1BhcmFtZXRlcnNba2V5XVxuXHR9KVxufVxuXG5mdW5jdGlvbiBzdGF0ZUNvbXBhcmlzb24ocGFyYW1ldGVyc0NoYW5nZWQsIG9yaWdpbmFsU3RhdGUsIG9yaWdpbmFsUGFyYW1ldGVycywgbmV3U3RhdGUsIG5ld1BhcmFtZXRlcnMpIHtcblx0dmFyIHN0YXRlcyA9IGNvbWJpbmUoe1xuXHRcdHN0YXJ0OiBzdGF0ZVN0cmluZ1BhcnNlcihvcmlnaW5hbFN0YXRlKSxcblx0XHRlbmQ6IHN0YXRlU3RyaW5nUGFyc2VyKG5ld1N0YXRlKVxuXHR9KVxuXG5cdHJldHVybiBzdGF0ZXMubWFwKGZ1bmN0aW9uKHN0YXRlcykge1xuXHRcdHJldHVybiB7XG5cdFx0XHRuYW1lQmVmb3JlOiBzdGF0ZXMuc3RhcnQsXG5cdFx0XHRuYW1lQWZ0ZXI6IHN0YXRlcy5lbmQsXG5cdFx0XHRzdGF0ZU5hbWVDaGFuZ2VkOiBzdGF0ZXMuc3RhcnQgIT09IHN0YXRlcy5lbmQsXG5cdFx0XHRzdGF0ZVBhcmFtZXRlcnNDaGFuZ2VkOiBzdGF0ZXMuc3RhcnQgPT09IHN0YXRlcy5lbmQgJiYgcGFyYW1ldGVyc0NoYW5nZWQoc3RhdGVzLnN0YXJ0LCBvcmlnaW5hbFBhcmFtZXRlcnMsIG5ld1BhcmFtZXRlcnMpXG5cdFx0fVxuXHR9KVxufVxuIiwidmFyIHN0YXRlU3RyaW5nUGFyc2VyID0gcmVxdWlyZSgnLi9zdGF0ZS1zdHJpbmctcGFyc2VyJylcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4vc3RhdGUtc3RyaW5nLXBhcnNlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gU3RhdGVTdGF0ZSgpIHtcblx0dmFyIHN0YXRlcyA9IHt9XG5cblx0ZnVuY3Rpb24gZ2V0SGllcmFyY2h5KG5hbWUpIHtcblx0XHR2YXIgbmFtZXMgPSBzdGF0ZVN0cmluZ1BhcnNlcihuYW1lKVxuXG5cdFx0cmV0dXJuIG5hbWVzLm1hcChmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRpZiAoIXN0YXRlc1tuYW1lXSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1N0YXRlICcgKyBuYW1lICsgJyBub3QgZm91bmQnKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0YXRlc1tuYW1lXVxuXHRcdH0pXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRQYXJlbnQobmFtZSkge1xuXHRcdHZhciBwYXJlbnROYW1lID0gZ2V0UGFyZW50TmFtZShuYW1lKVxuXG5cdFx0cmV0dXJuIHBhcmVudE5hbWUgJiYgc3RhdGVzW3BhcmVudE5hbWVdXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRQYXJlbnROYW1lKG5hbWUpIHtcblx0XHR2YXIgbmFtZXMgPSBzdGF0ZVN0cmluZ1BhcnNlcihuYW1lKVxuXG5cdFx0aWYgKG5hbWVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHZhciBzZWNvbmRUb0xhc3QgPSBuYW1lcy5sZW5ndGggLSAyXG5cblx0XHRcdHJldHVybiBuYW1lc1tzZWNvbmRUb0xhc3RdXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBudWxsXG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ3VhcmFudGVlQWxsU3RhdGVzRXhpc3QobmV3U3RhdGVOYW1lKSB7XG5cdFx0dmFyIHN0YXRlTmFtZXMgPSBwYXJzZShuZXdTdGF0ZU5hbWUpXG5cdFx0dmFyIHN0YXRlc1RoYXREb250RXhpc3QgPSBzdGF0ZU5hbWVzLmZpbHRlcihmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRyZXR1cm4gIXN0YXRlc1tuYW1lXVxuXHRcdH0pXG5cblx0XHRpZiAoc3RhdGVzVGhhdERvbnRFeGlzdC5sZW5ndGggPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1N0YXRlICcgKyBzdGF0ZXNUaGF0RG9udEV4aXN0W3N0YXRlc1RoYXREb250RXhpc3QubGVuZ3RoIC0gMV0gKyAnIGRvZXMgbm90IGV4aXN0Jylcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBidWlsZEZ1bGxTdGF0ZVJvdXRlKHN0YXRlTmFtZSkge1xuXHRcdHJldHVybiBnZXRIaWVyYXJjaHkoc3RhdGVOYW1lKS5tYXAoZnVuY3Rpb24oc3RhdGUpIHtcblx0XHRcdHJldHVybiAnLycgKyAoc3RhdGUucm91dGUgfHwgJycpXG5cdFx0fSkuam9pbignJykucmVwbGFjZSgvXFwvezIsfS9nLCAnLycpXG5cdH1cblxuXHRmdW5jdGlvbiBhcHBseURlZmF1bHRDaGlsZFN0YXRlcyhzdGF0ZU5hbWUpIHtcblx0XHR2YXIgc3RhdGUgPSBzdGF0ZXNbc3RhdGVOYW1lXVxuXG5cdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdENoaWxkU3RhdGVOYW1lKCkge1xuXHRcdFx0cmV0dXJuIHN0YXRlICYmICh0eXBlb2Ygc3RhdGUuZGVmYXVsdENoaWxkID09PSAnZnVuY3Rpb24nXG5cdFx0XHRcdD8gc3RhdGUuZGVmYXVsdENoaWxkKClcblx0XHRcdFx0OiBzdGF0ZS5kZWZhdWx0Q2hpbGQpXG5cdFx0fVxuXG5cdFx0dmFyIGRlZmF1bHRDaGlsZFN0YXRlTmFtZSA9IGdldERlZmF1bHRDaGlsZFN0YXRlTmFtZSgpXG5cblx0XHRpZiAoIWRlZmF1bHRDaGlsZFN0YXRlTmFtZSkge1xuXHRcdFx0cmV0dXJuIHN0YXRlTmFtZVxuXHRcdH1cblxuXHRcdHZhciBmdWxsU3RhdGVOYW1lID0gc3RhdGVOYW1lICsgJy4nICsgZGVmYXVsdENoaWxkU3RhdGVOYW1lXG5cblx0XHRyZXR1cm4gYXBwbHlEZWZhdWx0Q2hpbGRTdGF0ZXMoZnVsbFN0YXRlTmFtZSlcblx0fVxuXG5cblx0cmV0dXJuIHtcblx0XHRhZGQ6IGZ1bmN0aW9uKG5hbWUsIHN0YXRlKSB7XG5cdFx0XHRzdGF0ZXNbbmFtZV0gPSBzdGF0ZVxuXHRcdH0sXG5cdFx0Z2V0OiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRyZXR1cm4gbmFtZSAmJiBzdGF0ZXNbbmFtZV1cblx0XHR9LFxuXHRcdGdldEhpZXJhcmNoeTogZ2V0SGllcmFyY2h5LFxuXHRcdGdldFBhcmVudDogZ2V0UGFyZW50LFxuXHRcdGdldFBhcmVudE5hbWU6IGdldFBhcmVudE5hbWUsXG5cdFx0Z3VhcmFudGVlQWxsU3RhdGVzRXhpc3Q6IGd1YXJhbnRlZUFsbFN0YXRlc0V4aXN0LFxuXHRcdGJ1aWxkRnVsbFN0YXRlUm91dGU6IGJ1aWxkRnVsbFN0YXRlUm91dGUsXG5cdFx0YXBwbHlEZWZhdWx0Q2hpbGRTdGF0ZXM6IGFwcGx5RGVmYXVsdENoaWxkU3RhdGVzXG5cdH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3RhdGVTdHJpbmcpIHtcblx0cmV0dXJuIHN0YXRlU3RyaW5nLnNwbGl0KCcuJykucmVkdWNlKGZ1bmN0aW9uKHN0YXRlTmFtZXMsIGxhdGVzdE5hbWVDaHVuaykge1xuXHRcdGlmIChzdGF0ZU5hbWVzLmxlbmd0aCkge1xuXHRcdFx0bGF0ZXN0TmFtZUNodW5rID0gc3RhdGVOYW1lc1tzdGF0ZU5hbWVzLmxlbmd0aCAtIDFdICsgJy4nICsgbGF0ZXN0TmFtZUNodW5rXG5cdFx0fVxuXHRcdHN0YXRlTmFtZXMucHVzaChsYXRlc3ROYW1lQ2h1bmspXG5cdFx0cmV0dXJuIHN0YXRlTmFtZXNcblx0fSwgW10pXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbWl0dGVyKSB7XHJcblx0dmFyIGN1cnJlbnRUcmFuc2l0aW9uQXR0ZW1wdCA9IG51bGxcclxuXHR2YXIgbmV4dFRyYW5zaXRpb24gPSBudWxsXHJcblxyXG5cdGZ1bmN0aW9uIGRvbmVUcmFuc2l0aW9uaW5nKCkge1xyXG5cdFx0Y3VycmVudFRyYW5zaXRpb25BdHRlbXB0ID0gbnVsbFxyXG5cdFx0aWYgKG5leHRUcmFuc2l0aW9uKSB7XHJcblx0XHRcdGJlZ2luTmV4dFRyYW5zaXRpb25BdHRlbXB0KClcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGlzVHJhbnNpdGlvbmluZygpIHtcclxuXHRcdHJldHVybiAhIWN1cnJlbnRUcmFuc2l0aW9uQXR0ZW1wdFxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gYmVnaW5OZXh0VHJhbnNpdGlvbkF0dGVtcHQoKSB7XHJcblx0XHRjdXJyZW50VHJhbnNpdGlvbkF0dGVtcHQgPSBuZXh0VHJhbnNpdGlvblxyXG5cdFx0bmV4dFRyYW5zaXRpb24gPSBudWxsXHJcblx0XHRjdXJyZW50VHJhbnNpdGlvbkF0dGVtcHQuYmVnaW5TdGF0ZUNoYW5nZSgpXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBjYW5jZWxDdXJyZW50VHJhbnNpdGlvbigpIHtcclxuXHRcdGN1cnJlbnRUcmFuc2l0aW9uQXR0ZW1wdC50cmFuc2l0aW9uLmNhbmNlbGxlZCA9IHRydWVcclxuXHRcdHZhciBlcnIgPSBuZXcgRXJyb3IoJ1N0YXRlIHRyYW5zaXRpb24gY2FuY2VsbGVkIGJ5IHRoZSBzdGF0ZSB0cmFuc2l0aW9uIG1hbmFnZXInKVxyXG5cdFx0ZXJyLndhc0NhbmNlbGxlZEJ5U29tZW9uZUVsc2UgPSB0cnVlXHJcblx0XHRlbWl0dGVyLmVtaXQoJ3N0YXRlQ2hhbmdlQ2FuY2VsbGVkJywgZXJyKVxyXG5cdH1cclxuXHJcblx0ZW1pdHRlci5vbignc3RhdGVDaGFuZ2VBdHRlbXB0JywgZnVuY3Rpb24oYmVnaW5TdGF0ZUNoYW5nZSkge1xyXG5cdFx0bmV4dFRyYW5zaXRpb24gPSBjcmVhdGVTdGF0ZVRyYW5zaXRpb25BdHRlbXB0KGJlZ2luU3RhdGVDaGFuZ2UpXHJcblxyXG5cdFx0aWYgKGlzVHJhbnNpdGlvbmluZygpICYmIGN1cnJlbnRUcmFuc2l0aW9uQXR0ZW1wdC50cmFuc2l0aW9uLmNhbmNlbGxhYmxlKSB7XHJcblx0XHRcdGNhbmNlbEN1cnJlbnRUcmFuc2l0aW9uKClcclxuXHRcdH0gZWxzZSBpZiAoIWlzVHJhbnNpdGlvbmluZygpKSB7XHJcblx0XHRcdGJlZ2luTmV4dFRyYW5zaXRpb25BdHRlbXB0KClcclxuXHRcdH1cclxuXHR9KVxyXG5cclxuXHRlbWl0dGVyLm9uKCdzdGF0ZUNoYW5nZUVycm9yJywgZG9uZVRyYW5zaXRpb25pbmcpXHJcblx0ZW1pdHRlci5vbignc3RhdGVDaGFuZ2VDYW5jZWxsZWQnLCBkb25lVHJhbnNpdGlvbmluZylcclxuXHRlbWl0dGVyLm9uKCdzdGF0ZUNoYW5nZUVuZCcsIGRvbmVUcmFuc2l0aW9uaW5nKVxyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGVTdGF0ZVRyYW5zaXRpb25BdHRlbXB0KGJlZ2luU3RhdGVDaGFuZ2UpIHtcclxuXHRcdHZhciB0cmFuc2l0aW9uID0ge1xyXG5cdFx0XHRjYW5jZWxsZWQ6IGZhbHNlLFxyXG5cdFx0XHRjYW5jZWxsYWJsZTogdHJ1ZVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dHJhbnNpdGlvbjogdHJhbnNpdGlvbixcclxuXHRcdFx0YmVnaW5TdGF0ZUNoYW5nZTogYmVnaW5TdGF0ZUNoYW5nZS5iaW5kKG51bGwsIHRyYW5zaXRpb24pXHJcblx0XHR9XHJcblx0fVxyXG59XHJcbiIsIi8vIEFycmF5LnByb3RvdHlwZS5maW5kIC0gTUlUIExpY2Vuc2UgKGMpIDIwMTMgUGF1bCBNaWxsZXIgPGh0dHA6Ly9wYXVsbWlsbHIuY29tPlxuLy8gRm9yIGFsbCBkZXRhaWxzIGFuZCBkb2NzOiBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL2FycmF5LnByb3RvdHlwZS5maW5kXG4vLyBGaXhlcyBhbmQgdGVzdHMgc3VwcGxpZWQgYnkgRHVuY2FuIEhhbGwgPGh0dHA6Ly9kdW5jYW5oYWxsLm5ldD4gXG4oZnVuY3Rpb24oZ2xvYmFscyl7XG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmluZCkgcmV0dXJuO1xuXG4gIHZhciBmaW5kID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgdmFyIGxpc3QgPSBPYmplY3QodGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoIDwgMCA/IDAgOiBsaXN0Lmxlbmd0aCA+Pj4gMDsgLy8gRVMuVG9VaW50MzI7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Z1bmN0aW9uJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJlZGljYXRlKSAhPT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkjZmluZDogcHJlZGljYXRlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1sxXTtcbiAgICBmb3IgKHZhciBpID0gMCwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWUgPSBsaXN0W2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpLCBsaXN0KSkgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5LnByb3RvdHlwZSwgJ2ZpbmQnLCB7XG4gICAgICAgIHZhbHVlOiBmaW5kLCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBjYXRjaChlKSB7fVxuICB9XG5cbiAgaWYgKCFBcnJheS5wcm90b3R5cGUuZmluZCkge1xuICAgIEFycmF5LnByb3RvdHlwZS5maW5kID0gZmluZDtcbiAgfVxufSkodGhpcyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaikge1xuXHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iailcblxuXHRrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KG9ialtrZXldKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGtleSArICcgaXMgbm90IGFuIGFycmF5Jylcblx0XHR9XG5cdH0pXG5cblx0dmFyIG1heEluZGV4ID0ga2V5cy5yZWR1Y2UoZnVuY3Rpb24obWF4U29GYXIsIGtleSkge1xuXHRcdHZhciBsZW4gPSBvYmpba2V5XS5sZW5ndGhcblx0XHRyZXR1cm4gbWF4U29GYXIgPiBsZW4gPyBtYXhTb0ZhciA6IGxlblxuXHR9LCAwKVxuXG5cdHZhciBvdXRwdXQgPSBbXVxuXG5cdGZ1bmN0aW9uIGdldE9iamVjdChpbmRleCkge1xuXHRcdHZhciBvID0ge31cblx0XHRrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRvW2tleV0gPSBvYmpba2V5XVtpbmRleF1cblx0XHR9KVxuXHRcdHJldHVybiBvXG5cdH1cblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG1heEluZGV4OyArK2kpIHtcblx0XHRvdXRwdXQucHVzaChnZXRPYmplY3QoaSkpXG5cdH1cblxuXHRyZXR1cm4gb3V0cHV0XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCJ2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gSGFzaExvY2F0aW9uKHdpbmRvdykge1xuXHR2YXIgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKVxuXHR2YXIgbGFzdCA9ICcnXG5cdHZhciBuZWVkVG9EZWNvZGUgPSBnZXROZWVkVG9EZWNvZGUoKVxuXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgZnVuY3Rpb24oKSB7XG5cdFx0aWYgKGxhc3QgIT09IGVtaXR0ZXIuZ2V0KCkpIHtcblx0XHRcdGxhc3QgPSBlbWl0dGVyLmdldCgpXG5cdFx0XHRlbWl0dGVyLmVtaXQoJ2hhc2hjaGFuZ2UnKVxuXHRcdH1cblx0fSlcblxuXHRlbWl0dGVyLmdvID0gZ28uYmluZChudWxsLCB3aW5kb3cpXG5cdGVtaXR0ZXIucmVwbGFjZSA9IHJlcGxhY2UuYmluZChudWxsLCB3aW5kb3cpXG5cdGVtaXR0ZXIuZ2V0ID0gZ2V0LmJpbmQobnVsbCwgd2luZG93LCBuZWVkVG9EZWNvZGUpXG5cblx0cmV0dXJuIGVtaXR0ZXJcbn1cblxuZnVuY3Rpb24gcmVwbGFjZSh3aW5kb3csIG5ld1BhdGgpIHtcblx0d2luZG93LmxvY2F0aW9uLnJlcGxhY2UoZXZlcnl0aGluZ0JlZm9yZVRoZVNsYXNoKHdpbmRvdy5sb2NhdGlvbi5ocmVmKSArICcjJyArIG5ld1BhdGgpXG59XG5cbmZ1bmN0aW9uIGV2ZXJ5dGhpbmdCZWZvcmVUaGVTbGFzaCh1cmwpIHtcblx0dmFyIGhhc2hJbmRleCA9IHVybC5pbmRleE9mKCcjJylcblx0cmV0dXJuIGhhc2hJbmRleCA9PT0gLTEgPyB1cmwgOiB1cmwuc3Vic3RyaW5nKDAsIGhhc2hJbmRleClcbn1cblxuZnVuY3Rpb24gZ28od2luZG93LCBuZXdQYXRoKSB7XG5cdHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gbmV3UGF0aFxufVxuXG5mdW5jdGlvbiBnZXQod2luZG93LCBuZWVkVG9EZWNvZGUpIHtcblx0dmFyIGhhc2ggPSByZW1vdmVIYXNoRnJvbVBhdGgod2luZG93LmxvY2F0aW9uLmhhc2gpXG5cdHJldHVybiBuZWVkVG9EZWNvZGUgPyBkZWNvZGVVUkkoaGFzaCkgOiBoYXNoXG59XG5cbmZ1bmN0aW9uIHJlbW92ZUhhc2hGcm9tUGF0aChwYXRoKSB7XG5cdHJldHVybiAocGF0aCAmJiBwYXRoWzBdID09PSAnIycpID8gcGF0aC5zdWJzdHIoMSkgOiBwYXRoXG59XG5cbmZ1bmN0aW9uIGdldE5lZWRUb0RlY29kZSgpIHtcblx0dmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcblx0YS5ocmVmID0gJyN4IHgnXG5cdHJldHVybiAhL3ggeC8udGVzdChhLmhhc2gpXG59XG4iLCJ2YXIgcGF0aFRvUmVnZXhwID0gcmVxdWlyZSgncGF0aC10by1yZWdleHAtd2l0aC1yZXZlcnNpYmxlLWtleXMnKVxudmFyIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKVxudmFyIHh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIGJyb3dzZXJIYXNoTG9jYXRpb24gPSByZXF1aXJlKCcuL2hhc2gtbG9jYXRpb24uanMnKVxucmVxdWlyZSgnYXJyYXkucHJvdG90eXBlLmZpbmQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFJvdXRlcihvcHRzLCBoYXNoTG9jYXRpb24pIHtcblx0aWYgKGlzSGFzaExvY2F0aW9uKG9wdHMpKSB7XG5cdFx0aGFzaExvY2F0aW9uID0gb3B0c1xuXHRcdG9wdHMgPSBudWxsXG5cdH1cblxuXHRvcHRzID0gb3B0cyB8fCB7fVxuXG5cdGlmICghaGFzaExvY2F0aW9uKSB7XG5cdFx0aGFzaExvY2F0aW9uID0gYnJvd3Nlckhhc2hMb2NhdGlvbih3aW5kb3cpXG5cdH1cblxuXHR2YXIgcm91dGVzID0gW11cblxuXHR2YXIgb25IYXNoQ2hhbmdlID0gZXZhbHVhdGVDdXJyZW50UGF0aC5iaW5kKG51bGwsIHJvdXRlcywgaGFzaExvY2F0aW9uLCAhIW9wdHMucmV2ZXJzZSlcblxuXHRoYXNoTG9jYXRpb24ub24oJ2hhc2hjaGFuZ2UnLCBvbkhhc2hDaGFuZ2UpXG5cblx0ZnVuY3Rpb24gc3RvcCgpIHtcblx0XHRoYXNoTG9jYXRpb24ucmVtb3ZlTGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCBvbkhhc2hDaGFuZ2UpXG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGFkZDogYWRkLmJpbmQobnVsbCwgcm91dGVzKSxcblx0XHRzdG9wOiBzdG9wLFxuXHRcdGV2YWx1YXRlQ3VycmVudDogZXZhbHVhdGVDdXJyZW50UGF0aE9yR29Ub0RlZmF1bHQuYmluZChudWxsLCByb3V0ZXMsIGhhc2hMb2NhdGlvbiwgISFvcHRzLnJldmVyc2UpLFxuXHRcdHNldERlZmF1bHQ6IHNldERlZmF1bHQuYmluZChudWxsLCByb3V0ZXMpLFxuXHRcdHJlcGxhY2U6IGhhc2hMb2NhdGlvbi5yZXBsYWNlLFxuXHRcdGdvOiBoYXNoTG9jYXRpb24uZ28sXG5cdFx0bG9jYXRpb246IGhhc2hMb2NhdGlvblxuXHR9XG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRlQ3VycmVudFBhdGgocm91dGVzLCBoYXNoTG9jYXRpb24sIHJldmVyc2UpIHtcblx0ZXZhbHVhdGVQYXRoKHJvdXRlcywgaGFzaExvY2F0aW9uLmdldCgpLCByZXZlcnNlKVxufVxuXG5mdW5jdGlvbiBnZXRQYXRoUGFydHMocGF0aCkge1xuXHR2YXIgY2h1bmtzID0gcGF0aC5zcGxpdCgnPycpXG5cdHJldHVybiB7XG5cdFx0cGF0aDogY2h1bmtzLnNoaWZ0KCksXG5cdFx0cXVlcnlTdHJpbmc6IHFzLnBhcnNlKGNodW5rcy5qb2luKCcnKSlcblx0fVxufVxuXG5mdW5jdGlvbiBldmFsdWF0ZVBhdGgocm91dGVzLCBwYXRoLCByZXZlcnNlKSB7XG5cdHZhciBwYXRoUGFydHMgPSBnZXRQYXRoUGFydHMocGF0aClcblx0cGF0aCA9IHBhdGhQYXJ0cy5wYXRoXG5cdHZhciBxdWVyeVN0cmluZ1BhcmFtZXRlcnMgPSBwYXRoUGFydHMucXVlcnlTdHJpbmdcblxuXHR2YXIgbWF0Y2hpbmdSb3V0ZSA9IChyZXZlcnNlID8gcmV2ZXJzZUFycmF5KHJvdXRlcykgOiByb3V0ZXMpLmZpbmQoXCJcIi5tYXRjaCwgcGF0aClcblxuXHRpZiAobWF0Y2hpbmdSb3V0ZSkge1xuXHRcdHZhciByZWdleFJlc3VsdCA9IG1hdGNoaW5nUm91dGUuZXhlYyhwYXRoKVxuXHRcdHZhciByb3V0ZVBhcmFtZXRlcnMgPSBtYWtlUGFyYW1ldGVyc09iamVjdEZyb21SZWdleFJlc3VsdChtYXRjaGluZ1JvdXRlLmtleXMsIHJlZ2V4UmVzdWx0KVxuXHRcdHZhciBwYXJhbXMgPSB4dGVuZChxdWVyeVN0cmluZ1BhcmFtZXRlcnMsIHJvdXRlUGFyYW1ldGVycylcblx0XHRtYXRjaGluZ1JvdXRlLmZuKHBhcmFtcylcblx0fSBlbHNlIGlmIChyb3V0ZXMuZGVmYXVsdEZuKSB7XG5cdFx0cm91dGVzLmRlZmF1bHRGbihwYXRoLCBxdWVyeVN0cmluZ1BhcmFtZXRlcnMpXG5cdH1cbn1cblxuZnVuY3Rpb24gcmV2ZXJzZUFycmF5KGFyeSkge1xuXHRyZXR1cm4gYXJ5LnNsaWNlKCkucmV2ZXJzZSgpXG59XG5cbmZ1bmN0aW9uIG1ha2VQYXJhbWV0ZXJzT2JqZWN0RnJvbVJlZ2V4UmVzdWx0KGtleXMsIHJlZ2V4UmVzdWx0KSB7XG5cdHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbihtZW1vLCB1cmxLZXksIGluZGV4KSB7XG5cdFx0bWVtb1t1cmxLZXkubmFtZV0gPSByZWdleFJlc3VsdFtpbmRleCArIDFdXG5cdFx0cmV0dXJuIG1lbW9cblx0fSwge30pXG59XG5cbmZ1bmN0aW9uIGFkZChyb3V0ZXMsIHJvdXRlU3RyaW5nLCByb3V0ZUZ1bmN0aW9uKSB7XG5cdGlmICh0eXBlb2Ygcm91dGVGdW5jdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyBFcnJvcignVGhlIHJvdXRlciBhZGQgZnVuY3Rpb24gbXVzdCBiZSBwYXNzZWQgYSBjYWxsYmFjayBmdW5jdGlvbicpXG5cdH1cblx0dmFyIG5ld1JvdXRlID0gcGF0aFRvUmVnZXhwKHJvdXRlU3RyaW5nKVxuXHRuZXdSb3V0ZS5mbiA9IHJvdXRlRnVuY3Rpb25cblx0cm91dGVzLnB1c2gobmV3Um91dGUpXG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRlQ3VycmVudFBhdGhPckdvVG9EZWZhdWx0KHJvdXRlcywgaGFzaExvY2F0aW9uLCByZXZlcnNlLCBkZWZhdWx0UGF0aCkge1xuXHRpZiAoaGFzaExvY2F0aW9uLmdldCgpKSB7XG5cdFx0dmFyIHJvdXRlc0NvcHkgPSByb3V0ZXMuc2xpY2UoKVxuXHRcdHJvdXRlc0NvcHkuZGVmYXVsdEZuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRoYXNoTG9jYXRpb24uZ28oZGVmYXVsdFBhdGgpXG5cdFx0fVxuXHRcdGV2YWx1YXRlQ3VycmVudFBhdGgocm91dGVzQ29weSwgaGFzaExvY2F0aW9uLCByZXZlcnNlKVxuXHR9IGVsc2Uge1xuXHRcdGhhc2hMb2NhdGlvbi5nbyhkZWZhdWx0UGF0aClcblx0fVxufVxuXG5mdW5jdGlvbiBzZXREZWZhdWx0KHJvdXRlcywgZGVmYXVsdEZuKSB7XG5cdHJvdXRlcy5kZWZhdWx0Rm4gPSBkZWZhdWx0Rm5cbn1cblxuZnVuY3Rpb24gaXNIYXNoTG9jYXRpb24oaGFzaExvY2F0aW9uKSB7XG5cdHJldHVybiBoYXNoTG9jYXRpb24gJiYgaGFzaExvY2F0aW9uLmdvICYmIGhhc2hMb2NhdGlvbi5yZXBsYWNlICYmIGhhc2hMb2NhdGlvbi5vblxufSIsIi8qISBOYXRpdmUgUHJvbWlzZSBPbmx5XG4gICAgdjAuOC4xIChjKSBLeWxlIFNpbXBzb25cbiAgICBNSVQgTGljZW5zZTogaHR0cDovL2dldGlmeS5taXQtbGljZW5zZS5vcmdcbiovXG4hZnVuY3Rpb24odCxuLGUpe25bdF09blt0XXx8ZSgpLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPW5bdF06XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kJiZkZWZpbmUoZnVuY3Rpb24oKXtyZXR1cm4gblt0XX0pfShcIlByb21pc2VcIixcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDp0aGlzLGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gdCh0LG4pe2wuYWRkKHQsbiksaHx8KGg9eShsLmRyYWluKSl9ZnVuY3Rpb24gbih0KXt2YXIgbixlPXR5cGVvZiB0O3JldHVybiBudWxsPT10fHxcIm9iamVjdFwiIT1lJiZcImZ1bmN0aW9uXCIhPWV8fChuPXQudGhlbiksXCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uOiExfWZ1bmN0aW9uIGUoKXtmb3IodmFyIHQ9MDt0PHRoaXMuY2hhaW4ubGVuZ3RoO3QrKylvKHRoaXMsMT09PXRoaXMuc3RhdGU/dGhpcy5jaGFpblt0XS5zdWNjZXNzOnRoaXMuY2hhaW5bdF0uZmFpbHVyZSx0aGlzLmNoYWluW3RdKTt0aGlzLmNoYWluLmxlbmd0aD0wfWZ1bmN0aW9uIG8odCxlLG8pe3ZhciByLGk7dHJ5e2U9PT0hMT9vLnJlamVjdCh0Lm1zZyk6KHI9ZT09PSEwP3QubXNnOmUuY2FsbCh2b2lkIDAsdC5tc2cpLHI9PT1vLnByb21pc2U/by5yZWplY3QoVHlwZUVycm9yKFwiUHJvbWlzZS1jaGFpbiBjeWNsZVwiKSk6KGk9bihyKSk/aS5jYWxsKHIsby5yZXNvbHZlLG8ucmVqZWN0KTpvLnJlc29sdmUocikpfWNhdGNoKGMpe28ucmVqZWN0KGMpfX1mdW5jdGlvbiByKG8pe3ZhciBjLHU9dGhpcztpZighdS50cmlnZ2VyZWQpe3UudHJpZ2dlcmVkPSEwLHUuZGVmJiYodT11LmRlZik7dHJ5eyhjPW4obykpP3QoZnVuY3Rpb24oKXt2YXIgdD1uZXcgZih1KTt0cnl7Yy5jYWxsKG8sZnVuY3Rpb24oKXtyLmFwcGx5KHQsYXJndW1lbnRzKX0sZnVuY3Rpb24oKXtpLmFwcGx5KHQsYXJndW1lbnRzKX0pfWNhdGNoKG4pe2kuY2FsbCh0LG4pfX0pOih1Lm1zZz1vLHUuc3RhdGU9MSx1LmNoYWluLmxlbmd0aD4wJiZ0KGUsdSkpfWNhdGNoKGEpe2kuY2FsbChuZXcgZih1KSxhKX19fWZ1bmN0aW9uIGkobil7dmFyIG89dGhpcztvLnRyaWdnZXJlZHx8KG8udHJpZ2dlcmVkPSEwLG8uZGVmJiYobz1vLmRlZiksby5tc2c9bixvLnN0YXRlPTIsby5jaGFpbi5sZW5ndGg+MCYmdChlLG8pKX1mdW5jdGlvbiBjKHQsbixlLG8pe2Zvcih2YXIgcj0wO3I8bi5sZW5ndGg7cisrKSFmdW5jdGlvbihyKXt0LnJlc29sdmUobltyXSkudGhlbihmdW5jdGlvbih0KXtlKHIsdCl9LG8pfShyKX1mdW5jdGlvbiBmKHQpe3RoaXMuZGVmPXQsdGhpcy50cmlnZ2VyZWQ9ITF9ZnVuY3Rpb24gdSh0KXt0aGlzLnByb21pc2U9dCx0aGlzLnN0YXRlPTAsdGhpcy50cmlnZ2VyZWQ9ITEsdGhpcy5jaGFpbj1bXSx0aGlzLm1zZz12b2lkIDB9ZnVuY3Rpb24gYShuKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBuKXRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO2lmKDAhPT10aGlzLl9fTlBPX18pdGhyb3cgVHlwZUVycm9yKFwiTm90IGEgcHJvbWlzZVwiKTt0aGlzLl9fTlBPX189MTt2YXIgbz1uZXcgdSh0aGlzKTt0aGlzLnRoZW49ZnVuY3Rpb24obixyKXt2YXIgaT17c3VjY2VzczpcImZ1bmN0aW9uXCI9PXR5cGVvZiBuP246ITAsZmFpbHVyZTpcImZ1bmN0aW9uXCI9PXR5cGVvZiByP3I6ITF9O3JldHVybiBpLnByb21pc2U9bmV3IHRoaXMuY29uc3RydWN0b3IoZnVuY3Rpb24odCxuKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0fHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBuKXRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO2kucmVzb2x2ZT10LGkucmVqZWN0PW59KSxvLmNoYWluLnB1c2goaSksMCE9PW8uc3RhdGUmJnQoZSxvKSxpLnByb21pc2V9LHRoaXNbXCJjYXRjaFwiXT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aGVuKHZvaWQgMCx0KX07dHJ5e24uY2FsbCh2b2lkIDAsZnVuY3Rpb24odCl7ci5jYWxsKG8sdCl9LGZ1bmN0aW9uKHQpe2kuY2FsbChvLHQpfSl9Y2F0Y2goYyl7aS5jYWxsKG8sYyl9fXZhciBzLGgsbCxwPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcseT1cInVuZGVmaW5lZFwiIT10eXBlb2Ygc2V0SW1tZWRpYXRlP2Z1bmN0aW9uKHQpe3JldHVybiBzZXRJbW1lZGlhdGUodCl9OnNldFRpbWVvdXQ7dHJ5e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSxcInhcIix7fSkscz1mdW5jdGlvbih0LG4sZSxvKXtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbix7dmFsdWU6ZSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6byE9PSExfSl9fWNhdGNoKGQpe3M9ZnVuY3Rpb24odCxuLGUpe3JldHVybiB0W25dPWUsdH19bD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxuKXt0aGlzLmZuPXQsdGhpcy5zZWxmPW4sdGhpcy5uZXh0PXZvaWQgMH12YXIgbixlLG87cmV0dXJue2FkZDpmdW5jdGlvbihyLGkpe289bmV3IHQocixpKSxlP2UubmV4dD1vOm49byxlPW8sbz12b2lkIDB9LGRyYWluOmZ1bmN0aW9uKCl7dmFyIHQ9bjtmb3Iobj1lPWg9dm9pZCAwO3Q7KXQuZm4uY2FsbCh0LnNlbGYpLHQ9dC5uZXh0fX19KCk7dmFyIGc9cyh7fSxcImNvbnN0cnVjdG9yXCIsYSwhMSk7cmV0dXJuIGEucHJvdG90eXBlPWcscyhnLFwiX19OUE9fX1wiLDAsITEpLHMoYSxcInJlc29sdmVcIixmdW5jdGlvbih0KXt2YXIgbj10aGlzO3JldHVybiB0JiZcIm9iamVjdFwiPT10eXBlb2YgdCYmMT09PXQuX19OUE9fXz90Om5ldyBuKGZ1bmN0aW9uKG4sZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2Ygbnx8XCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBmdW5jdGlvblwiKTtuKHQpfSl9KSxzKGEsXCJyZWplY3RcIixmdW5jdGlvbih0KXtyZXR1cm4gbmV3IHRoaXMoZnVuY3Rpb24obixlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBufHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO2UodCl9KX0pLHMoYSxcImFsbFwiLGZ1bmN0aW9uKHQpe3ZhciBuPXRoaXM7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiIT1wLmNhbGwodCk/bi5yZWplY3QoVHlwZUVycm9yKFwiTm90IGFuIGFycmF5XCIpKTowPT09dC5sZW5ndGg/bi5yZXNvbHZlKFtdKTpuZXcgbihmdW5jdGlvbihlLG8pe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGV8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIG8pdGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7dmFyIHI9dC5sZW5ndGgsaT1BcnJheShyKSxmPTA7YyhuLHQsZnVuY3Rpb24odCxuKXtpW3RdPW4sKytmPT09ciYmZShpKX0sbyl9KX0pLHMoYSxcInJhY2VcIixmdW5jdGlvbih0KXt2YXIgbj10aGlzO3JldHVyblwiW29iamVjdCBBcnJheV1cIiE9cC5jYWxsKHQpP24ucmVqZWN0KFR5cGVFcnJvcihcIk5vdCBhbiBhcnJheVwiKSk6bmV3IG4oZnVuY3Rpb24oZSxvKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBvKXRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO2Mobix0LGZ1bmN0aW9uKHQsbil7ZShuKX0sbyl9KX0pLGF9KTtcbiIsInZhciBwYXJzZXIgPSByZXF1aXJlKCcuL3BhdGgtcGFyc2VyJylcbnZhciBzdHJpbmdpZnlRdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJykuc3RyaW5naWZ5XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocGF0aFN0ciwgcGFyYW1ldGVycykge1xuXG5cdHZhciBwYXJzZWQgPSB0eXBlb2YgcGF0aFN0ciA9PT0gJ3N0cmluZycgPyBwYXJzZXIocGF0aFN0cikgOiBwYXRoU3RyXG5cdHZhciBhbGxUb2tlbnMgPSBwYXJzZWQuYWxsVG9rZW5zXG5cdHZhciByZWdleCA9IHBhcnNlZC5yZWdleFxuXG5cdGlmIChwYXJhbWV0ZXJzKSB7XG5cdFx0dmFyIHBhdGggPSBhbGxUb2tlbnMubWFwKGZ1bmN0aW9uKGJpdCkge1xuXHRcdFx0aWYgKGJpdC5zdHJpbmcpIHtcblx0XHRcdFx0cmV0dXJuIGJpdC5zdHJpbmdcblx0XHRcdH1cblxuXHRcdFx0dmFyIGRlZmluZWQgPSB0eXBlb2YgcGFyYW1ldGVyc1tiaXQubmFtZV0gIT09ICd1bmRlZmluZWQnXG5cdFx0XHRpZiAoIWJpdC5vcHRpb25hbCAmJiAhZGVmaW5lZCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3VwcGx5IGFyZ3VtZW50ICcgKyBiaXQubmFtZSArICcgZm9yIHBhdGggJyArIHBhdGhTdHIpXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkZWZpbmVkID8gKGJpdC5kZWxpbWl0ZXIgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1ldGVyc1tiaXQubmFtZV0pKSA6ICcnXG5cdFx0fSkuam9pbignJylcblxuXHRcdGlmICghcmVnZXgudGVzdChwYXRoKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCBhcmd1bWVudHMgZG8gbm90IG1hdGNoIHRoZSBvcmlnaW5hbCBhcmd1bWVudHMnKVxuXHRcdH1cblxuXHRcdHJldHVybiBidWlsZFBhdGhXaXRoUXVlcnlzdHJpbmcocGF0aCwgcGFyYW1ldGVycywgYWxsVG9rZW5zKVxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBwYXJzZWRcblx0fVxufVxuXG5mdW5jdGlvbiBidWlsZFBhdGhXaXRoUXVlcnlzdHJpbmcocGF0aCwgcGFyYW1ldGVycywgdG9rZW5BcnJheSkge1xuXHR2YXIgcGFyYW1ldGVyc0luUXVlcnlzdHJpbmcgPSBnZXRQYXJhbWV0ZXJzV2l0aG91dE1hdGNoaW5nVG9rZW4ocGFyYW1ldGVycywgdG9rZW5BcnJheSlcblxuXHRpZiAoT2JqZWN0LmtleXMocGFyYW1ldGVyc0luUXVlcnlzdHJpbmcpLmxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybiBwYXRoXG5cdH1cblxuXHRyZXR1cm4gcGF0aCArICc/JyArIHN0cmluZ2lmeVF1ZXJ5c3RyaW5nKHBhcmFtZXRlcnNJblF1ZXJ5c3RyaW5nKVxufVxuXG5mdW5jdGlvbiBnZXRQYXJhbWV0ZXJzV2l0aG91dE1hdGNoaW5nVG9rZW4ocGFyYW1ldGVycywgdG9rZW5BcnJheSkge1xuXHR2YXIgdG9rZW5IYXNoID0gdG9rZW5BcnJheS5yZWR1Y2UoZnVuY3Rpb24obWVtbywgYml0KSB7XG5cdFx0aWYgKCFiaXQuc3RyaW5nKSB7XG5cdFx0XHRtZW1vW2JpdC5uYW1lXSA9IGJpdFxuXHRcdH1cblx0XHRyZXR1cm4gbWVtb1xuXHR9LCB7fSlcblxuXHRyZXR1cm4gT2JqZWN0LmtleXMocGFyYW1ldGVycykuZmlsdGVyKGZ1bmN0aW9uKHBhcmFtKSB7XG5cdFx0cmV0dXJuICF0b2tlbkhhc2hbcGFyYW1dXG5cdH0pLnJlZHVjZShmdW5jdGlvbihuZXdQYXJhbWV0ZXJzLCBwYXJhbSkge1xuXHRcdG5ld1BhcmFtZXRlcnNbcGFyYW1dID0gcGFyYW1ldGVyc1twYXJhbV1cblx0XHRyZXR1cm4gbmV3UGFyYW1ldGVyc1xuXHR9LCB7fSlcbn1cbiIsIi8vIFRoaXMgZmlsZSB0byBiZSByZXBsYWNlZCB3aXRoIGFuIG9mZmljaWFsIGltcGxlbWVudGF0aW9uIG1haW50YWluZWQgYnlcbi8vIHRoZSBwYWdlLmpzIGNyZXcgaWYgYW5kIHdoZW4gdGhhdCBiZWNvbWVzIGFuIG9wdGlvblxuXG52YXIgcGF0aFRvUmVnZXhwID0gcmVxdWlyZSgncGF0aC10by1yZWdleHAtd2l0aC1yZXZlcnNpYmxlLWtleXMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHBhdGhTdHJpbmcpIHtcblx0dmFyIHBhcnNlUmVzdWx0cyA9IHBhdGhUb1JlZ2V4cChwYXRoU3RyaW5nKVxuXG5cdC8vIFRoZSBvbmx5IHJlYXNvbiBJJ20gcmV0dXJuaW5nIGEgbmV3IG9iamVjdCBpbnN0ZWFkIG9mIHRoZSByZXN1bHRzIG9mIHRoZSBwYXRoVG9SZWdleHBcblx0Ly8gZnVuY3Rpb24gaXMgc28gdGhhdCBpZiB0aGUgb2ZmaWNpYWwgaW1wbGVtZW50YXRpb24gZW5kcyB1cCByZXR1cm5pbmcgYW5cblx0Ly8gYWxsVG9rZW5zLXN0eWxlIGFycmF5IHZpYSBzb21lIG90aGVyIG1lY2hhbmlzbSwgSSBtYXkgYmUgYWJsZSB0byBjaGFuZ2UgdGhpcyBmaWxlXG5cdC8vIHdpdGhvdXQgaGF2aW5nIHRvIGNoYW5nZSB0aGUgcmVzdCBvZiB0aGUgbW9kdWxlIGluIGluZGV4LmpzXG5cdHJldHVybiB7XG5cdFx0cmVnZXg6IHBhcnNlUmVzdWx0cyxcblx0XHRhbGxUb2tlbnM6IHBhcnNlUmVzdWx0cy5hbGxUb2tlbnNcblx0fVxufVxuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG5cbi8qKlxuICogRXhwb3NlIGBwYXRoVG9SZWdleHBgLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGhUb1JlZ2V4cDtcblxuLyoqXG4gKiBUaGUgbWFpbiBwYXRoIG1hdGNoaW5nIHJlZ2V4cCB1dGlsaXR5LlxuICpcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbnZhciBQQVRIX1JFR0VYUCA9IG5ldyBSZWdFeHAoW1xuICAvLyBNYXRjaCBlc2NhcGVkIGNoYXJhY3RlcnMgdGhhdCB3b3VsZCBvdGhlcndpc2UgYXBwZWFyIGluIGZ1dHVyZSBtYXRjaGVzLlxuICAvLyBUaGlzIGFsbG93cyB0aGUgdXNlciB0byBlc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXQgd29uJ3QgdHJhbnNmb3JtLlxuICAnKFxcXFxcXFxcLiknLFxuICAvLyBNYXRjaCBFeHByZXNzLXN0eWxlIHBhcmFtZXRlcnMgYW5kIHVuLW5hbWVkIHBhcmFtZXRlcnMgd2l0aCBhIHByZWZpeFxuICAvLyBhbmQgb3B0aW9uYWwgc3VmZml4ZXMuIE1hdGNoZXMgYXBwZWFyIGFzOlxuICAvL1xuICAvLyBcIi86dGVzdChcXFxcZCspP1wiID0+IFtcIi9cIiwgXCJ0ZXN0XCIsIFwiXFxkK1wiLCB1bmRlZmluZWQsIFwiP1wiXVxuICAvLyBcIi9yb3V0ZShcXFxcZCspXCIgPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiXFxkK1wiLCB1bmRlZmluZWRdXG4gICcoW1xcXFwvLl0pPyg/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W14pXSkqKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteKV0pKilcXFxcKSkoWysqP10pPycsXG4gIC8vIE1hdGNoIHJlZ2V4cCBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCBhcmUgYWx3YXlzIGVzY2FwZWQuXG4gICcoWy4rKj89XiE6JHt9KClbXFxcXF18XFxcXC9dKSdcbl0uam9pbignfCcpLCAnZycpO1xuXG4vKipcbiAqIEVzY2FwZSB0aGUgY2FwdHVyaW5nIGdyb3VwIGJ5IGVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGdyb3VwXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUdyb3VwIChncm91cCkge1xuICByZXR1cm4gZ3JvdXAucmVwbGFjZSgvKFs9ITokXFwvKCldKS9nLCAnXFxcXCQxJyk7XG59XG5cbi8qKlxuICogQXR0YWNoIHRoZSBrZXlzIGFzIGEgcHJvcGVydHkgb2YgdGhlIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHtSZWdFeHB9IHJlXG4gKiBAcGFyYW0gIHtBcnJheX0gIGtleXNcbiAqIEByZXR1cm4ge1JlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXR0YWNoS2V5cyAocmUsIGtleXMsIGFsbFRva2Vucykge1xuICByZS5rZXlzID0ga2V5cztcbiAgcmUuYWxsVG9rZW5zID0gYWxsVG9rZW5zO1xuICByZXR1cm4gcmU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZmxhZ3MgKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuc2Vuc2l0aXZlID8gJycgOiAnaSc7XG59XG5cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAge1JlZ0V4cH0gcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzLCBhbGxUb2tlbnMpIHtcbiAgLy8gVXNlIGEgbmVnYXRpdmUgbG9va2FoZWFkIHRvIG1hdGNoIG9ubHkgY2FwdHVyaW5nIGdyb3Vwcy5cbiAgdmFyIGdyb3VwcyA9IHBhdGguc291cmNlLm1hdGNoKC9cXCgoPyFcXD8pL2cpO1xuXG4gIGlmIChncm91cHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgbmFtZTogICAgICBpLFxuICAgICAgICBkZWxpbWl0ZXI6IG51bGwsXG4gICAgICAgIG9wdGlvbmFsOiAgZmFsc2UsXG4gICAgICAgIHJlcGVhdDogICAgZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKHBhdGgsIGtleXMsIGFsbFRva2Vucyk7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9ICBwYXRoXG4gKiBAcGFyYW0gIHtBcnJheX0gIGtleXNcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7UmVnRXhwfVxuICovXG5mdW5jdGlvbiBhcnJheVRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zLCBhbGxUb2tlbnMpIHtcbiAgdmFyIHBhcnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydHMucHVzaChwYXRoVG9SZWdleHAocGF0aFtpXSwga2V5cywgb3B0aW9ucywgYWxsVG9rZW5zKS5zb3VyY2UpO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJyg/OicgKyBwYXJ0cy5qb2luKCd8JykgKyAnKScsIGZsYWdzKG9wdGlvbnMpKTtcbiAgcmV0dXJuIGF0dGFjaEtleXMocmVnZXhwLCBrZXlzLCBhbGxUb2tlbnMpO1xufVxuXG4vKipcbiAqIFJlcGxhY2UgdGhlIHNwZWNpZmljIHRhZ3Mgd2l0aCByZWdleHAgc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAga2V5c1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiByZXBsYWNlUGF0aCAocGF0aCwga2V5cywgYWxsVG9rZW5zKSB7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0RW5kSW5kZXggPSAwXG5cbiAgZnVuY3Rpb24gYWRkTGFzdFRva2VuKGxhc3RUb2tlbikge1xuICAgIGlmIChsYXN0RW5kSW5kZXggPT09IDAgJiYgbGFzdFRva2VuWzBdICE9PSAnLycpIHtcbiAgICAgIGxhc3RUb2tlbiA9ICcvJyArIGxhc3RUb2tlblxuICAgIH1cbiAgICBhbGxUb2tlbnMucHVzaCh7XG4gICAgICBzdHJpbmc6IGxhc3RUb2tlblxuICAgIH0pO1xuICB9XG5cblxuICBmdW5jdGlvbiByZXBsYWNlIChtYXRjaCwgZXNjYXBlZCwgcHJlZml4LCBrZXksIGNhcHR1cmUsIGdyb3VwLCBzdWZmaXgsIGVzY2FwZSwgb2Zmc2V0KSB7XG4gICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgIHJldHVybiBlc2NhcGVkO1xuICAgIH1cblxuICAgIGlmIChlc2NhcGUpIHtcbiAgICAgIHJldHVybiAnXFxcXCcgKyBlc2NhcGU7XG4gICAgfVxuXG4gICAgdmFyIHJlcGVhdCAgID0gc3VmZml4ID09PSAnKycgfHwgc3VmZml4ID09PSAnKic7XG4gICAgdmFyIG9wdGlvbmFsID0gc3VmZml4ID09PSAnPycgfHwgc3VmZml4ID09PSAnKic7XG5cbiAgICBpZiAob2Zmc2V0ID4gbGFzdEVuZEluZGV4KSB7XG4gICAgICBhZGRMYXN0VG9rZW4ocGF0aC5zdWJzdHJpbmcobGFzdEVuZEluZGV4LCBvZmZzZXQpKTtcbiAgICB9XG5cbiAgICBsYXN0RW5kSW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICB2YXIgbmV3S2V5ID0ge1xuICAgICAgbmFtZTogICAgICBrZXkgfHwgaW5kZXgrKyxcbiAgICAgIGRlbGltaXRlcjogcHJlZml4IHx8ICcvJyxcbiAgICAgIG9wdGlvbmFsOiAgb3B0aW9uYWwsXG4gICAgICByZXBlYXQ6ICAgIHJlcGVhdFxuICAgIH1cblxuICAgIGtleXMucHVzaChuZXdLZXkpO1xuICAgIGFsbFRva2Vucy5wdXNoKG5ld0tleSk7XG5cbiAgICBwcmVmaXggPSBwcmVmaXggPyAoJ1xcXFwnICsgcHJlZml4KSA6ICcnO1xuICAgIGNhcHR1cmUgPSBlc2NhcGVHcm91cChjYXB0dXJlIHx8IGdyb3VwIHx8ICdbXicgKyAocHJlZml4IHx8ICdcXFxcLycpICsgJ10rPycpO1xuXG4gICAgaWYgKHJlcGVhdCkge1xuICAgICAgY2FwdHVyZSA9IGNhcHR1cmUgKyAnKD86JyArIHByZWZpeCArIGNhcHR1cmUgKyAnKSonO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgcmV0dXJuICcoPzonICsgcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpKT8nO1xuICAgIH1cblxuICAgIC8vIEJhc2ljIHBhcmFtZXRlciBzdXBwb3J0LlxuICAgIHJldHVybiBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyknO1xuICB9XG5cbiAgdmFyIG5ld1BhdGggPSBwYXRoLnJlcGxhY2UoUEFUSF9SRUdFWFAsIHJlcGxhY2UpO1xuXG4gIGlmIChsYXN0RW5kSW5kZXggPCBwYXRoLmxlbmd0aCkge1xuICAgIGFkZExhc3RUb2tlbihwYXRoLnN1YnN0cmluZyhsYXN0RW5kSW5kZXgpKVxuICB9XG5cbiAgcmV0dXJuIG5ld1BhdGg7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqXG4gKiBAcGFyYW0gIHsoU3RyaW5nfFJlZ0V4cHxBcnJheSl9IHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgICAgICAgICAgICAgW2tleXNdXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICAgICAgICAgIFtvcHRpb25zXVxuICogQHJldHVybiB7UmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMsIGFsbFRva2Vucykge1xuICBrZXlzID0ga2V5cyB8fCBbXTtcbiAgYWxsVG9rZW5zID0gYWxsVG9rZW5zIHx8IFtdO1xuXG4gIGlmICghaXNBcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSBrZXlzO1xuICAgIGtleXMgPSBbXTtcbiAgfSBlbHNlIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMsIGFsbFRva2Vucyk7XG4gIH1cblxuICBpZiAoaXNBcnJheShwYXRoKSkge1xuICAgIHJldHVybiBhcnJheVRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMsIGFsbFRva2Vucyk7XG4gIH1cblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2U7XG4gIHZhciByb3V0ZSA9IHJlcGxhY2VQYXRoKHBhdGgsIGtleXMsIGFsbFRva2Vucyk7XG4gIHZhciBlbmRzV2l0aFNsYXNoID0gcGF0aC5jaGFyQXQocGF0aC5sZW5ndGggLSAxKSA9PT0gJy8nO1xuXG4gIC8vIEluIG5vbi1zdHJpY3QgbW9kZSB3ZSBhbGxvdyBhIHNsYXNoIGF0IHRoZSBlbmQgb2YgbWF0Y2guIElmIHRoZSBwYXRoIHRvXG4gIC8vIG1hdGNoIGFscmVhZHkgZW5kcyB3aXRoIGEgc2xhc2gsIHdlIHJlbW92ZSBpdCBmb3IgY29uc2lzdGVuY3kuIFRoZSBzbGFzaFxuICAvLyBpcyB2YWxpZCBhdCB0aGUgZW5kIG9mIGEgcGF0aCBtYXRjaCwgbm90IGluIHRoZSBtaWRkbGUuIFRoaXMgaXMgaW1wb3J0YW50XG4gIC8vIGluIG5vbi1lbmRpbmcgbW9kZSwgd2hlcmUgXCIvdGVzdC9cIiBzaG91bGRuJ3QgbWF0Y2ggXCIvdGVzdC8vcm91dGVcIi5cbiAgaWYgKCFzdHJpY3QpIHtcbiAgICByb3V0ZSA9IChlbmRzV2l0aFNsYXNoID8gcm91dGUuc2xpY2UoMCwgLTIpIDogcm91dGUpICsgJyg/OlxcXFwvKD89JCkpPyc7XG4gIH1cblxuICBpZiAoZW5kKSB7XG4gICAgcm91dGUgKz0gJyQnO1xuICB9IGVsc2Uge1xuICAgIC8vIEluIG5vbi1lbmRpbmcgbW9kZSwgd2UgbmVlZCB0aGUgY2FwdHVyaW5nIGdyb3VwcyB0byBtYXRjaCBhcyBtdWNoIGFzXG4gICAgLy8gcG9zc2libGUgYnkgdXNpbmcgYSBwb3NpdGl2ZSBsb29rYWhlYWQgdG8gdGhlIGVuZCBvciBuZXh0IHBhdGggc2VnbWVudC5cbiAgICByb3V0ZSArPSBzdHJpY3QgJiYgZW5kc1dpdGhTbGFzaCA/ICcnIDogJyg/PVxcXFwvfCQpJztcbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKG5ldyBSZWdFeHAoJ14nICsgcm91dGUsIGZsYWdzKG9wdGlvbnMpKSwga2V5cywgYWxsVG9rZW5zKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH1cbn0gKCkpXG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBjYWNoZWRTZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCJ2YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxuXG5mdW5jdGlvbiB3cmFwV2Fja3lQcm9taXNlKHByb21pc2UsIGNiKSB7XG5cdHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcblx0XHRjYigpXG5cdH0sIGZ1bmN0aW9uKGVycikge1xuXHRcdGNiKGVycilcblx0fSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBSYWN0aXZlU3RhdGVSb3V0ZXIoUmFjdGl2ZSwgcmFjdGl2ZU9wdGlvbnMsIG9wdGlvbnMpIHtcblx0ZnVuY3Rpb24gY29weUlmQXBwcm9wcmlhdGUodmFsdWUpIHtcblx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRlZXBDb3B5RGF0YU9uU2V0KSB7XG5cdFx0XHRyZXR1cm4gY29weSh2YWx1ZSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0fVxuXHR9XG5cdHJldHVybiBmdW5jdGlvbiBtYWtlUmVuZGVyZXIoc3RhdGVSb3V0ZXIpIHtcblx0XHR2YXIgRXh0ZW5kZWRSYWN0aXZlID0gUmFjdGl2ZS5leHRlbmQocmFjdGl2ZU9wdGlvbnMgfHwge30pXG5cdFx0dmFyIGV4dGVuZGVkRGF0YSA9IEV4dGVuZGVkUmFjdGl2ZS5kZWZhdWx0cy5kYXRhXG5cdFx0dmFyIHJhY3RpdmVEYXRhID0gUmFjdGl2ZS5kZWZhdWx0cy5kYXRhXG5cblx0XHRleHRlbmRlZERhdGEubWFrZVBhdGggPSByYWN0aXZlRGF0YS5tYWtlUGF0aCA9IHN0YXRlUm91dGVyLm1ha2VQYXRoXG5cblx0XHRleHRlbmRlZERhdGEuYWN0aXZlID0gcmFjdGl2ZURhdGEuYWN0aXZlID0gZnVuY3Rpb24gYWN0aXZlKHN0YXRlTmFtZSkge1xuXHRcdFx0cmV0dXJuIHN0YXRlUm91dGVyLnN0YXRlSXNBY3RpdmUoc3RhdGVOYW1lKSA/ICdhY3RpdmUnIDogJydcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoY29udGV4dCwgY2IpIHtcblx0XHRcdFx0dmFyIGVsZW1lbnQgPSBjb250ZXh0LmVsZW1lbnRcblx0XHRcdFx0dmFyIGlucHV0VGVtcGxhdGUgPSBjb250ZXh0LnRlbXBsYXRlXG5cblx0XHRcdFx0dmFyIGRlZmF1bHREZWNvcmF0b3JzID0ge1xuXHRcdFx0XHRcdGFjdGl2ZTogYWN0aXZlU3RhdGVEZWNhcmF0b3IuYmluZChudWxsLCBzdGF0ZVJvdXRlcilcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZ1bmN0aW9uIGdldERhdGEoKSB7XG5cdFx0XHRcdFx0dmFyIGNvcHlPZkNvbnRlbnQgPSBjb3B5SWZBcHByb3ByaWF0ZShjb250ZXh0LmNvbnRlbnQpXG5cdFx0XHRcdFx0cmV0dXJuIGlzVGVtcGxhdGUoaW5wdXRUZW1wbGF0ZSkgPyBjb3B5T2ZDb250ZW50IDogZXh0ZW5kKGlucHV0VGVtcGxhdGUuZGF0YSwgY29weU9mQ29udGVudClcblx0XHRcdFx0fVxuXHRcdFx0XHRmdW5jdGlvbiBnZXREZWNvcmF0b3JzKCkge1xuXHRcdFx0XHRcdHJldHVybiBpc1RlbXBsYXRlKGlucHV0VGVtcGxhdGUpID8gZGVmYXVsdERlY29yYXRvcnMgOiBleHRlbmQoZGVmYXVsdERlY29yYXRvcnMsIGlucHV0VGVtcGxhdGUuZGVjb3JhdG9ycylcblx0XHRcdFx0fVxuXHRcdFx0XHRmdW5jdGlvbiBnZXRPcHRpb25zKCkge1xuXHRcdFx0XHRcdHZhciBiYXJlT3B0aW9ucyA9IGlzVGVtcGxhdGUoaW5wdXRUZW1wbGF0ZSkgPyB7IHRlbXBsYXRlOiBpbnB1dFRlbXBsYXRlIH0gOiBpbnB1dFRlbXBsYXRlXG5cblx0XHRcdFx0XHRyZXR1cm4gZXh0ZW5kKGJhcmVPcHRpb25zLCB7XG5cdFx0XHRcdFx0XHRkZWNvcmF0b3JzOiBnZXREZWNvcmF0b3JzKCksXG5cdFx0XHRcdFx0XHRkYXRhOiBnZXREYXRhKCksXG5cdFx0XHRcdFx0XHRlbDogZWxlbWVudFxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhciByYWN0aXZlID0gbmV3IEV4dGVuZGVkUmFjdGl2ZShnZXRPcHRpb25zKCkpXG5cdFx0XHRcdFx0Y2IobnVsbCwgcmFjdGl2ZSlcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdGNiKGUpXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZXNldDogZnVuY3Rpb24gcmVzZXQoY29udGV4dCwgY2IpIHtcblx0XHRcdFx0dmFyIHJhY3RpdmUgPSBjb250ZXh0LmRvbUFwaVxuXHRcdFx0XHRyYWN0aXZlLm9mZigpXG5cdFx0XHRcdHdyYXBXYWNreVByb21pc2UocmFjdGl2ZS5yZXNldChjb3B5SWZBcHByb3ByaWF0ZShjb250ZXh0LmNvbnRlbnQpKSwgY2IpXG5cdFx0XHR9LFxuXHRcdFx0ZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveShyYWN0aXZlLCBjYikge1xuXHRcdFx0XHR3cmFwV2Fja3lQcm9taXNlKHJhY3RpdmUudGVhcmRvd24oKSwgY2IpXG5cdFx0XHR9LFxuXHRcdFx0Z2V0Q2hpbGRFbGVtZW50OiBmdW5jdGlvbiBnZXRDaGlsZEVsZW1lbnQocmFjdGl2ZSwgY2IpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YXIgY2hpbGQgPSByYWN0aXZlLmZpbmQoJ3VpLXZpZXcnKVxuXHRcdFx0XHRcdGNiKG51bGwsIGNoaWxkKVxuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0Y2IoZSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBjb3B5KHZhbHVlKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdHJldHVybiB2YWx1ZS5tYXAoY29weSlcblx0fSBlbHNlIGlmIChvYmplY3QodmFsdWUpKSB7XG5cdFx0dmFyIHRhcmdldCA9IHt9XG5cdFx0T2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHR0YXJnZXRba2V5XSA9IGNvcHkodmFsdWVba2V5XSlcblx0XHR9KVxuXHRcdHJldHVybiB0YXJnZXRcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gdmFsdWVcblx0fVxufVxuXG5mdW5jdGlvbiBvYmplY3Qobykge1xuXHRyZXR1cm4gbyAmJiB0eXBlb2YgbyA9PT0gJ29iamVjdCdcbn1cblxuZnVuY3Rpb24gYWN0aXZlU3RhdGVEZWNhcmF0b3Ioc3RhdGVSb3V0ZXIsIGVsZW1lbnQsIHN0YXRlTmFtZSkge1xuXHR2YXIgcGFyYW1ldGVyc1RvTWF0Y2ggPSBwYXJzZVBhcmFtZXRlcnMoYXJndW1lbnRzKVxuXHRmdW5jdGlvbiBvblN0YXRlQ2hhbmdlKCkge1xuXHRcdHZhciBhY3RpdmUgPSBzdGF0ZVJvdXRlci5zdGF0ZUlzQWN0aXZlKHN0YXRlTmFtZSwgcGFyYW1ldGVyc1RvTWF0Y2gpXG5cblx0XHRpZiAoYWN0aXZlKSB7XG5cdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpXG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJylcblx0XHR9XG5cblx0fVxuXG5cdHN0YXRlUm91dGVyLm9uKCdzdGF0ZUNoYW5nZUVuZCcsIG9uU3RhdGVDaGFuZ2UpXG5cblx0ZnVuY3Rpb24gdGVhcmRvd24oKSB7XG5cdFx0c3RhdGVSb3V0ZXIucmVtb3ZlTGlzdGVuZXIoJ3N0YXRlQ2hhbmdlRW5kJywgb25TdGF0ZUNoYW5nZSlcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0dGVhcmRvd246IHRlYXJkb3duXG5cdH1cbn1cblxuZnVuY3Rpb24gcGFyc2VQYXJhbWV0ZXJzKGFyZ3MpIHtcblx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDIpXG5cdHJldHVybiBhcmdzLnJlZHVjZShmdW5jdGlvbihhbGxQYXJhbWV0ZXJzLCBwYXJhbWV0ZXJQYWlyKSB7XG5cdFx0dmFyIGtleUFuZFZhbHVlID0gcGFyYW1ldGVyUGFpci5zcGxpdCgnOicpXG5cdFx0aWYgKGtleUFuZFZhbHVlLmxlbmd0aCA+IDEpIHtcblx0XHRcdGFsbFBhcmFtZXRlcnNba2V5QW5kVmFsdWVbMF1dID0ga2V5QW5kVmFsdWVbMV1cblx0XHR9XG5cdFx0cmV0dXJuIGFsbFBhcmFtZXRlcnNcblx0fSwge30pXG59XG5cbmZ1bmN0aW9uIGFsbFBhcmFtZXRlcnNNYXRjaCh0b01hdGNoLCBwYXJhbWV0ZXJzKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyh0b01hdGNoKS5ldmVyeShmdW5jdGlvbihrZXkpIHtcblx0XHRyZXR1cm4gdG9NYXRjaFtrZXldID09IHBhcmFtZXRlcnNba2V5XVxuXHR9KVxufVxuXG5mdW5jdGlvbiBpc1RlbXBsYXRlKGlucHV0VGVtcGxhdGUpIHtcblx0cmV0dXJuIHR5cGVvZiBpbnB1dFRlbXBsYXRlID09PSAnc3RyaW5nJyB8fCBpc1JhY3RpdmVUZW1wbGF0ZU9iamVjdChpbnB1dFRlbXBsYXRlKVxufVxuXG5mdW5jdGlvbiBpc1JhY3RpdmVUZW1wbGF0ZU9iamVjdCh0ZW1wbGF0ZSkge1xuXHQvLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvYmxvYi9iMWM5ZTFlNWMyMmRhYWMzMjEwZWU3ZGIwZjUxMTA2NWIzMWFhYzNjL3NyYy9SYWN0aXZlL2NvbmZpZy9jdXN0b20vdGVtcGxhdGUvdGVtcGxhdGUuanMjTDExMy1MMTE2XG5cdHJldHVybiB0ZW1wbGF0ZSAmJiB0eXBlb2YgdGVtcGxhdGUudiA9PT0gJ251bWJlcidcbn1cbiIsIi8qXG5cdFJhY3RpdmUuanMgdjAuNy4zXG5cdFNhdCBBcHIgMjUgMjAxNSAxMzo1MjozOCBHTVQtMDQwMCAoRURUKSAtIGNvbW1pdCBkYTQwZjgxYzY2MGJhMmYwOWM0NWEwOWE5YzIwZmRkMzRlZTM2ZDgwXG5cblx0aHR0cDovL3JhY3RpdmVqcy5vcmdcblx0aHR0cDovL3R3aXR0ZXIuY29tL1JhY3RpdmVKU1xuXG5cdFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgZ2xvYmFsLlJhY3RpdmUgPSBmYWN0b3J5KClcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIFRFTVBMQVRFX1ZFUlNJT04gPSAzO1xuXG4gIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcblxuICBcdC8vIHJlbmRlciBwbGFjZW1lbnQ6XG4gIFx0ZWw6IHZvaWQgMCxcbiAgXHRhcHBlbmQ6IGZhbHNlLFxuXG4gIFx0Ly8gdGVtcGxhdGU6XG4gIFx0dGVtcGxhdGU6IHsgdjogVEVNUExBVEVfVkVSU0lPTiwgdDogW10gfSxcblxuICBcdC8vIHBhcnNlOiAgICAgLy8gVE9ETyBzdGF0aWMgZGVsaW1pdGVycz9cbiAgXHRwcmVzZXJ2ZVdoaXRlc3BhY2U6IGZhbHNlLFxuICBcdHNhbml0aXplOiBmYWxzZSxcbiAgXHRzdHJpcENvbW1lbnRzOiB0cnVlLFxuICBcdGRlbGltaXRlcnM6IFtcInt7XCIsIFwifX1cIl0sXG4gIFx0dHJpcGxlRGVsaW1pdGVyczogW1wie3t7XCIsIFwifX19XCJdLFxuICBcdGludGVycG9sYXRlOiBmYWxzZSxcblxuICBcdC8vIGRhdGEgJiBiaW5kaW5nOlxuICBcdGRhdGE6IHt9LFxuICBcdGNvbXB1dGVkOiB7fSxcbiAgXHRtYWdpYzogZmFsc2UsXG4gIFx0bW9kaWZ5QXJyYXlzOiB0cnVlLFxuICBcdGFkYXB0OiBbXSxcbiAgXHRpc29sYXRlZDogZmFsc2UsXG4gIFx0dHdvd2F5OiB0cnVlLFxuICBcdGxhenk6IGZhbHNlLFxuXG4gIFx0Ly8gdHJhbnNpdGlvbnM6XG4gIFx0bm9JbnRybzogZmFsc2UsXG4gIFx0dHJhbnNpdGlvbnNFbmFibGVkOiB0cnVlLFxuICBcdGNvbXBsZXRlOiB2b2lkIDAsXG5cbiAgXHQvLyBjc3M6XG4gIFx0Y3NzOiBudWxsLFxuICBcdG5vQ3NzVHJhbnNmb3JtOiBmYWxzZVxuICB9O1xuXG4gIHZhciBjb25maWdfZGVmYXVsdHMgPSBkZWZhdWx0T3B0aW9ucztcblxuICAvLyBUaGVzZSBhcmUgYSBzdWJzZXQgb2YgdGhlIGVhc2luZyBlcXVhdGlvbnMgZm91bmQgYXRcbiAgLy8gaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9kYW5yby9lYXNpbmctanMgLSBsaWNlbnNlIGluZm9cbiAgLy8gZm9sbG93czpcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBlYXNpbmcuanMgdjAuNS40XG4gIC8vIEdlbmVyaWMgc2V0IG9mIGVhc2luZyBmdW5jdGlvbnMgd2l0aCBBTUQgc3VwcG9ydFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZGFucm8vZWFzaW5nLWpzXG4gIC8vIFRoaXMgY29kZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICAvLyBodHRwOi8vZGFucm8ubWl0LWxpY2Vuc2Uub3JnL1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBBbGwgZnVuY3Rpb25zIGFkYXB0ZWQgZnJvbSBUaG9tYXMgRnVjaHMgJiBKZXJlbXkgS2FoblxuICAvLyBFYXNpbmcgRXF1YXRpb25zIChjKSAyMDAzIFJvYmVydCBQZW5uZXIsIEJTRCBsaWNlbnNlXG4gIC8vIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZGFucm8vZWFzaW5nLWpzL21hc3Rlci9MSUNFTlNFXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gSW4gdGhhdCBsaWJyYXJ5LCB0aGUgZnVuY3Rpb25zIG5hbWVkIGVhc2VJbiwgZWFzZU91dCwgYW5kXG4gIC8vIGVhc2VJbk91dCBiZWxvdyBhcmUgbmFtZWQgZWFzZUluQ3ViaWMsIGVhc2VPdXRDdWJpYywgYW5kXG4gIC8vICh5b3UgZ3Vlc3NlZCBpdCkgZWFzZUluT3V0Q3ViaWMuXG4gIC8vXG4gIC8vIFlvdSBjYW4gYWRkIGFkZGl0aW9uYWwgZWFzaW5nIGZ1bmN0aW9ucyB0byB0aGlzIGxpc3QsIGFuZCB0aGV5XG4gIC8vIHdpbGwgYmUgZ2xvYmFsbHkgYXZhaWxhYmxlLlxuXG4gIHZhciBzdGF0aWNfZWFzaW5nID0ge1xuICBcdGxpbmVhcjogZnVuY3Rpb24gKHBvcykge1xuICBcdFx0cmV0dXJuIHBvcztcbiAgXHR9LFxuICBcdGVhc2VJbjogZnVuY3Rpb24gKHBvcykge1xuICBcdFx0cmV0dXJuIE1hdGgucG93KHBvcywgMyk7XG4gIFx0fSxcbiAgXHRlYXNlT3V0OiBmdW5jdGlvbiAocG9zKSB7XG4gIFx0XHRyZXR1cm4gTWF0aC5wb3cocG9zIC0gMSwgMykgKyAxO1xuICBcdH0sXG4gIFx0ZWFzZUluT3V0OiBmdW5jdGlvbiAocG9zKSB7XG4gIFx0XHRpZiAoKHBvcyAvPSAwLjUpIDwgMSkge1xuICBcdFx0XHRyZXR1cm4gMC41ICogTWF0aC5wb3cocG9zLCAzKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiAwLjUgKiAoTWF0aC5wb3cocG9zIC0gMiwgMykgKyAyKTtcbiAgXHR9XG4gIH07XG5cbiAgLypnbG9iYWwgY29uc29sZSwgbmF2aWdhdG9yICovXG4gIHZhciBpc0NsaWVudCwgaXNKc2RvbSwgaGFzQ29uc29sZSwgZW52aXJvbm1lbnRfX21hZ2ljLCBuYW1lc3BhY2VzLCBzdmcsIHZlbmRvcnM7XG5cbiAgaXNDbGllbnQgPSB0eXBlb2YgZG9jdW1lbnQgPT09IFwib2JqZWN0XCI7XG5cbiAgaXNKc2RvbSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgL2pzRG9tLy50ZXN0KG5hdmlnYXRvci5hcHBOYW1lKTtcblxuICBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbnNvbGUud2FybiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBjb25zb2xlLndhcm4uYXBwbHkgPT09IFwiZnVuY3Rpb25cIjtcblxuICB0cnkge1xuICBcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJ0ZXN0XCIsIHsgdmFsdWU6IDAgfSk7XG4gIFx0ZW52aXJvbm1lbnRfX21hZ2ljID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICBcdGVudmlyb25tZW50X19tYWdpYyA9IGZhbHNlO1xuICB9XG5cbiAgbmFtZXNwYWNlcyA9IHtcbiAgXHRodG1sOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIixcbiAgXHRtYXRobWw6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLFxuICBcdHN2ZzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICBcdHhsaW5rOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgXHR4bWw6IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXG4gIFx0eG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIlxuICB9O1xuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgXHRzdmcgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgXHRzdmcgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKFwiaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNCYXNpY1N0cnVjdHVyZVwiLCBcIjEuMVwiKTtcbiAgfVxuXG4gIHZlbmRvcnMgPSBbXCJvXCIsIFwibXNcIiwgXCJtb3pcIiwgXCJ3ZWJraXRcIl07XG5cbiAgdmFyIGNyZWF0ZUVsZW1lbnQsIG1hdGNoZXMsIGRvbV9fZGl2LCBtZXRob2ROYW1lcywgdW5wcmVmaXhlZCwgcHJlZml4ZWQsIGRvbV9faSwgaiwgbWFrZUZ1bmN0aW9uO1xuXG4gIC8vIFRlc3QgZm9yIFNWRyBzdXBwb3J0XG4gIGlmICghc3ZnKSB7XG4gIFx0Y3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBucykge1xuICBcdFx0aWYgKG5zICYmIG5zICE9PSBuYW1lc3BhY2VzLmh0bWwpIHtcbiAgXHRcdFx0dGhyb3cgXCJUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBuYW1lc3BhY2VzIG90aGVyIHRoYW4gaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC4gVGhlIG1vc3QgbGlrZWx5IGNhdXNlIG9mIHRoaXMgZXJyb3IgaXMgdGhhdCB5b3UncmUgdHJ5aW5nIHRvIHJlbmRlciBTVkcgaW4gYW4gb2xkZXIgYnJvd3Nlci4gU2VlIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L3N2Zy1hbmQtb2xkZXItYnJvd3NlcnMgZm9yIG1vcmUgaW5mb3JtYXRpb25cIjtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gIFx0fTtcbiAgfSBlbHNlIHtcbiAgXHRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIG5zKSB7XG4gIFx0XHRpZiAoIW5zIHx8IG5zID09PSBuYW1lc3BhY2VzLmh0bWwpIHtcbiAgXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsIHR5cGUpO1xuICBcdH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFbGVtZW50KGlucHV0KSB7XG4gIFx0dmFyIG91dHB1dDtcblxuICBcdGlmICghaW5wdXQgfHwgdHlwZW9mIGlucHV0ID09PSBcImJvb2xlYW5cIikge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8ICFkb2N1bWVudCB8fCAhaW5wdXQpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIFdlIGFscmVhZHkgaGF2ZSBhIERPTSBub2RlIC0gbm8gd29yayB0byBkby4gKER1Y2sgdHlwaW5nIGFsZXJ0ISlcbiAgXHRpZiAoaW5wdXQubm9kZVR5cGUpIHtcbiAgXHRcdHJldHVybiBpbnB1dDtcbiAgXHR9XG5cbiAgXHQvLyBHZXQgbm9kZSBmcm9tIHN0cmluZ1xuICBcdGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdC8vIHRyeSBJRCBmaXJzdFxuICBcdFx0b3V0cHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaW5wdXQpO1xuXG4gIFx0XHQvLyB0aGVuIGFzIHNlbGVjdG9yLCBpZiBwb3NzaWJsZVxuICBcdFx0aWYgKCFvdXRwdXQgJiYgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcikge1xuICBcdFx0XHRvdXRwdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGlucHV0KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gZGlkIGl0IHdvcms/XG4gIFx0XHRpZiAob3V0cHV0ICYmIG91dHB1dC5ub2RlVHlwZSkge1xuICBcdFx0XHRyZXR1cm4gb3V0cHV0O1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIElmIHdlJ3ZlIGJlZW4gZ2l2ZW4gYSBjb2xsZWN0aW9uIChqUXVlcnksIFplcHRvIGV0YyksIGV4dHJhY3QgdGhlIGZpcnN0IGl0ZW1cbiAgXHRpZiAoaW5wdXRbMF0gJiYgaW5wdXRbMF0ubm9kZVR5cGUpIHtcbiAgXHRcdHJldHVybiBpbnB1dFswXTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICghaXNDbGllbnQpIHtcbiAgXHRtYXRjaGVzID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgXHRkb21fX2RpdiA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIFx0bWV0aG9kTmFtZXMgPSBbXCJtYXRjaGVzXCIsIFwibWF0Y2hlc1NlbGVjdG9yXCJdO1xuXG4gIFx0bWFrZUZ1bmN0aW9uID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgXHRcdHJldHVybiBmdW5jdGlvbiAobm9kZSwgc2VsZWN0b3IpIHtcbiAgXHRcdFx0cmV0dXJuIG5vZGVbbWV0aG9kTmFtZV0oc2VsZWN0b3IpO1xuICBcdFx0fTtcbiAgXHR9O1xuXG4gIFx0ZG9tX19pID0gbWV0aG9kTmFtZXMubGVuZ3RoO1xuXG4gIFx0d2hpbGUgKGRvbV9faS0tICYmICFtYXRjaGVzKSB7XG4gIFx0XHR1bnByZWZpeGVkID0gbWV0aG9kTmFtZXNbZG9tX19pXTtcblxuICBcdFx0aWYgKGRvbV9fZGl2W3VucHJlZml4ZWRdKSB7XG4gIFx0XHRcdG1hdGNoZXMgPSBtYWtlRnVuY3Rpb24odW5wcmVmaXhlZCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRqID0gdmVuZG9ycy5sZW5ndGg7XG4gIFx0XHRcdHdoaWxlIChqLS0pIHtcbiAgXHRcdFx0XHRwcmVmaXhlZCA9IHZlbmRvcnNbZG9tX19pXSArIHVucHJlZml4ZWQuc3Vic3RyKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyB1bnByZWZpeGVkLnN1YnN0cmluZygxKTtcblxuICBcdFx0XHRcdGlmIChkb21fX2RpdltwcmVmaXhlZF0pIHtcbiAgXHRcdFx0XHRcdG1hdGNoZXMgPSBtYWtlRnVuY3Rpb24ocHJlZml4ZWQpO1xuICBcdFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gSUU4Li4uXG4gIFx0aWYgKCFtYXRjaGVzKSB7XG4gIFx0XHRtYXRjaGVzID0gZnVuY3Rpb24gKG5vZGUsIHNlbGVjdG9yKSB7XG4gIFx0XHRcdHZhciBub2RlcywgcGFyZW50Tm9kZSwgaTtcblxuICBcdFx0XHRwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXG4gIFx0XHRcdGlmICghcGFyZW50Tm9kZSkge1xuICBcdFx0XHRcdC8vIGVtcHR5IGR1bW15IDxkaXY+XG4gIFx0XHRcdFx0ZG9tX19kaXYuaW5uZXJIVE1MID0gXCJcIjtcblxuICBcdFx0XHRcdHBhcmVudE5vZGUgPSBkb21fX2RpdjtcbiAgXHRcdFx0XHRub2RlID0gbm9kZS5jbG9uZU5vZGUoKTtcblxuICBcdFx0XHRcdGRvbV9fZGl2LmFwcGVuZENoaWxkKG5vZGUpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0bm9kZXMgPSBwYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuXG4gIFx0XHRcdGkgPSBub2Rlcy5sZW5ndGg7XG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRpZiAobm9kZXNbaV0gPT09IG5vZGUpIHtcbiAgXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH07XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZGV0YWNoTm9kZShub2RlKSB7XG4gIFx0aWYgKG5vZGUgJiYgdHlwZW9mIG5vZGUucGFyZW50Tm9kZSAhPT0gXCJ1bmtub3duXCIgJiYgbm9kZS5wYXJlbnROb2RlKSB7XG4gIFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBzYWZlVG9TdHJpbmdWYWx1ZSh2YWx1ZSkge1xuICBcdHJldHVybiB2YWx1ZSA9PSBudWxsIHx8ICF2YWx1ZS50b1N0cmluZyA/IFwiXCIgOiB2YWx1ZTtcbiAgfVxuXG4gIHZhciBsZWdhY3kgPSBudWxsO1xuXG4gIHZhciBjcmVhdGUsIGRlZmluZVByb3BlcnR5LCBkZWZpbmVQcm9wZXJ0aWVzO1xuXG4gIHRyeSB7XG4gIFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInRlc3RcIiwgeyB2YWx1ZTogMCB9KTtcblxuICBcdGlmIChpc0NsaWVudCkge1xuICBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIFwidGVzdFwiLCB7IHZhbHVlOiAwIH0pO1xuICBcdH1cblxuICBcdGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgXHQvLyBPYmplY3QuZGVmaW5lUHJvcGVydHkgZG9lc24ndCBleGlzdCwgb3Igd2UncmUgaW4gSUU4IHdoZXJlIHlvdSBjYW5cbiAgXHQvLyBvbmx5IHVzZSBpdCB3aXRoIERPTSBvYmplY3RzICh3aGF0IHdlcmUgeW91IHNtb2tpbmcsIE1TRlQ/KVxuICBcdGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgZGVzYykge1xuICBcdFx0b2JqW3Byb3BdID0gZGVzYy52YWx1ZTtcbiAgXHR9O1xuICB9XG5cbiAgdHJ5IHtcbiAgXHR0cnkge1xuICBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoe30sIHsgdGVzdDogeyB2YWx1ZTogMCB9IH0pO1xuICBcdH0gY2F0Y2ggKGVycikge1xuICBcdFx0Ly8gVE9ETyBob3cgZG8gd2UgYWNjb3VudCBmb3IgdGhpcz8gbm9NYWdpYyA9IHRydWU7XG4gIFx0XHR0aHJvdyBlcnI7XG4gIFx0fVxuXG4gIFx0aWYgKGlzQ2xpZW50KSB7XG4gIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjcmVhdGVFbGVtZW50KFwiZGl2XCIpLCB7IHRlc3Q6IHsgdmFsdWU6IDAgfSB9KTtcbiAgXHR9XG5cbiAgXHRkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG4gIH0gY2F0Y2ggKGVycikge1xuICBcdGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqLCBwcm9wcykge1xuICBcdFx0dmFyIHByb3A7XG5cbiAgXHRcdGZvciAocHJvcCBpbiBwcm9wcykge1xuICBcdFx0XHRpZiAocHJvcHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgXHRcdFx0XHRkZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHByb3BzW3Byb3BdKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH07XG4gIH1cblxuICB0cnkge1xuICBcdE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgXHRjcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgXHQvLyBzaWdoXG4gIFx0Y3JlYXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBGID0gZnVuY3Rpb24gKCkge307XG5cbiAgXHRcdHJldHVybiBmdW5jdGlvbiAocHJvdG8sIHByb3BzKSB7XG4gIFx0XHRcdHZhciBvYmo7XG5cbiAgXHRcdFx0aWYgKHByb3RvID09PSBudWxsKSB7XG4gIFx0XHRcdFx0cmV0dXJuIHt9O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ri5wcm90b3R5cGUgPSBwcm90bztcbiAgXHRcdFx0b2JqID0gbmV3IEYoKTtcblxuICBcdFx0XHRpZiAocHJvcHMpIHtcbiAgXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmosIHByb3BzKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBvYmo7XG4gIFx0XHR9O1xuICBcdH0pKCk7XG4gIH1cblxuICBmdW5jdGlvbiB1dGlsc19vYmplY3RfX2V4dGVuZCh0YXJnZXQpIHtcbiAgXHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgXHRcdHNvdXJjZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICBcdH1cblxuICBcdHZhciBwcm9wLCBzb3VyY2U7XG5cbiAgXHR3aGlsZSAoc291cmNlID0gc291cmNlcy5zaGlmdCgpKSB7XG4gIFx0XHRmb3IgKHByb3AgaW4gc291cmNlKSB7XG4gIFx0XHRcdGlmIChoYXNPd24uY2FsbChzb3VyY2UsIHByb3ApKSB7XG4gIFx0XHRcdFx0dGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGxHYXBzKHRhcmdldCkge1xuICBcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICBcdFx0c291cmNlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIFx0fVxuXG4gIFx0c291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gcykge1xuICBcdFx0XHRpZiAocy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgXHRcdFx0XHR0YXJnZXRba2V5XSA9IHNba2V5XTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0pO1xuXG4gIFx0cmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIC8vIHRoYW5rcywgaHR0cDovL3BlcmZlY3Rpb25raWxscy5jb20vaW5zdGFuY2VvZi1jb25zaWRlcmVkLWhhcm1mdWwtb3ItaG93LXRvLXdyaXRlLWEtcm9idXN0LWlzYXJyYXkvXG4gIHZhciBpc19fdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgICAgYXJyYXlMaWtlUGF0dGVybiA9IC9eXFxbb2JqZWN0ICg/OkFycmF5fEZpbGVMaXN0KVxcXSQvO1xuICBmdW5jdGlvbiBpc0FycmF5KHRoaW5nKSB7XG4gIFx0cmV0dXJuIGlzX190b1N0cmluZy5jYWxsKHRoaW5nKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNBcnJheUxpa2Uob2JqKSB7XG4gIFx0cmV0dXJuIGFycmF5TGlrZVBhdHRlcm4udGVzdChpc19fdG9TdHJpbmcuY2FsbChvYmopKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRXF1YWwoYSwgYikge1xuICBcdGlmIChhID09PSBudWxsICYmIGIgPT09IG51bGwpIHtcbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cblxuICBcdGlmICh0eXBlb2YgYSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgYiA9PT0gXCJvYmplY3RcIikge1xuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH1cblxuICBcdHJldHVybiBhID09PSBiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNfX2lzTnVtZXJpYyh0aGluZykge1xuICBcdHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdCh0aGluZykpICYmIGlzRmluaXRlKHRoaW5nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT2JqZWN0KHRoaW5nKSB7XG4gIFx0cmV0dXJuIHRoaW5nICYmIGlzX190b1N0cmluZy5jYWxsKHRoaW5nKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbiAgfVxuXG4gIHZhciBub29wID0gZnVuY3Rpb24gKCkge307XG5cbiAgLyogZ2xvYmFsIGNvbnNvbGUgKi9cbiAgdmFyIGFscmVhZHlXYXJuZWQgPSB7fSxcbiAgICAgIGxvZyxcbiAgICAgIHByaW50V2FybmluZyxcbiAgICAgIHdlbGNvbWU7XG5cbiAgaWYgKGhhc0NvbnNvbGUpIHtcbiAgXHQoZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHdlbGNvbWVJbnRybyA9IFtcIiVjUmFjdGl2ZS5qcyAlYzAuNy4zICVjaW4gZGVidWcgbW9kZSwgJWNtb3JlLi4uXCIsIFwiY29sb3I6IHJnYigxMTQsIDE1NywgNTIpOyBmb250LXdlaWdodDogbm9ybWFsO1wiLCBcImNvbG9yOiByZ2IoODUsIDg1LCA4NSk7IGZvbnQtd2VpZ2h0OiBub3JtYWw7XCIsIFwiY29sb3I6IHJnYig4NSwgODUsIDg1KTsgZm9udC13ZWlnaHQ6IG5vcm1hbDtcIiwgXCJjb2xvcjogcmdiKDgyLCAxNDAsIDIyNCk7IGZvbnQtd2VpZ2h0OiBub3JtYWw7IHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1wiXTtcbiAgXHRcdHZhciB3ZWxjb21lTWVzc2FnZSA9IFwiWW91J3JlIHJ1bm5pbmcgUmFjdGl2ZSAwLjcuMyBpbiBkZWJ1ZyBtb2RlIC0gbWVzc2FnZXMgd2lsbCBiZSBwcmludGVkIHRvIHRoZSBjb25zb2xlIHRvIGhlbHAgeW91IGZpeCBwcm9ibGVtcyBhbmQgb3B0aW1pc2UgeW91ciBhcHBsaWNhdGlvbi5cXG5cXG5UbyBkaXNhYmxlIGRlYnVnIG1vZGUsIGFkZCB0aGlzIGxpbmUgYXQgdGhlIHN0YXJ0IG9mIHlvdXIgYXBwOlxcbiAgUmFjdGl2ZS5ERUJVRyA9IGZhbHNlO1xcblxcblRvIGRpc2FibGUgZGVidWcgbW9kZSB3aGVuIHlvdXIgYXBwIGlzIG1pbmlmaWVkLCBhZGQgdGhpcyBzbmlwcGV0OlxcbiAgUmFjdGl2ZS5ERUJVRyA9IC91bm1pbmlmaWVkLy50ZXN0KGZ1bmN0aW9uKCl7Lyp1bm1pbmlmaWVkKi99KTtcXG5cXG5HZXQgaGVscCBhbmQgc3VwcG9ydDpcXG4gIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmdcXG4gIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvdGFnZ2VkL3JhY3RpdmVqc1xcbiAgaHR0cDovL2dyb3Vwcy5nb29nbGUuY29tL2ZvcnVtLyMhZm9ydW0vcmFjdGl2ZS1qc1xcbiAgaHR0cDovL3R3aXR0ZXIuY29tL3JhY3RpdmVqc1xcblxcbkZvdW5kIGEgYnVnPyBSYWlzZSBhbiBpc3N1ZTpcXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9pc3N1ZXNcXG5cXG5cIjtcblxuICBcdFx0d2VsY29tZSA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dmFyIGhhc0dyb3VwID0gISFjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICBcdFx0XHRjb25zb2xlW2hhc0dyb3VwID8gXCJncm91cENvbGxhcHNlZFwiIDogXCJsb2dcIl0uYXBwbHkoY29uc29sZSwgd2VsY29tZUludHJvKTtcbiAgXHRcdFx0Y29uc29sZS5sb2cod2VsY29tZU1lc3NhZ2UpO1xuICBcdFx0XHRpZiAoaGFzR3JvdXApIHtcbiAgXHRcdFx0XHRjb25zb2xlLmdyb3VwRW5kKHdlbGNvbWVJbnRybyk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR3ZWxjb21lID0gbm9vcDtcbiAgXHRcdH07XG5cbiAgXHRcdHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChtZXNzYWdlLCBhcmdzKSB7XG4gIFx0XHRcdHdlbGNvbWUoKTtcblxuICBcdFx0XHQvLyBleHRyYWN0IGluZm9ybWF0aW9uIGFib3V0IHRoZSBpbnN0YW5jZSB0aGlzIG1lc3NhZ2UgcGVydGFpbnMgdG8sIGlmIGFwcGxpY2FibGVcbiAgXHRcdFx0aWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdFx0XHR2YXIgb3B0aW9ucyA9IGFyZ3MucG9wKCk7XG4gIFx0XHRcdFx0dmFyIHJhY3RpdmUgPSBvcHRpb25zID8gb3B0aW9ucy5yYWN0aXZlIDogbnVsbDtcblxuICBcdFx0XHRcdGlmIChyYWN0aXZlKSB7XG4gIFx0XHRcdFx0XHQvLyBpZiB0aGlzIGlzIGFuIGluc3RhbmNlIG9mIGEgY29tcG9uZW50IHRoYXQgd2Uga25vdyB0aGUgbmFtZSBvZiwgYWRkXG4gIFx0XHRcdFx0XHQvLyBpdCB0byB0aGUgbWVzc2FnZVxuICBcdFx0XHRcdFx0dmFyIF9uYW1lID0gdW5kZWZpbmVkO1xuICBcdFx0XHRcdFx0aWYgKHJhY3RpdmUuY29tcG9uZW50ICYmIChfbmFtZSA9IHJhY3RpdmUuY29tcG9uZW50Lm5hbWUpKSB7XG4gIFx0XHRcdFx0XHRcdG1lc3NhZ2UgPSBcIjxcIiArIF9uYW1lICsgXCI+IFwiICsgbWVzc2FnZTtcbiAgXHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0dmFyIG5vZGUgPSB1bmRlZmluZWQ7XG4gIFx0XHRcdFx0XHRpZiAobm9kZSA9IG9wdGlvbnMubm9kZSB8fCByYWN0aXZlLmZyYWdtZW50ICYmIHJhY3RpdmUuZnJhZ21lbnQucmVuZGVyZWQgJiYgcmFjdGl2ZS5maW5kKFwiKlwiKSkge1xuICBcdFx0XHRcdFx0XHRhcmdzLnB1c2gobm9kZSk7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0Y29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIFtcIiVjUmFjdGl2ZS5qczogJWNcIiArIG1lc3NhZ2UsIFwiY29sb3I6IHJnYigxMTQsIDE1NywgNTIpO1wiLCBcImNvbG9yOiByZ2IoODUsIDg1LCA4NSk7XCJdLmNvbmNhdChhcmdzKSk7XG4gIFx0XHR9O1xuXG4gIFx0XHRsb2cgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gIFx0XHR9O1xuICBcdH0pKCk7XG4gIH0gZWxzZSB7XG4gIFx0cHJpbnRXYXJuaW5nID0gbG9nID0gd2VsY29tZSA9IG5vb3A7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXQobWVzc2FnZSwgYXJncykge1xuICBcdHJldHVybiBtZXNzYWdlLnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBhcmdzLnNoaWZ0KCk7XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiBmYXRhbChtZXNzYWdlKSB7XG4gIFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gIFx0XHRhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgXHR9XG5cbiAgXHRtZXNzYWdlID0gZm9ybWF0KG1lc3NhZ2UsIGFyZ3MpO1xuICBcdHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvZ0lmRGVidWcoKSB7XG4gIFx0aWYgKF9SYWN0aXZlLkRFQlVHKSB7XG4gIFx0XHRsb2cuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuKG1lc3NhZ2UpIHtcbiAgXHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgXHRcdGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICBcdH1cblxuICBcdG1lc3NhZ2UgPSBmb3JtYXQobWVzc2FnZSwgYXJncyk7XG4gIFx0cHJpbnRXYXJuaW5nKG1lc3NhZ2UsIGFyZ3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UobWVzc2FnZSkge1xuICBcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICBcdFx0YXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIFx0fVxuXG4gIFx0bWVzc2FnZSA9IGZvcm1hdChtZXNzYWdlLCBhcmdzKTtcblxuICBcdGlmIChhbHJlYWR5V2FybmVkW21lc3NhZ2VdKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0YWxyZWFkeVdhcm5lZFttZXNzYWdlXSA9IHRydWU7XG4gIFx0cHJpbnRXYXJuaW5nKG1lc3NhZ2UsIGFyZ3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FybklmRGVidWcoKSB7XG4gIFx0aWYgKF9SYWN0aXZlLkRFQlVHKSB7XG4gIFx0XHR3YXJuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2VJZkRlYnVnKCkge1xuICBcdGlmIChfUmFjdGl2ZS5ERUJVRykge1xuICBcdFx0d2Fybk9uY2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgXHR9XG4gIH1cblxuICAvLyBFcnJvciBtZXNzYWdlcyB0aGF0IGFyZSB1c2VkIChvciBjb3VsZCBiZSkgaW4gbXVsdGlwbGUgcGxhY2VzXG4gIHZhciBiYWRBcmd1bWVudHMgPSBcIkJhZCBhcmd1bWVudHNcIjtcbiAgdmFyIG5vUmVnaXN0cnlGdW5jdGlvblJldHVybiA9IFwiQSBmdW5jdGlvbiB3YXMgc3BlY2lmaWVkIGZvciBcXFwiJXNcXFwiICVzLCBidXQgbm8gJXMgd2FzIHJldHVybmVkXCI7XG4gIHZhciBtaXNzaW5nUGx1Z2luID0gZnVuY3Rpb24gKG5hbWUsIHR5cGUpIHtcbiAgICByZXR1cm4gXCJNaXNzaW5nIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgXCIgKyB0eXBlICsgXCIgcGx1Z2luLiBZb3UgbWF5IG5lZWQgdG8gZG93bmxvYWQgYSBwbHVnaW4gdmlhIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L3BsdWdpbnMjXCIgKyB0eXBlICsgXCJzXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gZmluZEluVmlld0hpZXJhcmNoeShyZWdpc3RyeU5hbWUsIHJhY3RpdmUsIG5hbWUpIHtcbiAgXHR2YXIgaW5zdGFuY2UgPSBmaW5kSW5zdGFuY2UocmVnaXN0cnlOYW1lLCByYWN0aXZlLCBuYW1lKTtcbiAgXHRyZXR1cm4gaW5zdGFuY2UgPyBpbnN0YW5jZVtyZWdpc3RyeU5hbWVdW25hbWVdIDogbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRJbnN0YW5jZShyZWdpc3RyeU5hbWUsIHJhY3RpdmUsIG5hbWUpIHtcbiAgXHR3aGlsZSAocmFjdGl2ZSkge1xuICBcdFx0aWYgKG5hbWUgaW4gcmFjdGl2ZVtyZWdpc3RyeU5hbWVdKSB7XG4gIFx0XHRcdHJldHVybiByYWN0aXZlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAocmFjdGl2ZS5pc29sYXRlZCkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cmFjdGl2ZSA9IHJhY3RpdmUucGFyZW50O1xuICBcdH1cbiAgfVxuXG4gIHZhciBpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIChmcm9tLCB0bywgcmFjdGl2ZSwgdHlwZSkge1xuICBcdGlmIChmcm9tID09PSB0bykge1xuICBcdFx0cmV0dXJuIHNuYXAodG8pO1xuICBcdH1cblxuICBcdGlmICh0eXBlKSB7XG5cbiAgXHRcdHZhciBpbnRlcnBvbCA9IGZpbmRJblZpZXdIaWVyYXJjaHkoXCJpbnRlcnBvbGF0b3JzXCIsIHJhY3RpdmUsIHR5cGUpO1xuICBcdFx0aWYgKGludGVycG9sKSB7XG4gIFx0XHRcdHJldHVybiBpbnRlcnBvbChmcm9tLCB0bykgfHwgc25hcCh0byk7XG4gIFx0XHR9XG5cbiAgXHRcdGZhdGFsKG1pc3NpbmdQbHVnaW4odHlwZSwgXCJpbnRlcnBvbGF0b3JcIikpO1xuICBcdH1cblxuICBcdHJldHVybiBzdGF0aWNfaW50ZXJwb2xhdG9ycy5udW1iZXIoZnJvbSwgdG8pIHx8IHN0YXRpY19pbnRlcnBvbGF0b3JzLmFycmF5KGZyb20sIHRvKSB8fCBzdGF0aWNfaW50ZXJwb2xhdG9ycy5vYmplY3QoZnJvbSwgdG8pIHx8IHNuYXAodG8pO1xuICB9O1xuXG4gIHZhciBzaGFyZWRfaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZTtcblxuICBmdW5jdGlvbiBzbmFwKHRvKSB7XG4gIFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0bztcbiAgXHR9O1xuICB9XG5cbiAgdmFyIGludGVycG9sYXRvcnMgPSB7XG4gIFx0bnVtYmVyOiBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgXHRcdHZhciBkZWx0YTtcblxuICBcdFx0aWYgKCFpc19faXNOdW1lcmljKGZyb20pIHx8ICFpc19faXNOdW1lcmljKHRvKSkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0ZnJvbSA9ICtmcm9tO1xuICBcdFx0dG8gPSArdG87XG5cbiAgXHRcdGRlbHRhID0gdG8gLSBmcm9tO1xuXG4gIFx0XHRpZiAoIWRlbHRhKSB7XG4gIFx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGZyb207XG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBmdW5jdGlvbiAodCkge1xuICBcdFx0XHRyZXR1cm4gZnJvbSArIHQgKiBkZWx0YTtcbiAgXHRcdH07XG4gIFx0fSxcblxuICBcdGFycmF5OiBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgXHRcdHZhciBpbnRlcm1lZGlhdGUsIGludGVycG9sYXRvcnMsIGxlbiwgaTtcblxuICBcdFx0aWYgKCFpc0FycmF5KGZyb20pIHx8ICFpc0FycmF5KHRvKSkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0aW50ZXJtZWRpYXRlID0gW107XG4gIFx0XHRpbnRlcnBvbGF0b3JzID0gW107XG5cbiAgXHRcdGkgPSBsZW4gPSBNYXRoLm1pbihmcm9tLmxlbmd0aCwgdG8ubGVuZ3RoKTtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0aW50ZXJwb2xhdG9yc1tpXSA9IHNoYXJlZF9pbnRlcnBvbGF0ZShmcm9tW2ldLCB0b1tpXSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHN1cnBsdXMgdmFsdWVzIC0gZG9uJ3QgaW50ZXJwb2xhdGUsIGJ1dCBkb24ndCBleGNsdWRlIHRoZW0gZWl0aGVyXG4gIFx0XHRmb3IgKGkgPSBsZW47IGkgPCBmcm9tLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRcdGludGVybWVkaWF0ZVtpXSA9IGZyb21baV07XG4gIFx0XHR9XG5cbiAgXHRcdGZvciAoaSA9IGxlbjsgaSA8IHRvLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRcdGludGVybWVkaWF0ZVtpXSA9IHRvW2ldO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgXHRcdFx0dmFyIGkgPSBsZW47XG5cbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdGludGVybWVkaWF0ZVtpXSA9IGludGVycG9sYXRvcnNbaV0odCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gaW50ZXJtZWRpYXRlO1xuICBcdFx0fTtcbiAgXHR9LFxuXG4gIFx0b2JqZWN0OiBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgXHRcdHZhciBwcm9wZXJ0aWVzLCBsZW4sIGludGVycG9sYXRvcnMsIGludGVybWVkaWF0ZSwgcHJvcDtcblxuICBcdFx0aWYgKCFpc09iamVjdChmcm9tKSB8fCAhaXNPYmplY3QodG8pKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRwcm9wZXJ0aWVzID0gW107XG4gIFx0XHRpbnRlcm1lZGlhdGUgPSB7fTtcbiAgXHRcdGludGVycG9sYXRvcnMgPSB7fTtcblxuICBcdFx0Zm9yIChwcm9wIGluIGZyb20pIHtcbiAgXHRcdFx0aWYgKGhhc093bi5jYWxsKGZyb20sIHByb3ApKSB7XG4gIFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKHRvLCBwcm9wKSkge1xuICBcdFx0XHRcdFx0cHJvcGVydGllcy5wdXNoKHByb3ApO1xuICBcdFx0XHRcdFx0aW50ZXJwb2xhdG9yc1twcm9wXSA9IHNoYXJlZF9pbnRlcnBvbGF0ZShmcm9tW3Byb3BdLCB0b1twcm9wXSk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdGludGVybWVkaWF0ZVtwcm9wXSA9IGZyb21bcHJvcF07XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGZvciAocHJvcCBpbiB0bykge1xuICBcdFx0XHRpZiAoaGFzT3duLmNhbGwodG8sIHByb3ApICYmICFoYXNPd24uY2FsbChmcm9tLCBwcm9wKSkge1xuICBcdFx0XHRcdGludGVybWVkaWF0ZVtwcm9wXSA9IHRvW3Byb3BdO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGxlbiA9IHByb3BlcnRpZXMubGVuZ3RoO1xuXG4gIFx0XHRyZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgXHRcdFx0dmFyIGkgPSBsZW4sXG4gIFx0XHRcdCAgICBwcm9wO1xuXG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRwcm9wID0gcHJvcGVydGllc1tpXTtcblxuICBcdFx0XHRcdGludGVybWVkaWF0ZVtwcm9wXSA9IGludGVycG9sYXRvcnNbcHJvcF0odCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gaW50ZXJtZWRpYXRlO1xuICBcdFx0fTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIHN0YXRpY19pbnRlcnBvbGF0b3JzID0gaW50ZXJwb2xhdG9ycztcblxuICAvLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGEga2V5cGF0aCBzdWNoIGFzICdmb28uYmFyLmJheicsIGFuZCByZXR1cm5zXG4gIC8vIGFsbCB0aGUgdmFyaWFudHMgb2YgdGhhdCBrZXlwYXRoIHRoYXQgaW5jbHVkZSBhIHdpbGRjYXJkIGluIHBsYWNlXG4gIC8vIG9mIGEga2V5LCBzdWNoIGFzICdmb28uYmFyLionLCAnZm9vLiouYmF6JywgJ2Zvby4qLionIGFuZCBzbyBvbi5cbiAgLy8gVGhlc2UgYXJlIHRoZW4gY2hlY2tlZCBhZ2FpbnN0IHRoZSBkZXBlbmRhbnRzIG1hcCAocmFjdGl2ZS52aWV3bW9kZWwuZGVwc01hcClcbiAgLy8gdG8gc2VlIGlmIGFueSBwYXR0ZXJuIG9ic2VydmVycyBhcmUgZG93bnN0cmVhbSBvZiBvbmUgb3IgbW9yZSBvZlxuICAvLyB0aGVzZSB3aWxkY2FyZCBrZXlwYXRocyAoZS5nLiAnZm9vLmJhci4qLnN0YXR1cycpXG4gIHZhciB1dGlsc19nZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMgPSBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXM7XG5cbiAgdmFyIHN0YXJNYXBzID0ge307XG4gIGZ1bmN0aW9uIGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyhrZXlwYXRoKSB7XG4gIFx0dmFyIGtleXMsIHN0YXJNYXAsIG1hcHBlciwgaSwgcmVzdWx0LCB3aWxkY2FyZEtleXBhdGg7XG5cbiAgXHRrZXlzID0ga2V5cGF0aC5zcGxpdChcIi5cIik7XG4gIFx0aWYgKCEoc3Rhck1hcCA9IHN0YXJNYXBzW2tleXMubGVuZ3RoXSkpIHtcbiAgXHRcdHN0YXJNYXAgPSBnZXRTdGFyTWFwKGtleXMubGVuZ3RoKTtcbiAgXHR9XG5cbiAgXHRyZXN1bHQgPSBbXTtcblxuICBcdG1hcHBlciA9IGZ1bmN0aW9uIChzdGFyLCBpKSB7XG4gIFx0XHRyZXR1cm4gc3RhciA/IFwiKlwiIDoga2V5c1tpXTtcbiAgXHR9O1xuXG4gIFx0aSA9IHN0YXJNYXAubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdHdpbGRjYXJkS2V5cGF0aCA9IHN0YXJNYXBbaV0ubWFwKG1hcHBlcikuam9pbihcIi5cIik7XG5cbiAgXHRcdGlmICghcmVzdWx0Lmhhc093blByb3BlcnR5KHdpbGRjYXJkS2V5cGF0aCkpIHtcbiAgXHRcdFx0cmVzdWx0LnB1c2god2lsZGNhcmRLZXlwYXRoKTtcbiAgXHRcdFx0cmVzdWx0W3dpbGRjYXJkS2V5cGF0aF0gPSB0cnVlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYWxsIHRoZSBwb3NzaWJsZSB0cnVlL2ZhbHNlIGNvbWJpbmF0aW9ucyBmb3JcbiAgLy8gYSBnaXZlbiBudW1iZXIgLSBlLmcuIGZvciB0d28sIHRoZSBwb3NzaWJsZSBjb21iaW5hdGlvbnMgYXJlXG4gIC8vIFsgdHJ1ZSwgdHJ1ZSBdLCBbIHRydWUsIGZhbHNlIF0sIFsgZmFsc2UsIHRydWUgXSwgWyBmYWxzZSwgZmFsc2UgXS5cbiAgLy8gSXQgZG9lcyBzbyBieSBnZXR0aW5nIGFsbCB0aGUgYmluYXJ5IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIGUuZy4gMTFcbiAgZnVuY3Rpb24gZ2V0U3Rhck1hcChudW0pIHtcbiAgXHR2YXIgb25lcyA9IFwiXCIsXG4gIFx0ICAgIG1heCxcbiAgXHQgICAgYmluYXJ5LFxuICBcdCAgICBzdGFyTWFwLFxuICBcdCAgICBtYXBwZXIsXG4gIFx0ICAgIGksXG4gIFx0ICAgIGosXG4gIFx0ICAgIGwsXG4gIFx0ICAgIG1hcDtcblxuICBcdGlmICghc3Rhck1hcHNbbnVtXSkge1xuICBcdFx0c3Rhck1hcCA9IFtdO1xuXG4gIFx0XHR3aGlsZSAob25lcy5sZW5ndGggPCBudW0pIHtcbiAgXHRcdFx0b25lcyArPSAxO1xuICBcdFx0fVxuXG4gIFx0XHRtYXggPSBwYXJzZUludChvbmVzLCAyKTtcblxuICBcdFx0bWFwcGVyID0gZnVuY3Rpb24gKGRpZ2l0KSB7XG4gIFx0XHRcdHJldHVybiBkaWdpdCA9PT0gXCIxXCI7XG4gIFx0XHR9O1xuXG4gIFx0XHRmb3IgKGkgPSAwOyBpIDw9IG1heDsgaSArPSAxKSB7XG4gIFx0XHRcdGJpbmFyeSA9IGkudG9TdHJpbmcoMik7XG4gIFx0XHRcdHdoaWxlIChiaW5hcnkubGVuZ3RoIDwgbnVtKSB7XG4gIFx0XHRcdFx0YmluYXJ5ID0gXCIwXCIgKyBiaW5hcnk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRtYXAgPSBbXTtcbiAgXHRcdFx0bCA9IGJpbmFyeS5sZW5ndGg7XG4gIFx0XHRcdGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgXHRcdFx0XHRtYXAucHVzaChtYXBwZXIoYmluYXJ5W2pdKSk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0c3Rhck1hcFtpXSA9IG1hcDtcbiAgXHRcdH1cblxuICBcdFx0c3Rhck1hcHNbbnVtXSA9IHN0YXJNYXA7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHN0YXJNYXBzW251bV07XG4gIH1cblxuICB2YXIgcmVmUGF0dGVybiA9IC9cXFtcXHMqKFxcKnxbMC05XXxbMS05XVswLTldKylcXHMqXFxdL2c7XG4gIHZhciBwYXR0ZXJuUGF0dGVybiA9IC9cXCovO1xuICB2YXIga2V5cGF0aENhY2hlID0ge307XG5cbiAgdmFyIEtleXBhdGggPSBmdW5jdGlvbiAoc3RyKSB7XG4gIFx0dmFyIGtleXMgPSBzdHIuc3BsaXQoXCIuXCIpO1xuXG4gIFx0dGhpcy5zdHIgPSBzdHI7XG5cbiAgXHRpZiAoc3RyWzBdID09PSBcIkBcIikge1xuICBcdFx0dGhpcy5pc1NwZWNpYWwgPSB0cnVlO1xuICBcdFx0dGhpcy52YWx1ZSA9IGRlY29kZUtleXBhdGgoc3RyKTtcbiAgXHR9XG5cbiAgXHR0aGlzLmZpcnN0S2V5ID0ga2V5c1swXTtcbiAgXHR0aGlzLmxhc3RLZXkgPSBrZXlzLnBvcCgpO1xuXG4gIFx0dGhpcy5pc1BhdHRlcm4gPSBwYXR0ZXJuUGF0dGVybi50ZXN0KHN0cik7XG5cbiAgXHR0aGlzLnBhcmVudCA9IHN0ciA9PT0gXCJcIiA/IG51bGwgOiBnZXRLZXlwYXRoKGtleXMuam9pbihcIi5cIikpO1xuICBcdHRoaXMuaXNSb290ID0gIXN0cjtcbiAgfTtcblxuICBLZXlwYXRoLnByb3RvdHlwZSA9IHtcbiAgXHRlcXVhbHNPclN0YXJ0c1dpdGg6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRyZXR1cm4ga2V5cGF0aCA9PT0gdGhpcyB8fCB0aGlzLnN0YXJ0c1dpdGgoa2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdGpvaW46IGZ1bmN0aW9uIChzdHIpIHtcbiAgXHRcdHJldHVybiBnZXRLZXlwYXRoKHRoaXMuaXNSb290ID8gU3RyaW5nKHN0cikgOiB0aGlzLnN0ciArIFwiLlwiICsgc3RyKTtcbiAgXHR9LFxuXG4gIFx0cmVwbGFjZTogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdGlmICh0aGlzID09PSBvbGRLZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybiBuZXdLZXlwYXRoO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5zdGFydHNXaXRoKG9sZEtleXBhdGgpKSB7XG4gIFx0XHRcdHJldHVybiBuZXdLZXlwYXRoID09PSBudWxsID8gbmV3S2V5cGF0aCA6IGdldEtleXBhdGgodGhpcy5zdHIucmVwbGFjZShvbGRLZXlwYXRoLnN0ciArIFwiLlwiLCBuZXdLZXlwYXRoLnN0ciArIFwiLlwiKSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRpZiAoIWtleXBhdGgpIHtcbiAgXHRcdFx0Ly8gVE9ETyB1bmRlciB3aGF0IGNpcmN1bXN0YW5jZXMgZG9lcyB0aGlzIGhhcHBlbj9cbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ga2V5cGF0aCAmJiB0aGlzLnN0ci5zdWJzdHIoMCwga2V5cGF0aC5zdHIubGVuZ3RoICsgMSkgPT09IGtleXBhdGguc3RyICsgXCIuXCI7XG4gIFx0fSxcblxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJCYWQgY29lcmNpb25cIik7XG4gIFx0fSxcblxuICBcdHZhbHVlT2Y6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkJhZCBjb2VyY2lvblwiKTtcbiAgXHR9LFxuXG4gIFx0d2lsZGNhcmRNYXRjaGVzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fd2lsZGNhcmRNYXRjaGVzIHx8ICh0aGlzLl93aWxkY2FyZE1hdGNoZXMgPSB1dGlsc19nZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXModGhpcy5zdHIpKTtcbiAgXHR9XG4gIH07XG4gIGZ1bmN0aW9uIGFzc2lnbk5ld0tleXBhdGgodGFyZ2V0LCBwcm9wZXJ0eSwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdHZhciBleGlzdGluZ0tleXBhdGggPSB0YXJnZXRbcHJvcGVydHldO1xuXG4gIFx0aWYgKGV4aXN0aW5nS2V5cGF0aCAmJiAoZXhpc3RpbmdLZXlwYXRoLmVxdWFsc09yU3RhcnRzV2l0aChuZXdLZXlwYXRoKSB8fCAhZXhpc3RpbmdLZXlwYXRoLmVxdWFsc09yU3RhcnRzV2l0aChvbGRLZXlwYXRoKSkpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHR0YXJnZXRbcHJvcGVydHldID0gZXhpc3RpbmdLZXlwYXRoID8gZXhpc3RpbmdLZXlwYXRoLnJlcGxhY2Uob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkgOiBuZXdLZXlwYXRoO1xuICBcdHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlS2V5cGF0aChrZXlwYXRoKSB7XG4gIFx0dmFyIHZhbHVlID0ga2V5cGF0aC5zbGljZSgyKTtcblxuICBcdGlmIChrZXlwYXRoWzFdID09PSBcImlcIikge1xuICBcdFx0cmV0dXJuIGlzX19pc051bWVyaWModmFsdWUpID8gK3ZhbHVlIDogdmFsdWU7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJldHVybiB2YWx1ZTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRLZXlwYXRoKHN0cikge1xuICBcdGlmIChzdHIgPT0gbnVsbCkge1xuICBcdFx0cmV0dXJuIHN0cjtcbiAgXHR9XG5cbiAgXHQvLyBUT0RPIGl0ICptYXkqIGJlIHdvcnRoIGhhdmluZyB0d28gdmVyc2lvbnMgb2YgdGhpcyBmdW5jdGlvbiAtIG9uZSB3aGVyZVxuICBcdC8vIGtleXBhdGhDYWNoZSBpbmhlcml0cyBmcm9tIG51bGwsIGFuZCBvbmUgZm9yIElFOC4gRGVwZW5kcyBvbiBob3dcbiAgXHQvLyBtdWNoIG9mIGFuIG92ZXJoZWFkIGhhc093blByb3BlcnR5IGlzIC0gcHJvYmFibHkgbmVnbGlnaWJsZVxuICBcdGlmICgha2V5cGF0aENhY2hlLmhhc093blByb3BlcnR5KHN0cikpIHtcbiAgXHRcdGtleXBhdGhDYWNoZVtzdHJdID0gbmV3IEtleXBhdGgoc3RyKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ga2V5cGF0aENhY2hlW3N0cl07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNYXRjaGluZ0tleXBhdGhzKHJhY3RpdmUsIGtleXBhdGgpIHtcbiAgXHR2YXIga2V5cywga2V5LCBtYXRjaGluZ0tleXBhdGhzO1xuXG4gIFx0a2V5cyA9IGtleXBhdGguc3RyLnNwbGl0KFwiLlwiKTtcbiAgXHRtYXRjaGluZ0tleXBhdGhzID0gW3Jvb3RLZXlwYXRoXTtcblxuICBcdHdoaWxlIChrZXkgPSBrZXlzLnNoaWZ0KCkpIHtcbiAgXHRcdGlmIChrZXkgPT09IFwiKlwiKSB7XG4gIFx0XHRcdC8vIGV4cGFuZCB0byBmaW5kIGFsbCB2YWxpZCBjaGlsZCBrZXlwYXRoc1xuICBcdFx0XHRtYXRjaGluZ0tleXBhdGhzID0gbWF0Y2hpbmdLZXlwYXRocy5yZWR1Y2UoZXhwYW5kLCBbXSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRpZiAobWF0Y2hpbmdLZXlwYXRoc1swXSA9PT0gcm9vdEtleXBhdGgpIHtcbiAgXHRcdFx0XHQvLyBmaXJzdCBrZXlcbiAgXHRcdFx0XHRtYXRjaGluZ0tleXBhdGhzWzBdID0gZ2V0S2V5cGF0aChrZXkpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdG1hdGNoaW5nS2V5cGF0aHMgPSBtYXRjaGluZ0tleXBhdGhzLm1hcChjb25jYXRlbmF0ZShrZXkpKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBtYXRjaGluZ0tleXBhdGhzO1xuXG4gIFx0ZnVuY3Rpb24gZXhwYW5kKG1hdGNoaW5nS2V5cGF0aHMsIGtleXBhdGgpIHtcbiAgXHRcdHZhciB3cmFwcGVyLCB2YWx1ZSwga2V5cztcblxuICBcdFx0aWYgKGtleXBhdGguaXNSb290KSB7XG4gIFx0XHRcdGtleXMgPSBbXS5jb25jYXQoT2JqZWN0LmtleXMocmFjdGl2ZS52aWV3bW9kZWwuZGF0YSksIE9iamVjdC5rZXlzKHJhY3RpdmUudmlld21vZGVsLm1hcHBpbmdzKSwgT2JqZWN0LmtleXMocmFjdGl2ZS52aWV3bW9kZWwuY29tcHV0YXRpb25zKSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR3cmFwcGVyID0gcmFjdGl2ZS52aWV3bW9kZWwud3JhcHBlZFtrZXlwYXRoLnN0cl07XG4gIFx0XHRcdHZhbHVlID0gd3JhcHBlciA/IHdyYXBwZXIuZ2V0KCkgOiByYWN0aXZlLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRcdFx0a2V5cyA9IHZhbHVlID8gT2JqZWN0LmtleXModmFsdWUpIDogbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGtleXMpIHtcbiAgXHRcdFx0a2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdFx0XHRpZiAoa2V5ICE9PSBcIl9yYWN0aXZlXCIgfHwgIWlzQXJyYXkodmFsdWUpKSB7XG4gIFx0XHRcdFx0XHRtYXRjaGluZ0tleXBhdGhzLnB1c2goa2V5cGF0aC5qb2luKGtleSkpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBtYXRjaGluZ0tleXBhdGhzO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmNhdGVuYXRlKGtleSkge1xuICBcdHJldHVybiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0cmV0dXJuIGtleXBhdGguam9pbihrZXkpO1xuICBcdH07XG4gIH1cbiAgZnVuY3Rpb24gbm9ybWFsaXNlKHJlZikge1xuICBcdHJldHVybiByZWYgPyByZWYucmVwbGFjZShyZWZQYXR0ZXJuLCBcIi4kMVwiKSA6IFwiXCI7XG4gIH1cblxuICB2YXIgcm9vdEtleXBhdGggPSBnZXRLZXlwYXRoKFwiXCIpO1xuXG4gIHZhciBzaGFyZWRfYWRkID0gYWRkO1xuICB2YXIgc2hhcmVkX2FkZF9fZXJyb3JNZXNzYWdlID0gXCJDYW5ub3QgYWRkIHRvIGEgbm9uLW51bWVyaWMgdmFsdWVcIjtcbiAgZnVuY3Rpb24gYWRkKHJvb3QsIGtleXBhdGgsIGQpIHtcbiAgXHRpZiAodHlwZW9mIGtleXBhdGggIT09IFwic3RyaW5nXCIgfHwgIWlzX19pc051bWVyaWMoZCkpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkJhZCBhcmd1bWVudHNcIik7XG4gIFx0fVxuXG4gIFx0dmFyIHZhbHVlID0gdW5kZWZpbmVkLFxuICBcdCAgICBjaGFuZ2VzID0gdW5kZWZpbmVkO1xuXG4gIFx0aWYgKC9cXCovLnRlc3Qoa2V5cGF0aCkpIHtcbiAgXHRcdGNoYW5nZXMgPSB7fTtcblxuICBcdFx0Z2V0TWF0Y2hpbmdLZXlwYXRocyhyb290LCBnZXRLZXlwYXRoKG5vcm1hbGlzZShrZXlwYXRoKSkpLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0dmFyIHZhbHVlID0gcm9vdC52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuXG4gIFx0XHRcdGlmICghaXNfX2lzTnVtZXJpYyh2YWx1ZSkpIHtcbiAgXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3Ioc2hhcmVkX2FkZF9fZXJyb3JNZXNzYWdlKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNoYW5nZXNba2V5cGF0aC5zdHJdID0gdmFsdWUgKyBkO1xuICBcdFx0fSk7XG5cbiAgXHRcdHJldHVybiByb290LnNldChjaGFuZ2VzKTtcbiAgXHR9XG5cbiAgXHR2YWx1ZSA9IHJvb3QuZ2V0KGtleXBhdGgpO1xuXG4gIFx0aWYgKCFpc19faXNOdW1lcmljKHZhbHVlKSkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKHNoYXJlZF9hZGRfX2Vycm9yTWVzc2FnZSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHJvb3Quc2V0KGtleXBhdGgsICt2YWx1ZSArIGQpO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9hZGQgPSBSYWN0aXZlJGFkZDtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRhZGQoa2V5cGF0aCwgZCkge1xuICBcdHJldHVybiBzaGFyZWRfYWRkKHRoaXMsIGtleXBhdGgsIGQgPT09IHVuZGVmaW5lZCA/IDEgOiArZCk7XG4gIH1cblxuICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXG4gIC8vIElmIHdpbmRvdyBkb2Vzbid0IGV4aXN0LCB3ZSBkb24ndCBuZWVkIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICBcdHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gIFx0Ly8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzE1Nzk2NzFcbiAgXHQoZnVuY3Rpb24gKHZlbmRvcnMsIGxhc3RUaW1lLCB3aW5kb3cpIHtcblxuICBcdFx0dmFyIHgsIHNldFRpbWVvdXQ7XG5cbiAgXHRcdGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Zm9yICh4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcbiAgXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgXCJSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl07XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICBcdFx0XHRzZXRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQ7XG5cbiAgXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBcdFx0XHRcdHZhciBjdXJyVGltZSwgdGltZVRvQ2FsbCwgaWQ7XG5cbiAgXHRcdFx0XHRjdXJyVGltZSA9IERhdGUubm93KCk7XG4gIFx0XHRcdFx0dGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcbiAgXHRcdFx0XHRpZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0Y2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTtcbiAgXHRcdFx0XHR9LCB0aW1lVG9DYWxsKTtcblxuICBcdFx0XHRcdGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICBcdFx0XHRcdHJldHVybiBpZDtcbiAgXHRcdFx0fTtcbiAgXHRcdH1cbiAgXHR9KSh2ZW5kb3JzLCAwLCB3aW5kb3cpO1xuXG4gIFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgfVxuXG4gIHZhciByQUYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cbiAgdmFyIGdldFRpbWU7XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnBlcmZvcm1hbmNlICYmIHR5cGVvZiB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRnZXRUaW1lID0gZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgXHR9O1xuICB9IGVsc2Uge1xuICBcdGdldFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gRGF0ZS5ub3coKTtcbiAgXHR9O1xuICB9XG5cbiAgdmFyIHV0aWxzX2dldFRpbWUgPSBnZXRUaW1lO1xuXG4gIHZhciBkZXByZWNhdGlvbnMgPSB7XG4gIFx0Y29uc3RydWN0OiB7XG4gIFx0XHRkZXByZWNhdGVkOiBcImJlZm9yZUluaXRcIixcbiAgXHRcdHJlcGxhY2VtZW50OiBcIm9uY29uc3RydWN0XCJcbiAgXHR9LFxuICBcdHJlbmRlcjoge1xuICBcdFx0ZGVwcmVjYXRlZDogXCJpbml0XCIsXG4gIFx0XHRtZXNzYWdlOiBcIlRoZSBcXFwiaW5pdFxcXCIgbWV0aG9kIGhhcyBiZWVuIGRlcHJlY2F0ZWQgXCIgKyBcImFuZCB3aWxsIGxpa2VseSBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuIFwiICsgXCJZb3UgY2FuIGVpdGhlciB1c2UgdGhlIFxcXCJvbmluaXRcXFwiIG1ldGhvZCB3aGljaCB3aWxsIGZpcmUgXCIgKyBcIm9ubHkgb25jZSBwcmlvciB0bywgYW5kIHJlZ2FyZGxlc3Mgb2YsIGFueSBldmVudHVhbCByYWN0aXZlIFwiICsgXCJpbnN0YW5jZSBiZWluZyByZW5kZXJlZCwgb3IgaWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBcIiArIFwicmVuZGVyZWQgRE9NLCB1c2UgXFxcIm9ucmVuZGVyXFxcIiBpbnN0ZWFkLiBcIiArIFwiU2VlIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L21pZ3JhdGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIlxuICBcdH0sXG4gIFx0Y29tcGxldGU6IHtcbiAgXHRcdGRlcHJlY2F0ZWQ6IFwiY29tcGxldGVcIixcbiAgXHRcdHJlcGxhY2VtZW50OiBcIm9uY29tcGxldGVcIlxuICBcdH1cbiAgfTtcblxuICBmdW5jdGlvbiBIb29rKGV2ZW50KSB7XG4gIFx0dGhpcy5ldmVudCA9IGV2ZW50O1xuICBcdHRoaXMubWV0aG9kID0gXCJvblwiICsgZXZlbnQ7XG4gIFx0dGhpcy5kZXByZWNhdGUgPSBkZXByZWNhdGlvbnNbZXZlbnRdO1xuICB9XG5cbiAgSG9vay5wcm90b3R5cGUuZmlyZSA9IGZ1bmN0aW9uIChyYWN0aXZlLCBhcmcpIHtcbiAgXHRmdW5jdGlvbiBjYWxsKG1ldGhvZCkge1xuICBcdFx0aWYgKHJhY3RpdmVbbWV0aG9kXSkge1xuICBcdFx0XHRhcmcgPyByYWN0aXZlW21ldGhvZF0oYXJnKSA6IHJhY3RpdmVbbWV0aG9kXSgpO1xuICBcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRjYWxsKHRoaXMubWV0aG9kKTtcblxuICBcdGlmICghcmFjdGl2ZVt0aGlzLm1ldGhvZF0gJiYgdGhpcy5kZXByZWNhdGUgJiYgY2FsbCh0aGlzLmRlcHJlY2F0ZS5kZXByZWNhdGVkKSkge1xuICBcdFx0aWYgKHRoaXMuZGVwcmVjYXRlLm1lc3NhZ2UpIHtcbiAgXHRcdFx0d2FybklmRGVidWcodGhpcy5kZXByZWNhdGUubWVzc2FnZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR3YXJuSWZEZWJ1ZyhcIlRoZSBtZXRob2QgXFxcIiVzXFxcIiBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIFxcXCIlc1xcXCIgYW5kIHdpbGwgbGlrZWx5IGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4gU2VlIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L21pZ3JhdGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIiwgdGhpcy5kZXByZWNhdGUuZGVwcmVjYXRlZCwgdGhpcy5kZXByZWNhdGUucmVwbGFjZW1lbnQpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGFyZyA/IHJhY3RpdmUuZmlyZSh0aGlzLmV2ZW50LCBhcmcpIDogcmFjdGl2ZS5maXJlKHRoaXMuZXZlbnQpO1xuICB9O1xuXG4gIHZhciBob29rc19Ib29rID0gSG9vaztcblxuICBmdW5jdGlvbiBhZGRUb0FycmF5KGFycmF5LCB2YWx1ZSkge1xuICBcdHZhciBpbmRleCA9IGFycmF5LmluZGV4T2YodmFsdWUpO1xuXG4gIFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0YXJyYXkucHVzaCh2YWx1ZSk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlDb250YWlucyhhcnJheSwgdmFsdWUpIHtcbiAgXHRmb3IgKHZhciBpID0gMCwgYyA9IGFycmF5Lmxlbmd0aDsgaSA8IGM7IGkrKykge1xuICBcdFx0aWYgKGFycmF5W2ldID09IHZhbHVlKSB7XG4gIFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5Q29udGVudHNNYXRjaChhLCBiKSB7XG4gIFx0dmFyIGk7XG5cbiAgXHRpZiAoIWlzQXJyYXkoYSkgfHwgIWlzQXJyYXkoYikpIHtcbiAgXHRcdHJldHVybiBmYWxzZTtcbiAgXHR9XG5cbiAgXHRpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fVxuXG4gIFx0aSA9IGEubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGlmIChhW2ldICE9PSBiW2ldKSB7XG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuc3VyZUFycmF5KHgpIHtcbiAgXHRpZiAodHlwZW9mIHggPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHJldHVybiBbeF07XG4gIFx0fVxuXG4gIFx0aWYgKHggPT09IHVuZGVmaW5lZCkge1xuICBcdFx0cmV0dXJuIFtdO1xuICBcdH1cblxuICBcdHJldHVybiB4O1xuICB9XG5cbiAgZnVuY3Rpb24gbGFzdEl0ZW0oYXJyYXkpIHtcbiAgXHRyZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVGcm9tQXJyYXkoYXJyYXksIG1lbWJlcikge1xuICBcdHZhciBpbmRleCA9IGFycmF5LmluZGV4T2YobWVtYmVyKTtcblxuICBcdGlmIChpbmRleCAhPT0gLTEpIHtcbiAgXHRcdGFycmF5LnNwbGljZShpbmRleCwgMSk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gdG9BcnJheShhcnJheUxpa2UpIHtcbiAgXHR2YXIgYXJyYXkgPSBbXSxcbiAgXHQgICAgaSA9IGFycmF5TGlrZS5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0YXJyYXlbaV0gPSBhcnJheUxpa2VbaV07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGFycmF5O1xuICB9XG5cbiAgdmFyIF9Qcm9taXNlLFxuICAgICAgUEVORElORyA9IHt9LFxuICAgICAgRlVMRklMTEVEID0ge30sXG4gICAgICBSRUpFQ1RFRCA9IHt9O1xuXG4gIGlmICh0eXBlb2YgUHJvbWlzZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0Ly8gdXNlIG5hdGl2ZSBQcm9taXNlXG4gIFx0X1Byb21pc2UgPSBQcm9taXNlO1xuICB9IGVsc2Uge1xuICBcdF9Qcm9taXNlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIFx0XHR2YXIgZnVsZmlsbGVkSGFuZGxlcnMgPSBbXSxcbiAgXHRcdCAgICByZWplY3RlZEhhbmRsZXJzID0gW10sXG4gIFx0XHQgICAgc3RhdGUgPSBQRU5ESU5HLFxuICBcdFx0ICAgIHJlc3VsdCxcbiAgXHRcdCAgICBkaXNwYXRjaEhhbmRsZXJzLFxuICBcdFx0ICAgIG1ha2VSZXNvbHZlcixcbiAgXHRcdCAgICBmdWxmaWwsXG4gIFx0XHQgICAgcmVqZWN0LFxuICBcdFx0ICAgIHByb21pc2U7XG5cbiAgXHRcdG1ha2VSZXNvbHZlciA9IGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuICBcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHRcdFx0aWYgKHN0YXRlICE9PSBQRU5ESU5HKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0cmVzdWx0ID0gdmFsdWU7XG4gIFx0XHRcdFx0c3RhdGUgPSBuZXdTdGF0ZTtcblxuICBcdFx0XHRcdGRpc3BhdGNoSGFuZGxlcnMgPSBtYWtlRGlzcGF0Y2hlcihzdGF0ZSA9PT0gRlVMRklMTEVEID8gZnVsZmlsbGVkSGFuZGxlcnMgOiByZWplY3RlZEhhbmRsZXJzLCByZXN1bHQpO1xuXG4gIFx0XHRcdFx0Ly8gZGlzcGF0Y2ggb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgaGFuZGxlcnMgYXN5bmNocm9ub3VzbHlcbiAgXHRcdFx0XHR3YWl0KGRpc3BhdGNoSGFuZGxlcnMpO1xuICBcdFx0XHR9O1xuICBcdFx0fTtcblxuICBcdFx0ZnVsZmlsID0gbWFrZVJlc29sdmVyKEZVTEZJTExFRCk7XG4gIFx0XHRyZWplY3QgPSBtYWtlUmVzb2x2ZXIoUkVKRUNURUQpO1xuXG4gIFx0XHR0cnkge1xuICBcdFx0XHRjYWxsYmFjayhmdWxmaWwsIHJlamVjdCk7XG4gIFx0XHR9IGNhdGNoIChlcnIpIHtcbiAgXHRcdFx0cmVqZWN0KGVycik7XG4gIFx0XHR9XG5cbiAgXHRcdHByb21pc2UgPSB7XG4gIFx0XHRcdC8vIGB0aGVuKClgIHJldHVybnMgYSBQcm9taXNlIC0gMi4yLjdcbiAgXHRcdFx0dGhlbjogZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIFx0XHRcdFx0dmFyIHByb21pc2UyID0gbmV3IF9Qcm9taXNlKGZ1bmN0aW9uIChmdWxmaWwsIHJlamVjdCkge1xuXG4gIFx0XHRcdFx0XHR2YXIgcHJvY2Vzc1Jlc29sdXRpb25IYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIsIGhhbmRsZXJzLCBmb3J3YXJkKSB7XG5cbiAgXHRcdFx0XHRcdFx0Ly8gMi4yLjEuMVxuICBcdFx0XHRcdFx0XHRpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRcdFx0XHRcdGhhbmRsZXJzLnB1c2goZnVuY3Rpb24gKHAxcmVzdWx0KSB7XG4gIFx0XHRcdFx0XHRcdFx0XHR2YXIgeDtcblxuICBcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcbiAgXHRcdFx0XHRcdFx0XHRcdFx0eCA9IGhhbmRsZXIocDFyZXN1bHQpO1xuICBcdFx0XHRcdFx0XHRcdFx0XHR1dGlsc19Qcm9taXNlX19yZXNvbHZlKHByb21pc2UyLCB4LCBmdWxmaWwsIHJlamVjdCk7XG4gIFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcbiAgXHRcdFx0XHRcdFx0XHRcdFx0cmVqZWN0KGVycik7XG4gIFx0XHRcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRcdFx0Ly8gRm9yd2FyZCB0aGUgcmVzdWx0IG9mIHByb21pc2UxIHRvIHByb21pc2UyLCBpZiByZXNvbHV0aW9uIGhhbmRsZXJzXG4gIFx0XHRcdFx0XHRcdFx0Ly8gYXJlIG5vdCBnaXZlblxuICBcdFx0XHRcdFx0XHRcdGhhbmRsZXJzLnB1c2goZm9yd2FyZCk7XG4gIFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdH07XG5cbiAgXHRcdFx0XHRcdC8vIDIuMlxuICBcdFx0XHRcdFx0cHJvY2Vzc1Jlc29sdXRpb25IYW5kbGVyKG9uRnVsZmlsbGVkLCBmdWxmaWxsZWRIYW5kbGVycywgZnVsZmlsKTtcbiAgXHRcdFx0XHRcdHByb2Nlc3NSZXNvbHV0aW9uSGFuZGxlcihvblJlamVjdGVkLCByZWplY3RlZEhhbmRsZXJzLCByZWplY3QpO1xuXG4gIFx0XHRcdFx0XHRpZiAoc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByb21pc2UgaGFzIHJlc29sdmVkIGFscmVhZHksIGRpc3BhdGNoIHRoZSBhcHByb3ByaWF0ZSBoYW5kbGVycyBhc3luY2hyb25vdXNseVxuICBcdFx0XHRcdFx0XHR3YWl0KGRpc3BhdGNoSGFuZGxlcnMpO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH0pO1xuXG4gIFx0XHRcdFx0cmV0dXJuIHByb21pc2UyO1xuICBcdFx0XHR9XG4gIFx0XHR9O1xuXG4gIFx0XHRwcm9taXNlW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xuICBcdFx0fTtcblxuICBcdFx0cmV0dXJuIHByb21pc2U7XG4gIFx0fTtcblxuICBcdF9Qcm9taXNlLmFsbCA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICBcdFx0cmV0dXJuIG5ldyBfUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsLCByZWplY3QpIHtcbiAgXHRcdFx0dmFyIHJlc3VsdCA9IFtdLFxuICBcdFx0XHQgICAgcGVuZGluZyxcbiAgXHRcdFx0ICAgIGksXG4gIFx0XHRcdCAgICBwcm9jZXNzUHJvbWlzZTtcblxuICBcdFx0XHRpZiAoIXByb21pc2VzLmxlbmd0aCkge1xuICBcdFx0XHRcdGZ1bGZpbChyZXN1bHQpO1xuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHByb2Nlc3NQcm9taXNlID0gZnVuY3Rpb24gKHByb21pc2UsIGkpIHtcbiAgXHRcdFx0XHRpZiAocHJvbWlzZSAmJiB0eXBlb2YgcHJvbWlzZS50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0XHRcdHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdFx0XHRcdFx0cmVzdWx0W2ldID0gdmFsdWU7XG4gIFx0XHRcdFx0XHRcdC0tcGVuZGluZyB8fCBmdWxmaWwocmVzdWx0KTtcbiAgXHRcdFx0XHRcdH0sIHJlamVjdCk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdHJlc3VsdFtpXSA9IHByb21pc2U7XG4gIFx0XHRcdFx0XHQtLXBlbmRpbmcgfHwgZnVsZmlsKHJlc3VsdCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9O1xuXG4gIFx0XHRcdHBlbmRpbmcgPSBpID0gcHJvbWlzZXMubGVuZ3RoO1xuICBcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0cHJvY2Vzc1Byb21pc2UocHJvbWlzZXNbaV0sIGkpO1xuICBcdFx0XHR9XG4gIFx0XHR9KTtcbiAgXHR9O1xuXG4gIFx0X1Byb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0cmV0dXJuIG5ldyBfUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsKSB7XG4gIFx0XHRcdGZ1bGZpbCh2YWx1ZSk7XG4gIFx0XHR9KTtcbiAgXHR9O1xuXG4gIFx0X1Byb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICBcdFx0cmV0dXJuIG5ldyBfUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsLCByZWplY3QpIHtcbiAgXHRcdFx0cmVqZWN0KHJlYXNvbik7XG4gIFx0XHR9KTtcbiAgXHR9O1xuICB9XG5cbiAgdmFyIHV0aWxzX1Byb21pc2UgPSBfUHJvbWlzZTtcblxuICAvLyBUT0RPIHVzZSBNdXRhdGlvbk9ic2VydmVycyBvciBzb21ldGhpbmcgdG8gc2ltdWxhdGUgc2V0SW1tZWRpYXRlXG4gIGZ1bmN0aW9uIHdhaXQoY2FsbGJhY2spIHtcbiAgXHRzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VEaXNwYXRjaGVyKGhhbmRsZXJzLCByZXN1bHQpIHtcbiAgXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGhhbmRsZXI7XG5cbiAgXHRcdHdoaWxlIChoYW5kbGVyID0gaGFuZGxlcnMuc2hpZnQoKSkge1xuICBcdFx0XHRoYW5kbGVyKHJlc3VsdCk7XG4gIFx0XHR9XG4gIFx0fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHV0aWxzX1Byb21pc2VfX3Jlc29sdmUocHJvbWlzZSwgeCwgZnVsZmlsLCByZWplY3QpIHtcbiAgXHQvLyBQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlXG4gIFx0dmFyIHRoZW47XG5cbiAgXHQvLyAyLjMuMVxuICBcdGlmICh4ID09PSBwcm9taXNlKSB7XG4gIFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSBwcm9taXNlJ3MgZnVsZmlsbG1lbnQgaGFuZGxlciBjYW5ub3QgcmV0dXJuIHRoZSBzYW1lIHByb21pc2VcIik7XG4gIFx0fVxuXG4gIFx0Ly8gMi4zLjJcbiAgXHRpZiAoeCBpbnN0YW5jZW9mIF9Qcm9taXNlKSB7XG4gIFx0XHR4LnRoZW4oZnVsZmlsLCByZWplY3QpO1xuICBcdH1cblxuICBcdC8vIDIuMy4zXG4gIFx0ZWxzZSBpZiAoeCAmJiAodHlwZW9mIHggPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgXHRcdHRyeSB7XG4gIFx0XHRcdHRoZW4gPSB4LnRoZW47IC8vIDIuMy4zLjFcbiAgXHRcdH0gY2F0Y2ggKGUpIHtcbiAgXHRcdFx0cmVqZWN0KGUpOyAvLyAyLjMuMy4yXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Ly8gMi4zLjMuM1xuICBcdFx0aWYgKHR5cGVvZiB0aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0dmFyIGNhbGxlZCwgcmVzb2x2ZVByb21pc2UsIHJlamVjdFByb21pc2U7XG5cbiAgXHRcdFx0cmVzb2x2ZVByb21pc2UgPSBmdW5jdGlvbiAoeSkge1xuICBcdFx0XHRcdGlmIChjYWxsZWQpIHtcbiAgXHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcbiAgXHRcdFx0XHR1dGlsc19Qcm9taXNlX19yZXNvbHZlKHByb21pc2UsIHksIGZ1bGZpbCwgcmVqZWN0KTtcbiAgXHRcdFx0fTtcblxuICBcdFx0XHRyZWplY3RQcm9taXNlID0gZnVuY3Rpb24gKHIpIHtcbiAgXHRcdFx0XHRpZiAoY2FsbGVkKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0fVxuICBcdFx0XHRcdGNhbGxlZCA9IHRydWU7XG4gIFx0XHRcdFx0cmVqZWN0KHIpO1xuICBcdFx0XHR9O1xuXG4gIFx0XHRcdHRyeSB7XG4gIFx0XHRcdFx0dGhlbi5jYWxsKHgsIHJlc29sdmVQcm9taXNlLCByZWplY3RQcm9taXNlKTtcbiAgXHRcdFx0fSBjYXRjaCAoZSkge1xuICBcdFx0XHRcdGlmICghY2FsbGVkKSB7XG4gIFx0XHRcdFx0XHQvLyAyLjMuMy4zLjQuMVxuICBcdFx0XHRcdFx0cmVqZWN0KGUpOyAvLyAyLjMuMy4zLjQuMlxuICBcdFx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcbiAgXHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGZ1bGZpbCh4KTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0ZnVsZmlsKHgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBnZXRJbm5lckNvbnRleHQgPSBmdW5jdGlvbiAoZnJhZ21lbnQpIHtcbiAgXHRkbyB7XG4gIFx0XHRpZiAoZnJhZ21lbnQuY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHJldHVybiBmcmFnbWVudC5jb250ZXh0O1xuICBcdFx0fVxuICBcdH0gd2hpbGUgKGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50KTtcblxuICBcdHJldHVybiByb290S2V5cGF0aDtcbiAgfTtcblxuICB2YXIgc2hhcmVkX3Jlc29sdmVSZWYgPSByZXNvbHZlUmVmO1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVSZWYocmFjdGl2ZSwgcmVmLCBmcmFnbWVudCkge1xuICBcdHZhciBrZXlwYXRoO1xuXG4gIFx0cmVmID0gbm9ybWFsaXNlKHJlZik7XG5cbiAgXHQvLyBJZiBhIHJlZmVyZW5jZSBiZWdpbnMgJ34vJywgaXQncyBhIHRvcC1sZXZlbCByZWZlcmVuY2VcbiAgXHRpZiAocmVmLnN1YnN0cigwLCAyKSA9PT0gXCJ+L1wiKSB7XG4gIFx0XHRrZXlwYXRoID0gZ2V0S2V5cGF0aChyZWYuc3Vic3RyaW5nKDIpKTtcbiAgXHRcdGNyZWF0ZU1hcHBpbmdJZk5lY2Vzc2FyeShyYWN0aXZlLCBrZXlwYXRoLmZpcnN0S2V5LCBmcmFnbWVudCk7XG4gIFx0fVxuXG4gIFx0Ly8gSWYgYSByZWZlcmVuY2UgYmVnaW5zIHdpdGggJy4nLCBpdCdzIGVpdGhlciBhIHJlc3RyaWN0ZWQgcmVmZXJlbmNlIG9yXG4gIFx0Ly8gYW4gYW5jZXN0b3IgcmVmZXJlbmNlLi4uXG4gIFx0ZWxzZSBpZiAocmVmWzBdID09PSBcIi5cIikge1xuICBcdFx0a2V5cGF0aCA9IHJlc29sdmVBbmNlc3RvclJlZihnZXRJbm5lckNvbnRleHQoZnJhZ21lbnQpLCByZWYpO1xuXG4gIFx0XHRpZiAoa2V5cGF0aCkge1xuICBcdFx0XHRjcmVhdGVNYXBwaW5nSWZOZWNlc3NhcnkocmFjdGl2ZSwga2V5cGF0aC5maXJzdEtleSwgZnJhZ21lbnQpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIC4uLm90aGVyd2lzZSB3ZSBuZWVkIHRvIGZpZ3VyZSBvdXQgdGhlIGtleXBhdGggYmFzZWQgb24gY29udGV4dFxuICBcdGVsc2Uge1xuICBcdFx0a2V5cGF0aCA9IHJlc29sdmVBbWJpZ3VvdXNSZWZlcmVuY2UocmFjdGl2ZSwgZ2V0S2V5cGF0aChyZWYpLCBmcmFnbWVudCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGtleXBhdGg7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlQW5jZXN0b3JSZWYoYmFzZUNvbnRleHQsIHJlZikge1xuICBcdHZhciBjb250ZXh0S2V5cztcblxuICBcdC8vIFRPRE8uLi5cbiAgXHRpZiAoYmFzZUNvbnRleHQgIT0gdW5kZWZpbmVkICYmIHR5cGVvZiBiYXNlQ29udGV4dCAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0YmFzZUNvbnRleHQgPSBiYXNlQ29udGV4dC5zdHI7XG4gIFx0fVxuXG4gIFx0Ly8ge3sufX0gbWVhbnMgJ2N1cnJlbnQgY29udGV4dCdcbiAgXHRpZiAocmVmID09PSBcIi5cIikgcmV0dXJuIGdldEtleXBhdGgoYmFzZUNvbnRleHQpO1xuXG4gIFx0Y29udGV4dEtleXMgPSBiYXNlQ29udGV4dCA/IGJhc2VDb250ZXh0LnNwbGl0KFwiLlwiKSA6IFtdO1xuXG4gIFx0Ly8gYW5jZXN0b3IgcmVmZXJlbmNlcyAoc3RhcnRpbmcgXCIuLi9cIikgZ28gdXAgdGhlIHRyZWVcbiAgXHRpZiAocmVmLnN1YnN0cigwLCAzKSA9PT0gXCIuLi9cIikge1xuICBcdFx0d2hpbGUgKHJlZi5zdWJzdHIoMCwgMykgPT09IFwiLi4vXCIpIHtcbiAgXHRcdFx0aWYgKCFjb250ZXh0S2V5cy5sZW5ndGgpIHtcbiAgXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmVzb2x2ZSByZWZlcmVuY2UgLSB0b28gbWFueSBcXFwiLi4vXFxcIiBwcmVmaXhlc1wiKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNvbnRleHRLZXlzLnBvcCgpO1xuICBcdFx0XHRyZWYgPSByZWYuc3Vic3RyaW5nKDMpO1xuICBcdFx0fVxuXG4gIFx0XHRjb250ZXh0S2V5cy5wdXNoKHJlZik7XG4gIFx0XHRyZXR1cm4gZ2V0S2V5cGF0aChjb250ZXh0S2V5cy5qb2luKFwiLlwiKSk7XG4gIFx0fVxuXG4gIFx0Ly8gbm90IGFuIGFuY2VzdG9yIHJlZmVyZW5jZSAtIG11c3QgYmUgYSByZXN0cmljdGVkIHJlZmVyZW5jZSAocHJlcGVuZGVkIHdpdGggXCIuXCIgb3IgXCIuL1wiKVxuICBcdGlmICghYmFzZUNvbnRleHQpIHtcbiAgXHRcdHJldHVybiBnZXRLZXlwYXRoKHJlZi5yZXBsYWNlKC9eXFwuXFwvPy8sIFwiXCIpKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gZ2V0S2V5cGF0aChiYXNlQ29udGV4dCArIHJlZi5yZXBsYWNlKC9eXFwuXFwvLywgXCIuXCIpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVBbWJpZ3VvdXNSZWZlcmVuY2UocmFjdGl2ZSwgcmVmLCBmcmFnbWVudCwgaXNQYXJlbnRMb29rdXApIHtcbiAgXHR2YXIgY29udGV4dCwga2V5LCBwYXJlbnRWYWx1ZSwgaGFzQ29udGV4dENoYWluLCBwYXJlbnRLZXlwYXRoO1xuXG4gIFx0aWYgKHJlZi5pc1Jvb3QpIHtcbiAgXHRcdHJldHVybiByZWY7XG4gIFx0fVxuXG4gIFx0a2V5ID0gcmVmLmZpcnN0S2V5O1xuXG4gIFx0d2hpbGUgKGZyYWdtZW50KSB7XG4gIFx0XHRjb250ZXh0ID0gZnJhZ21lbnQuY29udGV4dDtcbiAgXHRcdGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50O1xuXG4gIFx0XHRpZiAoIWNvbnRleHQpIHtcbiAgXHRcdFx0Y29udGludWU7XG4gIFx0XHR9XG5cbiAgXHRcdGhhc0NvbnRleHRDaGFpbiA9IHRydWU7XG4gIFx0XHRwYXJlbnRWYWx1ZSA9IHJhY3RpdmUudmlld21vZGVsLmdldChjb250ZXh0KTtcblxuICBcdFx0aWYgKHBhcmVudFZhbHVlICYmICh0eXBlb2YgcGFyZW50VmFsdWUgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHBhcmVudFZhbHVlID09PSBcImZ1bmN0aW9uXCIpICYmIGtleSBpbiBwYXJlbnRWYWx1ZSkge1xuICBcdFx0XHRyZXR1cm4gY29udGV4dC5qb2luKHJlZi5zdHIpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIFJvb3QvY29tcHV0ZWQvbWFwcGVkIHByb3BlcnR5P1xuICBcdGlmIChpc1Jvb3RQcm9wZXJ0eShyYWN0aXZlLnZpZXdtb2RlbCwga2V5KSkge1xuICBcdFx0cmV0dXJuIHJlZjtcbiAgXHR9XG5cbiAgXHQvLyBJZiB0aGlzIGlzIGFuIGlubGluZSBjb21wb25lbnQsIGFuZCBpdCdzIG5vdCBpc29sYXRlZCwgd2VcbiAgXHQvLyBjYW4gdHJ5IGdvaW5nIHVwIHRoZSBzY29wZSBjaGFpblxuICBcdGlmIChyYWN0aXZlLnBhcmVudCAmJiAhcmFjdGl2ZS5pc29sYXRlZCkge1xuICBcdFx0aGFzQ29udGV4dENoYWluID0gdHJ1ZTtcbiAgXHRcdGZyYWdtZW50ID0gcmFjdGl2ZS5jb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG5cbiAgXHRcdGtleSA9IGdldEtleXBhdGgoa2V5KTtcblxuICBcdFx0aWYgKHBhcmVudEtleXBhdGggPSByZXNvbHZlQW1iaWd1b3VzUmVmZXJlbmNlKHJhY3RpdmUucGFyZW50LCBrZXksIGZyYWdtZW50LCB0cnVlKSkge1xuICBcdFx0XHQvLyBXZSBuZWVkIHRvIGNyZWF0ZSBhbiBpbnRlci1jb21wb25lbnQgYmluZGluZ1xuICBcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5tYXAoa2V5LCB7XG4gIFx0XHRcdFx0b3JpZ2luOiByYWN0aXZlLnBhcmVudC52aWV3bW9kZWwsXG4gIFx0XHRcdFx0a2V5cGF0aDogcGFyZW50S2V5cGF0aFxuICBcdFx0XHR9KTtcblxuICBcdFx0XHRyZXR1cm4gcmVmO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIElmIHRoZXJlJ3Mgbm8gY29udGV4dCBjaGFpbiwgYW5kIHRoZSBpbnN0YW5jZSBpcyBlaXRoZXIgYSkgaXNvbGF0ZWQgb3JcbiAgXHQvLyBiKSBhbiBvcnBoYW4sIHRoZW4gd2Uga25vdyB0aGF0IHRoZSBrZXlwYXRoIGlzIGlkZW50aWNhbCB0byB0aGUgcmVmZXJlbmNlXG4gIFx0aWYgKCFpc1BhcmVudExvb2t1cCAmJiAhaGFzQ29udGV4dENoYWluKSB7XG4gIFx0XHQvLyB0aGUgZGF0YSBvYmplY3QgbmVlZHMgdG8gaGF2ZSBhIHByb3BlcnR5IGJ5IHRoaXMgbmFtZSxcbiAgXHRcdC8vIHRvIHByZXZlbnQgZnV0dXJlIGZhaWxlZCBsb29rdXBzXG4gIFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5zZXQocmVmLCB1bmRlZmluZWQpO1xuICBcdFx0cmV0dXJuIHJlZjtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVNYXBwaW5nSWZOZWNlc3NhcnkocmFjdGl2ZSwga2V5KSB7XG4gIFx0dmFyIHBhcmVudEtleXBhdGg7XG5cbiAgXHRpZiAoIXJhY3RpdmUucGFyZW50IHx8IHJhY3RpdmUuaXNvbGF0ZWQgfHwgaXNSb290UHJvcGVydHkocmFjdGl2ZS52aWV3bW9kZWwsIGtleSkpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRrZXkgPSBnZXRLZXlwYXRoKGtleSk7XG5cbiAgXHRpZiAocGFyZW50S2V5cGF0aCA9IHJlc29sdmVBbWJpZ3VvdXNSZWZlcmVuY2UocmFjdGl2ZS5wYXJlbnQsIGtleSwgcmFjdGl2ZS5jb21wb25lbnQucGFyZW50RnJhZ21lbnQsIHRydWUpKSB7XG4gIFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5tYXAoa2V5LCB7XG4gIFx0XHRcdG9yaWdpbjogcmFjdGl2ZS5wYXJlbnQudmlld21vZGVsLFxuICBcdFx0XHRrZXlwYXRoOiBwYXJlbnRLZXlwYXRoXG4gIFx0XHR9KTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBpc1Jvb3RQcm9wZXJ0eSh2aWV3bW9kZWwsIGtleSkge1xuICBcdC8vIHNwZWNpYWwgY2FzZSBmb3IgcmVmZXJlbmNlIHRvIHJvb3RcbiAgXHRyZXR1cm4ga2V5ID09PSBcIlwiIHx8IGtleSBpbiB2aWV3bW9kZWwuZGF0YSB8fCBrZXkgaW4gdmlld21vZGVsLmNvbXB1dGF0aW9ucyB8fCBrZXkgaW4gdmlld21vZGVsLm1hcHBpbmdzO1xuICB9XG5cbiAgZnVuY3Rpb24gdGVhcmRvd24oeCkge1xuICAgIHgudGVhcmRvd24oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ldGhvZENhbGxlcnNfX3VuYmluZCh4KSB7XG4gICAgeC51bmJpbmQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ldGhvZENhbGxlcnNfX3VucmVuZGVyKHgpIHtcbiAgICB4LnVucmVuZGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoeCkge1xuICAgIHguY2FuY2VsKCk7XG4gIH1cblxuICB2YXIgVHJhbnNpdGlvbk1hbmFnZXIgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHBhcmVudCkge1xuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgXHR0aGlzLnBhcmVudCA9IHBhcmVudDtcblxuICBcdHRoaXMuaW50cm9zID0gW107XG4gIFx0dGhpcy5vdXRyb3MgPSBbXTtcblxuICBcdHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgXHR0aGlzLnRvdGFsQ2hpbGRyZW4gPSB0aGlzLm91dHJvQ2hpbGRyZW4gPSAwO1xuXG4gIFx0dGhpcy5kZXRhY2hRdWV1ZSA9IFtdO1xuICBcdHRoaXMuZGVjb3JhdG9yUXVldWUgPSBbXTtcbiAgXHR0aGlzLm91dHJvc0NvbXBsZXRlID0gZmFsc2U7XG5cbiAgXHRpZiAocGFyZW50KSB7XG4gIFx0XHRwYXJlbnQuYWRkQ2hpbGQodGhpcyk7XG4gIFx0fVxuICB9O1xuXG4gIFRyYW5zaXRpb25NYW5hZ2VyLnByb3RvdHlwZSA9IHtcbiAgXHRhZGRDaGlsZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gIFx0XHR0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuXG4gIFx0XHR0aGlzLnRvdGFsQ2hpbGRyZW4gKz0gMTtcbiAgXHRcdHRoaXMub3V0cm9DaGlsZHJlbiArPSAxO1xuICBcdH0sXG5cbiAgXHRkZWNyZW1lbnRPdXRyb3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMub3V0cm9DaGlsZHJlbiAtPSAxO1xuICBcdFx0Y2hlY2sodGhpcyk7XG4gIFx0fSxcblxuICBcdGRlY3JlbWVudFRvdGFsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLnRvdGFsQ2hpbGRyZW4gLT0gMTtcbiAgXHRcdGNoZWNrKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRhZGQ6IGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7XG4gIFx0XHR2YXIgbGlzdCA9IHRyYW5zaXRpb24uaXNJbnRybyA/IHRoaXMuaW50cm9zIDogdGhpcy5vdXRyb3M7XG4gIFx0XHRsaXN0LnB1c2godHJhbnNpdGlvbik7XG4gIFx0fSxcblxuICBcdGFkZERlY29yYXRvcjogZnVuY3Rpb24gKGRlY29yYXRvcikge1xuICBcdFx0dGhpcy5kZWNvcmF0b3JRdWV1ZS5wdXNoKGRlY29yYXRvcik7XG4gIFx0fSxcblxuICBcdHJlbW92ZTogZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcbiAgXHRcdHZhciBsaXN0ID0gdHJhbnNpdGlvbi5pc0ludHJvID8gdGhpcy5pbnRyb3MgOiB0aGlzLm91dHJvcztcbiAgXHRcdHJlbW92ZUZyb21BcnJheShsaXN0LCB0cmFuc2l0aW9uKTtcbiAgXHRcdGNoZWNrKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgXHRcdGNoZWNrKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRkZXRhY2hOb2RlczogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5kZWNvcmF0b3JRdWV1ZS5mb3JFYWNoKHRlYXJkb3duKTtcbiAgXHRcdHRoaXMuZGV0YWNoUXVldWUuZm9yRWFjaChkZXRhY2gpO1xuICBcdFx0dGhpcy5jaGlsZHJlbi5mb3JFYWNoKGRldGFjaE5vZGVzKTtcbiAgXHR9XG4gIH07XG5cbiAgZnVuY3Rpb24gZGV0YWNoKGVsZW1lbnQpIHtcbiAgXHRlbGVtZW50LmRldGFjaCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGV0YWNoTm9kZXModG0pIHtcbiAgXHR0bS5kZXRhY2hOb2RlcygpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2sodG0pIHtcbiAgXHRpZiAoIXRtLnJlYWR5IHx8IHRtLm91dHJvcy5sZW5ndGggfHwgdG0ub3V0cm9DaGlsZHJlbikgcmV0dXJuO1xuXG4gIFx0Ly8gSWYgYWxsIG91dHJvcyBhcmUgY29tcGxldGUsIGFuZCB3ZSBoYXZlbid0IGFscmVhZHkgZG9uZSB0aGlzLFxuICBcdC8vIHdlIG5vdGlmeSB0aGUgcGFyZW50IGlmIHRoZXJlIGlzIG9uZSwgb3RoZXJ3aXNlXG4gIFx0Ly8gc3RhcnQgZGV0YWNoaW5nIG5vZGVzXG4gIFx0aWYgKCF0bS5vdXRyb3NDb21wbGV0ZSkge1xuICBcdFx0aWYgKHRtLnBhcmVudCkge1xuICBcdFx0XHR0bS5wYXJlbnQuZGVjcmVtZW50T3V0cm9zKHRtKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRtLmRldGFjaE5vZGVzKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRtLm91dHJvc0NvbXBsZXRlID0gdHJ1ZTtcbiAgXHR9XG5cbiAgXHQvLyBPbmNlIGV2ZXJ5dGhpbmcgaXMgZG9uZSwgd2UgY2FuIG5vdGlmeSBwYXJlbnQgdHJhbnNpdGlvblxuICBcdC8vIG1hbmFnZXIgYW5kIGNhbGwgdGhlIGNhbGxiYWNrXG4gIFx0aWYgKCF0bS5pbnRyb3MubGVuZ3RoICYmICF0bS50b3RhbENoaWxkcmVuKSB7XG4gIFx0XHRpZiAodHlwZW9mIHRtLmNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0dG0uY2FsbGJhY2soKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRtLnBhcmVudCkge1xuICBcdFx0XHR0bS5wYXJlbnQuZGVjcmVtZW50VG90YWwoKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgZ2xvYmFsX1RyYW5zaXRpb25NYW5hZ2VyID0gVHJhbnNpdGlvbk1hbmFnZXI7XG5cbiAgdmFyIGJhdGNoLFxuICAgICAgcnVubG9vcCxcbiAgICAgIHVucmVzb2x2ZWQgPSBbXSxcbiAgICAgIGNoYW5nZUhvb2sgPSBuZXcgaG9va3NfSG9vayhcImNoYW5nZVwiKTtcblxuICBydW5sb29wID0ge1xuICBcdHN0YXJ0OiBmdW5jdGlvbiAoaW5zdGFuY2UsIHJldHVyblByb21pc2UpIHtcbiAgXHRcdHZhciBwcm9taXNlLCBmdWxmaWxQcm9taXNlO1xuXG4gIFx0XHRpZiAocmV0dXJuUHJvbWlzZSkge1xuICBcdFx0XHRwcm9taXNlID0gbmV3IHV0aWxzX1Byb21pc2UoZnVuY3Rpb24gKGYpIHtcbiAgXHRcdFx0XHRyZXR1cm4gZnVsZmlsUHJvbWlzZSA9IGY7XG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuXG4gIFx0XHRiYXRjaCA9IHtcbiAgXHRcdFx0cHJldmlvdXNCYXRjaDogYmF0Y2gsXG4gIFx0XHRcdHRyYW5zaXRpb25NYW5hZ2VyOiBuZXcgZ2xvYmFsX1RyYW5zaXRpb25NYW5hZ2VyKGZ1bGZpbFByb21pc2UsIGJhdGNoICYmIGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyKSxcbiAgXHRcdFx0dmlld3M6IFtdLFxuICBcdFx0XHR0YXNrczogW10sXG4gIFx0XHRcdHJhY3RpdmVzOiBbXSxcbiAgXHRcdFx0aW5zdGFuY2U6IGluc3RhbmNlXG4gIFx0XHR9O1xuXG4gIFx0XHRpZiAoaW5zdGFuY2UpIHtcbiAgXHRcdFx0YmF0Y2gucmFjdGl2ZXMucHVzaChpbnN0YW5jZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBwcm9taXNlO1xuICBcdH0sXG5cbiAgXHRlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGZsdXNoQ2hhbmdlcygpO1xuXG4gIFx0XHRiYXRjaC50cmFuc2l0aW9uTWFuYWdlci5pbml0KCk7XG4gIFx0XHRpZiAoIWJhdGNoLnByZXZpb3VzQmF0Y2ggJiYgISFiYXRjaC5pbnN0YW5jZSkgYmF0Y2guaW5zdGFuY2Uudmlld21vZGVsLmNoYW5nZXMgPSBbXTtcbiAgXHRcdGJhdGNoID0gYmF0Y2gucHJldmlvdXNCYXRjaDtcbiAgXHR9LFxuXG4gIFx0YWRkUmFjdGl2ZTogZnVuY3Rpb24gKHJhY3RpdmUpIHtcbiAgXHRcdGlmIChiYXRjaCkge1xuICBcdFx0XHRhZGRUb0FycmF5KGJhdGNoLnJhY3RpdmVzLCByYWN0aXZlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmVnaXN0ZXJUcmFuc2l0aW9uOiBmdW5jdGlvbiAodHJhbnNpdGlvbikge1xuICBcdFx0dHJhbnNpdGlvbi5fbWFuYWdlciA9IGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyO1xuICBcdFx0YmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIuYWRkKHRyYW5zaXRpb24pO1xuICBcdH0sXG5cbiAgXHRyZWdpc3RlckRlY29yYXRvcjogZnVuY3Rpb24gKGRlY29yYXRvcikge1xuICBcdFx0YmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIuYWRkRGVjb3JhdG9yKGRlY29yYXRvcik7XG4gIFx0fSxcblxuICBcdGFkZFZpZXc6IGZ1bmN0aW9uICh2aWV3KSB7XG4gIFx0XHRiYXRjaC52aWV3cy5wdXNoKHZpZXcpO1xuICBcdH0sXG5cbiAgXHRhZGRVbnJlc29sdmVkOiBmdW5jdGlvbiAodGhpbmcpIHtcbiAgXHRcdHVucmVzb2x2ZWQucHVzaCh0aGluZyk7XG4gIFx0fSxcblxuICBcdHJlbW92ZVVucmVzb2x2ZWQ6IGZ1bmN0aW9uICh0aGluZykge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KHVucmVzb2x2ZWQsIHRoaW5nKTtcbiAgXHR9LFxuXG4gIFx0Ly8gc3luY2hyb25pc2Ugbm9kZSBkZXRhY2htZW50cyB3aXRoIHRyYW5zaXRpb24gZW5kc1xuICBcdGRldGFjaFdoZW5SZWFkeTogZnVuY3Rpb24gKHRoaW5nKSB7XG4gIFx0XHRiYXRjaC50cmFuc2l0aW9uTWFuYWdlci5kZXRhY2hRdWV1ZS5wdXNoKHRoaW5nKTtcbiAgXHR9LFxuXG4gIFx0c2NoZWR1bGVUYXNrOiBmdW5jdGlvbiAodGFzaywgcG9zdFJlbmRlcikge1xuICBcdFx0dmFyIF9iYXRjaDtcblxuICBcdFx0aWYgKCFiYXRjaCkge1xuICBcdFx0XHR0YXNrKCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRfYmF0Y2ggPSBiYXRjaDtcbiAgXHRcdFx0d2hpbGUgKHBvc3RSZW5kZXIgJiYgX2JhdGNoLnByZXZpb3VzQmF0Y2gpIHtcbiAgXHRcdFx0XHQvLyB0aGlzIGNhbid0IGhhcHBlbiB1bnRpbCB0aGUgRE9NIGhhcyBiZWVuIGZ1bGx5IHVwZGF0ZWRcbiAgXHRcdFx0XHQvLyBvdGhlcndpc2UgaW4gc29tZSBzaXR1YXRpb25zICh3aXRoIGNvbXBvbmVudHMgaW5zaWRlIGVsZW1lbnRzKVxuICBcdFx0XHRcdC8vIHRyYW5zaXRpb25zIGFuZCBkZWNvcmF0b3JzIHdpbGwgaW5pdGlhbGlzZSBwcmVtYXR1cmVseVxuICBcdFx0XHRcdF9iYXRjaCA9IF9iYXRjaC5wcmV2aW91c0JhdGNoO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0X2JhdGNoLnRhc2tzLnB1c2godGFzayk7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBnbG9iYWxfcnVubG9vcCA9IHJ1bmxvb3A7XG5cbiAgZnVuY3Rpb24gZmx1c2hDaGFuZ2VzKCkge1xuICBcdHZhciBpLCB0aGluZywgY2hhbmdlSGFzaDtcblxuICBcdHdoaWxlIChiYXRjaC5yYWN0aXZlcy5sZW5ndGgpIHtcbiAgXHRcdHRoaW5nID0gYmF0Y2gucmFjdGl2ZXMucG9wKCk7XG4gIFx0XHRjaGFuZ2VIYXNoID0gdGhpbmcudmlld21vZGVsLmFwcGx5Q2hhbmdlcygpO1xuXG4gIFx0XHRpZiAoY2hhbmdlSGFzaCkge1xuICBcdFx0XHRjaGFuZ2VIb29rLmZpcmUodGhpbmcsIGNoYW5nZUhhc2gpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGF0dGVtcHRLZXlwYXRoUmVzb2x1dGlvbigpO1xuXG4gIFx0Ly8gTm93IHRoYXQgY2hhbmdlcyBoYXZlIGJlZW4gZnVsbHkgcHJvcGFnYXRlZCwgd2UgY2FuIHVwZGF0ZSB0aGUgRE9NXG4gIFx0Ly8gYW5kIGNvbXBsZXRlIG90aGVyIHRhc2tzXG4gIFx0Zm9yIChpID0gMDsgaSA8IGJhdGNoLnZpZXdzLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRiYXRjaC52aWV3c1tpXS51cGRhdGUoKTtcbiAgXHR9XG4gIFx0YmF0Y2gudmlld3MubGVuZ3RoID0gMDtcblxuICBcdGZvciAoaSA9IDA7IGkgPCBiYXRjaC50YXNrcy5sZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0YmF0Y2gudGFza3NbaV0oKTtcbiAgXHR9XG4gIFx0YmF0Y2gudGFza3MubGVuZ3RoID0gMDtcblxuICBcdC8vIElmIHVwZGF0aW5nIHRoZSB2aWV3IGNhdXNlZCBzb21lIG1vZGVsIGJsb3diYWNrIC0gZS5nLiBhIHRyaXBsZVxuICBcdC8vIGNvbnRhaW5pbmcgPG9wdGlvbj4gZWxlbWVudHMgY2F1c2VkIHRoZSBiaW5kaW5nIG9uIHRoZSA8c2VsZWN0PlxuICBcdC8vIHRvIHVwZGF0ZSAtIHRoZW4gd2Ugc3RhcnQgb3ZlclxuICBcdGlmIChiYXRjaC5yYWN0aXZlcy5sZW5ndGgpIHJldHVybiBmbHVzaENoYW5nZXMoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dGVtcHRLZXlwYXRoUmVzb2x1dGlvbigpIHtcbiAgXHR2YXIgaSwgaXRlbSwga2V5cGF0aCwgcmVzb2x2ZWQ7XG5cbiAgXHRpID0gdW5yZXNvbHZlZC5sZW5ndGg7XG5cbiAgXHQvLyBzZWUgaWYgd2UgY2FuIHJlc29sdmUgYW55IHVucmVzb2x2ZWQgcmVmZXJlbmNlc1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGl0ZW0gPSB1bnJlc29sdmVkW2ldO1xuXG4gIFx0XHRpZiAoaXRlbS5rZXlwYXRoKSB7XG4gIFx0XHRcdC8vIGl0IHJlc29sdmVkIHNvbWUgb3RoZXIgd2F5LiBUT0RPIGhvdz8gdHdvLXdheSBiaW5kaW5nPyBTZWVtc1xuICBcdFx0XHQvLyB3ZWlyZCB0aGF0IHdlJ2Qgc3RpbGwgZW5kIHVwIGhlcmVcbiAgXHRcdFx0dW5yZXNvbHZlZC5zcGxpY2UoaSwgMSk7XG4gIFx0XHRcdGNvbnRpbnVlOyAvLyBhdm9pZCByZW1vdmluZyB0aGUgd3JvbmcgdGhpbmcgc2hvdWxkIHRoZSBuZXh0IGNvbmRpdGlvbiBiZSB0cnVlXG4gIFx0XHR9XG5cbiAgXHRcdGlmIChrZXlwYXRoID0gc2hhcmVkX3Jlc29sdmVSZWYoaXRlbS5yb290LCBpdGVtLnJlZiwgaXRlbS5wYXJlbnRGcmFnbWVudCkpIHtcbiAgXHRcdFx0KHJlc29sdmVkIHx8IChyZXNvbHZlZCA9IFtdKSkucHVzaCh7XG4gIFx0XHRcdFx0aXRlbTogaXRlbSxcbiAgXHRcdFx0XHRrZXlwYXRoOiBrZXlwYXRoXG4gIFx0XHRcdH0pO1xuXG4gIFx0XHRcdHVucmVzb2x2ZWQuc3BsaWNlKGksIDEpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChyZXNvbHZlZCkge1xuICBcdFx0cmVzb2x2ZWQuZm9yRWFjaChnbG9iYWxfcnVubG9vcF9fcmVzb2x2ZSk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZ2xvYmFsX3J1bmxvb3BfX3Jlc29sdmUocmVzb2x2ZWQpIHtcbiAgXHRyZXNvbHZlZC5pdGVtLnJlc29sdmUocmVzb2x2ZWQua2V5cGF0aCk7XG4gIH1cblxuICB2YXIgcXVldWUgPSBbXTtcblxuICB2YXIgYW5pbWF0aW9ucyA9IHtcbiAgXHR0aWNrOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgaSwgYW5pbWF0aW9uLCBub3c7XG5cbiAgXHRcdG5vdyA9IHV0aWxzX2dldFRpbWUoKTtcblxuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc3RhcnQoKTtcblxuICBcdFx0Zm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRcdGFuaW1hdGlvbiA9IHF1ZXVlW2ldO1xuXG4gIFx0XHRcdGlmICghYW5pbWF0aW9uLnRpY2sobm93KSkge1xuICBcdFx0XHRcdC8vIGFuaW1hdGlvbiBpcyBjb21wbGV0ZSwgcmVtb3ZlIGl0IGZyb20gdGhlIHN0YWNrLCBhbmQgZGVjcmVtZW50IGkgc28gd2UgZG9uJ3QgbWlzcyBvbmVcbiAgXHRcdFx0XHRxdWV1ZS5zcGxpY2UoaS0tLCAxKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcblxuICBcdFx0aWYgKHF1ZXVlLmxlbmd0aCkge1xuICBcdFx0XHRyQUYoYW5pbWF0aW9ucy50aWNrKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGFuaW1hdGlvbnMucnVubmluZyA9IGZhbHNlO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRhZGQ6IGZ1bmN0aW9uIChhbmltYXRpb24pIHtcbiAgXHRcdHF1ZXVlLnB1c2goYW5pbWF0aW9uKTtcblxuICBcdFx0aWYgKCFhbmltYXRpb25zLnJ1bm5pbmcpIHtcbiAgXHRcdFx0YW5pbWF0aW9ucy5ydW5uaW5nID0gdHJ1ZTtcbiAgXHRcdFx0ckFGKGFuaW1hdGlvbnMudGljayk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdC8vIFRPRE8gb3B0aW1pc2UgdGhpc1xuICBcdGFib3J0OiBmdW5jdGlvbiAoa2V5cGF0aCwgcm9vdCkge1xuICBcdFx0dmFyIGkgPSBxdWV1ZS5sZW5ndGgsXG4gIFx0XHQgICAgYW5pbWF0aW9uO1xuXG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGFuaW1hdGlvbiA9IHF1ZXVlW2ldO1xuXG4gIFx0XHRcdGlmIChhbmltYXRpb24ucm9vdCA9PT0gcm9vdCAmJiBhbmltYXRpb24ua2V5cGF0aCA9PT0ga2V5cGF0aCkge1xuICBcdFx0XHRcdGFuaW1hdGlvbi5zdG9wKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIHNoYXJlZF9hbmltYXRpb25zID0gYW5pbWF0aW9ucztcblxuICB2YXIgQW5pbWF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR2YXIga2V5O1xuXG4gIFx0dGhpcy5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gIFx0Ly8gZnJvbSBhbmQgdG9cbiAgXHRmb3IgKGtleSBpbiBvcHRpb25zKSB7XG4gIFx0XHRpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gIFx0XHRcdHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHR0aGlzLmludGVycG9sYXRvciA9IHNoYXJlZF9pbnRlcnBvbGF0ZSh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMucm9vdCwgdGhpcy5pbnRlcnBvbGF0b3IpO1xuICBcdHRoaXMucnVubmluZyA9IHRydWU7XG5cbiAgXHR0aGlzLnRpY2soKTtcbiAgfTtcblxuICBBbmltYXRpb24ucHJvdG90eXBlID0ge1xuICBcdHRpY2s6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBlbGFwc2VkLCB0LCB2YWx1ZSwgdGltZU5vdywgaW5kZXgsIGtleXBhdGg7XG5cbiAgXHRcdGtleXBhdGggPSB0aGlzLmtleXBhdGg7XG5cbiAgXHRcdGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgXHRcdFx0dGltZU5vdyA9IERhdGUubm93KCk7XG4gIFx0XHRcdGVsYXBzZWQgPSB0aW1lTm93IC0gdGhpcy5zdGFydFRpbWU7XG5cbiAgXHRcdFx0aWYgKGVsYXBzZWQgPj0gdGhpcy5kdXJhdGlvbikge1xuICBcdFx0XHRcdGlmIChrZXlwYXRoICE9PSBudWxsKSB7XG4gIFx0XHRcdFx0XHRnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLnJvb3QpO1xuICBcdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoa2V5cGF0aCwgdGhpcy50byk7XG4gIFx0XHRcdFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAodGhpcy5zdGVwKSB7XG4gIFx0XHRcdFx0XHR0aGlzLnN0ZXAoMSwgdGhpcy50byk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0dGhpcy5jb21wbGV0ZSh0aGlzLnRvKTtcblxuICBcdFx0XHRcdGluZGV4ID0gdGhpcy5yb290Ll9hbmltYXRpb25zLmluZGV4T2YodGhpcyk7XG5cbiAgXHRcdFx0XHQvLyBUT0RPIGludmVzdGlnYXRlIHdoeSB0aGlzIGhhcHBlbnNcbiAgXHRcdFx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdFx0XHR3YXJuSWZEZWJ1ZyhcIkFuaW1hdGlvbiB3YXMgbm90IGZvdW5kXCIpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdHRoaXMucm9vdC5fYW5pbWF0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gIFx0XHRcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gIFx0XHRcdFx0cmV0dXJuIGZhbHNlOyAvLyByZW1vdmUgZnJvbSB0aGUgc3RhY2tcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHQgPSB0aGlzLmVhc2luZyA/IHRoaXMuZWFzaW5nKGVsYXBzZWQgLyB0aGlzLmR1cmF0aW9uKSA6IGVsYXBzZWQgLyB0aGlzLmR1cmF0aW9uO1xuXG4gIFx0XHRcdGlmIChrZXlwYXRoICE9PSBudWxsKSB7XG4gIFx0XHRcdFx0dmFsdWUgPSB0aGlzLmludGVycG9sYXRvcih0KTtcbiAgXHRcdFx0XHRnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLnJvb3QpO1xuICBcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KGtleXBhdGgsIHZhbHVlKTtcbiAgXHRcdFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICh0aGlzLnN0ZXApIHtcbiAgXHRcdFx0XHR0aGlzLnN0ZXAodCwgdmFsdWUpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIHRydWU7IC8vIGtlZXAgaW4gdGhlIHN0YWNrXG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBmYWxzZTsgLy8gcmVtb3ZlIGZyb20gdGhlIHN0YWNrXG4gIFx0fSxcblxuICBcdHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBpbmRleDtcblxuICBcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cbiAgXHRcdGluZGV4ID0gdGhpcy5yb290Ll9hbmltYXRpb25zLmluZGV4T2YodGhpcyk7XG5cbiAgXHRcdC8vIFRPRE8gaW52ZXN0aWdhdGUgd2h5IHRoaXMgaGFwcGVuc1xuICBcdFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0XHR3YXJuSWZEZWJ1ZyhcIkFuaW1hdGlvbiB3YXMgbm90IGZvdW5kXCIpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnJvb3QuX2FuaW1hdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIGFuaW1hdGVfQW5pbWF0aW9uID0gQW5pbWF0aW9uO1xuXG4gIHZhciBwcm90b3R5cGVfYW5pbWF0ZSA9IFJhY3RpdmUkYW5pbWF0ZTtcblxuICB2YXIgbm9BbmltYXRpb24gPSB7IHN0b3A6IG5vb3AgfTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRhbmltYXRlKGtleXBhdGgsIHRvLCBvcHRpb25zKSB7XG4gIFx0dmFyIHByb21pc2UsIGZ1bGZpbFByb21pc2UsIGssIGFuaW1hdGlvbiwgYW5pbWF0aW9ucywgZWFzaW5nLCBkdXJhdGlvbiwgc3RlcCwgY29tcGxldGUsIG1ha2VWYWx1ZUNvbGxlY3RvciwgY3VycmVudFZhbHVlcywgY29sbGVjdFZhbHVlLCBkdW1teSwgZHVtbXlPcHRpb25zO1xuXG4gIFx0cHJvbWlzZSA9IG5ldyB1dGlsc19Qcm9taXNlKGZ1bmN0aW9uIChmdWxmaWwpIHtcbiAgXHRcdHJldHVybiBmdWxmaWxQcm9taXNlID0gZnVsZmlsO1xuICBcdH0pO1xuXG4gIFx0Ly8gYW5pbWF0ZSBtdWx0aXBsZSBrZXlwYXRoc1xuICBcdGlmICh0eXBlb2Yga2V5cGF0aCA9PT0gXCJvYmplY3RcIikge1xuICBcdFx0b3B0aW9ucyA9IHRvIHx8IHt9O1xuICBcdFx0ZWFzaW5nID0gb3B0aW9ucy5lYXNpbmc7XG4gIFx0XHRkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb247XG5cbiAgXHRcdGFuaW1hdGlvbnMgPSBbXTtcblxuICBcdFx0Ly8gd2UgZG9uJ3Qgd2FudCB0byBwYXNzIHRoZSBgc3RlcGAgYW5kIGBjb21wbGV0ZWAgaGFuZGxlcnMsIGFzIHRoZXkgd2lsbFxuICBcdFx0Ly8gcnVuIGZvciBlYWNoIGFuaW1hdGlvbiEgU28gaW5zdGVhZCB3ZSdsbCBzdG9yZSB0aGUgaGFuZGxlcnMgYW5kIGNyZWF0ZVxuICBcdFx0Ly8gb3VyIG93bi4uLlxuICBcdFx0c3RlcCA9IG9wdGlvbnMuc3RlcDtcbiAgXHRcdGNvbXBsZXRlID0gb3B0aW9ucy5jb21wbGV0ZTtcblxuICBcdFx0aWYgKHN0ZXAgfHwgY29tcGxldGUpIHtcbiAgXHRcdFx0Y3VycmVudFZhbHVlcyA9IHt9O1xuXG4gIFx0XHRcdG9wdGlvbnMuc3RlcCA9IG51bGw7XG4gIFx0XHRcdG9wdGlvbnMuY29tcGxldGUgPSBudWxsO1xuXG4gIFx0XHRcdG1ha2VWYWx1ZUNvbGxlY3RvciA9IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uICh0LCB2YWx1ZSkge1xuICBcdFx0XHRcdFx0Y3VycmVudFZhbHVlc1trZXlwYXRoXSA9IHZhbHVlO1xuICBcdFx0XHRcdH07XG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdGZvciAoayBpbiBrZXlwYXRoKSB7XG4gIFx0XHRcdGlmIChrZXlwYXRoLmhhc093blByb3BlcnR5KGspKSB7XG4gIFx0XHRcdFx0aWYgKHN0ZXAgfHwgY29tcGxldGUpIHtcbiAgXHRcdFx0XHRcdGNvbGxlY3RWYWx1ZSA9IG1ha2VWYWx1ZUNvbGxlY3RvcihrKTtcbiAgXHRcdFx0XHRcdG9wdGlvbnMgPSB7IGVhc2luZzogZWFzaW5nLCBkdXJhdGlvbjogZHVyYXRpb24gfTtcblxuICBcdFx0XHRcdFx0aWYgKHN0ZXApIHtcbiAgXHRcdFx0XHRcdFx0b3B0aW9ucy5zdGVwID0gY29sbGVjdFZhbHVlO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdG9wdGlvbnMuY29tcGxldGUgPSBjb21wbGV0ZSA/IGNvbGxlY3RWYWx1ZSA6IG5vb3A7XG4gIFx0XHRcdFx0YW5pbWF0aW9ucy5wdXNoKGFuaW1hdGUodGhpcywgaywga2V5cGF0aFtrXSwgb3B0aW9ucykpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIENyZWF0ZSBhIGR1bW15IGFuaW1hdGlvbiwgdG8gZmFjaWxpdGF0ZSBzdGVwL2NvbXBsZXRlXG4gIFx0XHQvLyBjYWxsYmFja3MsIGFuZCBQcm9taXNlIGZ1bGZpbG1lbnRcbiAgXHRcdGR1bW15T3B0aW9ucyA9IHsgZWFzaW5nOiBlYXNpbmcsIGR1cmF0aW9uOiBkdXJhdGlvbiB9O1xuXG4gIFx0XHRpZiAoc3RlcCkge1xuICBcdFx0XHRkdW1teU9wdGlvbnMuc3RlcCA9IGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRcdFx0cmV0dXJuIHN0ZXAodCwgY3VycmVudFZhbHVlcyk7XG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChjb21wbGV0ZSkge1xuICBcdFx0XHRwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHQpIHtcbiAgXHRcdFx0XHRyZXR1cm4gY29tcGxldGUodCwgY3VycmVudFZhbHVlcyk7XG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuXG4gIFx0XHRkdW1teU9wdGlvbnMuY29tcGxldGUgPSBmdWxmaWxQcm9taXNlO1xuXG4gIFx0XHRkdW1teSA9IGFuaW1hdGUodGhpcywgbnVsbCwgbnVsbCwgZHVtbXlPcHRpb25zKTtcbiAgXHRcdGFuaW1hdGlvbnMucHVzaChkdW1teSk7XG5cbiAgXHRcdHByb21pc2Uuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dmFyIGFuaW1hdGlvbjtcblxuICBcdFx0XHR3aGlsZSAoYW5pbWF0aW9uID0gYW5pbWF0aW9ucy5wb3AoKSkge1xuICBcdFx0XHRcdGFuaW1hdGlvbi5zdG9wKCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoZHVtbXkpIHtcbiAgXHRcdFx0XHRkdW1teS5zdG9wKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH07XG5cbiAgXHRcdHJldHVybiBwcm9taXNlO1xuICBcdH1cblxuICBcdC8vIGFuaW1hdGUgYSBzaW5nbGUga2V5cGF0aFxuICBcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIFx0aWYgKG9wdGlvbnMuY29tcGxldGUpIHtcbiAgXHRcdHByb21pc2UudGhlbihvcHRpb25zLmNvbXBsZXRlKTtcbiAgXHR9XG5cbiAgXHRvcHRpb25zLmNvbXBsZXRlID0gZnVsZmlsUHJvbWlzZTtcbiAgXHRhbmltYXRpb24gPSBhbmltYXRlKHRoaXMsIGtleXBhdGgsIHRvLCBvcHRpb25zKTtcblxuICBcdHByb21pc2Uuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBhbmltYXRpb24uc3RvcCgpO1xuICBcdH07XG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBhbmltYXRlKHJvb3QsIGtleXBhdGgsIHRvLCBvcHRpb25zKSB7XG4gIFx0dmFyIGVhc2luZywgZHVyYXRpb24sIGFuaW1hdGlvbiwgZnJvbTtcblxuICBcdGlmIChrZXlwYXRoKSB7XG4gIFx0XHRrZXlwYXRoID0gZ2V0S2V5cGF0aChub3JtYWxpc2Uoa2V5cGF0aCkpO1xuICBcdH1cblxuICBcdGlmIChrZXlwYXRoICE9PSBudWxsKSB7XG4gIFx0XHRmcm9tID0gcm9vdC52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuICBcdH1cblxuICBcdC8vIGNhbmNlbCBhbnkgZXhpc3RpbmcgYW5pbWF0aW9uXG4gIFx0Ly8gVE9ETyB3aGF0IGFib3V0IHVwc3RyZWFtL2Rvd25zdHJlYW0ga2V5cGF0aHM/XG4gIFx0c2hhcmVkX2FuaW1hdGlvbnMuYWJvcnQoa2V5cGF0aCwgcm9vdCk7XG5cbiAgXHQvLyBkb24ndCBib3RoZXIgYW5pbWF0aW5nIHZhbHVlcyB0aGF0IHN0YXkgdGhlIHNhbWVcbiAgXHRpZiAoaXNFcXVhbChmcm9tLCB0bykpIHtcbiAgXHRcdGlmIChvcHRpb25zLmNvbXBsZXRlKSB7XG4gIFx0XHRcdG9wdGlvbnMuY29tcGxldGUob3B0aW9ucy50byk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBub0FuaW1hdGlvbjtcbiAgXHR9XG5cbiAgXHQvLyBlYXNpbmcgZnVuY3Rpb25cbiAgXHRpZiAob3B0aW9ucy5lYXNpbmcpIHtcbiAgXHRcdGlmICh0eXBlb2Ygb3B0aW9ucy5lYXNpbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRlYXNpbmcgPSBvcHRpb25zLmVhc2luZztcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGVhc2luZyA9IHJvb3QuZWFzaW5nW29wdGlvbnMuZWFzaW5nXTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHR5cGVvZiBlYXNpbmcgIT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRlYXNpbmcgPSBudWxsO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIGR1cmF0aW9uXG4gIFx0ZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uID09PSB1bmRlZmluZWQgPyA0MDAgOiBvcHRpb25zLmR1cmF0aW9uO1xuXG4gIFx0Ly8gVE9ETyBzdG9yZSBrZXlzLCB1c2UgYW4gaW50ZXJuYWwgc2V0IG1ldGhvZFxuICBcdGFuaW1hdGlvbiA9IG5ldyBhbmltYXRlX0FuaW1hdGlvbih7XG4gIFx0XHRrZXlwYXRoOiBrZXlwYXRoLFxuICBcdFx0ZnJvbTogZnJvbSxcbiAgXHRcdHRvOiB0byxcbiAgXHRcdHJvb3Q6IHJvb3QsXG4gIFx0XHRkdXJhdGlvbjogZHVyYXRpb24sXG4gIFx0XHRlYXNpbmc6IGVhc2luZyxcbiAgXHRcdGludGVycG9sYXRvcjogb3B0aW9ucy5pbnRlcnBvbGF0b3IsXG5cbiAgXHRcdC8vIFRPRE8gd3JhcCBjYWxsYmFja3MgaWYgbmVjZXNzYXJ5LCB0byB1c2UgaW5zdGFuY2UgYXMgY29udGV4dFxuICBcdFx0c3RlcDogb3B0aW9ucy5zdGVwLFxuICBcdFx0Y29tcGxldGU6IG9wdGlvbnMuY29tcGxldGVcbiAgXHR9KTtcblxuICBcdHNoYXJlZF9hbmltYXRpb25zLmFkZChhbmltYXRpb24pO1xuICBcdHJvb3QuX2FuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuXG4gIFx0cmV0dXJuIGFuaW1hdGlvbjtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZGV0YWNoID0gUmFjdGl2ZSRkZXRhY2g7XG4gIHZhciBwcm90b3R5cGVfZGV0YWNoX19kZXRhY2hIb29rID0gbmV3IGhvb2tzX0hvb2soXCJkZXRhY2hcIik7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkZGV0YWNoKCkge1xuICBcdGlmICh0aGlzLmRldGFjaGVkKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5kZXRhY2hlZDtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5lbCkge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLCB0aGlzKTtcbiAgXHR9XG4gIFx0dGhpcy5kZXRhY2hlZCA9IHRoaXMuZnJhZ21lbnQuZGV0YWNoKCk7XG4gIFx0cHJvdG90eXBlX2RldGFjaF9fZGV0YWNoSG9vay5maXJlKHRoaXMpO1xuICBcdHJldHVybiB0aGlzLmRldGFjaGVkO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9maW5kID0gUmFjdGl2ZSRmaW5kO1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkZmluZChzZWxlY3Rvcikge1xuICBcdGlmICghdGhpcy5lbCkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZChzZWxlY3Rvcik7XG4gIH1cblxuICB2YXIgdGVzdCA9IFF1ZXJ5JHRlc3Q7XG4gIGZ1bmN0aW9uIFF1ZXJ5JHRlc3QoaXRlbSwgbm9EaXJ0eSkge1xuICBcdHZhciBpdGVtTWF0Y2hlcztcblxuICBcdGlmICh0aGlzLl9pc0NvbXBvbmVudFF1ZXJ5KSB7XG4gIFx0XHRpdGVtTWF0Y2hlcyA9ICF0aGlzLnNlbGVjdG9yIHx8IGl0ZW0ubmFtZSA9PT0gdGhpcy5zZWxlY3RvcjtcbiAgXHR9IGVsc2Uge1xuICBcdFx0aXRlbU1hdGNoZXMgPSBpdGVtLm5vZGUgPyBtYXRjaGVzKGl0ZW0ubm9kZSwgdGhpcy5zZWxlY3RvcikgOiBudWxsO1xuICBcdH1cblxuICBcdGlmIChpdGVtTWF0Y2hlcykge1xuICBcdFx0dGhpcy5wdXNoKGl0ZW0ubm9kZSB8fCBpdGVtLmluc3RhbmNlKTtcblxuICBcdFx0aWYgKCFub0RpcnR5KSB7XG4gIFx0XHRcdHRoaXMuX21ha2VEaXJ0eSgpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG4gIH1cblxuICB2YXIgbWFrZVF1ZXJ5X2NhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgXHR2YXIgbGl2ZVF1ZXJpZXMsIHNlbGVjdG9yLCBpbmRleDtcblxuICBcdGxpdmVRdWVyaWVzID0gdGhpcy5fcm9vdFt0aGlzLl9pc0NvbXBvbmVudFF1ZXJ5ID8gXCJsaXZlQ29tcG9uZW50UXVlcmllc1wiIDogXCJsaXZlUXVlcmllc1wiXTtcbiAgXHRzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XG5cbiAgXHRpbmRleCA9IGxpdmVRdWVyaWVzLmluZGV4T2Yoc2VsZWN0b3IpO1xuXG4gIFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0bGl2ZVF1ZXJpZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHRcdGxpdmVRdWVyaWVzW3NlbGVjdG9yXSA9IG51bGw7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBzb3J0QnlJdGVtUG9zaXRpb24gPSBmdW5jdGlvbiAoYSwgYikge1xuICBcdHZhciBhbmNlc3RyeUEsIGFuY2VzdHJ5Qiwgb2xkZXN0QSwgb2xkZXN0QiwgbXV0dWFsQW5jZXN0b3IsIGluZGV4QSwgaW5kZXhCLCBmcmFnbWVudHMsIGZyYWdtZW50QSwgZnJhZ21lbnRCO1xuXG4gIFx0YW5jZXN0cnlBID0gZ2V0QW5jZXN0cnkoYS5jb21wb25lbnQgfHwgYS5fcmFjdGl2ZS5wcm94eSk7XG4gIFx0YW5jZXN0cnlCID0gZ2V0QW5jZXN0cnkoYi5jb21wb25lbnQgfHwgYi5fcmFjdGl2ZS5wcm94eSk7XG5cbiAgXHRvbGRlc3RBID0gbGFzdEl0ZW0oYW5jZXN0cnlBKTtcbiAgXHRvbGRlc3RCID0gbGFzdEl0ZW0oYW5jZXN0cnlCKTtcblxuICBcdC8vIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBlbmQgb2YgYm90aCBhbmNlc3RyaWVzIGFzIGxvbmcgYXMgdGhleSBhcmUgaWRlbnRpY2FsXG4gIFx0Ly8gLSB0aGUgZmluYWwgb25lIHJlbW92ZWQgaXMgdGhlIGNsb3Nlc3QgbXV0dWFsIGFuY2VzdG9yXG4gIFx0d2hpbGUgKG9sZGVzdEEgJiYgb2xkZXN0QSA9PT0gb2xkZXN0Qikge1xuICBcdFx0YW5jZXN0cnlBLnBvcCgpO1xuICBcdFx0YW5jZXN0cnlCLnBvcCgpO1xuXG4gIFx0XHRtdXR1YWxBbmNlc3RvciA9IG9sZGVzdEE7XG5cbiAgXHRcdG9sZGVzdEEgPSBsYXN0SXRlbShhbmNlc3RyeUEpO1xuICBcdFx0b2xkZXN0QiA9IGxhc3RJdGVtKGFuY2VzdHJ5Qik7XG4gIFx0fVxuXG4gIFx0Ly8gbm93IHRoYXQgd2UgaGF2ZSB0aGUgbXV0dWFsIGFuY2VzdG9yLCB3ZSBjYW4gZmluZCB3aGljaCBpcyBlYXJsaWVzdFxuICBcdG9sZGVzdEEgPSBvbGRlc3RBLmNvbXBvbmVudCB8fCBvbGRlc3RBO1xuICBcdG9sZGVzdEIgPSBvbGRlc3RCLmNvbXBvbmVudCB8fCBvbGRlc3RCO1xuXG4gIFx0ZnJhZ21lbnRBID0gb2xkZXN0QS5wYXJlbnRGcmFnbWVudDtcbiAgXHRmcmFnbWVudEIgPSBvbGRlc3RCLnBhcmVudEZyYWdtZW50O1xuXG4gIFx0Ly8gaWYgYm90aCBpdGVtcyBzaGFyZSBhIHBhcmVudCBmcmFnbWVudCwgb3VyIGpvYiBpcyBlYXN5XG4gIFx0aWYgKGZyYWdtZW50QSA9PT0gZnJhZ21lbnRCKSB7XG4gIFx0XHRpbmRleEEgPSBmcmFnbWVudEEuaXRlbXMuaW5kZXhPZihvbGRlc3RBKTtcbiAgXHRcdGluZGV4QiA9IGZyYWdtZW50Qi5pdGVtcy5pbmRleE9mKG9sZGVzdEIpO1xuXG4gIFx0XHQvLyBpZiBpdCdzIHRoZSBzYW1lIGluZGV4LCBpdCBtZWFucyBvbmUgY29udGFpbnMgdGhlIG90aGVyLFxuICBcdFx0Ly8gc28gd2Ugc2VlIHdoaWNoIGhhcyB0aGUgbG9uZ2VzdCBhbmNlc3RyeVxuICBcdFx0cmV0dXJuIGluZGV4QSAtIGluZGV4QiB8fCBhbmNlc3RyeUEubGVuZ3RoIC0gYW5jZXN0cnlCLmxlbmd0aDtcbiAgXHR9XG5cbiAgXHQvLyBpZiBtdXR1YWwgYW5jZXN0b3IgaXMgYSBzZWN0aW9uLCB3ZSBmaXJzdCB0ZXN0IHRvIHNlZSB3aGljaCBzZWN0aW9uXG4gIFx0Ly8gZnJhZ21lbnQgY29tZXMgZmlyc3RcbiAgXHRpZiAoZnJhZ21lbnRzID0gbXV0dWFsQW5jZXN0b3IuZnJhZ21lbnRzKSB7XG4gIFx0XHRpbmRleEEgPSBmcmFnbWVudHMuaW5kZXhPZihmcmFnbWVudEEpO1xuICBcdFx0aW5kZXhCID0gZnJhZ21lbnRzLmluZGV4T2YoZnJhZ21lbnRCKTtcblxuICBcdFx0cmV0dXJuIGluZGV4QSAtIGluZGV4QiB8fCBhbmNlc3RyeUEubGVuZ3RoIC0gYW5jZXN0cnlCLmxlbmd0aDtcbiAgXHR9XG5cbiAgXHR0aHJvdyBuZXcgRXJyb3IoXCJBbiB1bmV4cGVjdGVkIGNvbmRpdGlvbiB3YXMgbWV0IHdoaWxlIGNvbXBhcmluZyB0aGUgcG9zaXRpb24gb2YgdHdvIGNvbXBvbmVudHMuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9SYWN0aXZlSlMvUmFjdGl2ZS9pc3N1ZXMgLSB0aGFua3MhXCIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGdldFBhcmVudChpdGVtKSB7XG4gIFx0dmFyIHBhcmVudEZyYWdtZW50O1xuXG4gIFx0aWYgKHBhcmVudEZyYWdtZW50ID0gaXRlbS5wYXJlbnRGcmFnbWVudCkge1xuICBcdFx0cmV0dXJuIHBhcmVudEZyYWdtZW50Lm93bmVyO1xuICBcdH1cblxuICBcdGlmIChpdGVtLmNvbXBvbmVudCAmJiAocGFyZW50RnJhZ21lbnQgPSBpdGVtLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudCkpIHtcbiAgXHRcdHJldHVybiBwYXJlbnRGcmFnbWVudC5vd25lcjtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBbmNlc3RyeShpdGVtKSB7XG4gIFx0dmFyIGFuY2VzdHJ5LCBhbmNlc3RvcjtcblxuICBcdGFuY2VzdHJ5ID0gW2l0ZW1dO1xuXG4gIFx0YW5jZXN0b3IgPSBnZXRQYXJlbnQoaXRlbSk7XG5cbiAgXHR3aGlsZSAoYW5jZXN0b3IpIHtcbiAgXHRcdGFuY2VzdHJ5LnB1c2goYW5jZXN0b3IpO1xuICBcdFx0YW5jZXN0b3IgPSBnZXRQYXJlbnQoYW5jZXN0b3IpO1xuICBcdH1cblxuICBcdHJldHVybiBhbmNlc3RyeTtcbiAgfVxuXG4gIHZhciBzb3J0QnlEb2N1bWVudFBvc2l0aW9uID0gZnVuY3Rpb24gKG5vZGUsIG90aGVyTm9kZSkge1xuICBcdHZhciBiaXRtYXNrO1xuXG4gIFx0aWYgKG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgXHRcdGJpdG1hc2sgPSBub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG90aGVyTm9kZSk7XG4gIFx0XHRyZXR1cm4gYml0bWFzayAmIDIgPyAxIDogLTE7XG4gIFx0fVxuXG4gIFx0Ly8gSW4gb2xkIElFLCB3ZSBjYW4gcGlnZ3kgYmFjayBvbiB0aGUgbWVjaGFuaXNtIGZvclxuICBcdC8vIGNvbXBhcmluZyBjb21wb25lbnQgcG9zaXRpb25zXG4gIFx0cmV0dXJuIHNvcnRCeUl0ZW1Qb3NpdGlvbihub2RlLCBvdGhlck5vZGUpO1xuICB9O1xuXG4gIHZhciBzb3J0ID0gZnVuY3Rpb24gKCkge1xuICBcdHRoaXMuc29ydCh0aGlzLl9pc0NvbXBvbmVudFF1ZXJ5ID8gc29ydEJ5SXRlbVBvc2l0aW9uIDogc29ydEJ5RG9jdW1lbnRQb3NpdGlvbik7XG4gIFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgfTtcblxuICB2YXIgbWFrZVF1ZXJ5X2RpcnR5ID0gZnVuY3Rpb24gKCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRpZiAoIXRoaXMuX2RpcnR5KSB7XG4gIFx0XHR0aGlzLl9kaXJ0eSA9IHRydWU7XG5cbiAgXHRcdC8vIE9uY2UgdGhlIERPTSBoYXMgYmVlbiB1cGRhdGVkLCBlbnN1cmUgdGhlIHF1ZXJ5XG4gIFx0XHQvLyBpcyBjb3JyZWN0bHkgb3JkZXJlZFxuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0X3RoaXMuX3NvcnQoKTtcbiAgXHRcdH0pO1xuICBcdH1cbiAgfTtcblxuICB2YXIgcmVtb3ZlID0gZnVuY3Rpb24gKG5vZGVPckNvbXBvbmVudCkge1xuICBcdHZhciBpbmRleCA9IHRoaXMuaW5kZXhPZih0aGlzLl9pc0NvbXBvbmVudFF1ZXJ5ID8gbm9kZU9yQ29tcG9uZW50Lmluc3RhbmNlIDogbm9kZU9yQ29tcG9uZW50KTtcblxuICBcdGlmIChpbmRleCAhPT0gLTEpIHtcbiAgXHRcdHRoaXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIF9tYWtlUXVlcnkgPSBtYWtlUXVlcnk7XG4gIGZ1bmN0aW9uIG1ha2VRdWVyeShyYWN0aXZlLCBzZWxlY3RvciwgbGl2ZSwgaXNDb21wb25lbnRRdWVyeSkge1xuICBcdHZhciBxdWVyeSA9IFtdO1xuXG4gIFx0ZGVmaW5lUHJvcGVydGllcyhxdWVyeSwge1xuICBcdFx0c2VsZWN0b3I6IHsgdmFsdWU6IHNlbGVjdG9yIH0sXG4gIFx0XHRsaXZlOiB7IHZhbHVlOiBsaXZlIH0sXG5cbiAgXHRcdF9pc0NvbXBvbmVudFF1ZXJ5OiB7IHZhbHVlOiBpc0NvbXBvbmVudFF1ZXJ5IH0sXG4gIFx0XHRfdGVzdDogeyB2YWx1ZTogdGVzdCB9XG4gIFx0fSk7XG5cbiAgXHRpZiAoIWxpdmUpIHtcbiAgXHRcdHJldHVybiBxdWVyeTtcbiAgXHR9XG5cbiAgXHRkZWZpbmVQcm9wZXJ0aWVzKHF1ZXJ5LCB7XG4gIFx0XHRjYW5jZWw6IHsgdmFsdWU6IG1ha2VRdWVyeV9jYW5jZWwgfSxcblxuICBcdFx0X3Jvb3Q6IHsgdmFsdWU6IHJhY3RpdmUgfSxcbiAgXHRcdF9zb3J0OiB7IHZhbHVlOiBzb3J0IH0sXG4gIFx0XHRfbWFrZURpcnR5OiB7IHZhbHVlOiBtYWtlUXVlcnlfZGlydHkgfSxcbiAgXHRcdF9yZW1vdmU6IHsgdmFsdWU6IHJlbW92ZSB9LFxuXG4gIFx0XHRfZGlydHk6IHsgdmFsdWU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSB9XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gcXVlcnk7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2ZpbmRBbGwgPSBSYWN0aXZlJGZpbmRBbGw7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkZmluZEFsbChzZWxlY3Rvciwgb3B0aW9ucykge1xuICBcdHZhciBsaXZlUXVlcmllcywgcXVlcnk7XG5cbiAgXHRpZiAoIXRoaXMuZWwpIHtcbiAgXHRcdHJldHVybiBbXTtcbiAgXHR9XG5cbiAgXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgXHRsaXZlUXVlcmllcyA9IHRoaXMuX2xpdmVRdWVyaWVzO1xuXG4gIFx0Ly8gU2hvcnRjdXQ6IGlmIHdlJ3JlIG1haW50YWluaW5nIGEgbGl2ZSBxdWVyeSB3aXRoIHRoaXNcbiAgXHQvLyBzZWxlY3Rvciwgd2UgZG9uJ3QgbmVlZCB0byB0cmF2ZXJzZSB0aGUgcGFyYWxsZWwgRE9NXG4gIFx0aWYgKHF1ZXJ5ID0gbGl2ZVF1ZXJpZXNbc2VsZWN0b3JdKSB7XG5cbiAgXHRcdC8vIEVpdGhlciByZXR1cm4gdGhlIGV4YWN0IHNhbWUgcXVlcnksIG9yIChpZiBub3QgbGl2ZSkgYSBzbmFwc2hvdFxuICBcdFx0cmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5saXZlID8gcXVlcnkgOiBxdWVyeS5zbGljZSgpO1xuICBcdH1cblxuICBcdHF1ZXJ5ID0gX21ha2VRdWVyeSh0aGlzLCBzZWxlY3RvciwgISFvcHRpb25zLmxpdmUsIGZhbHNlKTtcblxuICBcdC8vIEFkZCB0aGlzIHRvIHRoZSBsaXN0IG9mIGxpdmUgcXVlcmllcyBSYWN0aXZlIG5lZWRzIHRvIG1haW50YWluLFxuICBcdC8vIGlmIGFwcGxpY2FibGVcbiAgXHRpZiAocXVlcnkubGl2ZSkge1xuICBcdFx0bGl2ZVF1ZXJpZXMucHVzaChzZWxlY3Rvcik7XG4gIFx0XHRsaXZlUXVlcmllc1tcIl9cIiArIHNlbGVjdG9yXSA9IHF1ZXJ5O1xuICBcdH1cblxuICBcdHRoaXMuZnJhZ21lbnQuZmluZEFsbChzZWxlY3RvciwgcXVlcnkpO1xuICBcdHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMgPSBSYWN0aXZlJGZpbmRBbGxDb21wb25lbnRzO1xuICBmdW5jdGlvbiBSYWN0aXZlJGZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBvcHRpb25zKSB7XG4gIFx0dmFyIGxpdmVRdWVyaWVzLCBxdWVyeTtcblxuICBcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBcdGxpdmVRdWVyaWVzID0gdGhpcy5fbGl2ZUNvbXBvbmVudFF1ZXJpZXM7XG5cbiAgXHQvLyBTaG9ydGN1dDogaWYgd2UncmUgbWFpbnRhaW5pbmcgYSBsaXZlIHF1ZXJ5IHdpdGggdGhpc1xuICBcdC8vIHNlbGVjdG9yLCB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIHRoZSBwYXJhbGxlbCBET01cbiAgXHRpZiAocXVlcnkgPSBsaXZlUXVlcmllc1tzZWxlY3Rvcl0pIHtcblxuICBcdFx0Ly8gRWl0aGVyIHJldHVybiB0aGUgZXhhY3Qgc2FtZSBxdWVyeSwgb3IgKGlmIG5vdCBsaXZlKSBhIHNuYXBzaG90XG4gIFx0XHRyZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmxpdmUgPyBxdWVyeSA6IHF1ZXJ5LnNsaWNlKCk7XG4gIFx0fVxuXG4gIFx0cXVlcnkgPSBfbWFrZVF1ZXJ5KHRoaXMsIHNlbGVjdG9yLCAhIW9wdGlvbnMubGl2ZSwgdHJ1ZSk7XG5cbiAgXHQvLyBBZGQgdGhpcyB0byB0aGUgbGlzdCBvZiBsaXZlIHF1ZXJpZXMgUmFjdGl2ZSBuZWVkcyB0byBtYWludGFpbixcbiAgXHQvLyBpZiBhcHBsaWNhYmxlXG4gIFx0aWYgKHF1ZXJ5LmxpdmUpIHtcbiAgXHRcdGxpdmVRdWVyaWVzLnB1c2goc2VsZWN0b3IpO1xuICBcdFx0bGl2ZVF1ZXJpZXNbXCJfXCIgKyBzZWxlY3Rvcl0gPSBxdWVyeTtcbiAgXHR9XG5cbiAgXHR0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0cmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9maW5kQ29tcG9uZW50ID0gUmFjdGl2ZSRmaW5kQ29tcG9uZW50O1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkZmluZENvbXBvbmVudChzZWxlY3Rvcikge1xuICBcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRDb21wb25lbnQoc2VsZWN0b3IpO1xuICB9XG5cbiAgdmFyIGZpbmRDb250YWluZXIgPSBSYWN0aXZlJGZpbmRDb250YWluZXI7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRmaW5kQ29udGFpbmVyKHNlbGVjdG9yKSB7XG4gIFx0aWYgKHRoaXMuY29udGFpbmVyKSB7XG4gIFx0XHRpZiAodGhpcy5jb250YWluZXIuY29tcG9uZW50ICYmIHRoaXMuY29udGFpbmVyLmNvbXBvbmVudC5uYW1lID09PSBzZWxlY3Rvcikge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5jb250YWluZXIuZmluZENvbnRhaW5lcihzZWxlY3Rvcik7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZmluZFBhcmVudCA9IFJhY3RpdmUkZmluZFBhcmVudDtcblxuICBmdW5jdGlvbiBSYWN0aXZlJGZpbmRQYXJlbnQoc2VsZWN0b3IpIHtcblxuICBcdGlmICh0aGlzLnBhcmVudCkge1xuICBcdFx0aWYgKHRoaXMucGFyZW50LmNvbXBvbmVudCAmJiB0aGlzLnBhcmVudC5jb21wb25lbnQubmFtZSA9PT0gc2VsZWN0b3IpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMucGFyZW50O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMucGFyZW50LmZpbmRQYXJlbnQoc2VsZWN0b3IpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGV2ZW50U3RhY2sgPSB7XG4gIFx0ZW5xdWV1ZTogZnVuY3Rpb24gKHJhY3RpdmUsIGV2ZW50KSB7XG4gIFx0XHRpZiAocmFjdGl2ZS5ldmVudCkge1xuICBcdFx0XHRyYWN0aXZlLl9ldmVudFF1ZXVlID0gcmFjdGl2ZS5fZXZlbnRRdWV1ZSB8fCBbXTtcbiAgXHRcdFx0cmFjdGl2ZS5fZXZlbnRRdWV1ZS5wdXNoKHJhY3RpdmUuZXZlbnQpO1xuICBcdFx0fVxuICBcdFx0cmFjdGl2ZS5ldmVudCA9IGV2ZW50O1xuICBcdH0sXG4gIFx0ZGVxdWV1ZTogZnVuY3Rpb24gKHJhY3RpdmUpIHtcbiAgXHRcdGlmIChyYWN0aXZlLl9ldmVudFF1ZXVlICYmIHJhY3RpdmUuX2V2ZW50UXVldWUubGVuZ3RoKSB7XG4gIFx0XHRcdHJhY3RpdmUuZXZlbnQgPSByYWN0aXZlLl9ldmVudFF1ZXVlLnBvcCgpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZGVsZXRlIHJhY3RpdmUuZXZlbnQ7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBzaGFyZWRfZXZlbnRTdGFjayA9IGV2ZW50U3RhY2s7XG5cbiAgdmFyIHNoYXJlZF9maXJlRXZlbnQgPSBmaXJlRXZlbnQ7XG5cbiAgZnVuY3Rpb24gZmlyZUV2ZW50KHJhY3RpdmUsIGV2ZW50TmFtZSkge1xuICBcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1syXTtcblxuICBcdGlmICghZXZlbnROYW1lKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKCFvcHRpb25zLmV2ZW50KSB7XG4gIFx0XHRvcHRpb25zLmV2ZW50ID0ge1xuICBcdFx0XHRuYW1lOiBldmVudE5hbWUsXG4gIFx0XHRcdC8vIHVudGlsIGV2ZW50IG5vdCBpbmNsdWRlZCBhcyBhcmd1bWVudCBkZWZhdWx0XG4gIFx0XHRcdF9ub0FyZzogdHJ1ZVxuICBcdFx0fTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0b3B0aW9ucy5ldmVudC5uYW1lID0gZXZlbnROYW1lO1xuICBcdH1cblxuICBcdHZhciBldmVudE5hbWVzID0gZ2V0S2V5cGF0aChldmVudE5hbWUpLndpbGRjYXJkTWF0Y2hlcygpO1xuICBcdGZpcmVFdmVudEFzKHJhY3RpdmUsIGV2ZW50TmFtZXMsIG9wdGlvbnMuZXZlbnQsIG9wdGlvbnMuYXJncywgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlRXZlbnRBcyhyYWN0aXZlLCBldmVudE5hbWVzLCBldmVudCwgYXJncykge1xuICBcdHZhciBpbml0aWFsRmlyZSA9IGFyZ3VtZW50c1s0XSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbNF07XG5cbiAgXHR2YXIgc3Vic2NyaWJlcnMsXG4gIFx0ICAgIGksXG4gIFx0ICAgIGJ1YmJsZSA9IHRydWU7XG5cbiAgXHRzaGFyZWRfZXZlbnRTdGFjay5lbnF1ZXVlKHJhY3RpdmUsIGV2ZW50KTtcblxuICBcdGZvciAoaSA9IGV2ZW50TmFtZXMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICBcdFx0c3Vic2NyaWJlcnMgPSByYWN0aXZlLl9zdWJzW2V2ZW50TmFtZXNbaV1dO1xuXG4gIFx0XHRpZiAoc3Vic2NyaWJlcnMpIHtcbiAgXHRcdFx0YnViYmxlID0gbm90aWZ5U3Vic2NyaWJlcnMocmFjdGl2ZSwgc3Vic2NyaWJlcnMsIGV2ZW50LCBhcmdzKSAmJiBidWJibGU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0c2hhcmVkX2V2ZW50U3RhY2suZGVxdWV1ZShyYWN0aXZlKTtcblxuICBcdGlmIChyYWN0aXZlLnBhcmVudCAmJiBidWJibGUpIHtcblxuICBcdFx0aWYgKGluaXRpYWxGaXJlICYmIHJhY3RpdmUuY29tcG9uZW50KSB7XG4gIFx0XHRcdHZhciBmdWxsTmFtZSA9IHJhY3RpdmUuY29tcG9uZW50Lm5hbWUgKyBcIi5cIiArIGV2ZW50TmFtZXNbZXZlbnROYW1lcy5sZW5ndGggLSAxXTtcbiAgXHRcdFx0ZXZlbnROYW1lcyA9IGdldEtleXBhdGgoZnVsbE5hbWUpLndpbGRjYXJkTWF0Y2hlcygpO1xuXG4gIFx0XHRcdGlmIChldmVudCkge1xuICBcdFx0XHRcdGV2ZW50LmNvbXBvbmVudCA9IHJhY3RpdmU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0ZmlyZUV2ZW50QXMocmFjdGl2ZS5wYXJlbnQsIGV2ZW50TmFtZXMsIGV2ZW50LCBhcmdzKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBub3RpZnlTdWJzY3JpYmVycyhyYWN0aXZlLCBzdWJzY3JpYmVycywgZXZlbnQsIGFyZ3MpIHtcbiAgXHR2YXIgb3JpZ2luYWxFdmVudCA9IG51bGwsXG4gIFx0ICAgIHN0b3BFdmVudCA9IGZhbHNlO1xuXG4gIFx0aWYgKGV2ZW50ICYmICFldmVudC5fbm9BcmcpIHtcbiAgXHRcdGFyZ3MgPSBbZXZlbnRdLmNvbmNhdChhcmdzKTtcbiAgXHR9XG5cbiAgXHQvLyBzdWJzY3JpYmVycyBjYW4gYmUgbW9kaWZpZWQgaW5mbGlnaHQsIGUuZy4gXCJvbmNlXCIgZnVuY3Rpb25hbGl0eVxuICBcdC8vIHNvIHdlIG5lZWQgdG8gY29weSB0byBtYWtlIHN1cmUgZXZlcnlvbmUgZ2V0cyBjYWxsZWRcbiAgXHRzdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzLnNsaWNlKCk7XG5cbiAgXHRmb3IgKHZhciBpID0gMCwgbGVuID0gc3Vic2NyaWJlcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdGlmIChzdWJzY3JpYmVyc1tpXS5hcHBseShyYWN0aXZlLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgXHRcdFx0c3RvcEV2ZW50ID0gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoZXZlbnQgJiYgIWV2ZW50Ll9ub0FyZyAmJiBzdG9wRXZlbnQgJiYgKG9yaWdpbmFsRXZlbnQgPSBldmVudC5vcmlnaW5hbCkpIHtcbiAgXHRcdG9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQgJiYgb3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBcdFx0b3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24gJiYgb3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gIXN0b3BFdmVudDtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZmlyZSA9IFJhY3RpdmUkZmlyZTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRmaXJlKGV2ZW50TmFtZSkge1xuXG4gIFx0dmFyIG9wdGlvbnMgPSB7XG4gIFx0XHRhcmdzOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gIFx0fTtcblxuICBcdHNoYXJlZF9maXJlRXZlbnQodGhpcywgZXZlbnROYW1lLCBvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZ2V0ID0gUmFjdGl2ZSRnZXQ7XG4gIHZhciBvcHRpb25zID0ge1xuICBcdGNhcHR1cmU6IHRydWUsIC8vIHRvcC1sZXZlbCBjYWxscyBzaG91bGQgYmUgaW50ZXJjZXB0ZWRcbiAgXHRub1Vud3JhcDogdHJ1ZSwgLy8gd3JhcHBlZCB2YWx1ZXMgc2hvdWxkIE5PVCBiZSB1bndyYXBwZWRcbiAgXHRmdWxsUm9vdEdldDogdHJ1ZSAvLyByb290IGdldCBzaG91bGQgcmV0dXJuIG1hcHBpbmdzXG4gIH07XG4gIGZ1bmN0aW9uIFJhY3RpdmUkZ2V0KGtleXBhdGgpIHtcbiAgXHR2YXIgdmFsdWU7XG5cbiAgXHRrZXlwYXRoID0gZ2V0S2V5cGF0aChub3JtYWxpc2Uoa2V5cGF0aCkpO1xuICBcdHZhbHVlID0gdGhpcy52aWV3bW9kZWwuZ2V0KGtleXBhdGgsIG9wdGlvbnMpO1xuXG4gIFx0Ly8gQ3JlYXRlIGludGVyLWNvbXBvbmVudCBiaW5kaW5nLCBpZiBuZWNlc3NhcnlcbiAgXHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnBhcmVudCAmJiAhdGhpcy5pc29sYXRlZCkge1xuICBcdFx0aWYgKHNoYXJlZF9yZXNvbHZlUmVmKHRoaXMsIGtleXBhdGguc3RyLCB0aGlzLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudCkpIHtcbiAgXHRcdFx0Ly8gY3JlYXRlcyBiaW5kaW5nIGFzIHNpZGUtZWZmZWN0LCBpZiBhcHByb3ByaWF0ZVxuICBcdFx0XHR2YWx1ZSA9IHRoaXMudmlld21vZGVsLmdldChrZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdmFsdWU7XG4gIH1cblxuICB2YXIgaW5zZXJ0ID0gUmFjdGl2ZSRpbnNlcnQ7XG5cbiAgdmFyIGluc2VydEhvb2sgPSBuZXcgaG9va3NfSG9vayhcImluc2VydFwiKTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRpbnNlcnQodGFyZ2V0LCBhbmNob3IpIHtcbiAgXHRpZiAoIXRoaXMuZnJhZ21lbnQucmVuZGVyZWQpIHtcbiAgXHRcdC8vIFRPRE8gY3JlYXRlLCBhbmQgbGluayB0bywgZG9jdW1lbnRhdGlvbiBleHBsYWluaW5nIHRoaXNcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIlRoZSBBUEkgaGFzIGNoYW5nZWQgLSB5b3UgbXVzdCBjYWxsIGByYWN0aXZlLnJlbmRlcih0YXJnZXRbLCBhbmNob3JdKWAgdG8gcmVuZGVyIHlvdXIgUmFjdGl2ZSBpbnN0YW5jZS4gT25jZSByZW5kZXJlZCB5b3UgY2FuIHVzZSBgcmFjdGl2ZS5pbnNlcnQoKWAuXCIpO1xuICBcdH1cblxuICBcdHRhcmdldCA9IGdldEVsZW1lbnQodGFyZ2V0KTtcbiAgXHRhbmNob3IgPSBnZXRFbGVtZW50KGFuY2hvcikgfHwgbnVsbDtcblxuICBcdGlmICghdGFyZ2V0KSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBzcGVjaWZ5IGEgdmFsaWQgdGFyZ2V0IHRvIGluc2VydCBpbnRvXCIpO1xuICBcdH1cblxuICBcdHRhcmdldC5pbnNlcnRCZWZvcmUodGhpcy5kZXRhY2goKSwgYW5jaG9yKTtcbiAgXHR0aGlzLmVsID0gdGFyZ2V0O1xuXG4gIFx0KHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gfHwgKHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gPSBbXSkpLnB1c2godGhpcyk7XG4gIFx0dGhpcy5kZXRhY2hlZCA9IG51bGw7XG5cbiAgXHRmaXJlSW5zZXJ0SG9vayh0aGlzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmVJbnNlcnRIb29rKHJhY3RpdmUpIHtcbiAgXHRpbnNlcnRIb29rLmZpcmUocmFjdGl2ZSk7XG5cbiAgXHRyYWN0aXZlLmZpbmRBbGxDb21wb25lbnRzKFwiKlwiKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICBcdFx0ZmlyZUluc2VydEhvb2soY2hpbGQuaW5zdGFuY2UpO1xuICBcdH0pO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9tZXJnZSA9IFJhY3RpdmUkbWVyZ2U7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkbWVyZ2Uoa2V5cGF0aCwgYXJyYXksIG9wdGlvbnMpIHtcbiAgXHR2YXIgY3VycmVudEFycmF5LCBwcm9taXNlO1xuXG4gIFx0a2V5cGF0aCA9IGdldEtleXBhdGgobm9ybWFsaXNlKGtleXBhdGgpKTtcbiAgXHRjdXJyZW50QXJyYXkgPSB0aGlzLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHQvLyBJZiBlaXRoZXIgdGhlIGV4aXN0aW5nIHZhbHVlIG9yIHRoZSBuZXcgdmFsdWUgaXNuJ3QgYW5cbiAgXHQvLyBhcnJheSwganVzdCBkbyBhIHJlZ3VsYXIgc2V0XG4gIFx0aWYgKCFpc0FycmF5KGN1cnJlbnRBcnJheSkgfHwgIWlzQXJyYXkoYXJyYXkpKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5zZXQoa2V5cGF0aCwgYXJyYXksIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21wbGV0ZSk7XG4gIFx0fVxuXG4gIFx0Ly8gTWFuYWdlIHRyYW5zaXRpb25zXG4gIFx0cHJvbWlzZSA9IGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMsIHRydWUpO1xuICBcdHRoaXMudmlld21vZGVsLm1lcmdlKGtleXBhdGgsIGN1cnJlbnRBcnJheSwgYXJyYXksIG9wdGlvbnMpO1xuICBcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICB2YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiAocmFjdGl2ZSwga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgXHR0aGlzLnJvb3QgPSByYWN0aXZlO1xuICBcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICBcdHRoaXMuZGVmZXIgPSBvcHRpb25zLmRlZmVyO1xuXG4gIFx0Ly8gZGVmYXVsdCB0byByb290IGFzIGNvbnRleHQsIGJ1dCBhbGxvdyBpdCB0byBiZSBvdmVycmlkZGVuXG4gIFx0dGhpcy5jb250ZXh0ID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbnRleHQgPyBvcHRpb25zLmNvbnRleHQgOiByYWN0aXZlO1xuICB9O1xuXG4gIE9ic2VydmVyLnByb3RvdHlwZSA9IHtcbiAgXHRpbml0OiBmdW5jdGlvbiAoaW1tZWRpYXRlKSB7XG4gIFx0XHR0aGlzLnZhbHVlID0gdGhpcy5yb290LmdldCh0aGlzLmtleXBhdGguc3RyKTtcblxuICBcdFx0aWYgKGltbWVkaWF0ZSAhPT0gZmFsc2UpIHtcbiAgXHRcdFx0dGhpcy51cGRhdGUoKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMub2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHRpZiAoIWlzRXF1YWwodmFsdWUsIHRoaXMudmFsdWUpKSB7XG4gIFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICBcdFx0XHRpZiAodGhpcy5kZWZlciAmJiB0aGlzLnJlYWR5KSB7XG4gIFx0XHRcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRcdHJldHVybiBfdGhpcy51cGRhdGUoKTtcbiAgXHRcdFx0XHR9KTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gUHJldmVudCBpbmZpbml0ZSBsb29wc1xuICBcdFx0aWYgKHRoaXMudXBkYXRpbmcpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblxuICBcdFx0dGhpcy5jYWxsYmFjay5jYWxsKHRoaXMuY29udGV4dCwgdGhpcy52YWx1ZSwgdGhpcy5vbGRWYWx1ZSwgdGhpcy5rZXlwYXRoLnN0cik7XG4gIFx0XHR0aGlzLm9sZFZhbHVlID0gdGhpcy52YWx1ZTtcblxuICBcdFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuICBcdH1cbiAgfTtcblxuICB2YXIgb2JzZXJ2ZV9PYnNlcnZlciA9IE9ic2VydmVyO1xuXG4gIHZhciBvYnNlcnZlX2dldFBhdHRlcm4gPSBnZXRQYXR0ZXJuO1xuICBmdW5jdGlvbiBnZXRQYXR0ZXJuKHJhY3RpdmUsIHBhdHRlcm4pIHtcbiAgXHR2YXIgbWF0Y2hpbmdLZXlwYXRocywgdmFsdWVzO1xuXG4gIFx0bWF0Y2hpbmdLZXlwYXRocyA9IGdldE1hdGNoaW5nS2V5cGF0aHMocmFjdGl2ZSwgcGF0dGVybik7XG5cbiAgXHR2YWx1ZXMgPSB7fTtcbiAgXHRtYXRjaGluZ0tleXBhdGhzLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHZhbHVlc1trZXlwYXRoLnN0cl0gPSByYWN0aXZlLmdldChrZXlwYXRoLnN0cik7XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgdmFyIFBhdHRlcm5PYnNlcnZlcixcbiAgICAgIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIFBhdHRlcm5PYnNlcnZlciA9IGZ1bmN0aW9uIChyYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICBcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG5cbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIFx0dGhpcy5kZWZlciA9IG9wdGlvbnMuZGVmZXI7XG5cbiAgXHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuICBcdHRoaXMucmVnZXggPSBuZXcgUmVnRXhwKFwiXlwiICsga2V5cGF0aC5zdHIucmVwbGFjZSgvXFwuL2csIFwiXFxcXC5cIikucmVwbGFjZSgvXFwqL2csIFwiKFteXFxcXC5dKylcIikgKyBcIiRcIik7XG4gIFx0dGhpcy52YWx1ZXMgPSB7fTtcblxuICBcdGlmICh0aGlzLmRlZmVyKSB7XG4gIFx0XHR0aGlzLnByb3hpZXMgPSBbXTtcbiAgXHR9XG5cbiAgXHQvLyBkZWZhdWx0IHRvIHJvb3QgYXMgY29udGV4dCwgYnV0IGFsbG93IGl0IHRvIGJlIG92ZXJyaWRkZW5cbiAgXHR0aGlzLmNvbnRleHQgPSBvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCA/IG9wdGlvbnMuY29udGV4dCA6IHJhY3RpdmU7XG4gIH07XG5cbiAgUGF0dGVybk9ic2VydmVyLnByb3RvdHlwZSA9IHtcbiAgXHRpbml0OiBmdW5jdGlvbiAoaW1tZWRpYXRlKSB7XG4gIFx0XHR2YXIgdmFsdWVzLCBrZXlwYXRoO1xuXG4gIFx0XHR2YWx1ZXMgPSBvYnNlcnZlX2dldFBhdHRlcm4odGhpcy5yb290LCB0aGlzLmtleXBhdGgpO1xuXG4gIFx0XHRpZiAoaW1tZWRpYXRlICE9PSBmYWxzZSkge1xuICBcdFx0XHRmb3IgKGtleXBhdGggaW4gdmFsdWVzKSB7XG4gIFx0XHRcdFx0aWYgKHZhbHVlcy5oYXNPd25Qcm9wZXJ0eShrZXlwYXRoKSkge1xuICBcdFx0XHRcdFx0dGhpcy51cGRhdGUoZ2V0S2V5cGF0aChrZXlwYXRoKSk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dXBkYXRlOiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0dmFyIHZhbHVlcztcblxuICBcdFx0aWYgKGtleXBhdGguaXNQYXR0ZXJuKSB7XG4gIFx0XHRcdHZhbHVlcyA9IG9ic2VydmVfZ2V0UGF0dGVybih0aGlzLnJvb3QsIGtleXBhdGgpO1xuXG4gIFx0XHRcdGZvciAoa2V5cGF0aCBpbiB2YWx1ZXMpIHtcbiAgXHRcdFx0XHRpZiAodmFsdWVzLmhhc093blByb3BlcnR5KGtleXBhdGgpKSB7XG4gIFx0XHRcdFx0XHR0aGlzLnVwZGF0ZShnZXRLZXlwYXRoKGtleXBhdGgpKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIGFycmF5IG11dGF0aW9uIHNob3VsZCBub3QgdHJpZ2dlciBgYXJyYXkuKmBcbiAgXHRcdC8vIHBhdHRlcm4gb2JzZXJ2ZXIgd2l0aCBgYXJyYXkubGVuZ3RoYFxuICBcdFx0aWYgKHRoaXMucm9vdC52aWV3bW9kZWwuaW1wbGljaXRDaGFuZ2VzW2tleXBhdGguc3RyXSkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLmRlZmVyICYmIHRoaXMucmVhZHkpIHtcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRyZXR1cm4gX3RoaXMuZ2V0UHJveHkoa2V5cGF0aCkudXBkYXRlKCk7XG4gIFx0XHRcdH0pO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMucmVhbGx5VXBkYXRlKGtleXBhdGgpO1xuICBcdH0sXG5cbiAgXHRyZWFsbHlVcGRhdGU6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHR2YXIga2V5cGF0aFN0ciwgdmFsdWUsIGtleXMsIGFyZ3M7XG5cbiAgXHRcdGtleXBhdGhTdHIgPSBrZXlwYXRoLnN0cjtcbiAgXHRcdHZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRcdC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcHNcbiAgXHRcdGlmICh0aGlzLnVwZGF0aW5nKSB7XG4gIFx0XHRcdHRoaXMudmFsdWVzW2tleXBhdGhTdHJdID0gdmFsdWU7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cbiAgXHRcdGlmICghaXNFcXVhbCh2YWx1ZSwgdGhpcy52YWx1ZXNba2V5cGF0aFN0cl0pIHx8ICF0aGlzLnJlYWR5KSB7XG4gIFx0XHRcdGtleXMgPSBzbGljZS5jYWxsKHRoaXMucmVnZXguZXhlYyhrZXlwYXRoU3RyKSwgMSk7XG4gIFx0XHRcdGFyZ3MgPSBbdmFsdWUsIHRoaXMudmFsdWVzW2tleXBhdGhTdHJdLCBrZXlwYXRoU3RyXS5jb25jYXQoa2V5cyk7XG5cbiAgXHRcdFx0dGhpcy52YWx1ZXNba2V5cGF0aFN0cl0gPSB2YWx1ZTtcbiAgXHRcdFx0dGhpcy5jYWxsYmFjay5hcHBseSh0aGlzLmNvbnRleHQsIGFyZ3MpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG4gIFx0fSxcblxuICBcdGdldFByb3h5OiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0aWYgKCF0aGlzLnByb3hpZXNba2V5cGF0aC5zdHJdKSB7XG4gIFx0XHRcdHRoaXMucHJveGllc1trZXlwYXRoLnN0cl0gPSB7XG4gIFx0XHRcdFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gX3RoaXMucmVhbGx5VXBkYXRlKGtleXBhdGgpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXMucHJveGllc1trZXlwYXRoLnN0cl07XG4gIFx0fVxuICB9O1xuXG4gIHZhciBvYnNlcnZlX1BhdHRlcm5PYnNlcnZlciA9IFBhdHRlcm5PYnNlcnZlcjtcblxuICB2YXIgb2JzZXJ2ZV9nZXRPYnNlcnZlckZhY2FkZSA9IGdldE9ic2VydmVyRmFjYWRlO1xuICB2YXIgZW1wdHlPYmplY3QgPSB7fTtcbiAgZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJGYWNhZGUocmFjdGl2ZSwga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgXHR2YXIgb2JzZXJ2ZXIsIGlzUGF0dGVybk9ic2VydmVyLCBjYW5jZWxsZWQ7XG5cbiAgXHRrZXlwYXRoID0gZ2V0S2V5cGF0aChub3JtYWxpc2Uoa2V5cGF0aCkpO1xuICBcdG9wdGlvbnMgPSBvcHRpb25zIHx8IGVtcHR5T2JqZWN0O1xuXG4gIFx0Ly8gcGF0dGVybiBvYnNlcnZlcnMgYXJlIHRyZWF0ZWQgZGlmZmVyZW50bHlcbiAgXHRpZiAoa2V5cGF0aC5pc1BhdHRlcm4pIHtcbiAgXHRcdG9ic2VydmVyID0gbmV3IG9ic2VydmVfUGF0dGVybk9ic2VydmVyKHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgXHRcdHJhY3RpdmUudmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gIFx0XHRpc1BhdHRlcm5PYnNlcnZlciA9IHRydWU7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdG9ic2VydmVyID0gbmV3IG9ic2VydmVfT2JzZXJ2ZXIocmFjdGl2ZSwga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICBcdH1cblxuICBcdG9ic2VydmVyLmluaXQob3B0aW9ucy5pbml0KTtcbiAgXHRyYWN0aXZlLnZpZXdtb2RlbC5yZWdpc3RlcihrZXlwYXRoLCBvYnNlcnZlciwgaXNQYXR0ZXJuT2JzZXJ2ZXIgPyBcInBhdHRlcm5PYnNlcnZlcnNcIiA6IFwib2JzZXJ2ZXJzXCIpO1xuXG4gIFx0Ly8gVGhpcyBmbGFnIGFsbG93cyBvYnNlcnZlcnMgdG8gaW5pdGlhbGlzZSBldmVuIHdpdGggdW5kZWZpbmVkIHZhbHVlc1xuICBcdG9ic2VydmVyLnJlYWR5ID0gdHJ1ZTtcblxuICBcdHZhciBmYWNhZGUgPSB7XG4gIFx0XHRjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dmFyIGluZGV4O1xuXG4gIFx0XHRcdGlmIChjYW5jZWxsZWQpIHtcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoaXNQYXR0ZXJuT2JzZXJ2ZXIpIHtcbiAgXHRcdFx0XHRpbmRleCA9IHJhY3RpdmUudmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlcik7XG5cbiAgXHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwudW5yZWdpc3RlcihrZXlwYXRoLCBvYnNlcnZlciwgXCJwYXR0ZXJuT2JzZXJ2ZXJzXCIpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnVucmVnaXN0ZXIoa2V5cGF0aCwgb2JzZXJ2ZXIsIFwib2JzZXJ2ZXJzXCIpO1xuICBcdFx0XHR9XG4gIFx0XHRcdGNhbmNlbGxlZCA9IHRydWU7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdHJhY3RpdmUuX29ic2VydmVycy5wdXNoKGZhY2FkZSk7XG4gIFx0cmV0dXJuIGZhY2FkZTtcbiAgfVxuXG4gIHZhciBvYnNlcnZlID0gUmFjdGl2ZSRvYnNlcnZlO1xuICBmdW5jdGlvbiBSYWN0aXZlJG9ic2VydmUoa2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcblxuICBcdHZhciBvYnNlcnZlcnMsIG1hcCwga2V5cGF0aHMsIGk7XG5cbiAgXHQvLyBBbGxvdyBhIG1hcCBvZiBrZXlwYXRocyB0byBoYW5kbGVyc1xuICBcdGlmIChpc09iamVjdChrZXlwYXRoKSkge1xuICBcdFx0b3B0aW9ucyA9IGNhbGxiYWNrO1xuICBcdFx0bWFwID0ga2V5cGF0aDtcblxuICBcdFx0b2JzZXJ2ZXJzID0gW107XG5cbiAgXHRcdGZvciAoa2V5cGF0aCBpbiBtYXApIHtcbiAgXHRcdFx0aWYgKG1hcC5oYXNPd25Qcm9wZXJ0eShrZXlwYXRoKSkge1xuICBcdFx0XHRcdGNhbGxiYWNrID0gbWFwW2tleXBhdGhdO1xuICBcdFx0XHRcdG9ic2VydmVycy5wdXNoKHRoaXMub2JzZXJ2ZShrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucykpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdHdoaWxlIChvYnNlcnZlcnMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0XHRvYnNlcnZlcnMucG9wKCkuY2FuY2VsKCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9O1xuICBcdH1cblxuICBcdC8vIEFsbG93IGByYWN0aXZlLm9ic2VydmUoIGNhbGxiYWNrIClgIC0gaS5lLiBvYnNlcnZlIGVudGlyZSBtb2RlbFxuICBcdGlmICh0eXBlb2Yga2V5cGF0aCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRvcHRpb25zID0gY2FsbGJhY2s7XG4gIFx0XHRjYWxsYmFjayA9IGtleXBhdGg7XG4gIFx0XHRrZXlwYXRoID0gXCJcIjtcblxuICBcdFx0cmV0dXJuIG9ic2VydmVfZ2V0T2JzZXJ2ZXJGYWNhZGUodGhpcywga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICBcdH1cblxuICBcdGtleXBhdGhzID0ga2V5cGF0aC5zcGxpdChcIiBcIik7XG5cbiAgXHQvLyBTaW5nbGUga2V5cGF0aFxuICBcdGlmIChrZXlwYXRocy5sZW5ndGggPT09IDEpIHtcbiAgXHRcdHJldHVybiBvYnNlcnZlX2dldE9ic2VydmVyRmFjYWRlKHRoaXMsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgXHR9XG5cbiAgXHQvLyBNdWx0aXBsZSBzcGFjZS1zZXBhcmF0ZWQga2V5cGF0aHNcbiAgXHRvYnNlcnZlcnMgPSBbXTtcblxuICBcdGkgPSBrZXlwYXRocy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0a2V5cGF0aCA9IGtleXBhdGhzW2ldO1xuXG4gIFx0XHRpZiAoa2V5cGF0aCkge1xuICBcdFx0XHRvYnNlcnZlcnMucHVzaChvYnNlcnZlX2dldE9ic2VydmVyRmFjYWRlKHRoaXMsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICBcdFx0XHR3aGlsZSAob2JzZXJ2ZXJzLmxlbmd0aCkge1xuICBcdFx0XHRcdG9ic2VydmVycy5wb3AoKS5jYW5jZWwoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH07XG4gIH1cblxuICB2YXIgb2JzZXJ2ZU9uY2UgPSBSYWN0aXZlJG9ic2VydmVPbmNlO1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkb2JzZXJ2ZU9uY2UocHJvcGVydHksIGNhbGxiYWNrLCBvcHRpb25zKSB7XG5cbiAgXHR2YXIgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmUocHJvcGVydHksIGZ1bmN0aW9uICgpIHtcbiAgXHRcdGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIFx0XHRvYnNlcnZlci5jYW5jZWwoKTtcbiAgXHR9LCB7IGluaXQ6IGZhbHNlLCBkZWZlcjogb3B0aW9ucyAmJiBvcHRpb25zLmRlZmVyIH0pO1xuXG4gIFx0cmV0dXJuIG9ic2VydmVyO1xuICB9XG5cbiAgdmFyIHNoYXJlZF90cmltID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIudHJpbSgpO1xuICB9O1xuXG4gIHZhciBub3RFbXB0eVN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyICE9PSBcIlwiO1xuICB9O1xuXG4gIHZhciBvZmYgPSBSYWN0aXZlJG9mZjtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRvZmYoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgZXZlbnROYW1lcztcblxuICBcdC8vIGlmIG5vIGFyZ3VtZW50cyBzcGVjaWZpZWQsIHJlbW92ZSBhbGwgY2FsbGJhY2tzXG4gIFx0aWYgKCFldmVudE5hbWUpIHtcbiAgXHRcdC8vIFRPRE8gdXNlIHRoaXMgY29kZSBpbnN0ZWFkLCBvbmNlIHRoZSBmb2xsb3dpbmcgaXNzdWUgaGFzIGJlZW4gcmVzb2x2ZWRcbiAgXHRcdC8vIGluIFBoYW50b21KUyAodGVzdHMgYXJlIHVucGFzc2FibGUgb3RoZXJ3aXNlISlcbiAgXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hcml5YS9waGFudG9tanMvaXNzdWVzLzExODU2XG4gIFx0XHQvLyBkZWZpbmVQcm9wZXJ0eSggdGhpcywgJ19zdWJzJywgeyB2YWx1ZTogY3JlYXRlKCBudWxsICksIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgXHRcdGZvciAoZXZlbnROYW1lIGluIHRoaXMuX3N1YnMpIHtcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuX3N1YnNbZXZlbnROYW1lXTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0Ly8gSGFuZGxlIG11bHRpcGxlIHNwYWNlLXNlcGFyYXRlZCBldmVudCBuYW1lc1xuICBcdFx0ZXZlbnROYW1lcyA9IGV2ZW50TmFtZS5zcGxpdChcIiBcIikubWFwKHNoYXJlZF90cmltKS5maWx0ZXIobm90RW1wdHlTdHJpbmcpO1xuXG4gIFx0XHRldmVudE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICBcdFx0XHR2YXIgc3Vic2NyaWJlcnMsIGluZGV4O1xuXG4gIFx0XHRcdC8vIElmIHdlIGhhdmUgc3Vic2NyaWJlcnMgZm9yIHRoaXMgZXZlbnQuLi5cbiAgXHRcdFx0aWYgKHN1YnNjcmliZXJzID0gX3RoaXMuX3N1YnNbZXZlbnROYW1lXSkge1xuICBcdFx0XHRcdC8vIC4uLmlmIGEgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgb25seSByZW1vdmUgdGhhdFxuICBcdFx0XHRcdGlmIChjYWxsYmFjaykge1xuICBcdFx0XHRcdFx0aW5kZXggPSBzdWJzY3JpYmVycy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgXHRcdFx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcbiAgXHRcdFx0XHRcdFx0c3Vic2NyaWJlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgcmVtb3ZlIGFsbCBjYWxsYmFja3NcbiAgXHRcdFx0XHRlbHNlIHtcbiAgXHRcdFx0XHRcdF90aGlzLl9zdWJzW2V2ZW50TmFtZV0gPSBbXTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIG9uID0gUmFjdGl2ZSRvbjtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRvbihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciBsaXN0ZW5lcnMsIG4sIGV2ZW50TmFtZXM7XG5cbiAgXHQvLyBhbGxvdyBtdXRsaXBsZSBsaXN0ZW5lcnMgdG8gYmUgYm91bmQgaW4gb25lIGdvXG4gIFx0aWYgKHR5cGVvZiBldmVudE5hbWUgPT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdGxpc3RlbmVycyA9IFtdO1xuXG4gIFx0XHRmb3IgKG4gaW4gZXZlbnROYW1lKSB7XG4gIFx0XHRcdGlmIChldmVudE5hbWUuaGFzT3duUHJvcGVydHkobikpIHtcbiAgXHRcdFx0XHRsaXN0ZW5lcnMucHVzaCh0aGlzLm9uKG4sIGV2ZW50TmFtZVtuXSkpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdHZhciBsaXN0ZW5lcjtcblxuICBcdFx0XHRcdHdoaWxlIChsaXN0ZW5lciA9IGxpc3RlbmVycy5wb3AoKSkge1xuICBcdFx0XHRcdFx0bGlzdGVuZXIuY2FuY2VsKCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9O1xuICBcdH1cblxuICBcdC8vIEhhbmRsZSBtdWx0aXBsZSBzcGFjZS1zZXBhcmF0ZWQgZXZlbnQgbmFtZXNcbiAgXHRldmVudE5hbWVzID0gZXZlbnROYW1lLnNwbGl0KFwiIFwiKS5tYXAoc2hhcmVkX3RyaW0pLmZpbHRlcihub3RFbXB0eVN0cmluZyk7XG5cbiAgXHRldmVudE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICBcdFx0KF90aGlzLl9zdWJzW2V2ZW50TmFtZV0gfHwgKF90aGlzLl9zdWJzW2V2ZW50TmFtZV0gPSBbXSkpLnB1c2goY2FsbGJhY2spO1xuICBcdH0pO1xuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gX3RoaXMub2ZmKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICBcdFx0fVxuICBcdH07XG4gIH1cblxuICB2YXIgb25jZSA9IFJhY3RpdmUkb25jZTtcblxuICBmdW5jdGlvbiBSYWN0aXZlJG9uY2UoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG5cbiAgXHR2YXIgbGlzdGVuZXIgPSB0aGlzLm9uKGV2ZW50TmFtZSwgZnVuY3Rpb24gKCkge1xuICBcdFx0aGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBcdFx0bGlzdGVuZXIuY2FuY2VsKCk7XG4gIFx0fSk7XG5cbiAgXHQvLyBzbyB3ZSBjYW4gc3RpbGwgZG8gbGlzdGVuZXIuY2FuY2VsKCkgbWFudWFsbHlcbiAgXHRyZXR1cm4gbGlzdGVuZXI7XG4gIH1cblxuICAvLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIGFycmF5LCB0aGUgbmFtZSBvZiBhIG11dGF0b3IgbWV0aG9kLCBhbmQgdGhlXG4gIC8vIGFyZ3VtZW50cyB0byBjYWxsIHRoYXQgbXV0YXRvciBtZXRob2Qgd2l0aCwgYW5kIHJldHVybnMgYW4gYXJyYXkgdGhhdFxuICAvLyBtYXBzIHRoZSBvbGQgaW5kaWNlcyB0byB0aGVpciBuZXcgaW5kaWNlcy5cblxuICAvLyBTbyBpZiB5b3UgaGFkIHNvbWV0aGluZyBsaWtlIHRoaXMuLi5cbiAgLy9cbiAgLy8gICAgIGFycmF5ID0gWyAnYScsICdiJywgJ2MnLCAnZCcgXTtcbiAgLy8gICAgIGFycmF5LnB1c2goICdlJyApO1xuICAvL1xuICAvLyAuLi55b3UnZCBnZXQgYFsgMCwgMSwgMiwgMyBdYCAtIGluIG90aGVyIHdvcmRzLCBub25lIG9mIHRoZSBvbGQgaW5kaWNlc1xuICAvLyBoYXZlIGNoYW5nZWQuIElmIHlvdSB0aGVuIGRpZCB0aGlzLi4uXG4gIC8vXG4gIC8vICAgICBhcnJheS51bnNoaWZ0KCAneicgKTtcbiAgLy9cbiAgLy8gLi4udGhlIGluZGljZXMgd291bGQgYmUgYFsgMSwgMiwgMywgNCwgNSBdYCAtIGV2ZXJ5IGl0ZW0gaGFzIGJlZW4gbW92ZWRcbiAgLy8gb25lIGhpZ2hlciB0byBtYWtlIHJvb20gZm9yIHRoZSAneicuIElmIHlvdSByZW1vdmVkIGFuIGl0ZW0sIHRoZSBuZXcgaW5kZXhcbiAgLy8gd291bGQgYmUgLTEuLi5cbiAgLy9cbiAgLy8gICAgIGFycmF5LnNwbGljZSggMiwgMiApO1xuICAvL1xuICAvLyAuLi50aGlzIHdvdWxkIHJlc3VsdCBpbiBbIDAsIDEsIC0xLCAtMSwgMiwgMyBdLlxuICAvL1xuICAvLyBUaGlzIGluZm9ybWF0aW9uIGlzIHVzZWQgdG8gZW5hYmxlIGZhc3QsIG5vbi1kZXN0cnVjdGl2ZSBzaHVmZmxpbmcgb2YgbGlzdFxuICAvLyBzZWN0aW9ucyB3aGVuIHlvdSBkbyBlLmcuIGByYWN0aXZlLnNwbGljZSggJ2l0ZW1zJywgMiwgMiApO1xuXG4gIHZhciBzaGFyZWRfZ2V0TmV3SW5kaWNlcyA9IGdldE5ld0luZGljZXM7XG5cbiAgZnVuY3Rpb24gZ2V0TmV3SW5kaWNlcyhhcnJheSwgbWV0aG9kTmFtZSwgYXJncykge1xuICBcdHZhciBzcGxpY2VBcmd1bWVudHMsXG4gIFx0ICAgIGxlbixcbiAgXHQgICAgbmV3SW5kaWNlcyA9IFtdLFxuICBcdCAgICByZW1vdmVTdGFydCxcbiAgXHQgICAgcmVtb3ZlRW5kLFxuICBcdCAgICBiYWxhbmNlLFxuICBcdCAgICBpO1xuXG4gIFx0c3BsaWNlQXJndW1lbnRzID0gZ2V0U3BsaWNlRXF1aXZhbGVudChhcnJheSwgbWV0aG9kTmFtZSwgYXJncyk7XG5cbiAgXHRpZiAoIXNwbGljZUFyZ3VtZW50cykge1xuICBcdFx0cmV0dXJuIG51bGw7IC8vIFRPRE8gc3VwcG9ydCByZXZlcnNlIGFuZCBzb3J0P1xuICBcdH1cblxuICBcdGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgXHRiYWxhbmNlID0gc3BsaWNlQXJndW1lbnRzLmxlbmd0aCAtIDIgLSBzcGxpY2VBcmd1bWVudHNbMV07XG5cbiAgXHRyZW1vdmVTdGFydCA9IE1hdGgubWluKGxlbiwgc3BsaWNlQXJndW1lbnRzWzBdKTtcbiAgXHRyZW1vdmVFbmQgPSByZW1vdmVTdGFydCArIHNwbGljZUFyZ3VtZW50c1sxXTtcblxuICBcdGZvciAoaSA9IDA7IGkgPCByZW1vdmVTdGFydDsgaSArPSAxKSB7XG4gIFx0XHRuZXdJbmRpY2VzLnB1c2goaSk7XG4gIFx0fVxuXG4gIFx0Zm9yICg7IGkgPCByZW1vdmVFbmQ7IGkgKz0gMSkge1xuICBcdFx0bmV3SW5kaWNlcy5wdXNoKC0xKTtcbiAgXHR9XG5cbiAgXHRmb3IgKDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRuZXdJbmRpY2VzLnB1c2goaSArIGJhbGFuY2UpO1xuICBcdH1cblxuICBcdC8vIHRoZXJlIGlzIGEgbmV0IHNoaWZ0IGZvciB0aGUgcmVzdCBvZiB0aGUgYXJyYXkgc3RhcnRpbmcgd2l0aCBpbmRleCArIGJhbGFuY2VcbiAgXHRpZiAoYmFsYW5jZSAhPT0gMCkge1xuICBcdFx0bmV3SW5kaWNlcy50b3VjaGVkRnJvbSA9IHNwbGljZUFyZ3VtZW50c1swXTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0bmV3SW5kaWNlcy50b3VjaGVkRnJvbSA9IGFycmF5Lmxlbmd0aDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbmV3SW5kaWNlcztcbiAgfVxuXG4gIC8vIFRoZSBwb3AsIHB1c2gsIHNoaWZ0IGFuIHVuc2hpZnQgbWV0aG9kcyBjYW4gYWxsIGJlIHJlcHJlc2VudGVkXG4gIC8vIGFzIGFuIGVxdWl2YWxlbnQgc3BsaWNlXG4gIGZ1bmN0aW9uIGdldFNwbGljZUVxdWl2YWxlbnQoYXJyYXksIG1ldGhvZE5hbWUsIGFyZ3MpIHtcbiAgXHRzd2l0Y2ggKG1ldGhvZE5hbWUpIHtcbiAgXHRcdGNhc2UgXCJzcGxpY2VcIjpcbiAgXHRcdFx0aWYgKGFyZ3NbMF0gIT09IHVuZGVmaW5lZCAmJiBhcmdzWzBdIDwgMCkge1xuICBcdFx0XHRcdGFyZ3NbMF0gPSBhcnJheS5sZW5ndGggKyBNYXRoLm1heChhcmdzWzBdLCAtYXJyYXkubGVuZ3RoKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHdoaWxlIChhcmdzLmxlbmd0aCA8IDIpIHtcbiAgXHRcdFx0XHRhcmdzLnB1c2goMCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBlbnN1cmUgd2Ugb25seSByZW1vdmUgZWxlbWVudHMgdGhhdCBleGlzdFxuICBcdFx0XHRhcmdzWzFdID0gTWF0aC5taW4oYXJnc1sxXSwgYXJyYXkubGVuZ3RoIC0gYXJnc1swXSk7XG5cbiAgXHRcdFx0cmV0dXJuIGFyZ3M7XG5cbiAgXHRcdGNhc2UgXCJzb3J0XCI6XG4gIFx0XHRjYXNlIFwicmV2ZXJzZVwiOlxuICBcdFx0XHRyZXR1cm4gbnVsbDtcblxuICBcdFx0Y2FzZSBcInBvcFwiOlxuICBcdFx0XHRpZiAoYXJyYXkubGVuZ3RoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIFthcnJheS5sZW5ndGggLSAxLCAxXTtcbiAgXHRcdFx0fVxuICBcdFx0XHRyZXR1cm4gWzAsIDBdO1xuXG4gIFx0XHRjYXNlIFwicHVzaFwiOlxuICBcdFx0XHRyZXR1cm4gW2FycmF5Lmxlbmd0aCwgMF0uY29uY2F0KGFyZ3MpO1xuXG4gIFx0XHRjYXNlIFwic2hpZnRcIjpcbiAgXHRcdFx0cmV0dXJuIFswLCBhcnJheS5sZW5ndGggPyAxIDogMF07XG5cbiAgXHRcdGNhc2UgXCJ1bnNoaWZ0XCI6XG4gIFx0XHRcdHJldHVybiBbMCwgMF0uY29uY2F0KGFyZ3MpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4gIHZhciBtYWtlQXJyYXlNZXRob2QgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICBcdHJldHVybiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gIFx0XHRcdGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgYXJyYXksXG4gIFx0XHQgICAgbmV3SW5kaWNlcyA9IFtdLFxuICBcdFx0ICAgIGxlbixcbiAgXHRcdCAgICBwcm9taXNlLFxuICBcdFx0ICAgIHJlc3VsdDtcblxuICBcdFx0a2V5cGF0aCA9IGdldEtleXBhdGgobm9ybWFsaXNlKGtleXBhdGgpKTtcblxuICBcdFx0YXJyYXkgPSB0aGlzLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG4gIFx0XHRsZW4gPSBhcnJheS5sZW5ndGg7XG5cbiAgXHRcdGlmICghaXNBcnJheShhcnJheSkpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2FsbGVkIHJhY3RpdmUuXCIgKyBtZXRob2ROYW1lICsgXCIoJ1wiICsga2V5cGF0aC5zdHIgKyBcIicpLCBidXQgJ1wiICsga2V5cGF0aC5zdHIgKyBcIicgZG9lcyBub3QgcmVmZXIgdG8gYW4gYXJyYXlcIik7XG4gIFx0XHR9XG5cbiAgXHRcdG5ld0luZGljZXMgPSBzaGFyZWRfZ2V0TmV3SW5kaWNlcyhhcnJheSwgbWV0aG9kTmFtZSwgYXJncyk7XG5cbiAgXHRcdHJlc3VsdCA9IGFycmF5UHJvdG9bbWV0aG9kTmFtZV0uYXBwbHkoYXJyYXksIGFyZ3MpO1xuICBcdFx0cHJvbWlzZSA9IGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMsIHRydWUpLnRoZW4oZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdFx0fSk7XG5cbiAgXHRcdGlmICghIW5ld0luZGljZXMpIHtcbiAgXHRcdFx0dGhpcy52aWV3bW9kZWwuc21hcnRVcGRhdGUoa2V5cGF0aCwgYXJyYXksIG5ld0luZGljZXMpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy52aWV3bW9kZWwubWFyayhrZXlwYXRoKTtcbiAgXHRcdH1cblxuICBcdFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG5cbiAgXHRcdHJldHVybiBwcm9taXNlO1xuICBcdH07XG4gIH07XG5cbiAgdmFyIHBvcCA9IG1ha2VBcnJheU1ldGhvZChcInBvcFwiKTtcblxuICB2YXIgcHVzaCA9IG1ha2VBcnJheU1ldGhvZChcInB1c2hcIik7XG5cbiAgdmFyIGNzcyxcbiAgICAgIHVwZGF0ZSxcbiAgICAgIHN0eWxlRWxlbWVudCxcbiAgICAgIGhlYWQsXG4gICAgICBzdHlsZVNoZWV0LFxuICAgICAgaW5Eb20sXG4gICAgICBnbG9iYWxfY3NzX19wcmVmaXggPSBcIi8qIFJhY3RpdmUuanMgY29tcG9uZW50IHN0eWxlcyAqL1xcblwiLFxuICAgICAgc3R5bGVzID0gW10sXG4gICAgICBkaXJ0eSA9IGZhbHNlO1xuXG4gIGlmICghaXNDbGllbnQpIHtcbiAgXHQvLyBUT0RPIGhhbmRsZSBlbmNhcHN1bGF0ZWQgQ1NTIGluIHNlcnZlci1yZW5kZXJlZCBIVE1MIVxuICBcdGNzcyA9IHtcbiAgXHRcdGFkZDogbm9vcCxcbiAgXHRcdGFwcGx5OiBub29wXG4gIFx0fTtcbiAgfSBlbHNlIHtcbiAgXHRzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIFx0c3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XG5cbiAgXHRoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuXG4gIFx0aW5Eb20gPSBmYWxzZTtcblxuICBcdC8vIEludGVybmV0IEV4cGxvZGVyIHdvbid0IGxldCB5b3UgdXNlIHN0eWxlU2hlZXQuaW5uZXJIVE1MIC0gd2UgaGF2ZSB0b1xuICBcdC8vIHVzZSBzdHlsZVNoZWV0LmNzc1RleHQgaW5zdGVhZFxuICBcdHN0eWxlU2hlZXQgPSBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldDtcblxuICBcdHVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBjc3MgPSBnbG9iYWxfY3NzX19wcmVmaXggKyBzdHlsZXMubWFwKGZ1bmN0aW9uIChzKSB7XG4gIFx0XHRcdHJldHVybiBcIlxcbi8qIHtcIiArIHMuaWQgKyBcIn0gKi9cXG5cIiArIHMuc3R5bGVzO1xuICBcdFx0fSkuam9pbihcIlxcblwiKTtcblxuICBcdFx0aWYgKHN0eWxlU2hlZXQpIHtcbiAgXHRcdFx0c3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0c3R5bGVFbGVtZW50LmlubmVySFRNTCA9IGNzcztcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFpbkRvbSkge1xuICBcdFx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG4gIFx0XHRcdGluRG9tID0gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0Y3NzID0ge1xuICBcdFx0YWRkOiBmdW5jdGlvbiAocykge1xuICBcdFx0XHRzdHlsZXMucHVzaChzKTtcbiAgXHRcdFx0ZGlydHkgPSB0cnVlO1xuICBcdFx0fSxcblxuICBcdFx0YXBwbHk6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0aWYgKGRpcnR5KSB7XG4gIFx0XHRcdFx0dXBkYXRlKCk7XG4gIFx0XHRcdFx0ZGlydHkgPSBmYWxzZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH07XG4gIH1cblxuICB2YXIgZ2xvYmFsX2NzcyA9IGNzcztcblxuICB2YXIgcHJvdG90eXBlX3JlbmRlciA9IFJhY3RpdmUkcmVuZGVyO1xuXG4gIHZhciByZW5kZXJIb29rID0gbmV3IGhvb2tzX0hvb2soXCJyZW5kZXJcIiksXG4gICAgICBjb21wbGV0ZUhvb2sgPSBuZXcgaG9va3NfSG9vayhcImNvbXBsZXRlXCIpO1xuICBmdW5jdGlvbiBSYWN0aXZlJHJlbmRlcih0YXJnZXQsIGFuY2hvcikge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgcHJvbWlzZSwgaW5zdGFuY2VzLCB0cmFuc2l0aW9uc0VuYWJsZWQ7XG5cbiAgXHQvLyBpZiBgbm9JbnRyb2AgaXMgYHRydWVgLCB0ZW1wb3JhcmlseSBkaXNhYmxlIHRyYW5zaXRpb25zXG4gIFx0dHJhbnNpdGlvbnNFbmFibGVkID0gdGhpcy50cmFuc2l0aW9uc0VuYWJsZWQ7XG4gIFx0aWYgKHRoaXMubm9JbnRybykge1xuICBcdFx0dGhpcy50cmFuc2l0aW9uc0VuYWJsZWQgPSBmYWxzZTtcbiAgXHR9XG5cbiAgXHRwcm9taXNlID0gZ2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcywgdHJ1ZSk7XG4gIFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiByZW5kZXJIb29rLmZpcmUoX3RoaXMpO1xuICBcdH0sIHRydWUpO1xuXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQucmVuZGVyZWQpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIllvdSBjYW5ub3QgY2FsbCByYWN0aXZlLnJlbmRlcigpIG9uIGFuIGFscmVhZHkgcmVuZGVyZWQgaW5zdGFuY2UhIENhbGwgcmFjdGl2ZS51bnJlbmRlcigpIGZpcnN0XCIpO1xuICBcdH1cblxuICBcdHRhcmdldCA9IGdldEVsZW1lbnQodGFyZ2V0KSB8fCB0aGlzLmVsO1xuICBcdGFuY2hvciA9IGdldEVsZW1lbnQoYW5jaG9yKSB8fCB0aGlzLmFuY2hvcjtcblxuICBcdHRoaXMuZWwgPSB0YXJnZXQ7XG4gIFx0dGhpcy5hbmNob3IgPSBhbmNob3I7XG5cbiAgXHRpZiAoIXRoaXMuYXBwZW5kICYmIHRhcmdldCkge1xuICBcdFx0Ly8gVGVhcmRvd24gYW55IGV4aXN0aW5nIGluc3RhbmNlcyAqYmVmb3JlKiB0cnlpbmcgdG8gc2V0IHVwIHRoZSBuZXcgb25lIC1cbiAgXHRcdC8vIGF2b2lkcyBjZXJ0YWluIHdlaXJkIGJ1Z3NcbiAgXHRcdHZhciBvdGhlcnMgPSB0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fO1xuICBcdFx0aWYgKG90aGVycyAmJiBvdGhlcnMubGVuZ3RoKSB7XG4gIFx0XHRcdHJlbW92ZU90aGVySW5zdGFuY2VzKG90aGVycyk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIG1ha2Ugc3VyZSB3ZSBhcmUgdGhlIG9ubHkgb2NjdXBhbnRzXG4gIFx0XHR0YXJnZXQuaW5uZXJIVE1MID0gXCJcIjsgLy8gVE9ETyBpcyB0aGlzIHF1aWNrZXIgdGhhbiByZW1vdmVDaGlsZD8gSW5pdGlhbCByZXNlYXJjaCBpbmNvbmNsdXNpdmVcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5jc3NJZCkge1xuICBcdFx0Ly8gZW5zdXJlIGVuY2Fwc3VsYXRlZCBDU1MgaXMgdXAtdG8tZGF0ZVxuICBcdFx0Z2xvYmFsX2Nzcy5hcHBseSgpO1xuICBcdH1cblxuICBcdGlmICh0YXJnZXQpIHtcbiAgXHRcdGlmICghKGluc3RhbmNlcyA9IHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18pKSB7XG4gIFx0XHRcdHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gPSBbdGhpc107XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRpbnN0YW5jZXMucHVzaCh0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGFuY2hvcikge1xuICBcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHRoaXMuZnJhZ21lbnQucmVuZGVyKCksIGFuY2hvcik7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQodGhpcy5mcmFnbWVudC5yZW5kZXIoKSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG5cbiAgXHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IHRyYW5zaXRpb25zRW5hYmxlZDtcblxuICBcdHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIGNvbXBsZXRlSG9vay5maXJlKF90aGlzKTtcbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU90aGVySW5zdGFuY2VzKG90aGVycykge1xuICBcdG90aGVycy5zcGxpY2UoMCwgb3RoZXJzLmxlbmd0aCkuZm9yRWFjaCh0ZWFyZG93bik7XG4gIH1cblxuICB2YXIgYWRhcHRDb25maWd1cmF0b3IgPSB7XG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiAoUGFyZW50LCBwcm90bywgb3B0aW9ucykge1xuICBcdFx0cHJvdG8uYWRhcHQgPSBjdXN0b21fYWRhcHRfX2NvbWJpbmUocHJvdG8uYWRhcHQsIGVuc3VyZUFycmF5KG9wdGlvbnMuYWRhcHQpKTtcbiAgXHR9LFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKCkge31cbiAgfTtcblxuICB2YXIgY3VzdG9tX2FkYXB0ID0gYWRhcHRDb25maWd1cmF0b3I7XG5cbiAgZnVuY3Rpb24gY3VzdG9tX2FkYXB0X19jb21iaW5lKGEsIGIpIHtcbiAgXHR2YXIgYyA9IGEuc2xpY2UoKSxcbiAgXHQgICAgaSA9IGIubGVuZ3RoO1xuXG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aWYgKCEgfmMuaW5kZXhPZihiW2ldKSkge1xuICBcdFx0XHRjLnB1c2goYltpXSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGM7XG4gIH1cblxuICB2YXIgdHJhbnNmb3JtID0gdHJhbnNmb3JtQ3NzO1xuXG4gIHZhciBzZWxlY3RvcnNQYXR0ZXJuID0gLyg/Ol58XFx9KT9cXHMqKFteXFx7XFx9XSspXFxzKlxcey9nLFxuICAgICAgY29tbWVudHNQYXR0ZXJuID0gL1xcL1xcKi4qP1xcKlxcLy9nLFxuICAgICAgc2VsZWN0b3JVbml0UGF0dGVybiA9IC8oKD86KD86XFxbW15cXF0rXVxcXSl8KD86W15cXHNcXCtcXD5cXH46XSkpKykoKD86OlteXFxzXFwrXFw+XFx+XFwoXSsoPzpcXChbXlxcKV0rXFwpKT8pP1xccypbXFxzXFwrXFw+XFx+XT8pXFxzKi9nLFxuICAgICAgbWVkaWFRdWVyeVBhdHRlcm4gPSAvXkBtZWRpYS8sXG4gICAgICBkYXRhUnZjR3VpZFBhdHRlcm4gPSAvXFxbZGF0YS1yYWN0aXZlLWNzc349XCJcXHtbYS16MC05LV0rXFx9XCJdL2c7XG4gIGZ1bmN0aW9uIHRyYW5zZm9ybUNzcyhjc3MsIGlkKSB7XG4gIFx0dmFyIHRyYW5zZm9ybWVkLCBkYXRhQXR0ciwgYWRkR3VpZDtcblxuICBcdGRhdGFBdHRyID0gXCJbZGF0YS1yYWN0aXZlLWNzc349XFxcIntcIiArIGlkICsgXCJ9XFxcIl1cIjtcblxuICBcdGFkZEd1aWQgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgXHRcdHZhciBzZWxlY3RvclVuaXRzLFxuICBcdFx0ICAgIG1hdGNoLFxuICBcdFx0ICAgIHVuaXQsXG4gIFx0XHQgICAgYmFzZSxcbiAgXHRcdCAgICBwcmVwZW5kZWQsXG4gIFx0XHQgICAgYXBwZW5kZWQsXG4gIFx0XHQgICAgaSxcbiAgXHRcdCAgICB0cmFuc2Zvcm1lZCA9IFtdO1xuXG4gIFx0XHRzZWxlY3RvclVuaXRzID0gW107XG5cbiAgXHRcdHdoaWxlIChtYXRjaCA9IHNlbGVjdG9yVW5pdFBhdHRlcm4uZXhlYyhzZWxlY3RvcikpIHtcbiAgXHRcdFx0c2VsZWN0b3JVbml0cy5wdXNoKHtcbiAgXHRcdFx0XHRzdHI6IG1hdGNoWzBdLFxuICBcdFx0XHRcdGJhc2U6IG1hdGNoWzFdLFxuICBcdFx0XHRcdG1vZGlmaWVyczogbWF0Y2hbMl1cbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIEZvciBlYWNoIHNpbXBsZSBzZWxlY3RvciB3aXRoaW4gdGhlIHNlbGVjdG9yLCB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHZlcnNpb25cbiAgXHRcdC8vIHRoYXQgYSkgY29tYmluZXMgd2l0aCB0aGUgaWQsIGFuZCBiKSBpcyBpbnNpZGUgdGhlIGlkXG4gIFx0XHRiYXNlID0gc2VsZWN0b3JVbml0cy5tYXAoZXh0cmFjdFN0cmluZyk7XG5cbiAgXHRcdGkgPSBzZWxlY3RvclVuaXRzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0YXBwZW5kZWQgPSBiYXNlLnNsaWNlKCk7XG5cbiAgXHRcdFx0Ly8gUHNldWRvLXNlbGVjdG9ycyBzaG91bGQgZ28gYWZ0ZXIgdGhlIGF0dHJpYnV0ZSBzZWxlY3RvclxuICBcdFx0XHR1bml0ID0gc2VsZWN0b3JVbml0c1tpXTtcbiAgXHRcdFx0YXBwZW5kZWRbaV0gPSB1bml0LmJhc2UgKyBkYXRhQXR0ciArIHVuaXQubW9kaWZpZXJzIHx8IFwiXCI7XG5cbiAgXHRcdFx0cHJlcGVuZGVkID0gYmFzZS5zbGljZSgpO1xuICBcdFx0XHRwcmVwZW5kZWRbaV0gPSBkYXRhQXR0ciArIFwiIFwiICsgcHJlcGVuZGVkW2ldO1xuXG4gIFx0XHRcdHRyYW5zZm9ybWVkLnB1c2goYXBwZW5kZWQuam9pbihcIiBcIiksIHByZXBlbmRlZC5qb2luKFwiIFwiKSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0cmFuc2Zvcm1lZC5qb2luKFwiLCBcIik7XG4gIFx0fTtcblxuICBcdGlmIChkYXRhUnZjR3VpZFBhdHRlcm4udGVzdChjc3MpKSB7XG4gIFx0XHR0cmFuc2Zvcm1lZCA9IGNzcy5yZXBsYWNlKGRhdGFSdmNHdWlkUGF0dGVybiwgZGF0YUF0dHIpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHR0cmFuc2Zvcm1lZCA9IGNzcy5yZXBsYWNlKGNvbW1lbnRzUGF0dGVybiwgXCJcIikucmVwbGFjZShzZWxlY3RvcnNQYXR0ZXJuLCBmdW5jdGlvbiAobWF0Y2gsICQxKSB7XG4gIFx0XHRcdHZhciBzZWxlY3RvcnMsIHRyYW5zZm9ybWVkO1xuXG4gIFx0XHRcdC8vIGRvbid0IHRyYW5zZm9ybSBtZWRpYSBxdWVyaWVzIVxuICBcdFx0XHRpZiAobWVkaWFRdWVyeVBhdHRlcm4udGVzdCgkMSkpIHJldHVybiBtYXRjaDtcblxuICBcdFx0XHRzZWxlY3RvcnMgPSAkMS5zcGxpdChcIixcIikubWFwKHRyaW0pO1xuICBcdFx0XHR0cmFuc2Zvcm1lZCA9IHNlbGVjdG9ycy5tYXAoYWRkR3VpZCkuam9pbihcIiwgXCIpICsgXCIgXCI7XG5cbiAgXHRcdFx0cmV0dXJuIG1hdGNoLnJlcGxhY2UoJDEsIHRyYW5zZm9ybWVkKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIFx0aWYgKHN0ci50cmltKSB7XG4gIFx0XHRyZXR1cm4gc3RyLnRyaW0oKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrLywgXCJcIikucmVwbGFjZSgvXFxzKyQvLCBcIlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3RTdHJpbmcodW5pdCkge1xuICBcdHJldHVybiB1bml0LnN0cjtcbiAgfVxuXG4gIHZhciBjc3NfY3NzX191aWQgPSAxO1xuXG4gIHZhciBjc3NDb25maWd1cmF0b3IgPSB7XG4gIFx0bmFtZTogXCJjc3NcIixcblxuICBcdGV4dGVuZDogZnVuY3Rpb24gKFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpIHtcbiAgXHRcdGlmIChvcHRpb25zLmNzcykge1xuICBcdFx0XHR2YXIgaWQgPSBjc3NfY3NzX191aWQrKztcbiAgXHRcdFx0dmFyIHN0eWxlcyA9IG9wdGlvbnMubm9Dc3NUcmFuc2Zvcm0gPyBvcHRpb25zLmNzcyA6IHRyYW5zZm9ybShvcHRpb25zLmNzcywgaWQpO1xuXG4gIFx0XHRcdHByb3RvLmNzc0lkID0gaWQ7XG4gIFx0XHRcdGdsb2JhbF9jc3MuYWRkKHsgaWQ6IGlkLCBzdHlsZXM6IHN0eWxlcyB9KTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKCkge31cbiAgfTtcblxuICB2YXIgY3NzX2NzcyA9IGNzc0NvbmZpZ3VyYXRvcjtcblxuICBmdW5jdGlvbiB2YWxpZGF0ZShkYXRhKSB7XG4gIFx0Ly8gV2FybiBpZiB1c2VyT3B0aW9ucy5kYXRhIGlzIGEgbm9uLVBPSk9cbiAgXHRpZiAoZGF0YSAmJiBkYXRhLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgXHRcdGlmICh0eXBlb2YgZGF0YSA9PT0gXCJmdW5jdGlvblwiKSB7fSBlbHNlIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIikge1xuICBcdFx0XHRmYXRhbChcImRhdGEgb3B0aW9uIG11c3QgYmUgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIGBcIiArIGRhdGEgKyBcImAgaXMgbm90IHZhbGlkXCIpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0d2FybklmRGVidWcoXCJJZiBzdXBwbGllZCwgb3B0aW9ucy5kYXRhIHNob3VsZCBiZSBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0IC0gdXNpbmcgYSBub24tUE9KTyBhcyB0aGUgcm9vdCBvYmplY3QgbWF5IHdvcmssIGJ1dCBpcyBkaXNjb3VyYWdlZFwiKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgZGF0YUNvbmZpZ3VyYXRvciA9IHtcbiAgXHRuYW1lOiBcImRhdGFcIixcblxuICBcdGV4dGVuZDogZnVuY3Rpb24gKFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpIHtcbiAgXHRcdHZhciBrZXkgPSB1bmRlZmluZWQsXG4gIFx0XHQgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgXHRcdC8vIGNoZWNrIGZvciBub24tcHJpbWl0aXZlcywgd2hpY2ggY291bGQgY2F1c2UgbXV0YXRpb24tcmVsYXRlZCBidWdzXG4gIFx0XHRpZiAob3B0aW9ucy5kYXRhICYmIGlzT2JqZWN0KG9wdGlvbnMuZGF0YSkpIHtcbiAgXHRcdFx0Zm9yIChrZXkgaW4gb3B0aW9ucy5kYXRhKSB7XG4gIFx0XHRcdFx0dmFsdWUgPSBvcHRpb25zLmRhdGFba2V5XTtcblxuICBcdFx0XHRcdGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdFx0XHRcdGlmIChpc09iamVjdCh2YWx1ZSkgfHwgaXNBcnJheSh2YWx1ZSkpIHtcbiAgXHRcdFx0XHRcdFx0d2FybklmRGVidWcoXCJQYXNzaW5nIGEgYGRhdGFgIG9wdGlvbiB3aXRoIG9iamVjdCBhbmQgYXJyYXkgcHJvcGVydGllcyB0byBSYWN0aXZlLmV4dGVuZCgpIGlzIGRpc2NvdXJhZ2VkLCBhcyBtdXRhdGluZyB0aGVtIGlzIGxpa2VseSB0byBjYXVzZSBidWdzLiBDb25zaWRlciB1c2luZyBhIGRhdGEgZnVuY3Rpb24gaW5zdGVhZDpcXG5cXG4gIC8vIHRoaXMuLi5cXG4gIGRhdGE6IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBteU9iamVjdDoge31cXG4gICAgfTtcXG4gIH0pXFxuXFxuICAvLyBpbnN0ZWFkIG9mIHRoaXM6XFxuICBkYXRhOiB7XFxuICAgIG15T2JqZWN0OiB7fVxcbiAgfVwiKTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cHJvdG8uZGF0YSA9IGN1c3RvbV9kYXRhX19jb21iaW5lKHByb3RvLmRhdGEsIG9wdGlvbnMuZGF0YSk7XG4gIFx0fSxcblxuICBcdGluaXQ6IGZ1bmN0aW9uIChQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMpIHtcbiAgXHRcdHZhciByZXN1bHQgPSBjdXN0b21fZGF0YV9fY29tYmluZShQYXJlbnQucHJvdG90eXBlLmRhdGEsIG9wdGlvbnMuZGF0YSk7XG5cbiAgXHRcdGlmICh0eXBlb2YgcmVzdWx0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0cmVzdWx0ID0gcmVzdWx0LmNhbGwocmFjdGl2ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiByZXN1bHQgfHwge307XG4gIFx0fSxcblxuICBcdHJlc2V0OiBmdW5jdGlvbiAocmFjdGl2ZSkge1xuICBcdFx0dmFyIHJlc3VsdCA9IHRoaXMuaW5pdChyYWN0aXZlLmNvbnN0cnVjdG9yLCByYWN0aXZlLCByYWN0aXZlLnZpZXdtb2RlbCk7XG5cbiAgXHRcdHJhY3RpdmUudmlld21vZGVsLnJlc2V0KHJlc3VsdCk7XG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIGN1c3RvbV9kYXRhID0gZGF0YUNvbmZpZ3VyYXRvcjtcblxuICBmdW5jdGlvbiBjdXN0b21fZGF0YV9fY29tYmluZShwYXJlbnRWYWx1ZSwgY2hpbGRWYWx1ZSkge1xuICBcdHZhbGlkYXRlKGNoaWxkVmFsdWUpO1xuXG4gIFx0dmFyIHBhcmVudElzRm4gPSB0eXBlb2YgcGFyZW50VmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbiAgXHR2YXIgY2hpbGRJc0ZuID0gdHlwZW9mIGNoaWxkVmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcblxuICBcdC8vIFZlcnkgaW1wb3J0YW50LCBvdGhlcndpc2UgY2hpbGQgaW5zdGFuY2UgY2FuIGJlY29tZVxuICBcdC8vIHRoZSBkZWZhdWx0IGRhdGEgb2JqZWN0IG9uIFJhY3RpdmUgb3IgYSBjb21wb25lbnQuXG4gIFx0Ly8gdGhlbiByYWN0aXZlLnNldCgpIGVuZHMgdXAgc2V0dGluZyBvbiB0aGUgcHJvdG90eXBlIVxuICBcdGlmICghY2hpbGRWYWx1ZSAmJiAhcGFyZW50SXNGbikge1xuICBcdFx0Y2hpbGRWYWx1ZSA9IHt9O1xuICBcdH1cblxuICBcdC8vIEZhc3QgcGF0aCwgd2hlcmUgd2UganVzdCBuZWVkIHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gIFx0Ly8gcGFyZW50IHRvIGNoaWxkXG4gIFx0aWYgKCFwYXJlbnRJc0ZuICYmICFjaGlsZElzRm4pIHtcbiAgXHRcdHJldHVybiBmcm9tUHJvcGVydGllcyhjaGlsZFZhbHVlLCBwYXJlbnRWYWx1ZSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBjaGlsZCA9IGNoaWxkSXNGbiA/IGNhbGxEYXRhRnVuY3Rpb24oY2hpbGRWYWx1ZSwgdGhpcykgOiBjaGlsZFZhbHVlO1xuICBcdFx0dmFyIHBhcmVudCA9IHBhcmVudElzRm4gPyBjYWxsRGF0YUZ1bmN0aW9uKHBhcmVudFZhbHVlLCB0aGlzKSA6IHBhcmVudFZhbHVlO1xuXG4gIFx0XHRyZXR1cm4gZnJvbVByb3BlcnRpZXMoY2hpbGQsIHBhcmVudCk7XG4gIFx0fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxEYXRhRnVuY3Rpb24oZm4sIGNvbnRleHQpIHtcbiAgXHR2YXIgZGF0YSA9IGZuLmNhbGwoY29udGV4dCk7XG5cbiAgXHRpZiAoIWRhdGEpIHJldHVybjtcblxuICBcdGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIikge1xuICBcdFx0ZmF0YWwoXCJEYXRhIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGFuIG9iamVjdFwiKTtcbiAgXHR9XG5cbiAgXHRpZiAoZGF0YS5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gIFx0XHR3YXJuT25jZUlmRGVidWcoXCJEYXRhIGZ1bmN0aW9uIHJldHVybmVkIHNvbWV0aGluZyBvdGhlciB0aGFuIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QuIFRoaXMgbWlnaHQgd29yaywgYnV0IGlzIHN0cm9uZ2x5IGRpc2NvdXJhZ2VkXCIpO1xuICBcdH1cblxuICBcdHJldHVybiBkYXRhO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJvbVByb3BlcnRpZXMocHJpbWFyeSwgc2Vjb25kYXJ5KSB7XG4gIFx0aWYgKHByaW1hcnkgJiYgc2Vjb25kYXJ5KSB7XG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gc2Vjb25kYXJ5KSB7XG4gIFx0XHRcdGlmICghKGtleSBpbiBwcmltYXJ5KSkge1xuICBcdFx0XHRcdHByaW1hcnlba2V5XSA9IHNlY29uZGFyeVtrZXldO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBwcmltYXJ5O1xuICBcdH1cblxuICBcdHJldHVybiBwcmltYXJ5IHx8IHNlY29uZGFyeTtcbiAgfVxuXG4gIC8vIFRPRE8gZG8gd2UgbmVlZCB0byBzdXBwb3J0IHRoaXMgaW4gdGhlIG5ldyBSYWN0aXZlKCkgY2FzZT9cblxuICB2YXIgUGFyc2VyLFxuICAgICAgUGFyc2VFcnJvcixcbiAgICAgIHBhcnNlX1BhcnNlcl9fbGVhZGluZ1doaXRlc3BhY2UgPSAvXlxccysvO1xuXG4gIFBhcnNlRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICBcdHRoaXMubmFtZSA9IFwiUGFyc2VFcnJvclwiO1xuICBcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIFx0dHJ5IHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgXHR9IGNhdGNoIChlKSB7XG4gIFx0XHR0aGlzLnN0YWNrID0gZS5zdGFjaztcbiAgXHR9XG4gIH07XG5cbiAgUGFyc2VFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgUGFyc2VyID0gZnVuY3Rpb24gKHN0ciwgb3B0aW9ucykge1xuICBcdHZhciBpdGVtcyxcbiAgXHQgICAgaXRlbSxcbiAgXHQgICAgbGluZVN0YXJ0ID0gMDtcblxuICBcdHRoaXMuc3RyID0gc3RyO1xuICBcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIFx0dGhpcy5wb3MgPSAwO1xuXG4gIFx0dGhpcy5saW5lcyA9IHRoaXMuc3RyLnNwbGl0KFwiXFxuXCIpO1xuICBcdHRoaXMubGluZUVuZHMgPSB0aGlzLmxpbmVzLm1hcChmdW5jdGlvbiAobGluZSkge1xuICBcdFx0dmFyIGxpbmVFbmQgPSBsaW5lU3RhcnQgKyBsaW5lLmxlbmd0aCArIDE7IC8vICsxIGZvciB0aGUgbmV3bGluZVxuXG4gIFx0XHRsaW5lU3RhcnQgPSBsaW5lRW5kO1xuICBcdFx0cmV0dXJuIGxpbmVFbmQ7XG4gIFx0fSwgMCk7XG5cbiAgXHQvLyBDdXN0b20gaW5pdCBsb2dpY1xuICBcdGlmICh0aGlzLmluaXQpIHRoaXMuaW5pdChzdHIsIG9wdGlvbnMpO1xuXG4gIFx0aXRlbXMgPSBbXTtcblxuICBcdHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuc3RyLmxlbmd0aCAmJiAoaXRlbSA9IHRoaXMucmVhZCgpKSkge1xuICBcdFx0aXRlbXMucHVzaChpdGVtKTtcbiAgXHR9XG5cbiAgXHR0aGlzLmxlZnRvdmVyID0gdGhpcy5yZW1haW5pbmcoKTtcbiAgXHR0aGlzLnJlc3VsdCA9IHRoaXMucG9zdFByb2Nlc3MgPyB0aGlzLnBvc3RQcm9jZXNzKGl0ZW1zLCBvcHRpb25zKSA6IGl0ZW1zO1xuICB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUgPSB7XG4gIFx0cmVhZDogZnVuY3Rpb24gKGNvbnZlcnRlcnMpIHtcbiAgXHRcdHZhciBwb3MsIGksIGxlbiwgaXRlbTtcblxuICBcdFx0aWYgKCFjb252ZXJ0ZXJzKSBjb252ZXJ0ZXJzID0gdGhpcy5jb252ZXJ0ZXJzO1xuXG4gIFx0XHRwb3MgPSB0aGlzLnBvcztcblxuICBcdFx0bGVuID0gY29udmVydGVycy5sZW5ndGg7XG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0dGhpcy5wb3MgPSBwb3M7IC8vIHJlc2V0IGZvciBlYWNoIGF0dGVtcHRcblxuICBcdFx0XHRpZiAoaXRlbSA9IGNvbnZlcnRlcnNbaV0odGhpcykpIHtcbiAgXHRcdFx0XHRyZXR1cm4gaXRlbTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9LFxuXG4gIFx0Z2V0TGluZVBvczogZnVuY3Rpb24gKGNoYXIpIHtcbiAgXHRcdHZhciBsaW5lTnVtID0gMCxcbiAgXHRcdCAgICBsaW5lU3RhcnQgPSAwLFxuICBcdFx0ICAgIGNvbHVtbk51bTtcblxuICBcdFx0d2hpbGUgKGNoYXIgPj0gdGhpcy5saW5lRW5kc1tsaW5lTnVtXSkge1xuICBcdFx0XHRsaW5lU3RhcnQgPSB0aGlzLmxpbmVFbmRzW2xpbmVOdW1dO1xuICBcdFx0XHRsaW5lTnVtICs9IDE7XG4gIFx0XHR9XG5cbiAgXHRcdGNvbHVtbk51bSA9IGNoYXIgLSBsaW5lU3RhcnQ7XG4gIFx0XHRyZXR1cm4gW2xpbmVOdW0gKyAxLCBjb2x1bW5OdW0gKyAxLCBjaGFyXTsgLy8gbGluZS9jb2wgc2hvdWxkIGJlIG9uZS1iYXNlZCwgbm90IHplcm8tYmFzZWQhXG4gIFx0fSxcblxuICBcdGVycm9yOiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICBcdFx0dmFyIHBvcyA9IHRoaXMuZ2V0TGluZVBvcyh0aGlzLnBvcyk7XG4gIFx0XHR2YXIgbGluZU51bSA9IHBvc1swXTtcbiAgXHRcdHZhciBjb2x1bW5OdW0gPSBwb3NbMV07XG5cbiAgXHRcdHZhciBsaW5lID0gdGhpcy5saW5lc1twb3NbMF0gLSAxXTtcbiAgXHRcdHZhciBudW1UYWJzID0gMDtcbiAgXHRcdHZhciBhbm5vdGF0aW9uID0gbGluZS5yZXBsYWNlKC9cXHQvZywgZnVuY3Rpb24gKG1hdGNoLCBjaGFyKSB7XG4gIFx0XHRcdGlmIChjaGFyIDwgcG9zWzFdKSB7XG4gIFx0XHRcdFx0bnVtVGFicyArPSAxO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIFwiICBcIjtcbiAgXHRcdH0pICsgXCJcXG5cIiArIG5ldyBBcnJheShwb3NbMV0gKyBudW1UYWJzKS5qb2luKFwiIFwiKSArIFwiXi0tLS1cIjtcblxuICBcdFx0dmFyIGVycm9yID0gbmV3IFBhcnNlRXJyb3IoXCJcIiArIG1lc3NhZ2UgKyBcIiBhdCBsaW5lIFwiICsgbGluZU51bSArIFwiIGNoYXJhY3RlciBcIiArIGNvbHVtbk51bSArIFwiOlxcblwiICsgYW5ub3RhdGlvbik7XG5cbiAgXHRcdGVycm9yLmxpbmUgPSBwb3NbMF07XG4gIFx0XHRlcnJvci5jaGFyYWN0ZXIgPSBwb3NbMV07XG4gIFx0XHRlcnJvci5zaG9ydE1lc3NhZ2UgPSBtZXNzYWdlO1xuXG4gIFx0XHR0aHJvdyBlcnJvcjtcbiAgXHR9LFxuXG4gIFx0bWF0Y2hTdHJpbmc6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgXHRcdGlmICh0aGlzLnN0ci5zdWJzdHIodGhpcy5wb3MsIHN0cmluZy5sZW5ndGgpID09PSBzdHJpbmcpIHtcbiAgXHRcdFx0dGhpcy5wb3MgKz0gc3RyaW5nLmxlbmd0aDtcbiAgXHRcdFx0cmV0dXJuIHN0cmluZztcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0bWF0Y2hQYXR0ZXJuOiBmdW5jdGlvbiAocGF0dGVybikge1xuICBcdFx0dmFyIG1hdGNoO1xuXG4gIFx0XHRpZiAobWF0Y2ggPSBwYXR0ZXJuLmV4ZWModGhpcy5yZW1haW5pbmcoKSkpIHtcbiAgXHRcdFx0dGhpcy5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICBcdFx0XHRyZXR1cm4gbWF0Y2hbMV0gfHwgbWF0Y2hbMF07XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGFsbG93V2hpdGVzcGFjZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5tYXRjaFBhdHRlcm4ocGFyc2VfUGFyc2VyX19sZWFkaW5nV2hpdGVzcGFjZSk7XG4gIFx0fSxcblxuICBcdHJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuc3RyLnN1YnN0cmluZyh0aGlzLnBvcyk7XG4gIFx0fSxcblxuICBcdG5leHRDaGFyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5zdHIuY2hhckF0KHRoaXMucG9zKTtcbiAgXHR9XG4gIH07XG5cbiAgUGFyc2VyLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm90bykge1xuICBcdHZhciBQYXJlbnQgPSB0aGlzLFxuICBcdCAgICBDaGlsZCxcbiAgXHQgICAga2V5O1xuXG4gIFx0Q2hpbGQgPSBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG4gIFx0XHRQYXJzZXIuY2FsbCh0aGlzLCBzdHIsIG9wdGlvbnMpO1xuICBcdH07XG5cbiAgXHRDaGlsZC5wcm90b3R5cGUgPSBjcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XG5cbiAgXHRmb3IgKGtleSBpbiBwcm90bykge1xuICBcdFx0aWYgKGhhc093bi5jYWxsKHByb3RvLCBrZXkpKSB7XG4gIFx0XHRcdENoaWxkLnByb3RvdHlwZVtrZXldID0gcHJvdG9ba2V5XTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRDaGlsZC5leHRlbmQgPSBQYXJzZXIuZXh0ZW5kO1xuICBcdHJldHVybiBDaGlsZDtcbiAgfTtcblxuICB2YXIgcGFyc2VfUGFyc2VyID0gUGFyc2VyO1xuXG4gIHZhciBURVhUID0gMTtcbiAgdmFyIElOVEVSUE9MQVRPUiA9IDI7XG4gIHZhciBUUklQTEUgPSAzO1xuICB2YXIgU0VDVElPTiA9IDQ7XG4gIHZhciBJTlZFUlRFRCA9IDU7XG4gIHZhciBDTE9TSU5HID0gNjtcbiAgdmFyIEVMRU1FTlQgPSA3O1xuICB2YXIgUEFSVElBTCA9IDg7XG4gIHZhciBDT01NRU5UID0gOTtcbiAgdmFyIERFTElNQ0hBTkdFID0gMTA7XG4gIHZhciBBVFRSSUJVVEUgPSAxMztcbiAgdmFyIENMT1NJTkdfVEFHID0gMTQ7XG4gIHZhciBDT01QT05FTlQgPSAxNTtcbiAgdmFyIFlJRUxERVIgPSAxNjtcbiAgdmFyIElOTElORV9QQVJUSUFMID0gMTc7XG4gIHZhciBET0NUWVBFID0gMTg7XG5cbiAgdmFyIE5VTUJFUl9MSVRFUkFMID0gMjA7XG4gIHZhciBTVFJJTkdfTElURVJBTCA9IDIxO1xuICB2YXIgQVJSQVlfTElURVJBTCA9IDIyO1xuICB2YXIgT0JKRUNUX0xJVEVSQUwgPSAyMztcbiAgdmFyIEJPT0xFQU5fTElURVJBTCA9IDI0O1xuICB2YXIgUkVHRVhQX0xJVEVSQUwgPSAyNTtcblxuICB2YXIgR0xPQkFMID0gMjY7XG4gIHZhciBLRVlfVkFMVUVfUEFJUiA9IDI3O1xuXG4gIHZhciBSRUZFUkVOQ0UgPSAzMDtcbiAgdmFyIFJFRklORU1FTlQgPSAzMTtcbiAgdmFyIE1FTUJFUiA9IDMyO1xuICB2YXIgUFJFRklYX09QRVJBVE9SID0gMzM7XG4gIHZhciBCUkFDS0VURUQgPSAzNDtcbiAgdmFyIENPTkRJVElPTkFMID0gMzU7XG4gIHZhciBJTkZJWF9PUEVSQVRPUiA9IDM2O1xuXG4gIHZhciBJTlZPQ0FUSU9OID0gNDA7XG5cbiAgdmFyIFNFQ1RJT05fSUYgPSA1MDtcbiAgdmFyIFNFQ1RJT05fVU5MRVNTID0gNTE7XG4gIHZhciBTRUNUSU9OX0VBQ0ggPSA1MjtcbiAgdmFyIFNFQ1RJT05fV0lUSCA9IDUzO1xuICB2YXIgU0VDVElPTl9JRl9XSVRIID0gNTQ7XG5cbiAgdmFyIEVMU0UgPSA2MDtcbiAgdmFyIEVMU0VJRiA9IDYxO1xuXG4gIHZhciBtdXN0YWNoZV9yZWFkRGVsaW1pdGVyQ2hhbmdlID0gcmVhZERlbGltaXRlckNoYW5nZTtcbiAgdmFyIGRlbGltaXRlckNoYW5nZVBhdHRlcm4gPSAvXlteXFxzPV0rLyxcbiAgICAgIHdoaXRlc3BhY2VQYXR0ZXJuID0gL15cXHMrLztcbiAgZnVuY3Rpb24gcmVhZERlbGltaXRlckNoYW5nZShwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIG9wZW5pbmcsIGNsb3Npbmc7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIj1cIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlIG5ldyBvcGVuaW5nIGRlbGltaXRlclxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdG9wZW5pbmcgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKGRlbGltaXRlckNoYW5nZVBhdHRlcm4pO1xuICBcdGlmICghb3BlbmluZykge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSAoaW4gZmFjdCwgaXQncyBuZWNlc3NhcnkuLi4pXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hQYXR0ZXJuKHdoaXRlc3BhY2VQYXR0ZXJuKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Y2xvc2luZyA9IHBhcnNlci5tYXRjaFBhdHRlcm4oZGVsaW1pdGVyQ2hhbmdlUGF0dGVybik7XG4gIFx0aWYgKCFjbG9zaW5nKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJlZm9yZSBjbG9zaW5nICc9J1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiPVwiKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIFtvcGVuaW5nLCBjbG9zaW5nXTtcbiAgfVxuXG4gIHZhciByZWFkUmVnZXhwTGl0ZXJhbCA9IHJlYWRSZWdleHBMaXRlcmFsX19yZWFkTnVtYmVyTGl0ZXJhbDtcbiAgdmFyIHJlZ2V4cFBhdHRlcm4gPSAvXihcXC8oPzpbXlxcblxcclxcdTIwMjhcXHUyMDI5L1xcXFxbXXxcXFxcLnxcXFsoPzpbXlxcblxcclxcdTIwMjhcXHUyMDI5XFxdXFxcXF18XFxcXC4pKl0pK1xcLyg/OihbZ2ltdXldKSg/IVthLXpdKlxcMikpKig/IVthLXpBLVpfJDAtOV0pKS87XG4gIGZ1bmN0aW9uIHJlYWRSZWdleHBMaXRlcmFsX19yZWFkTnVtYmVyTGl0ZXJhbChwYXJzZXIpIHtcbiAgXHR2YXIgcmVzdWx0O1xuXG4gIFx0aWYgKHJlc3VsdCA9IHBhcnNlci5tYXRjaFBhdHRlcm4ocmVnZXhwUGF0dGVybikpIHtcbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IFJFR0VYUF9MSVRFUkFMLFxuICBcdFx0XHR2OiByZXN1bHRcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgY29udmVydGVyc19yZWFkTXVzdGFjaGUgPSByZWFkTXVzdGFjaGU7XG5cbiAgdmFyIGRlbGltaXRlckNoYW5nZVRva2VuID0geyB0OiBERUxJTUNIQU5HRSwgZXhjbHVkZTogdHJ1ZSB9O1xuICBmdW5jdGlvbiByZWFkTXVzdGFjaGUocGFyc2VyKSB7XG4gIFx0dmFyIG11c3RhY2hlLCBpO1xuXG4gIFx0Ly8gSWYgd2UncmUgaW5zaWRlIGEgPHNjcmlwdD4gb3IgPHN0eWxlPiB0YWcsIGFuZCB3ZSdyZSBub3RcbiAgXHQvLyBpbnRlcnBvbGF0aW5nLCBidWcgb3V0XG4gIFx0aWYgKHBhcnNlci5pbnRlcnBvbGF0ZVtwYXJzZXIuaW5zaWRlXSA9PT0gZmFsc2UpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGZvciAoaSA9IDA7IGkgPCBwYXJzZXIudGFncy5sZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0aWYgKG11c3RhY2hlID0gcmVhZE11c3RhY2hlT2ZUeXBlKHBhcnNlciwgcGFyc2VyLnRhZ3NbaV0pKSB7XG4gIFx0XHRcdHJldHVybiBtdXN0YWNoZTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkTXVzdGFjaGVPZlR5cGUocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQsIG11c3RhY2hlLCByZWFkZXIsIGk7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiXFxcXFwiICsgdGFnLm9wZW4pKSB7XG4gIFx0XHRpZiAoc3RhcnQgPT09IDAgfHwgcGFyc2VyLnN0cltzdGFydCAtIDFdICE9PSBcIlxcXFxcIikge1xuICBcdFx0XHRyZXR1cm4gdGFnLm9wZW47XG4gIFx0XHR9XG4gIFx0fSBlbHNlIGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5vcGVuKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gZGVsaW1pdGVyIGNoYW5nZT9cbiAgXHRpZiAobXVzdGFjaGUgPSBtdXN0YWNoZV9yZWFkRGVsaW1pdGVyQ2hhbmdlKHBhcnNlcikpIHtcbiAgXHRcdC8vIGZpbmQgY2xvc2luZyBkZWxpbWl0ZXIgb3IgYWJvcnQuLi5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIC4uLnRoZW4gbWFrZSB0aGUgc3dpdGNoXG4gIFx0XHR0YWcub3BlbiA9IG11c3RhY2hlWzBdO1xuICBcdFx0dGFnLmNsb3NlID0gbXVzdGFjaGVbMV07XG4gIFx0XHRwYXJzZXIuc29ydE11c3RhY2hlVGFncygpO1xuXG4gIFx0XHRyZXR1cm4gZGVsaW1pdGVyQ2hhbmdlVG9rZW47XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0Ly8gaWxsZWdhbCBzZWN0aW9uIGNsb3NlclxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIvXCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zIC09IDE7XG4gIFx0XHR2YXIgcmV3aW5kID0gcGFyc2VyLnBvcztcbiAgXHRcdGlmICghcmVhZFJlZ2V4cExpdGVyYWwocGFyc2VyKSkge1xuICBcdFx0XHRwYXJzZXIucG9zID0gcmV3aW5kIC0gdGFnLmNsb3NlLmxlbmd0aDtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiQXR0ZW1wdGVkIHRvIGNsb3NlIGEgc2VjdGlvbiB0aGF0IHdhc24ndCBvcGVuXCIpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHJld2luZDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRmb3IgKGkgPSAwOyBpIDwgdGFnLnJlYWRlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdHJlYWRlciA9IHRhZy5yZWFkZXJzW2ldO1xuXG4gIFx0XHRpZiAobXVzdGFjaGUgPSByZWFkZXIocGFyc2VyLCB0YWcpKSB7XG4gIFx0XHRcdGlmICh0YWcuaXNTdGF0aWMpIHtcbiAgXHRcdFx0XHRtdXN0YWNoZS5zID0gdHJ1ZTsgLy8gVE9ETyBtYWtlIHRoaXMgYDFgIGluc3RlYWQgLSBtb3JlIGNvbXBhY3RcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChwYXJzZXIuaW5jbHVkZUxpbmVQb3NpdGlvbnMpIHtcbiAgXHRcdFx0XHRtdXN0YWNoZS5wID0gcGFyc2VyLmdldExpbmVQb3Moc3RhcnQpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIG11c3RhY2hlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBleHBlY3RlZEV4cHJlc3Npb24gPSBcIkV4cGVjdGVkIGEgSmF2YVNjcmlwdCBleHByZXNzaW9uXCI7XG4gIHZhciBleHBlY3RlZFBhcmVuID0gXCJFeHBlY3RlZCBjbG9zaW5nIHBhcmVuXCI7XG5cbiAgdmFyIGxpdGVyYWxfcmVhZE51bWJlckxpdGVyYWwgPSBsaXRlcmFsX3JlYWROdW1iZXJMaXRlcmFsX19yZWFkTnVtYmVyTGl0ZXJhbDtcbiAgdmFyIGxpdGVyYWxfcmVhZE51bWJlckxpdGVyYWxfX251bWJlclBhdHRlcm4gPSAvXig/OlsrLV0/KTAqKD86KD86KD86WzEtOV1cXGQqKT9cXC5cXGQrKXwoPzooPzowfFsxLTldXFxkKilcXC4pfCg/OjB8WzEtOV1cXGQqKSkoPzpbZUVdWystXT9cXGQrKT8vO1xuICBmdW5jdGlvbiBsaXRlcmFsX3JlYWROdW1iZXJMaXRlcmFsX19yZWFkTnVtYmVyTGl0ZXJhbChwYXJzZXIpIHtcbiAgXHR2YXIgcmVzdWx0O1xuXG4gIFx0aWYgKHJlc3VsdCA9IHBhcnNlci5tYXRjaFBhdHRlcm4obGl0ZXJhbF9yZWFkTnVtYmVyTGl0ZXJhbF9fbnVtYmVyUGF0dGVybikpIHtcbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IE5VTUJFUl9MSVRFUkFMLFxuICBcdFx0XHR2OiByZXN1bHRcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbGl0ZXJhbF9yZWFkQm9vbGVhbkxpdGVyYWwgPSByZWFkQm9vbGVhbkxpdGVyYWw7XG4gIGZ1bmN0aW9uIHJlYWRCb29sZWFuTGl0ZXJhbChwYXJzZXIpIHtcbiAgXHR2YXIgcmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXG4gIFx0aWYgKHJlbWFpbmluZy5zdWJzdHIoMCwgNCkgPT09IFwidHJ1ZVwiKSB7XG4gIFx0XHRwYXJzZXIucG9zICs9IDQ7XG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBCT09MRUFOX0xJVEVSQUwsXG4gIFx0XHRcdHY6IFwidHJ1ZVwiXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdGlmIChyZW1haW5pbmcuc3Vic3RyKDAsIDUpID09PSBcImZhbHNlXCIpIHtcbiAgXHRcdHBhcnNlci5wb3MgKz0gNTtcbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IEJPT0xFQU5fTElURVJBTCxcbiAgXHRcdFx0djogXCJmYWxzZVwiXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHN0cmluZ01pZGRsZVBhdHRlcm4sIGVzY2FwZVNlcXVlbmNlUGF0dGVybiwgbGluZUNvbnRpbnVhdGlvblBhdHRlcm47XG5cbiAgLy8gTWF0Y2ggb25lIG9yIG1vcmUgY2hhcmFjdGVycyB1bnRpbDogXCIsICcsIFxcLCBvciBFT0wvRU9GLlxuICAvLyBFT0wvRU9GIGlzIHdyaXR0ZW4gYXMgKD8hLikgKG1lYW5pbmcgdGhlcmUncyBubyBub24tbmV3bGluZSBjaGFyIG5leHQpLlxuICBzdHJpbmdNaWRkbGVQYXR0ZXJuID0gL14oPz0uKVteXCInXFxcXF0rPyg/Oig/IS4pfCg/PVtcIidcXFxcXSkpLztcblxuICAvLyBNYXRjaCBvbmUgZXNjYXBlIHNlcXVlbmNlLCBpbmNsdWRpbmcgdGhlIGJhY2tzbGFzaC5cbiAgZXNjYXBlU2VxdWVuY2VQYXR0ZXJuID0gL15cXFxcKD86WydcIlxcXFxiZm5ydF18MCg/IVswLTldKXx4WzAtOWEtZkEtRl17Mn18dVswLTlhLWZBLUZdezR9fCg/PS4pW151eDAtOV0pLztcblxuICAvLyBNYXRjaCBvbmUgRVM1IGxpbmUgY29udGludWF0aW9uIChiYWNrc2xhc2ggKyBsaW5lIHRlcm1pbmF0b3IpLlxuICBsaW5lQ29udGludWF0aW9uUGF0dGVybiA9IC9eXFxcXCg/OlxcclxcbnxbXFx1MDAwQVxcdTAwMERcXHUyMDI4XFx1MjAyOV0pLztcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIGdldERvdWJsZVF1b3RlZFN0cmluZyBhbmQgZ2V0U2luZ2xlUXVvdGVkU3RyaW5nLlxuICB2YXIgbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIgPSBmdW5jdGlvbiAob2tRdW90ZSkge1xuICBcdHJldHVybiBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0XHR2YXIgc3RhcnQsIGxpdGVyYWwsIGRvbmUsIG5leHQ7XG5cbiAgXHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcbiAgXHRcdGxpdGVyYWwgPSBcIlxcXCJcIjtcbiAgXHRcdGRvbmUgPSBmYWxzZTtcblxuICBcdFx0d2hpbGUgKCFkb25lKSB7XG4gIFx0XHRcdG5leHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHN0cmluZ01pZGRsZVBhdHRlcm4pIHx8IHBhcnNlci5tYXRjaFBhdHRlcm4oZXNjYXBlU2VxdWVuY2VQYXR0ZXJuKSB8fCBwYXJzZXIubWF0Y2hTdHJpbmcob2tRdW90ZSk7XG4gIFx0XHRcdGlmIChuZXh0KSB7XG4gIFx0XHRcdFx0aWYgKG5leHQgPT09IFwiXFxcIlwiKSB7XG4gIFx0XHRcdFx0XHRsaXRlcmFsICs9IFwiXFxcXFxcXCJcIjtcbiAgXHRcdFx0XHR9IGVsc2UgaWYgKG5leHQgPT09IFwiXFxcXCdcIikge1xuICBcdFx0XHRcdFx0bGl0ZXJhbCArPSBcIidcIjtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0bGl0ZXJhbCArPSBuZXh0O1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRuZXh0ID0gcGFyc2VyLm1hdGNoUGF0dGVybihsaW5lQ29udGludWF0aW9uUGF0dGVybik7XG4gIFx0XHRcdFx0aWYgKG5leHQpIHtcbiAgXHRcdFx0XHRcdC8vIGNvbnZlcnQgXFwobmV3bGluZS1saWtlKSBpbnRvIGEgXFx1IGVzY2FwZSwgd2hpY2ggaXMgYWxsb3dlZCBpbiBKU09OXG4gIFx0XHRcdFx0XHRsaXRlcmFsICs9IFwiXFxcXHVcIiArIChcIjAwMFwiICsgbmV4dC5jaGFyQ29kZUF0KDEpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRkb25lID0gdHJ1ZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0bGl0ZXJhbCArPSBcIlxcXCJcIjtcblxuICBcdFx0Ly8gdXNlIEpTT04ucGFyc2UgdG8gaW50ZXJwcmV0IGVzY2FwZXNcbiAgXHRcdHJldHVybiBKU09OLnBhcnNlKGxpdGVyYWwpO1xuICBcdH07XG4gIH07XG5cbiAgdmFyIGdldFNpbmdsZVF1b3RlZFN0cmluZyA9IG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyKFwiXFxcIlwiKTtcbiAgdmFyIGdldERvdWJsZVF1b3RlZFN0cmluZyA9IG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyKFwiJ1wiKTtcblxuICB2YXIgcmVhZFN0cmluZ0xpdGVyYWwgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBzdHJpbmc7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiXFxcIlwiKSkge1xuICBcdFx0c3RyaW5nID0gZ2V0RG91YmxlUXVvdGVkU3RyaW5nKHBhcnNlcik7XG5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiXFxcIlwiKSkge1xuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBTVFJJTkdfTElURVJBTCxcbiAgXHRcdFx0djogc3RyaW5nXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCInXCIpKSB7XG4gIFx0XHRzdHJpbmcgPSBnZXRTaW5nbGVRdW90ZWRTdHJpbmcocGFyc2VyKTtcblxuICBcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCInXCIpKSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IFNUUklOR19MSVRFUkFMLFxuICBcdFx0XHR2OiBzdHJpbmdcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdmFyIHBhdHRlcm5zX19uYW1lID0gL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSovO1xuXG4gIC8vIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtcHJvcGVydGllc1xuICAvLyBjYW4gYmUgYW55IG5hbWUsIHN0cmluZyBsaXRlcmFsLCBvciBudW1iZXIgbGl0ZXJhbFxuICB2YXIgc2hhcmVkX3JlYWRLZXkgPSByZWFkS2V5O1xuICB2YXIgaWRlbnRpZmllciA9IC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qJC87XG4gIGZ1bmN0aW9uIHJlYWRLZXkocGFyc2VyKSB7XG4gIFx0dmFyIHRva2VuO1xuXG4gIFx0aWYgKHRva2VuID0gcmVhZFN0cmluZ0xpdGVyYWwocGFyc2VyKSkge1xuICBcdFx0cmV0dXJuIGlkZW50aWZpZXIudGVzdCh0b2tlbi52KSA/IHRva2VuLnYgOiBcIlxcXCJcIiArIHRva2VuLnYucmVwbGFjZSgvXCIvZywgXCJcXFxcXFxcIlwiKSArIFwiXFxcIlwiO1xuICBcdH1cblxuICBcdGlmICh0b2tlbiA9IGxpdGVyYWxfcmVhZE51bWJlckxpdGVyYWwocGFyc2VyKSkge1xuICBcdFx0cmV0dXJuIHRva2VuLnY7XG4gIFx0fVxuXG4gIFx0aWYgKHRva2VuID0gcGFyc2VyLm1hdGNoUGF0dGVybihwYXR0ZXJuc19fbmFtZSkpIHtcbiAgXHRcdHJldHVybiB0b2tlbjtcbiAgXHR9XG4gIH1cblxuICB2YXIga2V5VmFsdWVQYWlyID0gcmVhZEtleVZhbHVlUGFpcjtcbiAgZnVuY3Rpb24gcmVhZEtleVZhbHVlUGFpcihwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIGtleSwgdmFsdWU7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gJ3snIGFuZCBrZXlcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRrZXkgPSBzaGFyZWRfcmVhZEtleShwYXJzZXIpO1xuICBcdGlmIChrZXkgPT09IG51bGwpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiBrZXkgYW5kICc6J1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdC8vIG5leHQgY2hhcmFjdGVyIG11c3QgYmUgJzonXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI6XCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gJzonIGFuZCB2YWx1ZVxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdC8vIG5leHQgZXhwcmVzc2lvbiBtdXN0IGJlIGEsIHdlbGwuLi4gZXhwcmVzc2lvblxuICBcdHZhbHVlID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuICBcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IEtFWV9WQUxVRV9QQUlSLFxuICBcdFx0azoga2V5LFxuICBcdFx0djogdmFsdWVcbiAgXHR9O1xuICB9XG5cbiAgdmFyIG9iamVjdExpdGVyYWxfa2V5VmFsdWVQYWlycyA9IHJlYWRLZXlWYWx1ZVBhaXJzO1xuICBmdW5jdGlvbiByZWFkS2V5VmFsdWVQYWlycyhwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIHBhaXJzLCBwYWlyLCBrZXlWYWx1ZVBhaXJzO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0cGFpciA9IGtleVZhbHVlUGFpcihwYXJzZXIpO1xuICBcdGlmIChwYWlyID09PSBudWxsKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYWlycyA9IFtwYWlyXTtcblxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIsXCIpKSB7XG4gIFx0XHRrZXlWYWx1ZVBhaXJzID0gcmVhZEtleVZhbHVlUGFpcnMocGFyc2VyKTtcblxuICBcdFx0aWYgKCFrZXlWYWx1ZVBhaXJzKSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBwYWlycy5jb25jYXQoa2V5VmFsdWVQYWlycyk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHBhaXJzO1xuICB9XG5cbiAgdmFyIHJlYWRPYmplY3RMaXRlcmFsID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwga2V5VmFsdWVQYWlycztcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2VcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIntcIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGtleVZhbHVlUGFpcnMgPSBvYmplY3RMaXRlcmFsX2tleVZhbHVlUGFpcnMocGFyc2VyKTtcblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiBmaW5hbCB2YWx1ZSBhbmQgJ30nXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCJ9XCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogT0JKRUNUX0xJVEVSQUwsXG4gIFx0XHRtOiBrZXlWYWx1ZVBhaXJzXG4gIFx0fTtcbiAgfTtcblxuICB2YXIgc2hhcmVkX3JlYWRFeHByZXNzaW9uTGlzdCA9IHJlYWRFeHByZXNzaW9uTGlzdDtcbiAgZnVuY3Rpb24gcmVhZEV4cHJlc3Npb25MaXN0KHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgZXhwcmVzc2lvbnMsIGV4cHIsIG5leHQ7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRleHByID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuXG4gIFx0aWYgKGV4cHIgPT09IG51bGwpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGV4cHJlc3Npb25zID0gW2V4cHJdO1xuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuIGV4cHJlc3Npb24gYW5kICcsJ1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIsXCIpKSB7XG4gIFx0XHRuZXh0ID0gcmVhZEV4cHJlc3Npb25MaXN0KHBhcnNlcik7XG4gIFx0XHRpZiAobmV4dCA9PT0gbnVsbCkge1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoZXhwZWN0ZWRFeHByZXNzaW9uKTtcbiAgXHRcdH1cblxuICBcdFx0bmV4dC5mb3JFYWNoKGFwcGVuZCk7XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gYXBwZW5kKGV4cHJlc3Npb24pIHtcbiAgXHRcdGV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGV4cHJlc3Npb25zO1xuICB9XG5cbiAgdmFyIHJlYWRBcnJheUxpdGVyYWwgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBleHByZXNzaW9uTGlzdDtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlICdbJ1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiW1wiKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0ZXhwcmVzc2lvbkxpc3QgPSBzaGFyZWRfcmVhZEV4cHJlc3Npb25MaXN0KHBhcnNlcik7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIl1cIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBBUlJBWV9MSVRFUkFMLFxuICBcdFx0bTogZXhwcmVzc2lvbkxpc3RcbiAgXHR9O1xuICB9O1xuXG4gIHZhciBwcmltYXJ5X3JlYWRMaXRlcmFsID0gcmVhZExpdGVyYWw7XG4gIGZ1bmN0aW9uIHJlYWRMaXRlcmFsKHBhcnNlcikge1xuICBcdHJldHVybiBsaXRlcmFsX3JlYWROdW1iZXJMaXRlcmFsKHBhcnNlcikgfHwgbGl0ZXJhbF9yZWFkQm9vbGVhbkxpdGVyYWwocGFyc2VyKSB8fCByZWFkU3RyaW5nTGl0ZXJhbChwYXJzZXIpIHx8IHJlYWRPYmplY3RMaXRlcmFsKHBhcnNlcikgfHwgcmVhZEFycmF5TGl0ZXJhbChwYXJzZXIpIHx8IHJlYWRSZWdleHBMaXRlcmFsKHBhcnNlcik7XG4gIH1cblxuICB2YXIgcHJpbWFyeV9yZWFkUmVmZXJlbmNlID0gcmVhZFJlZmVyZW5jZTtcbiAgdmFyIHByZWZpeFBhdHRlcm4gPSAvXig/On5cXC98KD86XFwuXFwuXFwvKSt8XFwuXFwvKD86XFwuXFwuXFwvKSp8XFwuKS8sXG4gICAgICBnbG9iYWxzLFxuICAgICAga2V5d29yZHM7XG5cbiAgLy8gaWYgYSByZWZlcmVuY2UgaXMgYSBicm93c2VyIGdsb2JhbCwgd2UgZG9uJ3QgZGVmZXJlbmNlIGl0IGxhdGVyLCBzbyBpdCBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudFxuICBnbG9iYWxzID0gL14oPzpBcnJheXxjb25zb2xlfERhdGV8UmVnRXhwfGRlY29kZVVSSUNvbXBvbmVudHxkZWNvZGVVUkl8ZW5jb2RlVVJJQ29tcG9uZW50fGVuY29kZVVSSXxpc0Zpbml0ZXxpc05hTnxwYXJzZUZsb2F0fHBhcnNlSW50fEpTT058TWF0aHxOYU58dW5kZWZpbmVkfG51bGwpXFxiLztcblxuICAvLyBrZXl3b3JkcyBhcmUgbm90IHZhbGlkIHJlZmVyZW5jZXMsIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBgdGhpc2BcbiAga2V5d29yZHMgPSAvXig/OmJyZWFrfGNhc2V8Y2F0Y2h8Y29udGludWV8ZGVidWdnZXJ8ZGVmYXVsdHxkZWxldGV8ZG98ZWxzZXxmaW5hbGx5fGZvcnxmdW5jdGlvbnxpZnxpbnxpbnN0YW5jZW9mfG5ld3xyZXR1cm58c3dpdGNofHRocm93fHRyeXx0eXBlb2Z8dmFyfHZvaWR8d2hpbGV8d2l0aCkkLztcblxuICB2YXIgbGVnYWxSZWZlcmVuY2UgPSAvXlthLXpBLVokXzAtOV0rKD86KD86XFwuW2EtekEtWiRfMC05XSspfCg/OlxcW1swLTldK1xcXSkpKi87XG4gIHZhciByZWxheGVkTmFtZSA9IC9eW2EtekEtWl8kXVstYS16QS1aXyQwLTldKi87XG4gIGZ1bmN0aW9uIHJlYWRSZWZlcmVuY2UocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0UG9zLCBwcmVmaXgsIG5hbWUsIGdsb2JhbCwgcmVmZXJlbmNlLCBsYXN0RG90SW5kZXg7XG5cbiAgXHRzdGFydFBvcyA9IHBhcnNlci5wb3M7XG5cbiAgXHRuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybigvXkAoPzprZXlwYXRofGluZGV4fGtleSkvKTtcblxuICBcdGlmICghbmFtZSkge1xuICBcdFx0cHJlZml4ID0gcGFyc2VyLm1hdGNoUGF0dGVybihwcmVmaXhQYXR0ZXJuKSB8fCBcIlwiO1xuICBcdFx0bmFtZSA9ICFwcmVmaXggJiYgcGFyc2VyLnJlbGF4ZWROYW1lcyAmJiBwYXJzZXIubWF0Y2hQYXR0ZXJuKHJlbGF4ZWROYW1lKSB8fCBwYXJzZXIubWF0Y2hQYXR0ZXJuKGxlZ2FsUmVmZXJlbmNlKTtcblxuICBcdFx0aWYgKCFuYW1lICYmIHByZWZpeCA9PT0gXCIuXCIpIHtcbiAgXHRcdFx0cHJlZml4ID0gXCJcIjtcbiAgXHRcdFx0bmFtZSA9IFwiLlwiO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICghbmFtZSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gYnVnIG91dCBpZiBpdCdzIGEga2V5d29yZCAoZXhjZXB0aW9uIGZvciBhbmNlc3Rvci9yZXN0cmljdGVkIHJlZnMgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3Vlcy8xNDk3KVxuICBcdGlmICghcHJlZml4ICYmICFwYXJzZXIucmVsYXhlZE5hbWVzICYmIGtleXdvcmRzLnRlc3QobmFtZSkpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydFBvcztcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIGlmIHRoaXMgaXMgYSBicm93c2VyIGdsb2JhbCwgc3RvcCBoZXJlXG4gIFx0aWYgKCFwcmVmaXggJiYgZ2xvYmFscy50ZXN0KG5hbWUpKSB7XG4gIFx0XHRnbG9iYWwgPSBnbG9iYWxzLmV4ZWMobmFtZSlbMF07XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnRQb3MgKyBnbG9iYWwubGVuZ3RoO1xuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBHTE9CQUwsXG4gIFx0XHRcdHY6IGdsb2JhbFxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRyZWZlcmVuY2UgPSAocHJlZml4IHx8IFwiXCIpICsgbm9ybWFsaXNlKG5hbWUpO1xuXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIihcIikpIHtcbiAgXHRcdC8vIGlmIHRoaXMgaXMgYSBtZXRob2QgaW52b2NhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIGZ1bmN0aW9uKSB3ZSBuZWVkXG4gIFx0XHQvLyB0byBzdHJpcCB0aGUgbWV0aG9kIG5hbWUgZnJvbSB0aGUgcmVmZXJlbmNlIGNvbWJvLCBlbHNlIHRoZSBjb250ZXh0XG4gIFx0XHQvLyB3aWxsIGJlIHdyb25nXG4gIFx0XHRsYXN0RG90SW5kZXggPSByZWZlcmVuY2UubGFzdEluZGV4T2YoXCIuXCIpO1xuICBcdFx0aWYgKGxhc3REb3RJbmRleCAhPT0gLTEpIHtcbiAgXHRcdFx0cmVmZXJlbmNlID0gcmVmZXJlbmNlLnN1YnN0cigwLCBsYXN0RG90SW5kZXgpO1xuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnRQb3MgKyByZWZlcmVuY2UubGVuZ3RoO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyAtPSAxO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBSRUZFUkVOQ0UsXG4gIFx0XHRuOiByZWZlcmVuY2UucmVwbGFjZSgvXnRoaXNcXC4vLCBcIi4vXCIpLnJlcGxhY2UoL150aGlzJC8sIFwiLlwiKVxuICBcdH07XG4gIH1cblxuICB2YXIgcHJpbWFyeV9yZWFkQnJhY2tldGVkRXhwcmVzc2lvbiA9IHJlYWRCcmFja2V0ZWRFeHByZXNzaW9uO1xuICBmdW5jdGlvbiByZWFkQnJhY2tldGVkRXhwcmVzc2lvbihwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIGV4cHI7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIihcIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGV4cHIgPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0aWYgKCFleHByKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoZXhwZWN0ZWRFeHByZXNzaW9uKTtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIilcIikpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihleHBlY3RlZFBhcmVuKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogQlJBQ0tFVEVELFxuICBcdFx0eDogZXhwclxuICBcdH07XG4gIH1cblxuICB2YXIgcmVhZFByaW1hcnkgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0cmV0dXJuIHByaW1hcnlfcmVhZExpdGVyYWwocGFyc2VyKSB8fCBwcmltYXJ5X3JlYWRSZWZlcmVuY2UocGFyc2VyKSB8fCBwcmltYXJ5X3JlYWRCcmFja2V0ZWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIH07XG5cbiAgdmFyIHNoYXJlZF9yZWFkUmVmaW5lbWVudCA9IHJlYWRSZWZpbmVtZW50O1xuICBmdW5jdGlvbiByZWFkUmVmaW5lbWVudChwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIG5hbWUsIGV4cHI7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHQvLyBcIi5cIiBuYW1lXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIi5cIikpIHtcbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0aWYgKG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHBhdHRlcm5zX19uYW1lKSkge1xuICBcdFx0XHRyZXR1cm4ge1xuICBcdFx0XHRcdHQ6IFJFRklORU1FTlQsXG4gIFx0XHRcdFx0bjogbmFtZVxuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBhIHByb3BlcnR5IG5hbWVcIik7XG4gIFx0fVxuXG4gIFx0Ly8gXCJbXCIgZXhwcmVzc2lvbiBcIl1cIlxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJbXCIpKSB7XG4gIFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdGV4cHIgPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0XHRpZiAoIWV4cHIpIHtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKGV4cGVjdGVkRXhwcmVzc2lvbik7XG4gIFx0XHR9XG5cbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCJdXCIpKSB7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkICddJ1wiKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogUkVGSU5FTUVOVCxcbiAgXHRcdFx0eDogZXhwclxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciByZWFkTWVtYmVyT3JJbnZvY2F0aW9uID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICBcdHZhciBjdXJyZW50LCBleHByZXNzaW9uLCByZWZpbmVtZW50LCBleHByZXNzaW9uTGlzdDtcblxuICBcdGV4cHJlc3Npb24gPSByZWFkUHJpbWFyeShwYXJzZXIpO1xuXG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHR3aGlsZSAoZXhwcmVzc2lvbikge1xuICBcdFx0Y3VycmVudCA9IHBhcnNlci5wb3M7XG5cbiAgXHRcdGlmIChyZWZpbmVtZW50ID0gc2hhcmVkX3JlYWRSZWZpbmVtZW50KHBhcnNlcikpIHtcbiAgXHRcdFx0ZXhwcmVzc2lvbiA9IHtcbiAgXHRcdFx0XHR0OiBNRU1CRVIsXG4gIFx0XHRcdFx0eDogZXhwcmVzc2lvbixcbiAgXHRcdFx0XHRyOiByZWZpbmVtZW50XG4gIFx0XHRcdH07XG4gIFx0XHR9IGVsc2UgaWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIihcIikpIHtcbiAgXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdFx0XHRleHByZXNzaW9uTGlzdCA9IHNoYXJlZF9yZWFkRXhwcmVzc2lvbkxpc3QocGFyc2VyKTtcblxuICBcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCIpXCIpKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKGV4cGVjdGVkUGFyZW4pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0ZXhwcmVzc2lvbiA9IHtcbiAgXHRcdFx0XHR0OiBJTlZPQ0FUSU9OLFxuICBcdFx0XHRcdHg6IGV4cHJlc3Npb25cbiAgXHRcdFx0fTtcblxuICBcdFx0XHRpZiAoZXhwcmVzc2lvbkxpc3QpIHtcbiAgXHRcdFx0XHRleHByZXNzaW9uLm8gPSBleHByZXNzaW9uTGlzdDtcbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0YnJlYWs7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGV4cHJlc3Npb247XG4gIH07XG5cbiAgdmFyIHJlYWRUeXBlT2YsIG1ha2VQcmVmaXhTZXF1ZW5jZU1hdGNoZXI7XG5cbiAgbWFrZVByZWZpeFNlcXVlbmNlTWF0Y2hlciA9IGZ1bmN0aW9uIChzeW1ib2wsIGZhbGx0aHJvdWdoKSB7XG4gIFx0cmV0dXJuIGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgXHRcdHZhciBleHByZXNzaW9uO1xuXG4gIFx0XHRpZiAoZXhwcmVzc2lvbiA9IGZhbGx0aHJvdWdoKHBhcnNlcikpIHtcbiAgXHRcdFx0cmV0dXJuIGV4cHJlc3Npb247XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHN5bWJvbCkpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0ZXhwcmVzc2lvbiA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgXHRcdGlmICghZXhwcmVzc2lvbikge1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoZXhwZWN0ZWRFeHByZXNzaW9uKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0czogc3ltYm9sLFxuICBcdFx0XHRvOiBleHByZXNzaW9uLFxuICBcdFx0XHR0OiBQUkVGSVhfT1BFUkFUT1JcbiAgXHRcdH07XG4gIFx0fTtcbiAgfTtcblxuICAvLyBjcmVhdGUgYWxsIHByZWZpeCBzZXF1ZW5jZSBtYXRjaGVycywgcmV0dXJuIHJlYWRUeXBlT2ZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgXHR2YXIgaSwgbGVuLCBtYXRjaGVyLCBwcmVmaXhPcGVyYXRvcnMsIGZhbGx0aHJvdWdoO1xuXG4gIFx0cHJlZml4T3BlcmF0b3JzID0gXCIhIH4gKyAtIHR5cGVvZlwiLnNwbGl0KFwiIFwiKTtcblxuICBcdGZhbGx0aHJvdWdoID0gcmVhZE1lbWJlck9ySW52b2NhdGlvbjtcbiAgXHRmb3IgKGkgPSAwLCBsZW4gPSBwcmVmaXhPcGVyYXRvcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdG1hdGNoZXIgPSBtYWtlUHJlZml4U2VxdWVuY2VNYXRjaGVyKHByZWZpeE9wZXJhdG9yc1tpXSwgZmFsbHRocm91Z2gpO1xuICBcdFx0ZmFsbHRocm91Z2ggPSBtYXRjaGVyO1xuICBcdH1cblxuICBcdC8vIHR5cGVvZiBvcGVyYXRvciBpcyBoaWdoZXIgcHJlY2VkZW5jZSB0aGFuIG11bHRpcGxpY2F0aW9uLCBzbyBwcm92aWRlcyB0aGVcbiAgXHQvLyBmYWxsdGhyb3VnaCBmb3IgdGhlIG11bHRpcGxpY2F0aW9uIHNlcXVlbmNlIG1hdGNoZXIgd2UncmUgYWJvdXQgdG8gY3JlYXRlXG4gIFx0Ly8gKHdlJ3JlIHNraXBwaW5nIHZvaWQgYW5kIGRlbGV0ZSlcbiAgXHRyZWFkVHlwZU9mID0gZmFsbHRocm91Z2g7XG4gIH0pKCk7XG5cbiAgdmFyIHJlYWRUeXBlb2YgPSByZWFkVHlwZU9mO1xuXG4gIHZhciByZWFkTG9naWNhbE9yLCBtYWtlSW5maXhTZXF1ZW5jZU1hdGNoZXI7XG5cbiAgbWFrZUluZml4U2VxdWVuY2VNYXRjaGVyID0gZnVuY3Rpb24gKHN5bWJvbCwgZmFsbHRocm91Z2gpIHtcbiAgXHRyZXR1cm4gZnVuY3Rpb24gKHBhcnNlcikge1xuICBcdFx0dmFyIHN0YXJ0LCBsZWZ0LCByaWdodDtcblxuICBcdFx0bGVmdCA9IGZhbGx0aHJvdWdoKHBhcnNlcik7XG4gIFx0XHRpZiAoIWxlZnQpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIExvb3AgdG8gaGFuZGxlIGxlZnQtcmVjdXJzaW9uIGluIGEgY2FzZSBsaWtlIGBhICogYiAqIGNgIGFuZCBwcm9kdWNlXG4gIFx0XHQvLyBsZWZ0IGFzc29jaWF0aW9uLCBpLmUuIGAoYSAqIGIpICogY2AuICBUaGUgbWF0Y2hlciBjYW4ndCBjYWxsIGl0c2VsZlxuICBcdFx0Ly8gdG8gcGFyc2UgYGxlZnRgIGJlY2F1c2UgdGhhdCB3b3VsZCBiZSBpbmZpbml0ZSByZWdyZXNzLlxuICBcdFx0d2hpbGUgKHRydWUpIHtcbiAgXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhzeW1ib2wpKSB7XG4gIFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0XHRcdHJldHVybiBsZWZ0O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gaW4gb3BlcmF0b3IgbXVzdCBub3QgYmUgZm9sbG93ZWQgYnkgW2EtekEtWl8kMC05XVxuICBcdFx0XHRpZiAoc3ltYm9sID09PSBcImluXCIgJiYgL1thLXpBLVpfJDAtOV0vLnRlc3QocGFyc2VyLnJlbWFpbmluZygpLmNoYXJBdCgwKSkpIHtcbiAgXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdFx0cmV0dXJuIGxlZnQ7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdFx0Ly8gcmlnaHQgb3BlcmFuZCBtdXN0IGFsc28gY29uc2lzdCBvZiBvbmx5IGhpZ2hlci1wcmVjZWRlbmNlIG9wZXJhdG9yc1xuICBcdFx0XHRyaWdodCA9IGZhbGx0aHJvdWdoKHBhcnNlcik7XG4gIFx0XHRcdGlmICghcmlnaHQpIHtcbiAgXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdFx0cmV0dXJuIGxlZnQ7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRsZWZ0ID0ge1xuICBcdFx0XHRcdHQ6IElORklYX09QRVJBVE9SLFxuICBcdFx0XHRcdHM6IHN5bWJvbCxcbiAgXHRcdFx0XHRvOiBbbGVmdCwgcmlnaHRdXG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0Ly8gTG9vcCBiYWNrIGFyb3VuZC4gIElmIHdlIGRvbid0IHNlZSBhbm90aGVyIG9jY3VycmVuY2Ugb2YgdGhlIHN5bWJvbCxcbiAgXHRcdFx0Ly8gd2UnbGwgcmV0dXJuIGxlZnQuXG4gIFx0XHR9XG4gIFx0fTtcbiAgfTtcblxuICAvLyBjcmVhdGUgYWxsIGluZml4IHNlcXVlbmNlIG1hdGNoZXJzLCBhbmQgcmV0dXJuIHJlYWRMb2dpY2FsT3JcbiAgKGZ1bmN0aW9uICgpIHtcbiAgXHR2YXIgaSwgbGVuLCBtYXRjaGVyLCBpbmZpeE9wZXJhdG9ycywgZmFsbHRocm91Z2g7XG5cbiAgXHQvLyBBbGwgdGhlIGluZml4IG9wZXJhdG9ycyBvbiBvcmRlciBvZiBwcmVjZWRlbmNlIChzb3VyY2U6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL09wZXJhdG9yX1ByZWNlZGVuY2UpXG4gIFx0Ly8gRWFjaCBzZXF1ZW5jZSBtYXRjaGVyIHdpbGwgaW5pdGlhbGx5IGZhbGwgdGhyb3VnaCB0byBpdHMgaGlnaGVyIHByZWNlZGVuY2VcbiAgXHQvLyBuZWlnaGJvdXIsIGFuZCBvbmx5IGF0dGVtcHQgdG8gbWF0Y2ggaWYgb25lIG9mIHRoZSBoaWdoZXIgcHJlY2VkZW5jZSBvcGVyYXRvcnNcbiAgXHQvLyAob3IsIHVsdGltYXRlbHksIGEgbGl0ZXJhbCwgcmVmZXJlbmNlLCBvciBicmFja2V0ZWQgZXhwcmVzc2lvbikgYWxyZWFkeSBtYXRjaGVkXG4gIFx0aW5maXhPcGVyYXRvcnMgPSBcIiogLyAlICsgLSA8PCA+PiA+Pj4gPCA8PSA+ID49IGluIGluc3RhbmNlb2YgPT0gIT0gPT09ICE9PSAmIF4gfCAmJiB8fFwiLnNwbGl0KFwiIFwiKTtcblxuICBcdC8vIEEgdHlwZW9mIG9wZXJhdG9yIGlzIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gbXVsdGlwbGljYXRpb25cbiAgXHRmYWxsdGhyb3VnaCA9IHJlYWRUeXBlb2Y7XG4gIFx0Zm9yIChpID0gMCwgbGVuID0gaW5maXhPcGVyYXRvcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdG1hdGNoZXIgPSBtYWtlSW5maXhTZXF1ZW5jZU1hdGNoZXIoaW5maXhPcGVyYXRvcnNbaV0sIGZhbGx0aHJvdWdoKTtcbiAgXHRcdGZhbGx0aHJvdWdoID0gbWF0Y2hlcjtcbiAgXHR9XG5cbiAgXHQvLyBMb2dpY2FsIE9SIGlzIHRoZSBmYWxsdGhyb3VnaCBmb3IgdGhlIGNvbmRpdGlvbmFsIG1hdGNoZXJcbiAgXHRyZWFkTG9naWNhbE9yID0gZmFsbHRocm91Z2g7XG4gIH0pKCk7XG5cbiAgdmFyIGV4cHJlc3Npb25zX3JlYWRMb2dpY2FsT3IgPSByZWFkTG9naWNhbE9yO1xuXG4gIC8vIFRoZSBjb25kaXRpb25hbCBvcGVyYXRvciBpcyB0aGUgbG93ZXN0IHByZWNlZGVuY2Ugb3BlcmF0b3IsIHNvIHdlIHN0YXJ0IGhlcmVcbiAgdmFyIHJlYWRDb25kaXRpb25hbCA9IGdldENvbmRpdGlvbmFsO1xuICBmdW5jdGlvbiBnZXRDb25kaXRpb25hbChwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIGV4cHJlc3Npb24sIGlmVHJ1ZSwgaWZGYWxzZTtcblxuICBcdGV4cHJlc3Npb24gPSBleHByZXNzaW9uc19yZWFkTG9naWNhbE9yKHBhcnNlcik7XG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIj9cIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBleHByZXNzaW9uO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmVHJ1ZSA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgXHRpZiAoIWlmVHJ1ZSkge1xuICBcdFx0cGFyc2VyLmVycm9yKGV4cGVjdGVkRXhwcmVzc2lvbik7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI6XCIpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBcXFwiOlxcXCJcIik7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWZGYWxzZSA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgXHRpZiAoIWlmRmFsc2UpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihleHBlY3RlZEV4cHJlc3Npb24pO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBDT05ESVRJT05BTCxcbiAgXHRcdG86IFtleHByZXNzaW9uLCBpZlRydWUsIGlmRmFsc2VdXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uID0gcmVhZEV4cHJlc3Npb247XG4gIGZ1bmN0aW9uIHJlYWRFeHByZXNzaW9uKHBhcnNlcikge1xuICBcdC8vIFRoZSBjb25kaXRpb25hbCBvcGVyYXRvciBpcyB0aGUgbG93ZXN0IHByZWNlZGVuY2Ugb3BlcmF0b3IgKGV4Y2VwdCB5aWVsZCxcbiAgXHQvLyBhc3NpZ25tZW50IG9wZXJhdG9ycywgYW5kIGNvbW1hcywgbm9uZSBvZiB3aGljaCBhcmUgc3VwcG9ydGVkKSwgc28gd2VcbiAgXHQvLyBzdGFydCB0aGVyZS4gSWYgaXQgZG9lc24ndCBtYXRjaCwgaXQgJ2ZhbGxzIHRocm91Z2gnIHRvIHByb2dyZXNzaXZlbHlcbiAgXHQvLyBoaWdoZXIgcHJlY2VkZW5jZSBvcGVyYXRvcnMsIHVudGlsIGl0IGV2ZW50dWFsbHkgbWF0Y2hlcyAob3IgZmFpbHMgdG9cbiAgXHQvLyBtYXRjaCkgYSAncHJpbWFyeScgLSBhIGxpdGVyYWwgb3IgYSByZWZlcmVuY2UuIFRoaXMgd2F5LCB0aGUgYWJzdHJhY3Qgc3ludGF4XG4gIFx0Ly8gdHJlZSBoYXMgZXZlcnl0aGluZyBpbiBpdHMgcHJvcGVyIHBsYWNlLCBpLmUuIDIgKyAzICogNCA9PT0gMTQsIG5vdCAyMC5cbiAgXHRyZXR1cm4gcmVhZENvbmRpdGlvbmFsKHBhcnNlcik7XG4gIH1cblxuICB2YXIgdXRpbHNfZmxhdHRlbkV4cHJlc3Npb24gPSBmbGF0dGVuRXhwcmVzc2lvbjtcblxuICBmdW5jdGlvbiBmbGF0dGVuRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gIFx0dmFyIHJlZnM7XG5cbiAgXHRleHRyYWN0UmVmcyhleHByZXNzaW9uLCByZWZzID0gW10pO1xuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHI6IHJlZnMsXG4gIFx0XHRzOiBzdHJpbmdpZnkoZXhwcmVzc2lvbilcbiAgXHR9O1xuXG4gIFx0ZnVuY3Rpb24gc3RyaW5naWZ5KG5vZGUpIHtcbiAgXHRcdHN3aXRjaCAobm9kZS50KSB7XG4gIFx0XHRcdGNhc2UgQk9PTEVBTl9MSVRFUkFMOlxuICBcdFx0XHRjYXNlIEdMT0JBTDpcbiAgXHRcdFx0Y2FzZSBOVU1CRVJfTElURVJBTDpcbiAgXHRcdFx0Y2FzZSBSRUdFWFBfTElURVJBTDpcbiAgXHRcdFx0XHRyZXR1cm4gbm9kZS52O1xuXG4gIFx0XHRcdGNhc2UgU1RSSU5HX0xJVEVSQUw6XG4gIFx0XHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KFN0cmluZyhub2RlLnYpKTtcblxuICBcdFx0XHRjYXNlIEFSUkFZX0xJVEVSQUw6XG4gIFx0XHRcdFx0cmV0dXJuIFwiW1wiICsgKG5vZGUubSA/IG5vZGUubS5tYXAoc3RyaW5naWZ5KS5qb2luKFwiLFwiKSA6IFwiXCIpICsgXCJdXCI7XG5cbiAgXHRcdFx0Y2FzZSBPQkpFQ1RfTElURVJBTDpcbiAgXHRcdFx0XHRyZXR1cm4gXCJ7XCIgKyAobm9kZS5tID8gbm9kZS5tLm1hcChzdHJpbmdpZnkpLmpvaW4oXCIsXCIpIDogXCJcIikgKyBcIn1cIjtcblxuICBcdFx0XHRjYXNlIEtFWV9WQUxVRV9QQUlSOlxuICBcdFx0XHRcdHJldHVybiBub2RlLmsgKyBcIjpcIiArIHN0cmluZ2lmeShub2RlLnYpO1xuXG4gIFx0XHRcdGNhc2UgUFJFRklYX09QRVJBVE9SOlxuICBcdFx0XHRcdHJldHVybiAobm9kZS5zID09PSBcInR5cGVvZlwiID8gXCJ0eXBlb2YgXCIgOiBub2RlLnMpICsgc3RyaW5naWZ5KG5vZGUubyk7XG5cbiAgXHRcdFx0Y2FzZSBJTkZJWF9PUEVSQVRPUjpcbiAgXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KG5vZGUub1swXSkgKyAobm9kZS5zLnN1YnN0cigwLCAyKSA9PT0gXCJpblwiID8gXCIgXCIgKyBub2RlLnMgKyBcIiBcIiA6IG5vZGUucykgKyBzdHJpbmdpZnkobm9kZS5vWzFdKTtcblxuICBcdFx0XHRjYXNlIElOVk9DQVRJT046XG4gIFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeShub2RlLngpICsgXCIoXCIgKyAobm9kZS5vID8gbm9kZS5vLm1hcChzdHJpbmdpZnkpLmpvaW4oXCIsXCIpIDogXCJcIikgKyBcIilcIjtcblxuICBcdFx0XHRjYXNlIEJSQUNLRVRFRDpcbiAgXHRcdFx0XHRyZXR1cm4gXCIoXCIgKyBzdHJpbmdpZnkobm9kZS54KSArIFwiKVwiO1xuXG4gIFx0XHRcdGNhc2UgTUVNQkVSOlxuICBcdFx0XHRcdHJldHVybiBzdHJpbmdpZnkobm9kZS54KSArIHN0cmluZ2lmeShub2RlLnIpO1xuXG4gIFx0XHRcdGNhc2UgUkVGSU5FTUVOVDpcbiAgXHRcdFx0XHRyZXR1cm4gbm9kZS5uID8gXCIuXCIgKyBub2RlLm4gOiBcIltcIiArIHN0cmluZ2lmeShub2RlLngpICsgXCJdXCI7XG5cbiAgXHRcdFx0Y2FzZSBDT05ESVRJT05BTDpcbiAgXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KG5vZGUub1swXSkgKyBcIj9cIiArIHN0cmluZ2lmeShub2RlLm9bMV0pICsgXCI6XCIgKyBzdHJpbmdpZnkobm9kZS5vWzJdKTtcblxuICBcdFx0XHRjYXNlIFJFRkVSRU5DRTpcbiAgXHRcdFx0XHRyZXR1cm4gXCJfXCIgKyByZWZzLmluZGV4T2Yobm9kZS5uKTtcblxuICBcdFx0XHRkZWZhdWx0OlxuICBcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGxlZ2FsIEphdmFTY3JpcHRcIik7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgLy8gVE9ETyBtYXliZSByZWZhY3RvciB0aGlzP1xuICBmdW5jdGlvbiBleHRyYWN0UmVmcyhub2RlLCByZWZzKSB7XG4gIFx0dmFyIGksIGxpc3Q7XG5cbiAgXHRpZiAobm9kZS50ID09PSBSRUZFUkVOQ0UpIHtcbiAgXHRcdGlmIChyZWZzLmluZGV4T2Yobm9kZS5uKSA9PT0gLTEpIHtcbiAgXHRcdFx0cmVmcy51bnNoaWZ0KG5vZGUubik7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0bGlzdCA9IG5vZGUubyB8fCBub2RlLm07XG4gIFx0aWYgKGxpc3QpIHtcbiAgXHRcdGlmIChpc09iamVjdChsaXN0KSkge1xuICBcdFx0XHRleHRyYWN0UmVmcyhsaXN0LCByZWZzKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGkgPSBsaXN0Lmxlbmd0aDtcbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdGV4dHJhY3RSZWZzKGxpc3RbaV0sIHJlZnMpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKG5vZGUueCkge1xuICBcdFx0ZXh0cmFjdFJlZnMobm9kZS54LCByZWZzKTtcbiAgXHR9XG5cbiAgXHRpZiAobm9kZS5yKSB7XG4gIFx0XHRleHRyYWN0UmVmcyhub2RlLnIsIHJlZnMpO1xuICBcdH1cblxuICBcdGlmIChub2RlLnYpIHtcbiAgXHRcdGV4dHJhY3RSZWZzKG5vZGUudiwgcmVmcyk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHV0aWxzX3JlZmluZUV4cHJlc3Npb24gPSByZWZpbmVFeHByZXNzaW9uO1xuXG4gIHZhciBhcnJheU1lbWJlclBhdHRlcm4gPSAvXlswLTldWzEtOV0qJC87XG4gIGZ1bmN0aW9uIHJlZmluZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgbXVzdGFjaGUpIHtcbiAgXHR2YXIgcmVmZXJlbmNlRXhwcmVzc2lvbjtcblxuICBcdGlmIChleHByZXNzaW9uKSB7XG4gIFx0XHR3aGlsZSAoZXhwcmVzc2lvbi50ID09PSBCUkFDS0VURUQgJiYgZXhwcmVzc2lvbi54KSB7XG4gIFx0XHRcdGV4cHJlc3Npb24gPSBleHByZXNzaW9uLng7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIGludGVnZXJzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGFycmF5IG1lbWJlcnMgcmVmZXJlbmNlcyxcbiAgXHRcdC8vIHJhdGhlciB0aGFuIGFzIGV4cHJlc3Npb25zIGluIHRoZWlyIG93biByaWdodFxuICBcdFx0aWYgKGV4cHJlc3Npb24udCA9PT0gUkVGRVJFTkNFKSB7XG4gIFx0XHRcdG11c3RhY2hlLnIgPSBleHByZXNzaW9uLm47XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRpZiAoZXhwcmVzc2lvbi50ID09PSBOVU1CRVJfTElURVJBTCAmJiBhcnJheU1lbWJlclBhdHRlcm4udGVzdChleHByZXNzaW9uLnYpKSB7XG4gIFx0XHRcdFx0bXVzdGFjaGUuciA9IGV4cHJlc3Npb24udjtcbiAgXHRcdFx0fSBlbHNlIGlmIChyZWZlcmVuY2VFeHByZXNzaW9uID0gZ2V0UmVmZXJlbmNlRXhwcmVzc2lvbihleHByZXNzaW9uKSkge1xuICBcdFx0XHRcdG11c3RhY2hlLnJ4ID0gcmVmZXJlbmNlRXhwcmVzc2lvbjtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRtdXN0YWNoZS54ID0gdXRpbHNfZmxhdHRlbkV4cHJlc3Npb24oZXhwcmVzc2lvbik7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG11c3RhY2hlO1xuICBcdH1cbiAgfVxuXG4gIC8vIFRPRE8gcmVmYWN0b3IgdGhpcyEgaXQncyBiZXdpbGRlcmluZ1xuICBmdW5jdGlvbiBnZXRSZWZlcmVuY2VFeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcbiAgXHR2YXIgbWVtYmVycyA9IFtdLFxuICBcdCAgICByZWZpbmVtZW50O1xuXG4gIFx0d2hpbGUgKGV4cHJlc3Npb24udCA9PT0gTUVNQkVSICYmIGV4cHJlc3Npb24uci50ID09PSBSRUZJTkVNRU5UKSB7XG4gIFx0XHRyZWZpbmVtZW50ID0gZXhwcmVzc2lvbi5yO1xuXG4gIFx0XHRpZiAocmVmaW5lbWVudC54KSB7XG4gIFx0XHRcdGlmIChyZWZpbmVtZW50LngudCA9PT0gUkVGRVJFTkNFKSB7XG4gIFx0XHRcdFx0bWVtYmVycy51bnNoaWZ0KHJlZmluZW1lbnQueCk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0bWVtYmVycy51bnNoaWZ0KHV0aWxzX2ZsYXR0ZW5FeHByZXNzaW9uKHJlZmluZW1lbnQueCkpO1xuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRtZW1iZXJzLnVuc2hpZnQocmVmaW5lbWVudC5uKTtcbiAgXHRcdH1cblxuICBcdFx0ZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24ueDtcbiAgXHR9XG5cbiAgXHRpZiAoZXhwcmVzc2lvbi50ICE9PSBSRUZFUkVOQ0UpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHRyOiBleHByZXNzaW9uLm4sXG4gIFx0XHRtOiBtZW1iZXJzXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBtdXN0YWNoZV9yZWFkVHJpcGxlID0gcmVhZFRyaXBsZTtcbiAgZnVuY3Rpb24gcmVhZFRyaXBsZShwYXJzZXIsIHRhZykge1xuICBcdHZhciBleHByZXNzaW9uID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpLFxuICBcdCAgICB0cmlwbGU7XG5cbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJ1wiKTtcbiAgXHR9XG5cbiAgXHR0cmlwbGUgPSB7IHQ6IFRSSVBMRSB9O1xuICBcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgdHJpcGxlKTsgLy8gVE9ETyBoYW5kbGUgdGhpcyBkaWZmZXJlbnRseSAtIGl0J3MgbXlzdGVyaW91c1xuXG4gIFx0cmV0dXJuIHRyaXBsZTtcbiAgfVxuXG4gIHZhciBtdXN0YWNoZV9yZWFkVW5lc2NhcGVkID0gcmVhZFVuZXNjYXBlZDtcbiAgZnVuY3Rpb24gcmVhZFVuZXNjYXBlZChwYXJzZXIsIHRhZykge1xuICBcdHZhciBleHByZXNzaW9uLCB0cmlwbGU7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIiZcIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG5cbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJ1wiKTtcbiAgXHR9XG5cbiAgXHR0cmlwbGUgPSB7IHQ6IFRSSVBMRSB9O1xuICBcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgdHJpcGxlKTsgLy8gVE9ETyBoYW5kbGUgdGhpcyBkaWZmZXJlbnRseSAtIGl0J3MgbXlzdGVyaW91c1xuXG4gIFx0cmV0dXJuIHRyaXBsZTtcbiAgfVxuXG4gIHZhciBtdXN0YWNoZV9yZWFkUGFydGlhbCA9IHJlYWRQYXJ0aWFsO1xuICBmdW5jdGlvbiByZWFkUGFydGlhbChwYXJzZXIsIHRhZykge1xuICBcdHZhciBzdGFydCwgbmFtZVN0YXJ0LCBleHByZXNzaW9uLCBjb250ZXh0LCBwYXJ0aWFsO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI+XCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gIFx0bmFtZVN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIFBhcnRpYWwgbmFtZXMgY2FuIGluY2x1ZGUgaHlwaGVucywgc28gd2UgY2FuJ3QgdXNlIHJlYWRFeHByZXNzaW9uXG4gIFx0Ly8gYmxpbmRseS4gSW5zdGVhZCwgd2UgdXNlIHRoZSBgcmVsYXhlZE5hbWVzYCBmbGFnIHRvIGluZGljYXRlIHRoYXRcbiAgXHQvLyBgZm9vLWJhcmAgc2hvdWxkIGJlIHJlYWQgYXMgYSBzaW5nbGUgbmFtZSwgcmF0aGVyIHRoYW4gJ3N1YnRyYWN0XG4gIFx0Ly8gYmFyIGZyb20gZm9vJ1xuICBcdHBhcnNlci5yZWxheGVkTmFtZXMgPSB0cnVlO1xuICBcdGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0cGFyc2VyLnJlbGF4ZWROYW1lcyA9IGZhbHNlO1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdGNvbnRleHQgPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJ0aWFsID0geyB0OiBQQVJUSUFMIH07XG4gIFx0dXRpbHNfcmVmaW5lRXhwcmVzc2lvbihleHByZXNzaW9uLCBwYXJ0aWFsKTsgLy8gVE9ETy4uLlxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0Ly8gaWYgd2UgaGF2ZSBhbm90aGVyIGV4cHJlc3Npb24gLSBlLmcuIGB7ez5mb28gYmFyfX1gIC0gdGhlblxuICBcdC8vIHdlIHR1cm4gaXQgaW50byBge3sjd2l0aCBiYXJ9fXt7PmZvb319e3svd2l0aH19YFxuICBcdGlmIChjb250ZXh0KSB7XG4gIFx0XHRwYXJ0aWFsID0ge1xuICBcdFx0XHR0OiBTRUNUSU9OLFxuICBcdFx0XHRuOiBTRUNUSU9OX1dJVEgsXG4gIFx0XHRcdGY6IFtwYXJ0aWFsXVxuICBcdFx0fTtcblxuICBcdFx0dXRpbHNfcmVmaW5lRXhwcmVzc2lvbihjb250ZXh0LCBwYXJ0aWFsKTtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyB0YWcuY2xvc2UgKyBcIidcIik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHBhcnRpYWw7XG4gIH1cblxuICB2YXIgcmVhZE11c3RhY2hlQ29tbWVudCA9IHJlYWRDb21tZW50O1xuICBmdW5jdGlvbiByZWFkQ29tbWVudChwYXJzZXIsIHRhZykge1xuICBcdHZhciBpbmRleDtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiIVwiKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aW5kZXggPSBwYXJzZXIucmVtYWluaW5nKCkuaW5kZXhPZih0YWcuY2xvc2UpO1xuXG4gIFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0cGFyc2VyLnBvcyArPSBpbmRleCArIHRhZy5jbG9zZS5sZW5ndGg7XG4gIFx0XHRyZXR1cm4geyB0OiBDT01NRU5UIH07XG4gIFx0fVxuICB9XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb25PclJlZmVyZW5jZSA9IHJlYWRFeHByZXNzaW9uT3JSZWZlcmVuY2U7XG4gIGZ1bmN0aW9uIHJlYWRFeHByZXNzaW9uT3JSZWZlcmVuY2UocGFyc2VyLCBleHBlY3RlZEZvbGxvd2Vycykge1xuICBcdHZhciBzdGFydCwgZXhwcmVzc2lvbiwgaTtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcbiAgXHRleHByZXNzaW9uID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuXG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRmb3IgKGkgPSAwOyBpIDwgZXhwZWN0ZWRGb2xsb3dlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdGlmIChwYXJzZXIucmVtYWluaW5nKCkuc3Vic3RyKDAsIGV4cGVjdGVkRm9sbG93ZXJzW2ldLmxlbmd0aCkgPT09IGV4cGVjdGVkRm9sbG93ZXJzW2ldKSB7XG4gIFx0XHRcdHJldHVybiBleHByZXNzaW9uO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRyZXR1cm4gcHJpbWFyeV9yZWFkUmVmZXJlbmNlKHBhcnNlcik7XG4gIH1cblxuICB2YXIgbXVzdGFjaGVfcmVhZEludGVycG9sYXRvciA9IHJlYWRJbnRlcnBvbGF0b3I7XG4gIGZ1bmN0aW9uIHJlYWRJbnRlcnBvbGF0b3IocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQsIGV4cHJlc3Npb24sIGludGVycG9sYXRvciwgZXJyO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0Ly8gVE9ETyB3b3VsZCBiZSBnb29kIGZvciBwZXJmIGlmIHdlIGNvdWxkIGRvIGF3YXkgd2l0aCB0aGUgdHJ5LWNhdGNoXG4gIFx0dHJ5IHtcbiAgXHRcdGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uT3JSZWZlcmVuY2UocGFyc2VyLCBbdGFnLmNsb3NlXSk7XG4gIFx0fSBjYXRjaCAoZSkge1xuICBcdFx0ZXJyID0gZTtcbiAgXHR9XG5cbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdGlmIChwYXJzZXIuc3RyLmNoYXJBdChzdGFydCkgPT09IFwiIVwiKSB7XG4gIFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIGNvbW1lbnRcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGVycikge1xuICBcdFx0XHR0aHJvdyBlcnI7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgdGFnLmNsb3NlICsgXCInIGFmdGVyIHJlZmVyZW5jZVwiKTtcblxuICBcdFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIGNvbW1lbnRcbiAgXHRcdFx0aWYgKHBhcnNlci5uZXh0Q2hhcigpID09PSBcIiFcIikge1xuICBcdFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgZXhwcmVzc2lvbiBvciBsZWdhbCByZWZlcmVuY2VcIik7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aW50ZXJwb2xhdG9yID0geyB0OiBJTlRFUlBPTEFUT1IgfTtcbiAgXHR1dGlsc19yZWZpbmVFeHByZXNzaW9uKGV4cHJlc3Npb24sIGludGVycG9sYXRvcik7IC8vIFRPRE8gaGFuZGxlIHRoaXMgZGlmZmVyZW50bHkgLSBpdCdzIG15c3RlcmlvdXNcblxuICBcdHJldHVybiBpbnRlcnBvbGF0b3I7XG4gIH1cblxuICB2YXIgbXVzdGFjaGVfcmVhZFlpZWxkZXIgPSByZWFkWWllbGRlcjtcbiAgdmFyIHlpZWxkUGF0dGVybiA9IC9eeWllbGRcXHMqLztcbiAgZnVuY3Rpb24gcmVhZFlpZWxkZXIocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQsIG5hbWUsIHlpZWxkZXI7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFBhdHRlcm4oeWllbGRQYXR0ZXJuKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuICBcdG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOVxcLV0qLyk7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJleHBlY3RlZCBsZWdhbCBwYXJ0aWFsIG5hbWVcIik7XG4gIFx0fVxuXG4gIFx0eWllbGRlciA9IHsgdDogWUlFTERFUiB9O1xuXG4gIFx0aWYgKG5hbWUpIHtcbiAgXHRcdHlpZWxkZXIubiA9IG5hbWU7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHlpZWxkZXI7XG4gIH1cblxuICB2YXIgc2VjdGlvbl9yZWFkQ2xvc2luZyA9IHJlYWRDbG9zaW5nO1xuICBmdW5jdGlvbiByZWFkQ2xvc2luZyhwYXJzZXIsIHRhZykge1xuICBcdHZhciBzdGFydCwgcmVtYWluaW5nLCBpbmRleCwgY2xvc2luZztcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5vcGVuKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCIvXCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG4gIFx0aW5kZXggPSByZW1haW5pbmcuaW5kZXhPZih0YWcuY2xvc2UpO1xuXG4gIFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0Y2xvc2luZyA9IHtcbiAgXHRcdFx0dDogQ0xPU0lORyxcbiAgXHRcdFx0cjogcmVtYWluaW5nLnN1YnN0cigwLCBpbmRleCkuc3BsaXQoXCIgXCIpWzBdXG4gIFx0XHR9O1xuXG4gIFx0XHRwYXJzZXIucG9zICs9IGluZGV4O1xuXG4gIFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJ1wiKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGNsb3Npbmc7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHNlY3Rpb25fcmVhZEVsc2UgPSBzZWN0aW9uX3JlYWRFbHNlX19yZWFkRWxzZTtcbiAgdmFyIHNlY3Rpb25fcmVhZEVsc2VfX2Vsc2VQYXR0ZXJuID0gL15cXHMqZWxzZVxccyovO1xuICBmdW5jdGlvbiBzZWN0aW9uX3JlYWRFbHNlX19yZWFkRWxzZShwYXJzZXIsIHRhZykge1xuICBcdHZhciBzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcub3BlbikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoUGF0dGVybihzZWN0aW9uX3JlYWRFbHNlX19lbHNlUGF0dGVybikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJ1wiKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogRUxTRVxuICBcdH07XG4gIH1cblxuICB2YXIgcmVhZEVsc2VJZiA9IHJlYWRFbHNlSWZfX3JlYWRFbHNlO1xuICB2YXIgcmVhZEVsc2VJZl9fZWxzZVBhdHRlcm4gPSAvXlxccyplbHNlaWZcXHMrLztcbiAgZnVuY3Rpb24gcmVhZEVsc2VJZl9fcmVhZEVsc2UocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQgPSBwYXJzZXIucG9zLFxuICBcdCAgICBleHByZXNzaW9uO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLm9wZW4pKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFBhdHRlcm4ocmVhZEVsc2VJZl9fZWxzZVBhdHRlcm4pKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRleHByZXNzaW9uID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgdGFnLmNsb3NlICsgXCInXCIpO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBFTFNFSUYsXG4gIFx0XHR4OiBleHByZXNzaW9uXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBoYW5kbGViYXJzQmxvY2tDb2RlcyA9IHtcbiAgXHRlYWNoOiBTRUNUSU9OX0VBQ0gsXG4gIFx0XCJpZlwiOiBTRUNUSU9OX0lGLFxuICBcdFwiaWYtd2l0aFwiOiBTRUNUSU9OX0lGX1dJVEgsXG4gIFx0XCJ3aXRoXCI6IFNFQ1RJT05fV0lUSCxcbiAgXHR1bmxlc3M6IFNFQ1RJT05fVU5MRVNTXG4gIH07XG5cbiAgdmFyIG11c3RhY2hlX3JlYWRTZWN0aW9uID0gcmVhZFNlY3Rpb247XG5cbiAgdmFyIGluZGV4UmVmUGF0dGVybiA9IC9eXFxzKjpcXHMqKFthLXpBLVpfJF1bYS16QS1aXyQwLTldKikvLFxuICAgICAga2V5SW5kZXhSZWZQYXR0ZXJuID0gL15cXHMqLFxccyooW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKS8sXG4gICAgICBoYW5kbGViYXJzQmxvY2tQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIl4oXCIgKyBPYmplY3Qua2V5cyhoYW5kbGViYXJzQmxvY2tDb2Rlcykuam9pbihcInxcIikgKyBcIilcXFxcYlwiKTtcbiAgZnVuY3Rpb24gcmVhZFNlY3Rpb24ocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQsIGV4cHJlc3Npb24sIHNlY3Rpb24sIGNoaWxkLCBjaGlsZHJlbiwgaGFzRWxzZSwgYmxvY2ssIHVubGVzc0Jsb2NrLCBjb25kaXRpb25zLCBjbG9zZWQsIGksIGV4cGVjdGVkQ2xvc2U7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiXlwiKSkge1xuICBcdFx0c2VjdGlvbiA9IHsgdDogU0VDVElPTiwgZjogW10sIG46IFNFQ1RJT05fVU5MRVNTIH07XG4gIFx0fSBlbHNlIGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIjXCIpKSB7XG4gIFx0XHRzZWN0aW9uID0geyB0OiBTRUNUSU9OLCBmOiBbXSB9O1xuXG4gIFx0XHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwicGFydGlhbFwiKSkge1xuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQgLSBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzBdLmxlbmd0aDtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiUGFydGlhbCBkZWZpbml0aW9ucyBjYW4gb25seSBiZSBhdCB0aGUgdG9wIGxldmVsIG9mIHRoZSB0ZW1wbGF0ZSwgb3IgaW1tZWRpYXRlbHkgaW5zaWRlIGNvbXBvbmVudHNcIik7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChibG9jayA9IHBhcnNlci5tYXRjaFBhdHRlcm4oaGFuZGxlYmFyc0Jsb2NrUGF0dGVybikpIHtcbiAgXHRcdFx0ZXhwZWN0ZWRDbG9zZSA9IGJsb2NrO1xuICBcdFx0XHRzZWN0aW9uLm4gPSBoYW5kbGViYXJzQmxvY2tDb2Rlc1tibG9ja107XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG5cbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGV4cHJlc3Npb25cIik7XG4gIFx0fVxuXG4gIFx0Ly8gb3B0aW9uYWwgaW5kZXggYW5kIGtleSByZWZlcmVuY2VzXG4gIFx0aWYgKGkgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKGluZGV4UmVmUGF0dGVybikpIHtcbiAgXHRcdHZhciBleHRyYSA9IHVuZGVmaW5lZDtcblxuICBcdFx0aWYgKGV4dHJhID0gcGFyc2VyLm1hdGNoUGF0dGVybihrZXlJbmRleFJlZlBhdHRlcm4pKSB7XG4gIFx0XHRcdHNlY3Rpb24uaSA9IGkgKyBcIixcIiArIGV4dHJhO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0c2VjdGlvbi5pID0gaTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyB0YWcuY2xvc2UgKyBcIidcIik7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLnNlY3Rpb25EZXB0aCArPSAxO1xuICBcdGNoaWxkcmVuID0gc2VjdGlvbi5mO1xuXG4gIFx0Y29uZGl0aW9ucyA9IFtdO1xuXG4gIFx0ZG8ge1xuICBcdFx0aWYgKGNoaWxkID0gc2VjdGlvbl9yZWFkQ2xvc2luZyhwYXJzZXIsIHRhZykpIHtcbiAgXHRcdFx0aWYgKGV4cGVjdGVkQ2xvc2UgJiYgY2hpbGQuciAhPT0gZXhwZWN0ZWRDbG9zZSkge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIFwiICsgdGFnLm9wZW4gKyBcIi9cIiArIGV4cGVjdGVkQ2xvc2UgKyBcIlwiICsgdGFnLmNsb3NlKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHBhcnNlci5zZWN0aW9uRGVwdGggLT0gMTtcbiAgXHRcdFx0Y2xvc2VkID0gdHJ1ZTtcbiAgXHRcdH0gZWxzZSBpZiAoY2hpbGQgPSByZWFkRWxzZUlmKHBhcnNlciwgdGFnKSkge1xuICBcdFx0XHRpZiAoc2VjdGlvbi5uID09PSBTRUNUSU9OX1VOTEVTUykge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihcInt7ZWxzZX19IG5vdCBhbGxvd2VkIGluIHt7I3VubGVzc319XCIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGhhc0Vsc2UpIHtcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJpbGxlZ2FsIHt7ZWxzZWlmLi4ufX0gYWZ0ZXIge3tlbHNlfX1cIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIXVubGVzc0Jsb2NrKSB7XG4gIFx0XHRcdFx0dW5sZXNzQmxvY2sgPSBjcmVhdGVVbmxlc3NCbG9jayhleHByZXNzaW9uLCBzZWN0aW9uLm4pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dW5sZXNzQmxvY2suZi5wdXNoKHtcbiAgXHRcdFx0XHR0OiBTRUNUSU9OLFxuICBcdFx0XHRcdG46IFNFQ1RJT05fSUYsXG4gIFx0XHRcdFx0eDogdXRpbHNfZmxhdHRlbkV4cHJlc3Npb24obXVzdGFjaGVfcmVhZFNlY3Rpb25fX2NvbWJpbmUoY29uZGl0aW9ucy5jb25jYXQoY2hpbGQueCkpKSxcbiAgXHRcdFx0XHRmOiBjaGlsZHJlbiA9IFtdXG4gIFx0XHRcdH0pO1xuXG4gIFx0XHRcdGNvbmRpdGlvbnMucHVzaChpbnZlcnQoY2hpbGQueCkpO1xuICBcdFx0fSBlbHNlIGlmIChjaGlsZCA9IHNlY3Rpb25fcmVhZEVsc2UocGFyc2VyLCB0YWcpKSB7XG4gIFx0XHRcdGlmIChzZWN0aW9uLm4gPT09IFNFQ1RJT05fVU5MRVNTKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwie3tlbHNlfX0gbm90IGFsbG93ZWQgaW4ge3sjdW5sZXNzfX1cIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoaGFzRWxzZSkge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihcInRoZXJlIGNhbiBvbmx5IGJlIG9uZSB7e2Vsc2V9fSBibG9jaywgYXQgdGhlIGVuZCBvZiBhIHNlY3Rpb25cIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRoYXNFbHNlID0gdHJ1ZTtcblxuICBcdFx0XHQvLyB1c2UgYW4gdW5sZXNzIGJsb2NrIGlmIHRoZXJlJ3Mgbm8gZWxzZWlmXG4gIFx0XHRcdGlmICghdW5sZXNzQmxvY2spIHtcbiAgXHRcdFx0XHR1bmxlc3NCbG9jayA9IGNyZWF0ZVVubGVzc0Jsb2NrKGV4cHJlc3Npb24sIHNlY3Rpb24ubik7XG4gIFx0XHRcdFx0Y2hpbGRyZW4gPSB1bmxlc3NCbG9jay5mO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHVubGVzc0Jsb2NrLmYucHVzaCh7XG4gIFx0XHRcdFx0XHR0OiBTRUNUSU9OLFxuICBcdFx0XHRcdFx0bjogU0VDVElPTl9JRixcbiAgXHRcdFx0XHRcdHg6IHV0aWxzX2ZsYXR0ZW5FeHByZXNzaW9uKG11c3RhY2hlX3JlYWRTZWN0aW9uX19jb21iaW5lKGNvbmRpdGlvbnMpKSxcbiAgXHRcdFx0XHRcdGY6IGNoaWxkcmVuID0gW11cbiAgXHRcdFx0XHR9KTtcbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Y2hpbGQgPSBwYXJzZXIucmVhZChSRUFERVJTKTtcblxuICBcdFx0XHRpZiAoIWNoaWxkKSB7XG4gIFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgXHRcdH1cbiAgXHR9IHdoaWxlICghY2xvc2VkKTtcblxuICBcdGlmICh1bmxlc3NCbG9jaykge1xuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gYHdpdGhgIHNob3VsZCBiZWNvbWUgYGlmLXdpdGhgIChUT0RPIGlzIHRoaXMgcmlnaHQ/XG4gIFx0XHQvLyBzZWVtcyB0byBtZSB0aGF0IGB3aXRoYCBvdWdodCB0byBiZWhhdmUgY29uc2lzdGVudGx5LCByZWdhcmRsZXNzXG4gIFx0XHQvLyBvZiB0aGUgcHJlc2VuY2UvYWJzZW5jZSBvZiBgZWxzZWAuIEluIG90aGVyIHdvcmRzIHNob3VsZCBhbHdheXNcbiAgXHRcdC8vIGJlIGBpZi13aXRoYFxuICBcdFx0aWYgKHNlY3Rpb24ubiA9PT0gU0VDVElPTl9XSVRIKSB7XG4gIFx0XHRcdHNlY3Rpb24ubiA9IFNFQ1RJT05fSUZfV0lUSDtcbiAgXHRcdH1cblxuICBcdFx0c2VjdGlvbi5sID0gdW5sZXNzQmxvY2s7XG4gIFx0fVxuXG4gIFx0dXRpbHNfcmVmaW5lRXhwcmVzc2lvbihleHByZXNzaW9uLCBzZWN0aW9uKTtcblxuICBcdC8vIFRPRE8gaWYgYSBzZWN0aW9uIGlzIGVtcHR5IGl0IHNob3VsZCBiZSBkaXNjYXJkZWQuIERvbid0IGRvXG4gIFx0Ly8gdGhhdCBoZXJlIHRob3VnaCAtIHdlIG5lZWQgdG8gY2xlYW4gZXZlcnl0aGluZyB1cCBmaXJzdCwgYXNcbiAgXHQvLyBpdCBtYXkgY29udGFpbiByZW1vdmVhYmxlIHdoaXRlc3BhY2UuIEFzIGEgdGVtcG9yYXJ5IG1lYXN1cmUsXG4gIFx0Ly8gdG8gcGFzcyB0aGUgZXhpc3RpbmcgdGVzdHMsIHJlbW92ZSBlbXB0eSBgZmAgYXJyYXlzXG4gIFx0aWYgKCFzZWN0aW9uLmYubGVuZ3RoKSB7XG4gIFx0XHRkZWxldGUgc2VjdGlvbi5mO1xuICBcdH1cblxuICBcdHJldHVybiBzZWN0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5sZXNzQmxvY2soZXhwcmVzc2lvbiwgc2VjdGlvblR5cGUpIHtcbiAgXHR2YXIgdW5sZXNzQmxvY2s7XG5cbiAgXHRpZiAoc2VjdGlvblR5cGUgPT09IFNFQ1RJT05fV0lUSCkge1xuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gYSBge3sjd2l0aCBmb299fWAgc2VjdGlvbiB3aWxsIHJlbmRlciBpZiBgZm9vYCBpc1xuICBcdFx0Ly8gdHJ1dGh5LCBzbyB0aGUgYHt7ZWxzZX19YCBzZWN0aW9uIG5lZWRzIHRvIHJlbmRlciBpZiBgZm9vYCBpcyBmYWxzeSxcbiAgXHRcdC8vIHJhdGhlciB0aGFuIGFkaGVyaW5nIHRvIHRoZSBub3JtYWwgYHt7I3VubGVzcyBmb299fWAgbG9naWMgKHdoaWNoXG4gIFx0XHQvLyB0cmVhdHMgZW1wdHkgYXJyYXlzL29iamVjdHMgYXMgZmFsc3kpXG4gIFx0XHR1bmxlc3NCbG9jayA9IHtcbiAgXHRcdFx0dDogU0VDVElPTixcbiAgXHRcdFx0bjogU0VDVElPTl9JRixcbiAgXHRcdFx0ZjogW11cbiAgXHRcdH07XG5cbiAgXHRcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oaW52ZXJ0KGV4cHJlc3Npb24pLCB1bmxlc3NCbG9jayk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHVubGVzc0Jsb2NrID0ge1xuICBcdFx0XHR0OiBTRUNUSU9OLFxuICBcdFx0XHRuOiBTRUNUSU9OX1VOTEVTUyxcbiAgXHRcdFx0ZjogW11cbiAgXHRcdH07XG5cbiAgXHRcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgdW5sZXNzQmxvY2spO1xuICBcdH1cblxuICBcdHJldHVybiB1bmxlc3NCbG9jaztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmVydChleHByZXNzaW9uKSB7XG4gIFx0aWYgKGV4cHJlc3Npb24udCA9PT0gUFJFRklYX09QRVJBVE9SICYmIGV4cHJlc3Npb24ucyA9PT0gXCIhXCIpIHtcbiAgXHRcdHJldHVybiBleHByZXNzaW9uLm87XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IFBSRUZJWF9PUEVSQVRPUixcbiAgXHRcdHM6IFwiIVwiLFxuICBcdFx0bzogcGFyZW5zSWZOZWNlc3NhcnkoZXhwcmVzc2lvbilcbiAgXHR9O1xuICB9XG5cbiAgZnVuY3Rpb24gbXVzdGFjaGVfcmVhZFNlY3Rpb25fX2NvbWJpbmUoZXhwcmVzc2lvbnMpIHtcbiAgXHRpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID09PSAxKSB7XG4gIFx0XHRyZXR1cm4gZXhwcmVzc2lvbnNbMF07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IElORklYX09QRVJBVE9SLFxuICBcdFx0czogXCImJlwiLFxuICBcdFx0bzogW3BhcmVuc0lmTmVjZXNzYXJ5KGV4cHJlc3Npb25zWzBdKSwgcGFyZW5zSWZOZWNlc3NhcnkobXVzdGFjaGVfcmVhZFNlY3Rpb25fX2NvbWJpbmUoZXhwcmVzc2lvbnMuc2xpY2UoMSkpKV1cbiAgXHR9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyZW5zSWZOZWNlc3NhcnkoZXhwcmVzc2lvbikge1xuICBcdC8vIFRPRE8gb25seSB3cmFwIGlmIG5lY2Vzc2FyeVxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBCUkFDS0VURUQsXG4gIFx0XHR4OiBleHByZXNzaW9uXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBjb252ZXJ0ZXJzX3JlYWRIdG1sQ29tbWVudCA9IHJlYWRIdG1sQ29tbWVudDtcbiAgdmFyIE9QRU5fQ09NTUVOVCA9IFwiPCEtLVwiLFxuICAgICAgQ0xPU0VfQ09NTUVOVCA9IFwiLS0+XCI7XG4gIGZ1bmN0aW9uIHJlYWRIdG1sQ29tbWVudChwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIGNvbnRlbnQsIHJlbWFpbmluZywgZW5kSW5kZXgsIGNvbW1lbnQ7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhPUEVOX0NPTU1FTlQpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG4gIFx0ZW5kSW5kZXggPSByZW1haW5pbmcuaW5kZXhPZihDTE9TRV9DT01NRU5UKTtcblxuICBcdGlmIChlbmRJbmRleCA9PT0gLTEpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIklsbGVnYWwgSFRNTCAtIGV4cGVjdGVkIGNsb3NpbmcgY29tbWVudCBzZXF1ZW5jZSAoJy0tPicpXCIpO1xuICBcdH1cblxuICBcdGNvbnRlbnQgPSByZW1haW5pbmcuc3Vic3RyKDAsIGVuZEluZGV4KTtcbiAgXHRwYXJzZXIucG9zICs9IGVuZEluZGV4ICsgMztcblxuICBcdGNvbW1lbnQgPSB7XG4gIFx0XHR0OiBDT01NRU5ULFxuICBcdFx0YzogY29udGVudFxuICBcdH07XG5cbiAgXHRpZiAocGFyc2VyLmluY2x1ZGVMaW5lUG9zaXRpb25zKSB7XG4gIFx0XHRjb21tZW50LnAgPSBwYXJzZXIuZ2V0TGluZVBvcyhzdGFydCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGNvbW1lbnQ7XG4gIH1cblxuICB2YXIgYm9vbGVhbkF0dHJpYnV0ZXMsIHZvaWRFbGVtZW50TmFtZXMsIGh0bWxFbnRpdGllcywgY29udHJvbENoYXJhY3RlcnMsIGVudGl0eVBhdHRlcm4sIGxlc3NUaGFuLCBncmVhdGVyVGhhbiwgYW1wO1xuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5nYXgvaHRtbC1taW5pZmllci9pc3N1ZXMvNjMjaXNzdWVjb21tZW50LTM3NzYzMzE2XG4gIGJvb2xlYW5BdHRyaWJ1dGVzID0gL14oYWxsb3dGdWxsc2NyZWVufGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjaGVja2VkfGNvbXBhY3R8Y29udHJvbHN8ZGVjbGFyZXxkZWZhdWx0fGRlZmF1bHRDaGVja2VkfGRlZmF1bHRNdXRlZHxkZWZhdWx0U2VsZWN0ZWR8ZGVmZXJ8ZGlzYWJsZWR8ZW5hYmxlZHxmb3JtTm9WYWxpZGF0ZXxoaWRkZW58aW5kZXRlcm1pbmF0ZXxpbmVydHxpc01hcHxpdGVtU2NvcGV8bG9vcHxtdWx0aXBsZXxtdXRlZHxub0hyZWZ8bm9SZXNpemV8bm9TaGFkZXxub1ZhbGlkYXRlfG5vV3JhcHxvcGVufHBhdXNlT25FeGl0fHJlYWRPbmx5fHJlcXVpcmVkfHJldmVyc2VkfHNjb3BlZHxzZWFtbGVzc3xzZWxlY3RlZHxzb3J0YWJsZXx0cmFuc2xhdGV8dHJ1ZVNwZWVkfHR5cGVNdXN0TWF0Y2h8dmlzaWJsZSkkL2k7XG4gIHZvaWRFbGVtZW50TmFtZXMgPSAvXig/OmFyZWF8YmFzZXxicnxjb2x8Y29tbWFuZHxkb2N0eXBlfGVtYmVkfGhyfGltZ3xpbnB1dHxrZXlnZW58bGlua3xtZXRhfHBhcmFtfHNvdXJjZXx0cmFja3x3YnIpJC9pO1xuXG4gIGh0bWxFbnRpdGllcyA9IHsgcXVvdDogMzQsIGFtcDogMzgsIGFwb3M6IDM5LCBsdDogNjAsIGd0OiA2MiwgbmJzcDogMTYwLCBpZXhjbDogMTYxLCBjZW50OiAxNjIsIHBvdW5kOiAxNjMsIGN1cnJlbjogMTY0LCB5ZW46IDE2NSwgYnJ2YmFyOiAxNjYsIHNlY3Q6IDE2NywgdW1sOiAxNjgsIGNvcHk6IDE2OSwgb3JkZjogMTcwLCBsYXF1bzogMTcxLCBub3Q6IDE3Miwgc2h5OiAxNzMsIHJlZzogMTc0LCBtYWNyOiAxNzUsIGRlZzogMTc2LCBwbHVzbW46IDE3Nywgc3VwMjogMTc4LCBzdXAzOiAxNzksIGFjdXRlOiAxODAsIG1pY3JvOiAxODEsIHBhcmE6IDE4MiwgbWlkZG90OiAxODMsIGNlZGlsOiAxODQsIHN1cDE6IDE4NSwgb3JkbTogMTg2LCByYXF1bzogMTg3LCBmcmFjMTQ6IDE4OCwgZnJhYzEyOiAxODksIGZyYWMzNDogMTkwLCBpcXVlc3Q6IDE5MSwgQWdyYXZlOiAxOTIsIEFhY3V0ZTogMTkzLCBBY2lyYzogMTk0LCBBdGlsZGU6IDE5NSwgQXVtbDogMTk2LCBBcmluZzogMTk3LCBBRWxpZzogMTk4LCBDY2VkaWw6IDE5OSwgRWdyYXZlOiAyMDAsIEVhY3V0ZTogMjAxLCBFY2lyYzogMjAyLCBFdW1sOiAyMDMsIElncmF2ZTogMjA0LCBJYWN1dGU6IDIwNSwgSWNpcmM6IDIwNiwgSXVtbDogMjA3LCBFVEg6IDIwOCwgTnRpbGRlOiAyMDksIE9ncmF2ZTogMjEwLCBPYWN1dGU6IDIxMSwgT2NpcmM6IDIxMiwgT3RpbGRlOiAyMTMsIE91bWw6IDIxNCwgdGltZXM6IDIxNSwgT3NsYXNoOiAyMTYsIFVncmF2ZTogMjE3LCBVYWN1dGU6IDIxOCwgVWNpcmM6IDIxOSwgVXVtbDogMjIwLCBZYWN1dGU6IDIyMSwgVEhPUk46IDIyMiwgc3psaWc6IDIyMywgYWdyYXZlOiAyMjQsIGFhY3V0ZTogMjI1LCBhY2lyYzogMjI2LCBhdGlsZGU6IDIyNywgYXVtbDogMjI4LCBhcmluZzogMjI5LCBhZWxpZzogMjMwLCBjY2VkaWw6IDIzMSwgZWdyYXZlOiAyMzIsIGVhY3V0ZTogMjMzLCBlY2lyYzogMjM0LCBldW1sOiAyMzUsIGlncmF2ZTogMjM2LCBpYWN1dGU6IDIzNywgaWNpcmM6IDIzOCwgaXVtbDogMjM5LCBldGg6IDI0MCwgbnRpbGRlOiAyNDEsIG9ncmF2ZTogMjQyLCBvYWN1dGU6IDI0Mywgb2NpcmM6IDI0NCwgb3RpbGRlOiAyNDUsIG91bWw6IDI0NiwgZGl2aWRlOiAyNDcsIG9zbGFzaDogMjQ4LCB1Z3JhdmU6IDI0OSwgdWFjdXRlOiAyNTAsIHVjaXJjOiAyNTEsIHV1bWw6IDI1MiwgeWFjdXRlOiAyNTMsIHRob3JuOiAyNTQsIHl1bWw6IDI1NSwgT0VsaWc6IDMzOCwgb2VsaWc6IDMzOSwgU2Nhcm9uOiAzNTIsIHNjYXJvbjogMzUzLCBZdW1sOiAzNzYsIGZub2Y6IDQwMiwgY2lyYzogNzEwLCB0aWxkZTogNzMyLCBBbHBoYTogOTEzLCBCZXRhOiA5MTQsIEdhbW1hOiA5MTUsIERlbHRhOiA5MTYsIEVwc2lsb246IDkxNywgWmV0YTogOTE4LCBFdGE6IDkxOSwgVGhldGE6IDkyMCwgSW90YTogOTIxLCBLYXBwYTogOTIyLCBMYW1iZGE6IDkyMywgTXU6IDkyNCwgTnU6IDkyNSwgWGk6IDkyNiwgT21pY3JvbjogOTI3LCBQaTogOTI4LCBSaG86IDkyOSwgU2lnbWE6IDkzMSwgVGF1OiA5MzIsIFVwc2lsb246IDkzMywgUGhpOiA5MzQsIENoaTogOTM1LCBQc2k6IDkzNiwgT21lZ2E6IDkzNywgYWxwaGE6IDk0NSwgYmV0YTogOTQ2LCBnYW1tYTogOTQ3LCBkZWx0YTogOTQ4LCBlcHNpbG9uOiA5NDksIHpldGE6IDk1MCwgZXRhOiA5NTEsIHRoZXRhOiA5NTIsIGlvdGE6IDk1Mywga2FwcGE6IDk1NCwgbGFtYmRhOiA5NTUsIG11OiA5NTYsIG51OiA5NTcsIHhpOiA5NTgsIG9taWNyb246IDk1OSwgcGk6IDk2MCwgcmhvOiA5NjEsIHNpZ21hZjogOTYyLCBzaWdtYTogOTYzLCB0YXU6IDk2NCwgdXBzaWxvbjogOTY1LCBwaGk6IDk2NiwgY2hpOiA5NjcsIHBzaTogOTY4LCBvbWVnYTogOTY5LCB0aGV0YXN5bTogOTc3LCB1cHNpaDogOTc4LCBwaXY6IDk4MiwgZW5zcDogODE5NCwgZW1zcDogODE5NSwgdGhpbnNwOiA4MjAxLCB6d25qOiA4MjA0LCB6d2o6IDgyMDUsIGxybTogODIwNiwgcmxtOiA4MjA3LCBuZGFzaDogODIxMSwgbWRhc2g6IDgyMTIsIGxzcXVvOiA4MjE2LCByc3F1bzogODIxNywgc2JxdW86IDgyMTgsIGxkcXVvOiA4MjIwLCByZHF1bzogODIyMSwgYmRxdW86IDgyMjIsIGRhZ2dlcjogODIyNCwgRGFnZ2VyOiA4MjI1LCBidWxsOiA4MjI2LCBoZWxsaXA6IDgyMzAsIHBlcm1pbDogODI0MCwgcHJpbWU6IDgyNDIsIFByaW1lOiA4MjQzLCBsc2FxdW86IDgyNDksIHJzYXF1bzogODI1MCwgb2xpbmU6IDgyNTQsIGZyYXNsOiA4MjYwLCBldXJvOiA4MzY0LCBpbWFnZTogODQ2NSwgd2VpZXJwOiA4NDcyLCByZWFsOiA4NDc2LCB0cmFkZTogODQ4MiwgYWxlZnN5bTogODUwMSwgbGFycjogODU5MiwgdWFycjogODU5MywgcmFycjogODU5NCwgZGFycjogODU5NSwgaGFycjogODU5NiwgY3JhcnI6IDg2MjksIGxBcnI6IDg2NTYsIHVBcnI6IDg2NTcsIHJBcnI6IDg2NTgsIGRBcnI6IDg2NTksIGhBcnI6IDg2NjAsIGZvcmFsbDogODcwNCwgcGFydDogODcwNiwgZXhpc3Q6IDg3MDcsIGVtcHR5OiA4NzA5LCBuYWJsYTogODcxMSwgaXNpbjogODcxMiwgbm90aW46IDg3MTMsIG5pOiA4NzE1LCBwcm9kOiA4NzE5LCBzdW06IDg3MjEsIG1pbnVzOiA4NzIyLCBsb3dhc3Q6IDg3MjcsIHJhZGljOiA4NzMwLCBwcm9wOiA4NzMzLCBpbmZpbjogODczNCwgYW5nOiA4NzM2LCBhbmQ6IDg3NDMsIG9yOiA4NzQ0LCBjYXA6IDg3NDUsIGN1cDogODc0NiwgaW50OiA4NzQ3LCB0aGVyZTQ6IDg3NTYsIHNpbTogODc2NCwgY29uZzogODc3MywgYXN5bXA6IDg3NzYsIG5lOiA4ODAwLCBlcXVpdjogODgwMSwgbGU6IDg4MDQsIGdlOiA4ODA1LCBzdWI6IDg4MzQsIHN1cDogODgzNSwgbnN1YjogODgzNiwgc3ViZTogODgzOCwgc3VwZTogODgzOSwgb3BsdXM6IDg4NTMsIG90aW1lczogODg1NSwgcGVycDogODg2OSwgc2RvdDogODkwMSwgbGNlaWw6IDg5NjgsIHJjZWlsOiA4OTY5LCBsZmxvb3I6IDg5NzAsIHJmbG9vcjogODk3MSwgbGFuZzogOTAwMSwgcmFuZzogOTAwMiwgbG96OiA5Njc0LCBzcGFkZXM6IDk4MjQsIGNsdWJzOiA5ODI3LCBoZWFydHM6IDk4MjksIGRpYW1zOiA5ODMwIH07XG4gIGNvbnRyb2xDaGFyYWN0ZXJzID0gWzgzNjQsIDEyOSwgODIxOCwgNDAyLCA4MjIyLCA4MjMwLCA4MjI0LCA4MjI1LCA3MTAsIDgyNDAsIDM1MiwgODI0OSwgMzM4LCAxNDEsIDM4MSwgMTQzLCAxNDQsIDgyMTYsIDgyMTcsIDgyMjAsIDgyMjEsIDgyMjYsIDgyMTEsIDgyMTIsIDczMiwgODQ4MiwgMzUzLCA4MjUwLCAzMzksIDE1NywgMzgyLCAzNzZdO1xuICBlbnRpdHlQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIiYoIz8oPzp4W1xcXFx3XFxcXGRdK3xcXFxcZCt8XCIgKyBPYmplY3Qua2V5cyhodG1sRW50aXRpZXMpLmpvaW4oXCJ8XCIpICsgXCIpKTs/XCIsIFwiZ1wiKTtcblxuICBmdW5jdGlvbiBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKGh0bWwpIHtcbiAgXHRyZXR1cm4gaHRtbC5yZXBsYWNlKGVudGl0eVBhdHRlcm4sIGZ1bmN0aW9uIChtYXRjaCwgZW50aXR5KSB7XG4gIFx0XHR2YXIgY29kZTtcblxuICBcdFx0Ly8gSGFuZGxlIG5hbWVkIGVudGl0aWVzXG4gIFx0XHRpZiAoZW50aXR5WzBdICE9PSBcIiNcIikge1xuICBcdFx0XHRjb2RlID0gaHRtbEVudGl0aWVzW2VudGl0eV07XG4gIFx0XHR9IGVsc2UgaWYgKGVudGl0eVsxXSA9PT0gXCJ4XCIpIHtcbiAgXHRcdFx0Y29kZSA9IHBhcnNlSW50KGVudGl0eS5zdWJzdHJpbmcoMiksIDE2KTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGNvZGUgPSBwYXJzZUludChlbnRpdHkuc3Vic3RyaW5nKDEpLCAxMCk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghY29kZSkge1xuICBcdFx0XHRyZXR1cm4gbWF0Y2g7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHZhbGlkYXRlQ29kZShjb2RlKSk7XG4gIFx0fSk7XG4gIH1cblxuICAvLyBzb21lIGNvZGUgcG9pbnRzIGFyZSB2ZXJib3Rlbi4gSWYgd2Ugd2VyZSBpbnNlcnRpbmcgSFRNTCwgdGhlIGJyb3dzZXIgd291bGQgcmVwbGFjZSB0aGUgaWxsZWdhbFxuICAvLyBjb2RlIHBvaW50cyB3aXRoIGFsdGVybmF0aXZlcyBpbiBzb21lIGNhc2VzIC0gc2luY2Ugd2UncmUgYnlwYXNzaW5nIHRoYXQgbWVjaGFuaXNtLCB3ZSBuZWVkXG4gIC8vIHRvIHJlcGxhY2UgdGhlbSBvdXJzZWx2ZXNcbiAgLy9cbiAgLy8gU291cmNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NoYXJhY3Rlcl9lbmNvZGluZ3NfaW5fSFRNTCNJbGxlZ2FsX2NoYXJhY3RlcnNcbiAgZnVuY3Rpb24gdmFsaWRhdGVDb2RlKGNvZGUpIHtcbiAgXHRpZiAoIWNvZGUpIHtcbiAgXHRcdHJldHVybiA2NTUzMztcbiAgXHR9XG5cbiAgXHQvLyBsaW5lIGZlZWQgYmVjb21lcyBnZW5lcmljIHdoaXRlc3BhY2VcbiAgXHRpZiAoY29kZSA9PT0gMTApIHtcbiAgXHRcdHJldHVybiAzMjtcbiAgXHR9XG5cbiAgXHQvLyBBU0NJSSByYW5nZS4gKFdoeSBzb21lb25lIHdvdWxkIHVzZSBIVE1MIGVudGl0aWVzIGZvciBBU0NJSSBjaGFyYWN0ZXJzIEkgZG9uJ3Qga25vdywgYnV0Li4uKVxuICBcdGlmIChjb2RlIDwgMTI4KSB7XG4gIFx0XHRyZXR1cm4gY29kZTtcbiAgXHR9XG5cbiAgXHQvLyBjb2RlIHBvaW50cyAxMjgtMTU5IGFyZSBkZWFsdCB3aXRoIGxlbmllbnRseSBieSBicm93c2VycywgYnV0IHRoZXkncmUgaW5jb3JyZWN0LiBXZSBuZWVkXG4gIFx0Ly8gdG8gY29ycmVjdCB0aGUgbWlzdGFrZSBvciB3ZSdsbCBlbmQgdXAgd2l0aCBtaXNzaW5nIOKCrCBzaWducyBhbmQgc28gb25cbiAgXHRpZiAoY29kZSA8PSAxNTkpIHtcbiAgXHRcdHJldHVybiBjb250cm9sQ2hhcmFjdGVyc1tjb2RlIC0gMTI4XTtcbiAgXHR9XG5cbiAgXHQvLyBiYXNpYyBtdWx0aWxpbmd1YWwgcGxhbmVcbiAgXHRpZiAoY29kZSA8IDU1Mjk2KSB7XG4gIFx0XHRyZXR1cm4gY29kZTtcbiAgXHR9XG5cbiAgXHQvLyBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlc1xuICBcdGlmIChjb2RlIDw9IDU3MzQzKSB7XG4gIFx0XHRyZXR1cm4gNjU1MzM7XG4gIFx0fVxuXG4gIFx0Ly8gcmVzdCBvZiB0aGUgYmFzaWMgbXVsdGlsaW5ndWFsIHBsYW5lXG4gIFx0aWYgKGNvZGUgPD0gNjU1MzUpIHtcbiAgXHRcdHJldHVybiBjb2RlO1xuICBcdH1cblxuICBcdHJldHVybiA2NTUzMztcbiAgfVxuXG4gIGxlc3NUaGFuID0gLzwvZztcbiAgZ3JlYXRlclRoYW4gPSAvPi9nO1xuICBhbXAgPSAvJi9nO1xuXG4gIGZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyKSB7XG4gIFx0cmV0dXJuIHN0ci5yZXBsYWNlKGFtcCwgXCImYW1wO1wiKS5yZXBsYWNlKGxlc3NUaGFuLCBcIiZsdDtcIikucmVwbGFjZShncmVhdGVyVGhhbiwgXCImZ3Q7XCIpO1xuICB9XG5cbiAgdmFyIGxlYWRpbmdMaW5lYnJlYWsgPSAvXlxccypcXHI/XFxuLyxcbiAgICAgIHRyYWlsaW5nTGluZWJyZWFrID0gL1xccj9cXG5cXHMqJC87XG5cbiAgdmFyIHN0cmlwU3RhbmRhbG9uZXMgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgXHR2YXIgaSwgY3VycmVudCwgYmFja09uZSwgYmFja1R3bywgbGFzdFNlY3Rpb25JdGVtO1xuXG4gIFx0Zm9yIChpID0gMTsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRjdXJyZW50ID0gaXRlbXNbaV07XG4gIFx0XHRiYWNrT25lID0gaXRlbXNbaSAtIDFdO1xuICBcdFx0YmFja1R3byA9IGl0ZW1zW2kgLSAyXTtcblxuICBcdFx0Ly8gaWYgd2UncmUgYXQgdGhlIGVuZCBvZiBhIFt0ZXh0XVtjb21tZW50XVt0ZXh0XSBzZXF1ZW5jZS4uLlxuICBcdFx0aWYgKGlzU3RyaW5nKGN1cnJlbnQpICYmIGlzQ29tbWVudChiYWNrT25lKSAmJiBpc1N0cmluZyhiYWNrVHdvKSkge1xuXG4gIFx0XHRcdC8vIC4uLiBhbmQgdGhlIGNvbW1lbnQgaXMgYSBzdGFuZGFsb25lIChpLmUuIGxpbmUgYnJlYWtzIGVpdGhlciBzaWRlKS4uLlxuICBcdFx0XHRpZiAodHJhaWxpbmdMaW5lYnJlYWsudGVzdChiYWNrVHdvKSAmJiBsZWFkaW5nTGluZWJyZWFrLnRlc3QoY3VycmVudCkpIHtcblxuICBcdFx0XHRcdC8vIC4uLiB0aGVuIHdlIHdhbnQgdG8gcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlIGFmdGVyIHRoZSBmaXJzdCBsaW5lIGJyZWFrXG4gIFx0XHRcdFx0aXRlbXNbaSAtIDJdID0gYmFja1R3by5yZXBsYWNlKHRyYWlsaW5nTGluZWJyZWFrLCBcIlxcblwiKTtcblxuICBcdFx0XHRcdC8vIGFuZCB0aGUgbGVhZGluZyBsaW5lIGJyZWFrIG9mIHRoZSBzZWNvbmQgdGV4dCB0b2tlblxuICBcdFx0XHRcdGl0ZW1zW2ldID0gY3VycmVudC5yZXBsYWNlKGxlYWRpbmdMaW5lYnJlYWssIFwiXCIpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGlmIHRoZSBjdXJyZW50IGl0ZW0gaXMgYSBzZWN0aW9uLCBhbmQgaXQgaXMgcHJlY2VkZWQgYnkgYSBsaW5lYnJlYWssIGFuZFxuICBcdFx0Ly8gaXRzIGZpcnN0IGl0ZW0gaXMgYSBsaW5lYnJlYWsuLi5cbiAgXHRcdGlmIChpc1NlY3Rpb24oY3VycmVudCkgJiYgaXNTdHJpbmcoYmFja09uZSkpIHtcbiAgXHRcdFx0aWYgKHRyYWlsaW5nTGluZWJyZWFrLnRlc3QoYmFja09uZSkgJiYgaXNTdHJpbmcoY3VycmVudC5mWzBdKSAmJiBsZWFkaW5nTGluZWJyZWFrLnRlc3QoY3VycmVudC5mWzBdKSkge1xuICBcdFx0XHRcdGl0ZW1zW2kgLSAxXSA9IGJhY2tPbmUucmVwbGFjZSh0cmFpbGluZ0xpbmVicmVhaywgXCJcXG5cIik7XG4gIFx0XHRcdFx0Y3VycmVudC5mWzBdID0gY3VycmVudC5mWzBdLnJlcGxhY2UobGVhZGluZ0xpbmVicmVhaywgXCJcIik7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gaWYgdGhlIGxhc3QgaXRlbSB3YXMgYSBzZWN0aW9uLCBhbmQgaXQgaXMgZm9sbG93ZWQgYnkgYSBsaW5lYnJlYWssIGFuZFxuICBcdFx0Ly8gaXRzIGxhc3QgaXRlbSBpcyBhIGxpbmVicmVhay4uLlxuICBcdFx0aWYgKGlzU3RyaW5nKGN1cnJlbnQpICYmIGlzU2VjdGlvbihiYWNrT25lKSkge1xuICBcdFx0XHRsYXN0U2VjdGlvbkl0ZW0gPSBsYXN0SXRlbShiYWNrT25lLmYpO1xuXG4gIFx0XHRcdGlmIChpc1N0cmluZyhsYXN0U2VjdGlvbkl0ZW0pICYmIHRyYWlsaW5nTGluZWJyZWFrLnRlc3QobGFzdFNlY3Rpb25JdGVtKSAmJiBsZWFkaW5nTGluZWJyZWFrLnRlc3QoY3VycmVudCkpIHtcbiAgXHRcdFx0XHRiYWNrT25lLmZbYmFja09uZS5mLmxlbmd0aCAtIDFdID0gbGFzdFNlY3Rpb25JdGVtLnJlcGxhY2UodHJhaWxpbmdMaW5lYnJlYWssIFwiXFxuXCIpO1xuICBcdFx0XHRcdGl0ZW1zW2ldID0gY3VycmVudC5yZXBsYWNlKGxlYWRpbmdMaW5lYnJlYWssIFwiXCIpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGl0ZW1zO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGlzU3RyaW5nKGl0ZW0pIHtcbiAgXHRyZXR1cm4gdHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc0NvbW1lbnQoaXRlbSkge1xuICBcdHJldHVybiBpdGVtLnQgPT09IENPTU1FTlQgfHwgaXRlbS50ID09PSBERUxJTUNIQU5HRTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU2VjdGlvbihpdGVtKSB7XG4gIFx0cmV0dXJuIChpdGVtLnQgPT09IFNFQ1RJT04gfHwgaXRlbS50ID09PSBJTlZFUlRFRCkgJiYgaXRlbS5mO1xuICB9XG5cbiAgdmFyIHRyaW1XaGl0ZXNwYWNlID0gZnVuY3Rpb24gKGl0ZW1zLCBsZWFkaW5nUGF0dGVybiwgdHJhaWxpbmdQYXR0ZXJuKSB7XG4gIFx0dmFyIGl0ZW07XG5cbiAgXHRpZiAobGVhZGluZ1BhdHRlcm4pIHtcbiAgXHRcdGl0ZW0gPSBpdGVtc1swXTtcbiAgXHRcdGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRpdGVtID0gaXRlbS5yZXBsYWNlKGxlYWRpbmdQYXR0ZXJuLCBcIlwiKTtcblxuICBcdFx0XHRpZiAoIWl0ZW0pIHtcbiAgXHRcdFx0XHRpdGVtcy5zaGlmdCgpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdGl0ZW1zWzBdID0gaXRlbTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICh0cmFpbGluZ1BhdHRlcm4pIHtcbiAgXHRcdGl0ZW0gPSBsYXN0SXRlbShpdGVtcyk7XG4gIFx0XHRpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0aXRlbSA9IGl0ZW0ucmVwbGFjZSh0cmFpbGluZ1BhdHRlcm4sIFwiXCIpO1xuXG4gIFx0XHRcdGlmICghaXRlbSkge1xuICBcdFx0XHRcdGl0ZW1zLnBvcCgpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdID0gaXRlbTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgdXRpbHNfY2xlYW51cCA9IGNsZWFudXA7XG4gIHZhciBjb250aWd1b3VzV2hpdGVzcGFjZSA9IC9bIFxcdFxcZlxcclxcbl0rL2c7XG4gIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2VFbGVtZW50cyA9IC9eKD86cHJlfHNjcmlwdHxzdHlsZXx0ZXh0YXJlYSkkL2k7XG4gIHZhciB1dGlsc19jbGVhbnVwX19sZWFkaW5nV2hpdGVzcGFjZSA9IC9eWyBcXHRcXGZcXHJcXG5dKy87XG4gIHZhciB0cmFpbGluZ1doaXRlc3BhY2UgPSAvWyBcXHRcXGZcXHJcXG5dKyQvO1xuICB2YXIgbGVhZGluZ05ld0xpbmUgPSAvXig/OlxcclxcbnxcXHJ8XFxuKS87XG4gIHZhciB0cmFpbGluZ05ld0xpbmUgPSAvKD86XFxyXFxufFxccnxcXG4pJC87XG4gIGZ1bmN0aW9uIGNsZWFudXAoaXRlbXMsIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2UsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZSkge1xuICBcdHZhciBpLCBpdGVtLCBwcmV2aW91c0l0ZW0sIG5leHRJdGVtLCBwcmVzZXJ2ZVdoaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIGtleTtcblxuICBcdC8vIEZpcnN0IHBhc3MgLSByZW1vdmUgc3RhbmRhbG9uZXMgYW5kIGNvbW1lbnRzIGV0Y1xuICBcdHN0cmlwU3RhbmRhbG9uZXMoaXRlbXMpO1xuXG4gIFx0aSA9IGl0ZW1zLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpdGVtID0gaXRlbXNbaV07XG5cbiAgXHRcdC8vIFJlbW92ZSBkZWxpbWl0ZXIgY2hhbmdlcywgdW5zYWZlIGVsZW1lbnRzIGV0Y1xuICBcdFx0aWYgKGl0ZW0uZXhjbHVkZSkge1xuICBcdFx0XHRpdGVtcy5zcGxpY2UoaSwgMSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIFJlbW92ZSBjb21tZW50cywgdW5sZXNzIHdlIHdhbnQgdG8ga2VlcCB0aGVtXG4gIFx0XHRlbHNlIGlmIChzdHJpcENvbW1lbnRzICYmIGl0ZW0udCA9PT0gQ09NTUVOVCkge1xuICBcdFx0XHRpdGVtcy5zcGxpY2UoaSwgMSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gSWYgbmVjZXNzYXJ5LCByZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICBcdHRyaW1XaGl0ZXNwYWNlKGl0ZW1zLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZSA/IHV0aWxzX2NsZWFudXBfX2xlYWRpbmdXaGl0ZXNwYWNlIDogbnVsbCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlID8gdHJhaWxpbmdXaGl0ZXNwYWNlIDogbnVsbCk7XG5cbiAgXHRpID0gaXRlbXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGl0ZW0gPSBpdGVtc1tpXTtcblxuICBcdFx0Ly8gUmVjdXJzZVxuICBcdFx0aWYgKGl0ZW0uZikge1xuICBcdFx0XHR2YXIgaXNQcmVzZXJ2ZVdoaXRlc3BhY2VFbGVtZW50ID0gaXRlbS50ID09PSBFTEVNRU5UICYmIHByZXNlcnZlV2hpdGVzcGFjZUVsZW1lbnRzLnRlc3QoaXRlbS5lKTtcbiAgXHRcdFx0cHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgPSBwcmVzZXJ2ZVdoaXRlc3BhY2UgfHwgaXNQcmVzZXJ2ZVdoaXRlc3BhY2VFbGVtZW50O1xuXG4gIFx0XHRcdGlmICghcHJlc2VydmVXaGl0ZXNwYWNlICYmIGlzUHJlc2VydmVXaGl0ZXNwYWNlRWxlbWVudCkge1xuICBcdFx0XHRcdHRyaW1XaGl0ZXNwYWNlKGl0ZW0uZiwgbGVhZGluZ05ld0xpbmUsIHRyYWlsaW5nTmV3TGluZSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIXByZXNlcnZlV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50KSB7XG4gIFx0XHRcdFx0cHJldmlvdXNJdGVtID0gaXRlbXNbaSAtIDFdO1xuICBcdFx0XHRcdG5leHRJdGVtID0gaXRlbXNbaSArIDFdO1xuXG4gIFx0XHRcdFx0Ly8gaWYgdGhlIHByZXZpb3VzIGl0ZW0gd2FzIGEgdGV4dCBpdGVtIHdpdGggdHJhaWxpbmcgd2hpdGVzcGFjZSxcbiAgXHRcdFx0XHQvLyByZW1vdmUgbGVhZGluZyB3aGl0ZXNwYWNlIGluc2lkZSB0aGUgZnJhZ21lbnRcbiAgXHRcdFx0XHRpZiAoIXByZXZpb3VzSXRlbSB8fCB0eXBlb2YgcHJldmlvdXNJdGVtID09PSBcInN0cmluZ1wiICYmIHRyYWlsaW5nV2hpdGVzcGFjZS50ZXN0KHByZXZpb3VzSXRlbSkpIHtcbiAgXHRcdFx0XHRcdHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgPSB0cnVlO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdC8vIGFuZCB2aWNlIHZlcnNhXG4gIFx0XHRcdFx0aWYgKCFuZXh0SXRlbSB8fCB0eXBlb2YgbmV4dEl0ZW0gPT09IFwic3RyaW5nXCIgJiYgdXRpbHNfY2xlYW51cF9fbGVhZGluZ1doaXRlc3BhY2UudGVzdChuZXh0SXRlbSkpIHtcbiAgXHRcdFx0XHRcdHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50ID0gdHJ1ZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjbGVhbnVwKGl0ZW0uZiwgc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gU3BsaXQgaWYtZWxzZSBibG9ja3MgaW50byB0d28gKGFuIGlmLCBhbmQgYW4gdW5sZXNzKVxuICBcdFx0aWYgKGl0ZW0ubCkge1xuICBcdFx0XHRjbGVhbnVwKGl0ZW0ubC5mLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50KTtcblxuICBcdFx0XHRpdGVtcy5zcGxpY2UoaSArIDEsIDAsIGl0ZW0ubCk7XG4gIFx0XHRcdGRlbGV0ZSBpdGVtLmw7IC8vIFRPRE8gd291bGQgYmUgbmljZSBpZiB0aGVyZSB3YXMgYSB3YXkgYXJvdW5kIHRoaXNcbiAgXHRcdH1cblxuICBcdFx0Ly8gQ2xlYW4gdXAgZWxlbWVudCBhdHRyaWJ1dGVzXG4gIFx0XHRpZiAoaXRlbS5hKSB7XG4gIFx0XHRcdGZvciAoa2V5IGluIGl0ZW0uYSkge1xuICBcdFx0XHRcdGlmIChpdGVtLmEuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0eXBlb2YgaXRlbS5hW2tleV0gIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0XHRcdGNsZWFudXAoaXRlbS5hW2tleV0sIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBDbGVhbiB1cCBjb25kaXRpb25hbCBhdHRyaWJ1dGVzXG4gIFx0XHRpZiAoaXRlbS5tKSB7XG4gIFx0XHRcdGNsZWFudXAoaXRlbS5tLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gQ2xlYW4gdXAgZXZlbnQgaGFuZGxlcnNcbiAgXHRcdGlmIChpdGVtLnYpIHtcbiAgXHRcdFx0Zm9yIChrZXkgaW4gaXRlbS52KSB7XG4gIFx0XHRcdFx0aWYgKGl0ZW0udi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gIFx0XHRcdFx0XHQvLyBjbGVhbiB1cCBuYW1lc1xuICBcdFx0XHRcdFx0aWYgKGlzQXJyYXkoaXRlbS52W2tleV0ubikpIHtcbiAgXHRcdFx0XHRcdFx0Y2xlYW51cChpdGVtLnZba2V5XS5uLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50KTtcbiAgXHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0Ly8gY2xlYW4gdXAgcGFyYW1zXG4gIFx0XHRcdFx0XHRpZiAoaXNBcnJheShpdGVtLnZba2V5XS5kKSkge1xuICBcdFx0XHRcdFx0XHRjbGVhbnVwKGl0ZW0udltrZXldLmQsIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQpO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIGZpbmFsIHBhc3MgLSBmdXNlIHRleHQgbm9kZXMgdG9nZXRoZXJcbiAgXHRpID0gaXRlbXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGlmICh0eXBlb2YgaXRlbXNbaV0gPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0aWYgKHR5cGVvZiBpdGVtc1tpICsgMV0gPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0XHRpdGVtc1tpXSA9IGl0ZW1zW2ldICsgaXRlbXNbaSArIDFdO1xuICBcdFx0XHRcdGl0ZW1zLnNwbGljZShpICsgMSwgMSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIXByZXNlcnZlV2hpdGVzcGFjZSkge1xuICBcdFx0XHRcdGl0ZW1zW2ldID0gaXRlbXNbaV0ucmVwbGFjZShjb250aWd1b3VzV2hpdGVzcGFjZSwgXCIgXCIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGl0ZW1zW2ldID09PSBcIlwiKSB7XG4gIFx0XHRcdFx0aXRlbXMuc3BsaWNlKGksIDEpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIGVsZW1lbnRfcmVhZENsb3NpbmdUYWcgPSByZWFkQ2xvc2luZ1RhZztcbiAgdmFyIGNsb3NpbmdUYWdQYXR0ZXJuID0gL14oW2EtekEtWl17MSx9Oj9bYS16QS1aMC05XFwtXSopXFxzKlxcPi87XG4gIGZ1bmN0aW9uIHJlYWRDbG9zaW5nVGFnKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgdGFnO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0Ly8gYXJlIHdlIGxvb2tpbmcgYXQgYSBjbG9zaW5nIHRhZz9cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIjwvXCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAodGFnID0gcGFyc2VyLm1hdGNoUGF0dGVybihjbG9zaW5nVGFnUGF0dGVybikpIHtcbiAgXHRcdGlmIChwYXJzZXIuaW5zaWRlICYmIHRhZyAhPT0gcGFyc2VyLmluc2lkZSkge1xuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBDTE9TSU5HX1RBRyxcbiAgXHRcdFx0ZTogdGFnXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdC8vIFdlIGhhdmUgYW4gaWxsZWdhbCBjbG9zaW5nIHRhZywgcmVwb3J0IGl0XG4gIFx0cGFyc2VyLnBvcyAtPSAyO1xuICBcdHBhcnNlci5lcnJvcihcIklsbGVnYWwgY2xvc2luZyB0YWdcIik7XG4gIH1cblxuICB2YXIgZ2V0TG93ZXN0SW5kZXggPSBmdW5jdGlvbiAoaGF5c3RhY2ssIG5lZWRsZXMpIHtcbiAgXHR2YXIgaSwgaW5kZXgsIGxvd2VzdDtcblxuICBcdGkgPSBuZWVkbGVzLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpbmRleCA9IGhheXN0YWNrLmluZGV4T2YobmVlZGxlc1tpXSk7XG5cbiAgXHRcdC8vIHNob3J0IGNpcmN1aXRcbiAgXHRcdGlmICghaW5kZXgpIHtcbiAgXHRcdFx0cmV0dXJuIDA7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0Y29udGludWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghbG93ZXN0IHx8IGluZGV4IDwgbG93ZXN0KSB7XG4gIFx0XHRcdGxvd2VzdCA9IGluZGV4O1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBsb3dlc3QgfHwgLTE7XG4gIH07XG5cbiAgdmFyIGVsZW1lbnRfcmVhZEF0dHJpYnV0ZSA9IHJlYWRBdHRyaWJ1dGU7XG5cbiAgdmFyIGF0dHJpYnV0ZU5hbWVQYXR0ZXJuID0gL15bXlxcc1wiJz5cXC89XSsvLFxuICAgICAgdW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRleHRQYXR0ZXJuID0gL15bXlxcc1wiJz08PmBdKy87XG4gIGZ1bmN0aW9uIHJlYWRBdHRyaWJ1dGUocGFyc2VyKSB7XG4gIFx0dmFyIGF0dHIsIG5hbWUsIHZhbHVlO1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0bmFtZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oYXR0cmlidXRlTmFtZVBhdHRlcm4pO1xuICBcdGlmICghbmFtZSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0YXR0ciA9IHsgbmFtZTogbmFtZSB9O1xuXG4gIFx0dmFsdWUgPSByZWFkQXR0cmlidXRlVmFsdWUocGFyc2VyKTtcbiAgXHRpZiAodmFsdWUgIT0gbnVsbCkge1xuICBcdFx0Ly8gbm90IG51bGwvdW5kZWZpbmVkXG4gIFx0XHRhdHRyLnZhbHVlID0gdmFsdWU7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGF0dHI7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkQXR0cmlidXRlVmFsdWUocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCB2YWx1ZVN0YXJ0LCBzdGFydERlcHRoLCB2YWx1ZTtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIG5leHQgY2hhcmFjdGVyIG11c3QgYmUgYD1gLCBgL2AsIGA+YCBvciB3aGl0ZXNwYWNlXG4gIFx0aWYgKCEvWz1cXC8+XFxzXS8udGVzdChwYXJzZXIubmV4dENoYXIoKSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGA9YCwgYC9gLCBgPmAgb3Igd2hpdGVzcGFjZVwiKTtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIj1cIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdHZhbHVlU3RhcnQgPSBwYXJzZXIucG9zO1xuICBcdHN0YXJ0RGVwdGggPSBwYXJzZXIuc2VjdGlvbkRlcHRoO1xuXG4gIFx0dmFsdWUgPSByZWFkUXVvdGVkQXR0cmlidXRlVmFsdWUocGFyc2VyLCBcIidcIikgfHwgcmVhZFF1b3RlZEF0dHJpYnV0ZVZhbHVlKHBhcnNlciwgXCJcXFwiXCIpIHx8IHJlYWRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlKHBhcnNlcik7XG5cbiAgXHRpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIHZhbGlkIGF0dHJpYnV0ZSB2YWx1ZVwiKTtcbiAgXHR9XG5cbiAgXHRpZiAocGFyc2VyLnNlY3Rpb25EZXB0aCAhPT0gc3RhcnREZXB0aCkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHZhbHVlU3RhcnQ7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJBbiBhdHRyaWJ1dGUgdmFsdWUgbXVzdCBjb250YWluIGFzIG1hbnkgb3BlbmluZyBzZWN0aW9uIHRhZ3MgYXMgY2xvc2luZyBzZWN0aW9uIHRhZ3NcIik7XG4gIFx0fVxuXG4gIFx0aWYgKCF2YWx1ZS5sZW5ndGgpIHtcbiAgXHRcdHJldHVybiBcIlwiO1xuICBcdH1cblxuICBcdGlmICh2YWx1ZS5sZW5ndGggPT09IDEgJiYgdHlwZW9mIHZhbHVlWzBdID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRyZXR1cm4gZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyh2YWx1ZVswXSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFVucXVvdGVkQXR0cmlidXRlVmFsdWVUb2tlbihwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIHRleHQsIGhheXN0YWNrLCBuZWVkbGVzLCBpbmRleDtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdHRleHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHVucXVvdGVkQXR0cmlidXRlVmFsdWVUZXh0UGF0dGVybik7XG5cbiAgXHRpZiAoIXRleHQpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGhheXN0YWNrID0gdGV4dDtcbiAgXHRuZWVkbGVzID0gcGFyc2VyLnRhZ3MubWFwKGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRyZXR1cm4gdC5vcGVuO1xuICBcdH0pOyAvLyBUT0RPIHJlZmFjdG9yLi4uIHdlIGRvIHRoaXMgaW4gcmVhZFRleHQuanMgYXMgd2VsbFxuXG4gIFx0aWYgKChpbmRleCA9IGdldExvd2VzdEluZGV4KGhheXN0YWNrLCBuZWVkbGVzKSkgIT09IC0xKSB7XG4gIFx0XHR0ZXh0ID0gdGV4dC5zdWJzdHIoMCwgaW5kZXgpO1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0ICsgdGV4dC5sZW5ndGg7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRleHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZShwYXJzZXIpIHtcbiAgXHR2YXIgdG9rZW5zLCB0b2tlbjtcblxuICBcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IHRydWU7XG5cbiAgXHR0b2tlbnMgPSBbXTtcblxuICBcdHRva2VuID0gY29udmVydGVyc19yZWFkTXVzdGFjaGUocGFyc2VyKSB8fCByZWFkVW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRva2VuKHBhcnNlcik7XG4gIFx0d2hpbGUgKHRva2VuICE9PSBudWxsKSB7XG4gIFx0XHR0b2tlbnMucHVzaCh0b2tlbik7XG4gIFx0XHR0b2tlbiA9IGNvbnZlcnRlcnNfcmVhZE11c3RhY2hlKHBhcnNlcikgfHwgcmVhZFVucXVvdGVkQXR0cmlidXRlVmFsdWVUb2tlbihwYXJzZXIpO1xuICBcdH1cblxuICBcdGlmICghdG9rZW5zLmxlbmd0aCkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmluQXR0cmlidXRlID0gZmFsc2U7XG4gIFx0cmV0dXJuIHRva2VucztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRRdW90ZWRBdHRyaWJ1dGVWYWx1ZShwYXJzZXIsIHF1b3RlTWFyaykge1xuICBcdHZhciBzdGFydCwgdG9rZW5zLCB0b2tlbjtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHF1b3RlTWFyaykpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IHF1b3RlTWFyaztcblxuICBcdHRva2VucyA9IFtdO1xuXG4gIFx0dG9rZW4gPSBjb252ZXJ0ZXJzX3JlYWRNdXN0YWNoZShwYXJzZXIpIHx8IHJlYWRRdW90ZWRTdHJpbmdUb2tlbihwYXJzZXIsIHF1b3RlTWFyayk7XG4gIFx0d2hpbGUgKHRva2VuICE9PSBudWxsKSB7XG4gIFx0XHR0b2tlbnMucHVzaCh0b2tlbik7XG4gIFx0XHR0b2tlbiA9IGNvbnZlcnRlcnNfcmVhZE11c3RhY2hlKHBhcnNlcikgfHwgcmVhZFF1b3RlZFN0cmluZ1Rva2VuKHBhcnNlciwgcXVvdGVNYXJrKTtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhxdW90ZU1hcmspKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuaW5BdHRyaWJ1dGUgPSBmYWxzZTtcblxuICBcdHJldHVybiB0b2tlbnM7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkUXVvdGVkU3RyaW5nVG9rZW4ocGFyc2VyLCBxdW90ZU1hcmspIHtcbiAgXHR2YXIgc3RhcnQsIGluZGV4LCBoYXlzdGFjaywgbmVlZGxlcztcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcbiAgXHRoYXlzdGFjayA9IHBhcnNlci5yZW1haW5pbmcoKTtcblxuICBcdG5lZWRsZXMgPSBwYXJzZXIudGFncy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgXHRcdHJldHVybiB0Lm9wZW47XG4gIFx0fSk7IC8vIFRPRE8gcmVmYWN0b3IuLi4gd2UgZG8gdGhpcyBpbiByZWFkVGV4dC5qcyBhcyB3ZWxsXG4gIFx0bmVlZGxlcy5wdXNoKHF1b3RlTWFyayk7XG5cbiAgXHRpbmRleCA9IGdldExvd2VzdEluZGV4KGhheXN0YWNrLCBuZWVkbGVzKTtcblxuICBcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIlF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUgbXVzdCBoYXZlIGEgY2xvc2luZyBxdW90ZVwiKTtcbiAgXHR9XG5cbiAgXHRpZiAoIWluZGV4KSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIucG9zICs9IGluZGV4O1xuICBcdHJldHVybiBoYXlzdGFjay5zdWJzdHIoMCwgaW5kZXgpO1xuICB9XG5cbiAgdmFyIEpzb25QYXJzZXIsIHNwZWNpYWxzLCBzcGVjaWFsc1BhdHRlcm4sIHBhcnNlSlNPTl9fbnVtYmVyUGF0dGVybiwgcGxhY2Vob2xkZXJQYXR0ZXJuLCBwbGFjZWhvbGRlckF0U3RhcnRQYXR0ZXJuLCBvbmx5V2hpdGVzcGFjZTtcblxuICBzcGVjaWFscyA9IHtcbiAgXHRcInRydWVcIjogdHJ1ZSxcbiAgXHRcImZhbHNlXCI6IGZhbHNlLFxuICBcdHVuZGVmaW5lZDogdW5kZWZpbmVkLFxuICBcdFwibnVsbFwiOiBudWxsXG4gIH07XG5cbiAgc3BlY2lhbHNQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIl4oPzpcIiArIE9iamVjdC5rZXlzKHNwZWNpYWxzKS5qb2luKFwifFwiKSArIFwiKVwiKTtcbiAgcGFyc2VKU09OX19udW1iZXJQYXR0ZXJuID0gL14oPzpbKy1dPykoPzooPzooPzowfFsxLTldXFxkKik/XFwuXFxkKyl8KD86KD86MHxbMS05XVxcZCopXFwuKXwoPzowfFsxLTldXFxkKikpKD86W2VFXVsrLV0/XFxkKyk/LztcbiAgcGxhY2Vob2xkZXJQYXR0ZXJuID0gL1xcJFxceyhbXlxcfV0rKVxcfS9nO1xuICBwbGFjZWhvbGRlckF0U3RhcnRQYXR0ZXJuID0gL15cXCRcXHsoW15cXH1dKylcXH0vO1xuICBvbmx5V2hpdGVzcGFjZSA9IC9eXFxzKiQvO1xuXG4gIEpzb25QYXJzZXIgPSBwYXJzZV9QYXJzZXIuZXh0ZW5kKHtcbiAgXHRpbml0OiBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG4gIFx0XHR0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuICBcdFx0dGhpcy5hbGxvd1doaXRlc3BhY2UoKTtcbiAgXHR9LFxuXG4gIFx0cG9zdFByb2Nlc3M6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgXHRcdGlmIChyZXN1bHQubGVuZ3RoICE9PSAxIHx8ICFvbmx5V2hpdGVzcGFjZS50ZXN0KHRoaXMubGVmdG92ZXIpKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4geyB2YWx1ZTogcmVzdWx0WzBdLnYgfTtcbiAgXHR9LFxuXG4gIFx0Y29udmVydGVyczogW2Z1bmN0aW9uIGdldFBsYWNlaG9sZGVyKHBhcnNlcikge1xuICBcdFx0dmFyIHBsYWNlaG9sZGVyO1xuXG4gIFx0XHRpZiAoIXBhcnNlci52YWx1ZXMpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHBsYWNlaG9sZGVyID0gcGFyc2VyLm1hdGNoUGF0dGVybihwbGFjZWhvbGRlckF0U3RhcnRQYXR0ZXJuKTtcblxuICBcdFx0aWYgKHBsYWNlaG9sZGVyICYmIHBhcnNlci52YWx1ZXMuaGFzT3duUHJvcGVydHkocGxhY2Vob2xkZXIpKSB7XG4gIFx0XHRcdHJldHVybiB7IHY6IHBhcnNlci52YWx1ZXNbcGxhY2Vob2xkZXJdIH07XG4gIFx0XHR9XG4gIFx0fSwgZnVuY3Rpb24gZ2V0U3BlY2lhbChwYXJzZXIpIHtcbiAgXHRcdHZhciBzcGVjaWFsO1xuXG4gIFx0XHRpZiAoc3BlY2lhbCA9IHBhcnNlci5tYXRjaFBhdHRlcm4oc3BlY2lhbHNQYXR0ZXJuKSkge1xuICBcdFx0XHRyZXR1cm4geyB2OiBzcGVjaWFsc1tzcGVjaWFsXSB9O1xuICBcdFx0fVxuICBcdH0sIGZ1bmN0aW9uIGdldE51bWJlcihwYXJzZXIpIHtcbiAgXHRcdHZhciBudW1iZXI7XG5cbiAgXHRcdGlmIChudW1iZXIgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHBhcnNlSlNPTl9fbnVtYmVyUGF0dGVybikpIHtcbiAgXHRcdFx0cmV0dXJuIHsgdjogK251bWJlciB9O1xuICBcdFx0fVxuICBcdH0sIGZ1bmN0aW9uIGdldFN0cmluZyhwYXJzZXIpIHtcbiAgXHRcdHZhciBzdHJpbmdMaXRlcmFsID0gcmVhZFN0cmluZ0xpdGVyYWwocGFyc2VyKSxcbiAgXHRcdCAgICB2YWx1ZXM7XG5cbiAgXHRcdGlmIChzdHJpbmdMaXRlcmFsICYmICh2YWx1ZXMgPSBwYXJzZXIudmFsdWVzKSkge1xuICBcdFx0XHRyZXR1cm4ge1xuICBcdFx0XHRcdHY6IHN0cmluZ0xpdGVyYWwudi5yZXBsYWNlKHBsYWNlaG9sZGVyUGF0dGVybiwgZnVuY3Rpb24gKG1hdGNoLCAkMSkge1xuICBcdFx0XHRcdFx0cmV0dXJuICQxIGluIHZhbHVlcyA/IHZhbHVlc1skMV0gOiAkMTtcbiAgXHRcdFx0XHR9KVxuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gc3RyaW5nTGl0ZXJhbDtcbiAgXHR9LCBmdW5jdGlvbiBnZXRPYmplY3QocGFyc2VyKSB7XG4gIFx0XHR2YXIgcmVzdWx0LCBwYWlyO1xuXG4gIFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIntcIikpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJlc3VsdCA9IHt9O1xuXG4gIFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJ9XCIpKSB7XG4gIFx0XHRcdHJldHVybiB7IHY6IHJlc3VsdCB9O1xuICBcdFx0fVxuXG4gIFx0XHR3aGlsZSAocGFpciA9IGdldEtleVZhbHVlUGFpcihwYXJzZXIpKSB7XG4gIFx0XHRcdHJlc3VsdFtwYWlyLmtleV0gPSBwYWlyLnZhbHVlO1xuXG4gIFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0XHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwifVwiKSkge1xuICBcdFx0XHRcdHJldHVybiB7IHY6IHJlc3VsdCB9O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCIsXCIpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fSwgZnVuY3Rpb24gZ2V0QXJyYXkocGFyc2VyKSB7XG4gIFx0XHR2YXIgcmVzdWx0LCB2YWx1ZVRva2VuO1xuXG4gIFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIltcIikpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJlc3VsdCA9IFtdO1xuXG4gIFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJdXCIpKSB7XG4gIFx0XHRcdHJldHVybiB7IHY6IHJlc3VsdCB9O1xuICBcdFx0fVxuXG4gIFx0XHR3aGlsZSAodmFsdWVUb2tlbiA9IHBhcnNlci5yZWFkKCkpIHtcbiAgXHRcdFx0cmVzdWx0LnB1c2godmFsdWVUb2tlbi52KTtcblxuICBcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIl1cIikpIHtcbiAgXHRcdFx0XHRyZXR1cm4geyB2OiByZXN1bHQgfTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiLFwiKSkge1xuICBcdFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XVxuICB9KTtcblxuICBmdW5jdGlvbiBnZXRLZXlWYWx1ZVBhaXIocGFyc2VyKSB7XG4gIFx0dmFyIGtleSwgdmFsdWVUb2tlbiwgcGFpcjtcblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGtleSA9IHNoYXJlZF9yZWFkS2V5KHBhcnNlcik7XG5cbiAgXHRpZiAoIWtleSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFpciA9IHsga2V5OiBrZXkgfTtcblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIjpcIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHR2YWx1ZVRva2VuID0gcGFyc2VyLnJlYWQoKTtcbiAgXHRpZiAoIXZhbHVlVG9rZW4pIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhaXIudmFsdWUgPSB2YWx1ZVRva2VuLnY7XG5cbiAgXHRyZXR1cm4gcGFpcjtcbiAgfVxuXG4gIHZhciBwYXJzZUpTT04gPSBmdW5jdGlvbiAoc3RyLCB2YWx1ZXMpIHtcbiAgXHR2YXIgcGFyc2VyID0gbmV3IEpzb25QYXJzZXIoc3RyLCB7XG4gIFx0XHR2YWx1ZXM6IHZhbHVlc1xuICBcdH0pO1xuXG4gIFx0cmV0dXJuIHBhcnNlci5yZXN1bHQ7XG4gIH07XG5cbiAgLy8gVE9ETyBjbGVhbiB0aGlzIHVwLCBpdCdzIHNob2NraW5nXG4gIHZhciBlbGVtZW50X3Byb2Nlc3NEaXJlY3RpdmUgPSBwcm9jZXNzRGlyZWN0aXZlO1xuICB2YXIgbWV0aG9kQ2FsbFBhdHRlcm4gPSAvXihbYS16QS1aXyRdW2EtekEtWl8kMC05XSopXFwoLyxcbiAgICAgIG1ldGhvZENhbGxFeGNlc3NQYXR0ZXJuID0gL1xcKVxccyokLyxcbiAgICAgIEV4cHJlc3Npb25QYXJzZXI7XG5cbiAgRXhwcmVzc2lvblBhcnNlciA9IHBhcnNlX1BhcnNlci5leHRlbmQoe1xuICBcdGNvbnZlcnRlcnM6IFtjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uXVxuICB9KTtcbiAgZnVuY3Rpb24gcHJvY2Vzc0RpcmVjdGl2ZSh0b2tlbnMsIHBhcmVudFBhcnNlcikge1xuICBcdHZhciByZXN1bHQsIG1hdGNoLCBwYXJzZXIsIGFyZ3MsIHRva2VuLCBjb2xvbkluZGV4LCBkaXJlY3RpdmVOYW1lLCBkaXJlY3RpdmVBcmdzLCBwYXJzZWQ7XG5cbiAgXHRpZiAodHlwZW9mIHRva2VucyA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0aWYgKG1hdGNoID0gbWV0aG9kQ2FsbFBhdHRlcm4uZXhlYyh0b2tlbnMpKSB7XG4gIFx0XHRcdHZhciBlbmQgPSB0b2tlbnMubGFzdEluZGV4T2YoXCIpXCIpO1xuXG4gIFx0XHRcdC8vIGNoZWNrIGZvciBpbnZhbGlkIG1ldGhvZCBjYWxsc1xuICBcdFx0XHRpZiAoIW1ldGhvZENhbGxFeGNlc3NQYXR0ZXJuLnRlc3QodG9rZW5zKSkge1xuICBcdFx0XHRcdHBhcmVudFBhcnNlci5lcnJvcihcIkludmFsaWQgaW5wdXQgYWZ0ZXIgbWV0aG9kIGNhbGwgZXhwcmVzc2lvbiAnXCIgKyB0b2tlbnMuc2xpY2UoZW5kICsgMSkgKyBcIidcIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXN1bHQgPSB7IG06IG1hdGNoWzFdIH07XG4gIFx0XHRcdGFyZ3MgPSBcIltcIiArIHRva2Vucy5zbGljZShyZXN1bHQubS5sZW5ndGggKyAxLCBlbmQpICsgXCJdXCI7XG5cbiAgXHRcdFx0cGFyc2VyID0gbmV3IEV4cHJlc3Npb25QYXJzZXIoYXJncyk7XG4gIFx0XHRcdHJlc3VsdC5hID0gdXRpbHNfZmxhdHRlbkV4cHJlc3Npb24ocGFyc2VyLnJlc3VsdFswXSk7XG5cbiAgXHRcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRva2Vucy5pbmRleE9mKFwiOlwiKSA9PT0gLTEpIHtcbiAgXHRcdFx0cmV0dXJuIHRva2Vucy50cmltKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRva2VucyA9IFt0b2tlbnNdO1xuICBcdH1cblxuICBcdHJlc3VsdCA9IHt9O1xuXG4gIFx0ZGlyZWN0aXZlTmFtZSA9IFtdO1xuICBcdGRpcmVjdGl2ZUFyZ3MgPSBbXTtcblxuICBcdGlmICh0b2tlbnMpIHtcbiAgXHRcdHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gIFx0XHRcdHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG5cbiAgXHRcdFx0aWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRcdGNvbG9uSW5kZXggPSB0b2tlbi5pbmRleE9mKFwiOlwiKTtcblxuICBcdFx0XHRcdGlmIChjb2xvbkluZGV4ID09PSAtMSkge1xuICBcdFx0XHRcdFx0ZGlyZWN0aXZlTmFtZS5wdXNoKHRva2VuKTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gIFx0XHRcdFx0XHQvLyBpcyB0aGUgY29sb24gdGhlIGZpcnN0IGNoYXJhY3Rlcj9cbiAgXHRcdFx0XHRcdGlmIChjb2xvbkluZGV4KSB7XG4gIFx0XHRcdFx0XHRcdC8vIG5vXG4gIFx0XHRcdFx0XHRcdGRpcmVjdGl2ZU5hbWUucHVzaCh0b2tlbi5zdWJzdHIoMCwgY29sb25JbmRleCkpO1xuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHQvLyBpZiB0aGVyZSBpcyBhbnl0aGluZyBhZnRlciB0aGUgY29sb24gaW4gdGhpcyB0b2tlbiwgdHJlYXRcbiAgXHRcdFx0XHRcdC8vIGl0IGFzIHRoZSBmaXJzdCB0b2tlbiBvZiB0aGUgZGlyZWN0aXZlQXJncyBmcmFnbWVudFxuICBcdFx0XHRcdFx0aWYgKHRva2VuLmxlbmd0aCA+IGNvbG9uSW5kZXggKyAxKSB7XG4gIFx0XHRcdFx0XHRcdGRpcmVjdGl2ZUFyZ3NbMF0gPSB0b2tlbi5zdWJzdHJpbmcoY29sb25JbmRleCArIDEpO1xuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHRicmVhaztcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0ZGlyZWN0aXZlTmFtZS5wdXNoKHRva2VuKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRkaXJlY3RpdmVBcmdzID0gZGlyZWN0aXZlQXJncy5jb25jYXQodG9rZW5zKTtcbiAgXHR9XG5cbiAgXHRpZiAoIWRpcmVjdGl2ZU5hbWUubGVuZ3RoKSB7XG4gIFx0XHRyZXN1bHQgPSBcIlwiO1xuICBcdH0gZWxzZSBpZiAoZGlyZWN0aXZlQXJncy5sZW5ndGggfHwgdHlwZW9mIGRpcmVjdGl2ZU5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHJlc3VsdCA9IHtcbiAgXHRcdFx0Ly8gVE9ETyBpcyB0aGlzIHJlYWxseSBuZWNlc3Nhcnk/IGp1c3QgdXNlIHRoZSBhcnJheVxuICBcdFx0XHRuOiBkaXJlY3RpdmVOYW1lLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZGlyZWN0aXZlTmFtZVswXSA9PT0gXCJzdHJpbmdcIiA/IGRpcmVjdGl2ZU5hbWVbMF0gOiBkaXJlY3RpdmVOYW1lXG4gIFx0XHR9O1xuXG4gIFx0XHRpZiAoZGlyZWN0aXZlQXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGRpcmVjdGl2ZUFyZ3NbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0cGFyc2VkID0gcGFyc2VKU09OKFwiW1wiICsgZGlyZWN0aXZlQXJnc1swXSArIFwiXVwiKTtcbiAgXHRcdFx0cmVzdWx0LmEgPSBwYXJzZWQgPyBwYXJzZWQudmFsdWUgOiBkaXJlY3RpdmVBcmdzWzBdLnRyaW0oKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJlc3VsdC5kID0gZGlyZWN0aXZlQXJncztcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0cmVzdWx0ID0gZGlyZWN0aXZlTmFtZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIHRhZ05hbWVQYXR0ZXJuID0gL15bYS16QS1aXXsxLH06P1thLXpBLVowLTlcXC1dKi8sXG4gICAgICB2YWxpZFRhZ05hbWVGb2xsb3dlciA9IC9eW1xcc1xcblxcLz5dLyxcbiAgICAgIG9uUGF0dGVybiA9IC9eb24vLFxuICAgICAgcHJveHlFdmVudFBhdHRlcm4gPSAvXm9uLShbYS16QS1aXFxcXCpcXFxcLiRfXVthLXpBLVpcXFxcKlxcXFwuJF8wLTlcXC1dKykkLyxcbiAgICAgIHJlc2VydmVkRXZlbnROYW1lcyA9IC9eKD86Y2hhbmdlfHJlc2V0fHRlYXJkb3dufHVwZGF0ZXxjb25zdHJ1Y3R8Y29uZmlnfGluaXR8cmVuZGVyfHVucmVuZGVyfGRldGFjaHxpbnNlcnQpJC8sXG4gICAgICBkaXJlY3RpdmVzID0geyBcImludHJvLW91dHJvXCI6IFwidDBcIiwgaW50cm86IFwidDFcIiwgb3V0cm86IFwidDJcIiwgZGVjb3JhdG9yOiBcIm9cIiB9LFxuICAgICAgZXhjbHVkZSA9IHsgZXhjbHVkZTogdHJ1ZSB9LFxuICAgICAgZGlzYWxsb3dlZENvbnRlbnRzO1xuXG4gIC8vIGJhc2VkIG9uIGh0dHA6Ly9kZXZlbG9wZXJzLndoYXR3Zy5vcmcvc3ludGF4Lmh0bWwjc3ludGF4LXRhZy1vbWlzc2lvblxuICBkaXNhbGxvd2VkQ29udGVudHMgPSB7XG4gIFx0bGk6IFtcImxpXCJdLFxuICBcdGR0OiBbXCJkdFwiLCBcImRkXCJdLFxuICBcdGRkOiBbXCJkdFwiLCBcImRkXCJdLFxuICBcdHA6IFwiYWRkcmVzcyBhcnRpY2xlIGFzaWRlIGJsb2NrcXVvdGUgZGl2IGRsIGZpZWxkc2V0IGZvb3RlciBmb3JtIGgxIGgyIGgzIGg0IGg1IGg2IGhlYWRlciBoZ3JvdXAgaHIgbWFpbiBtZW51IG5hdiBvbCBwIHByZSBzZWN0aW9uIHRhYmxlIHVsXCIuc3BsaXQoXCIgXCIpLFxuICBcdHJ0OiBbXCJydFwiLCBcInJwXCJdLFxuICBcdHJwOiBbXCJydFwiLCBcInJwXCJdLFxuICBcdG9wdGdyb3VwOiBbXCJvcHRncm91cFwiXSxcbiAgXHRvcHRpb246IFtcIm9wdGlvblwiLCBcIm9wdGdyb3VwXCJdLFxuICBcdHRoZWFkOiBbXCJ0Ym9keVwiLCBcInRmb290XCJdLFxuICBcdHRib2R5OiBbXCJ0Ym9keVwiLCBcInRmb290XCJdLFxuICBcdHRmb290OiBbXCJ0Ym9keVwiXSxcbiAgXHR0cjogW1widHJcIiwgXCJ0Ym9keVwiXSxcbiAgXHR0ZDogW1widGRcIiwgXCJ0aFwiLCBcInRyXCJdLFxuICBcdHRoOiBbXCJ0ZFwiLCBcInRoXCIsIFwidHJcIl1cbiAgfTtcblxuICB2YXIgY29udmVydGVyc19yZWFkRWxlbWVudCA9IHJlYWRFbGVtZW50O1xuXG4gIGZ1bmN0aW9uIHJlYWRFbGVtZW50KHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgZWxlbWVudCwgZGlyZWN0aXZlTmFtZSwgbWF0Y2gsIGFkZFByb3h5RXZlbnQsIGF0dHJpYnV0ZSwgZGlyZWN0aXZlLCBzZWxmQ2xvc2luZywgY2hpbGRyZW4sIHBhcnRpYWxzLCBoYXNQYXJ0aWFscywgY2hpbGQsIGNsb3NlZCwgcG9zLCByZW1haW5pbmcsIGNsb3NpbmdUYWc7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAocGFyc2VyLmluc2lkZSB8fCBwYXJzZXIuaW5BdHRyaWJ1dGUpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiPFwiKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gaWYgdGhpcyBpcyBhIGNsb3NpbmcgdGFnLCBhYm9ydCBzdHJhaWdodCBhd2F5XG4gIFx0aWYgKHBhcnNlci5uZXh0Q2hhcigpID09PSBcIi9cIikge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0ZWxlbWVudCA9IHt9O1xuICBcdGlmIChwYXJzZXIuaW5jbHVkZUxpbmVQb3NpdGlvbnMpIHtcbiAgXHRcdGVsZW1lbnQucCA9IHBhcnNlci5nZXRMaW5lUG9zKHN0YXJ0KTtcbiAgXHR9XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiIVwiKSkge1xuICBcdFx0ZWxlbWVudC50ID0gRE9DVFlQRTtcbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoUGF0dGVybigvXmRvY3R5cGUvaSkpIHtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgRE9DVFlQRSBkZWNsYXJhdGlvblwiKTtcbiAgXHRcdH1cblxuICBcdFx0ZWxlbWVudC5hID0gcGFyc2VyLm1hdGNoUGF0dGVybigvXiguKz8pPi8pO1xuICBcdFx0cmV0dXJuIGVsZW1lbnQ7XG4gIFx0fVxuXG4gIFx0ZWxlbWVudC50ID0gRUxFTUVOVDtcblxuICBcdC8vIGVsZW1lbnQgbmFtZVxuICBcdGVsZW1lbnQuZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4odGFnTmFtZVBhdHRlcm4pO1xuICBcdGlmICghZWxlbWVudC5lKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBuZXh0IGNoYXJhY3RlciBtdXN0IGJlIHdoaXRlc3BhY2UsIGNsb3Npbmcgc29saWR1cyBvciAnPidcbiAgXHRpZiAoIXZhbGlkVGFnTmFtZUZvbGxvd2VyLnRlc3QocGFyc2VyLm5leHRDaGFyKCkpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJJbGxlZ2FsIHRhZyBuYW1lXCIpO1xuICBcdH1cblxuICBcdGFkZFByb3h5RXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZGlyZWN0aXZlKSB7XG4gIFx0XHR2YXIgZGlyZWN0aXZlTmFtZSA9IGRpcmVjdGl2ZS5uIHx8IGRpcmVjdGl2ZTtcblxuICBcdFx0aWYgKHJlc2VydmVkRXZlbnROYW1lcy50ZXN0KGRpcmVjdGl2ZU5hbWUpKSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgLT0gZGlyZWN0aXZlTmFtZS5sZW5ndGg7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihcIkNhbm5vdCB1c2UgcmVzZXJ2ZWQgZXZlbnQgbmFtZXMgKGNoYW5nZSwgcmVzZXQsIHRlYXJkb3duLCB1cGRhdGUsIGNvbnN0cnVjdCwgY29uZmlnLCBpbml0LCByZW5kZXIsIHVucmVuZGVyLCBkZXRhY2gsIGluc2VydClcIik7XG4gIFx0XHR9XG5cbiAgXHRcdGVsZW1lbnQudltuYW1lXSA9IGRpcmVjdGl2ZTtcbiAgXHR9O1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0Ly8gZGlyZWN0aXZlcyBhbmQgYXR0cmlidXRlc1xuICBcdHdoaWxlIChhdHRyaWJ1dGUgPSBjb252ZXJ0ZXJzX3JlYWRNdXN0YWNoZShwYXJzZXIpIHx8IGVsZW1lbnRfcmVhZEF0dHJpYnV0ZShwYXJzZXIpKSB7XG4gIFx0XHQvLyByZWd1bGFyIGF0dHJpYnV0ZXNcbiAgXHRcdGlmIChhdHRyaWJ1dGUubmFtZSkge1xuICBcdFx0XHQvLyBpbnRybywgb3V0cm8sIGRlY29yYXRvclxuICBcdFx0XHRpZiAoZGlyZWN0aXZlTmFtZSA9IGRpcmVjdGl2ZXNbYXR0cmlidXRlLm5hbWVdKSB7XG4gIFx0XHRcdFx0ZWxlbWVudFtkaXJlY3RpdmVOYW1lXSA9IGVsZW1lbnRfcHJvY2Vzc0RpcmVjdGl2ZShhdHRyaWJ1dGUudmFsdWUsIHBhcnNlcik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBvbi1jbGljayBldGNcbiAgXHRcdFx0ZWxzZSBpZiAobWF0Y2ggPSBwcm94eUV2ZW50UGF0dGVybi5leGVjKGF0dHJpYnV0ZS5uYW1lKSkge1xuICBcdFx0XHRcdGlmICghZWxlbWVudC52KSBlbGVtZW50LnYgPSB7fTtcbiAgXHRcdFx0XHRkaXJlY3RpdmUgPSBlbGVtZW50X3Byb2Nlc3NEaXJlY3RpdmUoYXR0cmlidXRlLnZhbHVlLCBwYXJzZXIpO1xuICBcdFx0XHRcdGFkZFByb3h5RXZlbnQobWF0Y2hbMV0sIGRpcmVjdGl2ZSk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0aWYgKCFwYXJzZXIuc2FuaXRpemVFdmVudEF0dHJpYnV0ZXMgfHwgIW9uUGF0dGVybi50ZXN0KGF0dHJpYnV0ZS5uYW1lKSkge1xuICBcdFx0XHRcdFx0aWYgKCFlbGVtZW50LmEpIGVsZW1lbnQuYSA9IHt9O1xuICBcdFx0XHRcdFx0ZWxlbWVudC5hW2F0dHJpYnV0ZS5uYW1lXSA9IGF0dHJpYnV0ZS52YWx1ZSB8fCAoYXR0cmlidXRlLnZhbHVlID09PSBcIlwiID8gXCJcIiA6IDApO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyB7eyNpZiBmb299fWNsYXNzPSdmb28ne3svaWZ9fVxuICBcdFx0ZWxzZSB7XG4gIFx0XHRcdGlmICghZWxlbWVudC5tKSBlbGVtZW50Lm0gPSBbXTtcbiAgXHRcdFx0ZWxlbWVudC5tLnB1c2goYXR0cmlidXRlKTtcbiAgXHRcdH1cblxuICBcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdH1cblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlIGNsb3Npbmcgc29saWR1c1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdC8vIHNlbGYtY2xvc2luZyBzb2xpZHVzP1xuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIvXCIpKSB7XG4gIFx0XHRzZWxmQ2xvc2luZyA9IHRydWU7XG4gIFx0fVxuXG4gIFx0Ly8gY2xvc2luZyBhbmdsZSBicmFja2V0XG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI+XCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHR2YXIgbG93ZXJDYXNlTmFtZSA9IGVsZW1lbnQuZS50b0xvd2VyQ2FzZSgpO1xuICBcdHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBwYXJzZXIucHJlc2VydmVXaGl0ZXNwYWNlO1xuXG4gIFx0aWYgKCFzZWxmQ2xvc2luZyAmJiAhdm9pZEVsZW1lbnROYW1lcy50ZXN0KGVsZW1lbnQuZSkpIHtcbiAgXHRcdHBhcnNlci5lbGVtZW50U3RhY2sucHVzaChsb3dlckNhc2VOYW1lKTtcblxuICBcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gaWYgd2Ugb3BlbiBhIHNjcmlwdCBlbGVtZW50LCBmdXJ0aGVyIHRhZ3Mgc2hvdWxkXG4gIFx0XHQvLyBiZSBpZ25vcmVkIHVubGVzcyB0aGV5J3JlIGEgY2xvc2luZyBzY3JpcHQgZWxlbWVudFxuICBcdFx0aWYgKGxvd2VyQ2FzZU5hbWUgPT09IFwic2NyaXB0XCIgfHwgbG93ZXJDYXNlTmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gIFx0XHRcdHBhcnNlci5pbnNpZGUgPSBsb3dlckNhc2VOYW1lO1xuICBcdFx0fVxuXG4gIFx0XHRjaGlsZHJlbiA9IFtdO1xuICBcdFx0cGFydGlhbHMgPSBjcmVhdGUobnVsbCk7XG5cbiAgXHRcdGRvIHtcbiAgXHRcdFx0cG9zID0gcGFyc2VyLnBvcztcbiAgXHRcdFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXG4gIFx0XHRcdC8vIGlmIGZvciBleGFtcGxlIHdlJ3JlIGluIGFuIDxsaT4gZWxlbWVudCwgYW5kIHdlIHNlZSBhbm90aGVyXG4gIFx0XHRcdC8vIDxsaT4gdGFnLCBjbG9zZSB0aGUgZmlyc3Qgc28gdGhleSBiZWNvbWUgc2libGluZ3NcbiAgXHRcdFx0aWYgKCFjYW5Db250YWluKGxvd2VyQ2FzZU5hbWUsIHJlbWFpbmluZykpIHtcbiAgXHRcdFx0XHRjbG9zZWQgPSB0cnVlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gY2xvc2luZyB0YWdcbiAgXHRcdFx0ZWxzZSBpZiAoY2xvc2luZ1RhZyA9IGVsZW1lbnRfcmVhZENsb3NpbmdUYWcocGFyc2VyKSkge1xuICBcdFx0XHRcdGNsb3NlZCA9IHRydWU7XG5cbiAgXHRcdFx0XHR2YXIgY2xvc2luZ1RhZ05hbWUgPSBjbG9zaW5nVGFnLmUudG9Mb3dlckNhc2UoKTtcblxuICBcdFx0XHRcdC8vIGlmIHRoaXMgKmlzbid0KiB0aGUgY2xvc2luZyB0YWcgZm9yIHRoZSBjdXJyZW50IGVsZW1lbnQuLi5cbiAgXHRcdFx0XHRpZiAoY2xvc2luZ1RhZ05hbWUgIT09IGxvd2VyQ2FzZU5hbWUpIHtcbiAgXHRcdFx0XHRcdC8vIHJld2luZCBwYXJzZXJcbiAgXHRcdFx0XHRcdHBhcnNlci5wb3MgPSBwb3M7XG5cbiAgXHRcdFx0XHRcdC8vIGlmIGl0IGRvZXNuJ3QgY2xvc2UgYSBwYXJlbnQgdGFnLCBlcnJvclxuICBcdFx0XHRcdFx0aWYgKCEgfnBhcnNlci5lbGVtZW50U3RhY2suaW5kZXhPZihjbG9zaW5nVGFnTmFtZSkpIHtcbiAgXHRcdFx0XHRcdFx0dmFyIGVycm9yTWVzc2FnZSA9IFwiVW5leHBlY3RlZCBjbG9zaW5nIHRhZ1wiO1xuXG4gIFx0XHRcdFx0XHRcdC8vIGFkZCBhZGRpdGlvbmFsIGhlbHAgZm9yIHZvaWQgZWxlbWVudHMsIHNpbmNlIGNvbXBvbmVudCBuYW1lc1xuICBcdFx0XHRcdFx0XHQvLyBtaWdodCBjbGFzaCB3aXRoIHRoZW1cbiAgXHRcdFx0XHRcdFx0aWYgKHZvaWRFbGVtZW50TmFtZXMudGVzdChjbG9zaW5nVGFnTmFtZSkpIHtcbiAgXHRcdFx0XHRcdFx0XHRlcnJvck1lc3NhZ2UgKz0gXCIgKDxcIiArIGNsb3NpbmdUYWdOYW1lICsgXCI+IGlzIGEgdm9pZCBlbGVtZW50IC0gaXQgY2Fubm90IGNvbnRhaW4gY2hpbGRyZW4pXCI7XG4gIFx0XHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBpbXBsaWNpdCBjbG9zZSBieSBjbG9zaW5nIHNlY3Rpb24gdGFnLiBUT0RPIGNsZWFuIHRoaXMgdXBcbiAgXHRcdFx0ZWxzZSBpZiAoY2hpbGQgPSBzZWN0aW9uX3JlYWRDbG9zaW5nKHBhcnNlciwgeyBvcGVuOiBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzBdLCBjbG9zZTogcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVyc1sxXSB9KSkge1xuICBcdFx0XHRcdGNsb3NlZCA9IHRydWU7XG4gIFx0XHRcdFx0cGFyc2VyLnBvcyA9IHBvcztcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRpZiAoY2hpbGQgPSBwYXJzZXIucmVhZChQQVJUSUFMX1JFQURFUlMpKSB7XG4gIFx0XHRcdFx0XHRpZiAocGFydGlhbHNbY2hpbGQubl0pIHtcbiAgXHRcdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHBvcztcbiAgXHRcdFx0XHRcdFx0cGFyc2VyLmVycm9yKFwiRHVwbGljYXRlIHBhcnRpYWwgZGVmaW5pdGlvblwiKTtcbiAgXHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0dXRpbHNfY2xlYW51cChjaGlsZC5mLCBwYXJzZXIuc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCAhcHJlc2VydmVXaGl0ZXNwYWNlLCAhcHJlc2VydmVXaGl0ZXNwYWNlKTtcblxuICBcdFx0XHRcdFx0cGFydGlhbHNbY2hpbGQubl0gPSBjaGlsZC5mO1xuICBcdFx0XHRcdFx0aGFzUGFydGlhbHMgPSB0cnVlO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRpZiAoY2hpbGQgPSBwYXJzZXIucmVhZChSRUFERVJTKSkge1xuICBcdFx0XHRcdFx0XHRjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgXHRcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRcdGNsb3NlZCA9IHRydWU7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9IHdoaWxlICghY2xvc2VkKTtcblxuICBcdFx0aWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICBcdFx0XHRlbGVtZW50LmYgPSBjaGlsZHJlbjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGhhc1BhcnRpYWxzKSB7XG4gIFx0XHRcdGVsZW1lbnQucCA9IHBhcnRpYWxzO1xuICBcdFx0fVxuXG4gIFx0XHRwYXJzZXIuZWxlbWVudFN0YWNrLnBvcCgpO1xuICBcdH1cblxuICBcdHBhcnNlci5pbnNpZGUgPSBudWxsO1xuXG4gIFx0aWYgKHBhcnNlci5zYW5pdGl6ZUVsZW1lbnRzICYmIHBhcnNlci5zYW5pdGl6ZUVsZW1lbnRzLmluZGV4T2YobG93ZXJDYXNlTmFtZSkgIT09IC0xKSB7XG4gIFx0XHRyZXR1cm4gZXhjbHVkZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbkNvbnRhaW4obmFtZSwgcmVtYWluaW5nKSB7XG4gIFx0dmFyIG1hdGNoLCBkaXNhbGxvd2VkO1xuXG4gIFx0bWF0Y2ggPSAvXjwoW2EtekEtWl1bYS16QS1aMC05XSopLy5leGVjKHJlbWFpbmluZyk7XG4gIFx0ZGlzYWxsb3dlZCA9IGRpc2FsbG93ZWRDb250ZW50c1tuYW1lXTtcblxuICBcdGlmICghbWF0Y2ggfHwgIWRpc2FsbG93ZWQpIHtcbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cblxuICBcdHJldHVybiAhIH5kaXNhbGxvd2VkLmluZGV4T2YobWF0Y2hbMV0udG9Mb3dlckNhc2UoKSk7XG4gIH1cblxuICB2YXIgY29udmVydGVyc19yZWFkVGV4dCA9IHJlYWRUZXh0O1xuICBmdW5jdGlvbiByZWFkVGV4dChwYXJzZXIpIHtcbiAgXHR2YXIgaW5kZXgsIHJlbWFpbmluZywgZGlzYWxsb3dlZCwgYmFycmllcjtcblxuICBcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblxuICBcdGJhcnJpZXIgPSBwYXJzZXIuaW5zaWRlID8gXCI8L1wiICsgcGFyc2VyLmluc2lkZSA6IFwiPFwiO1xuXG4gIFx0aWYgKHBhcnNlci5pbnNpZGUgJiYgIXBhcnNlci5pbnRlcnBvbGF0ZVtwYXJzZXIuaW5zaWRlXSkge1xuICBcdFx0aW5kZXggPSByZW1haW5pbmcuaW5kZXhPZihiYXJyaWVyKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0ZGlzYWxsb3dlZCA9IHBhcnNlci50YWdzLm1hcChmdW5jdGlvbiAodCkge1xuICBcdFx0XHRyZXR1cm4gdC5vcGVuO1xuICBcdFx0fSk7XG4gIFx0XHRkaXNhbGxvd2VkID0gZGlzYWxsb3dlZC5jb25jYXQocGFyc2VyLnRhZ3MubWFwKGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRcdHJldHVybiBcIlxcXFxcIiArIHQub3BlbjtcbiAgXHRcdH0pKTtcblxuICBcdFx0Ly8gaHR0cDovL2RldmVsb3BlcnMud2hhdHdnLm9yZy9zeW50YXguaHRtbCNzeW50YXgtYXR0cmlidXRlc1xuICBcdFx0aWYgKHBhcnNlci5pbkF0dHJpYnV0ZSA9PT0gdHJ1ZSkge1xuICBcdFx0XHQvLyB3ZSdyZSBpbnNpZGUgYW4gdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlXG4gIFx0XHRcdGRpc2FsbG93ZWQucHVzaChcIlxcXCJcIiwgXCInXCIsIFwiPVwiLCBcIjxcIiwgXCI+XCIsIFwiYFwiKTtcbiAgXHRcdH0gZWxzZSBpZiAocGFyc2VyLmluQXR0cmlidXRlKSB7XG4gIFx0XHRcdC8vIHF1b3RlZCBhdHRyaWJ1dGUgdmFsdWVcbiAgXHRcdFx0ZGlzYWxsb3dlZC5wdXNoKHBhcnNlci5pbkF0dHJpYnV0ZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRkaXNhbGxvd2VkLnB1c2goYmFycmllcik7XG4gIFx0XHR9XG5cbiAgXHRcdGluZGV4ID0gZ2V0TG93ZXN0SW5kZXgocmVtYWluaW5nLCBkaXNhbGxvd2VkKTtcbiAgXHR9XG5cbiAgXHRpZiAoIWluZGV4KSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRpbmRleCA9IHJlbWFpbmluZy5sZW5ndGg7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLnBvcyArPSBpbmRleDtcblxuICBcdHJldHVybiBwYXJzZXIuaW5zaWRlID8gcmVtYWluaW5nLnN1YnN0cigwLCBpbmRleCkgOiBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKHJlbWFpbmluZy5zdWJzdHIoMCwgaW5kZXgpKTtcbiAgfVxuXG4gIHZhciB1dGlsc19lc2NhcGVSZWdFeHAgPSBlc2NhcGVSZWdFeHA7XG4gIHZhciB1dGlsc19lc2NhcGVSZWdFeHBfX3BhdHRlcm4gPSAvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZztcbiAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICBcdHJldHVybiBzdHIucmVwbGFjZSh1dGlsc19lc2NhcGVSZWdFeHBfX3BhdHRlcm4sIFwiXFxcXCQmXCIpO1xuICB9XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZFBhcnRpYWxEZWZpbml0aW9uQ29tbWVudCA9IHJlYWRQYXJ0aWFsRGVmaW5pdGlvbkNvbW1lbnQ7XG5cbiAgdmFyIHN0YXJ0UGF0dGVybiA9IC9ePCEtLVxccyovLFxuICAgICAgbmFtZVBhdHRlcm4gPSAvcyo+XFxzKihbYS16QS1aXyRdWy1hLXpBLVpfJDAtOV0qKVxccyovLFxuICAgICAgZmluaXNoUGF0dGVybiA9IC9cXHMqLS0+LyxcbiAgICAgIGNoaWxkO1xuXG4gIGZ1bmN0aW9uIHJlYWRQYXJ0aWFsRGVmaW5pdGlvbkNvbW1lbnQocGFyc2VyKSB7XG4gIFx0dmFyIGZpcnN0UG9zID0gcGFyc2VyLnBvcyxcbiAgXHQgICAgb3BlbiA9IHBhcnNlci5zdGFuZGFyZERlbGltaXRlcnNbMF0sXG4gIFx0ICAgIGNsb3NlID0gcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVyc1sxXSxcbiAgXHQgICAgY29udGVudCA9IHVuZGVmaW5lZCxcbiAgXHQgICAgY2xvc2VkID0gdW5kZWZpbmVkO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hQYXR0ZXJuKHN0YXJ0UGF0dGVybikgfHwgIXBhcnNlci5tYXRjaFN0cmluZyhvcGVuKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IGZpcnN0UG9zO1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0dmFyIG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKG5hbWVQYXR0ZXJuKTtcblxuICBcdHdhcm5PbmNlSWZEZWJ1ZyhcIklubGluZSBwYXJ0aWFsIGNvbW1lbnRzIGFyZSBkZXByZWNhdGVkLlxcblVzZSB0aGlzLi4uXFxuICB7eyNwYXJ0aWFsIFwiICsgbmFtZSArIFwifX0gLi4uIHt7L3BhcnRpYWx9fVxcblxcbi4uLmluc3RlYWQgb2YgdGhpczpcXG4gIDwhLS0ge3s+XCIgKyBuYW1lICsgXCJ9fSAtLT4gLi4uIDwhLS0ge3svXCIgKyBuYW1lICsgXCJ9fSAtLT4nXCIpO1xuXG4gIFx0Ly8gbWFrZSBzdXJlIHRoZSByZXN0IG9mIHRoZSBjb21tZW50IGlzIGluIHRoZSBjb3JyZWN0IHBsYWNlXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoY2xvc2UpIHx8ICFwYXJzZXIubWF0Y2hQYXR0ZXJuKGZpbmlzaFBhdHRlcm4pKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gZmlyc3RQb3M7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRjb250ZW50ID0gW107XG5cbiAgXHR2YXIgZW5kUGF0dGVybiA9IG5ldyBSZWdFeHAoXCJePCEtLVxcXFxzKlwiICsgdXRpbHNfZXNjYXBlUmVnRXhwKG9wZW4pICsgXCJcXFxccypcXFxcL1xcXFxzKlwiICsgbmFtZSArIFwiXFxcXHMqXCIgKyB1dGlsc19lc2NhcGVSZWdFeHAoY2xvc2UpICsgXCJcXFxccyotLT5cIik7XG5cbiAgXHRkbyB7XG4gIFx0XHRpZiAocGFyc2VyLm1hdGNoUGF0dGVybihlbmRQYXR0ZXJuKSkge1xuICBcdFx0XHRjbG9zZWQgPSB0cnVlO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Y2hpbGQgPSBwYXJzZXIucmVhZChSRUFERVJTKTtcbiAgXHRcdFx0aWYgKCFjaGlsZCkge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihcImV4cGVjdGVkIGNsb3NpbmcgY29tbWVudCAoJzwhLS0gXCIgKyBvcGVuICsgXCIvXCIgKyBuYW1lICsgXCJcIiArIGNsb3NlICsgXCIgLS0+JylcIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjb250ZW50LnB1c2goY2hpbGQpO1xuICBcdFx0fVxuICBcdH0gd2hpbGUgKCFjbG9zZWQpO1xuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IElOTElORV9QQVJUSUFMLFxuICBcdFx0ZjogY29udGVudCxcbiAgXHRcdG46IG5hbWVcbiAgXHR9O1xuICB9XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZFBhcnRpYWxEZWZpbml0aW9uU2VjdGlvbiA9IHJlYWRQYXJ0aWFsRGVmaW5pdGlvblNlY3Rpb247XG4gIHZhciBwYXJ0aWFsRGVmaW5pdGlvblNlY3Rpb25QYXR0ZXJuID0gL14jXFxzKnBhcnRpYWxcXHMrLztcbiAgZnVuY3Rpb24gcmVhZFBhcnRpYWxEZWZpbml0aW9uU2VjdGlvbihwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIG5hbWUsIGNvbnRlbnQsIGNoaWxkLCBjbG9zZWQ7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHR2YXIgZGVsaW1pdGVycyA9IHBhcnNlci5zdGFuZGFyZERlbGltaXRlcnM7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhkZWxpbWl0ZXJzWzBdKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hQYXR0ZXJuKHBhcnRpYWxEZWZpbml0aW9uU2VjdGlvblBhdHRlcm4pKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybigvXlthLXpBLVpfJF1bYS16QS1aXyQwLTlcXC1dKi8pO1xuXG4gIFx0aWYgKCFuYW1lKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJleHBlY3RlZCBsZWdhbCBwYXJ0aWFsIG5hbWVcIik7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoZGVsaW1pdGVyc1sxXSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIGRlbGltaXRlcnNbMV0gKyBcIidcIik7XG4gIFx0fVxuXG4gIFx0Y29udGVudCA9IFtdO1xuXG4gIFx0ZG8ge1xuICBcdFx0Ly8gVE9ETyBjbGVhbiB0aGlzIHVwXG4gIFx0XHRpZiAoY2hpbGQgPSBzZWN0aW9uX3JlYWRDbG9zaW5nKHBhcnNlciwgeyBvcGVuOiBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzBdLCBjbG9zZTogcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVyc1sxXSB9KSkge1xuICBcdFx0XHRpZiAoIWNoaWxkLnIgPT09IFwicGFydGlhbFwiKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgXCIgKyBkZWxpbWl0ZXJzWzBdICsgXCIvcGFydGlhbFwiICsgZGVsaW1pdGVyc1sxXSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjbG9zZWQgPSB0cnVlO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Y2hpbGQgPSBwYXJzZXIucmVhZChSRUFERVJTKTtcblxuICBcdFx0XHRpZiAoIWNoaWxkKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgXCIgKyBkZWxpbWl0ZXJzWzBdICsgXCIvcGFydGlhbFwiICsgZGVsaW1pdGVyc1sxXSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjb250ZW50LnB1c2goY2hpbGQpO1xuICBcdFx0fVxuICBcdH0gd2hpbGUgKCFjbG9zZWQpO1xuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IElOTElORV9QQVJUSUFMLFxuICBcdFx0bjogbmFtZSxcbiAgXHRcdGY6IGNvbnRlbnRcbiAgXHR9O1xuICB9XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZFRlbXBsYXRlID0gcmVhZFRlbXBsYXRlO1xuICBmdW5jdGlvbiByZWFkVGVtcGxhdGUocGFyc2VyKSB7XG4gIFx0dmFyIGZyYWdtZW50ID0gW107XG4gIFx0dmFyIHBhcnRpYWxzID0gY3JlYXRlKG51bGwpO1xuICBcdHZhciBoYXNQYXJ0aWFscyA9IGZhbHNlO1xuXG4gIFx0dmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IHBhcnNlci5wcmVzZXJ2ZVdoaXRlc3BhY2U7XG5cbiAgXHR3aGlsZSAocGFyc2VyLnBvcyA8IHBhcnNlci5zdHIubGVuZ3RoKSB7XG4gIFx0XHR2YXIgcG9zID0gcGFyc2VyLnBvcyxcbiAgXHRcdCAgICBpdGVtID0gdW5kZWZpbmVkLFxuICBcdFx0ICAgIHBhcnRpYWwgPSB1bmRlZmluZWQ7XG5cbiAgXHRcdGlmIChwYXJ0aWFsID0gcGFyc2VyLnJlYWQoUEFSVElBTF9SRUFERVJTKSkge1xuICBcdFx0XHRpZiAocGFydGlhbHNbcGFydGlhbC5uXSkge1xuICBcdFx0XHRcdHBhcnNlci5wb3MgPSBwb3M7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwiRHVwbGljYXRlZCBwYXJ0aWFsIGRlZmluaXRpb25cIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR1dGlsc19jbGVhbnVwKHBhcnRpYWwuZiwgcGFyc2VyLnN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgIXByZXNlcnZlV2hpdGVzcGFjZSwgIXByZXNlcnZlV2hpdGVzcGFjZSk7XG5cbiAgXHRcdFx0cGFydGlhbHNbcGFydGlhbC5uXSA9IHBhcnRpYWwuZjtcbiAgXHRcdFx0aGFzUGFydGlhbHMgPSB0cnVlO1xuICBcdFx0fSBlbHNlIGlmIChpdGVtID0gcGFyc2VyLnJlYWQoUkVBREVSUykpIHtcbiAgXHRcdFx0ZnJhZ21lbnQucHVzaChpdGVtKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihcIlVuZXhwZWN0ZWQgdGVtcGxhdGUgY29udGVudFwiKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHR2YXIgcmVzdWx0ID0ge1xuICBcdFx0djogVEVNUExBVEVfVkVSU0lPTixcbiAgXHRcdHQ6IGZyYWdtZW50XG4gIFx0fTtcblxuICBcdGlmIChoYXNQYXJ0aWFscykge1xuICBcdFx0cmVzdWx0LnAgPSBwYXJ0aWFscztcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIF9wYXJzZSA9IHBhcnNlO1xuXG4gIHZhciBTVEFOREFSRF9SRUFERVJTID0gW211c3RhY2hlX3JlYWRQYXJ0aWFsLCBtdXN0YWNoZV9yZWFkVW5lc2NhcGVkLCBtdXN0YWNoZV9yZWFkU2VjdGlvbiwgbXVzdGFjaGVfcmVhZFlpZWxkZXIsIG11c3RhY2hlX3JlYWRJbnRlcnBvbGF0b3IsIHJlYWRNdXN0YWNoZUNvbW1lbnRdO1xuICB2YXIgVFJJUExFX1JFQURFUlMgPSBbbXVzdGFjaGVfcmVhZFRyaXBsZV07XG4gIHZhciBTVEFUSUNfUkVBREVSUyA9IFttdXN0YWNoZV9yZWFkVW5lc2NhcGVkLCBtdXN0YWNoZV9yZWFkU2VjdGlvbiwgbXVzdGFjaGVfcmVhZEludGVycG9sYXRvcl07IC8vIFRPRE8gZG9lcyBpdCBtYWtlIHNlbnNlIHRvIGhhdmUgYSBzdGF0aWMgc2VjdGlvbj9cblxuICB2YXIgU3RhbmRhcmRQYXJzZXIgPSB1bmRlZmluZWQ7XG4gIGZ1bmN0aW9uIHBhcnNlKHRlbXBsYXRlLCBvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBTdGFuZGFyZFBhcnNlcih0ZW1wbGF0ZSwgb3B0aW9ucyB8fCB7fSkucmVzdWx0O1xuICB9XG5cbiAgdmFyIFJFQURFUlMgPSBbY29udmVydGVyc19yZWFkTXVzdGFjaGUsIGNvbnZlcnRlcnNfcmVhZEh0bWxDb21tZW50LCBjb252ZXJ0ZXJzX3JlYWRFbGVtZW50LCBjb252ZXJ0ZXJzX3JlYWRUZXh0XTtcbiAgdmFyIFBBUlRJQUxfUkVBREVSUyA9IFtjb252ZXJ0ZXJzX3JlYWRQYXJ0aWFsRGVmaW5pdGlvbkNvbW1lbnQsIGNvbnZlcnRlcnNfcmVhZFBhcnRpYWxEZWZpbml0aW9uU2VjdGlvbl07XG5cbiAgU3RhbmRhcmRQYXJzZXIgPSBwYXJzZV9QYXJzZXIuZXh0ZW5kKHtcbiAgXHRpbml0OiBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG4gIFx0XHR2YXIgdHJpcGxlRGVsaW1pdGVycyA9IG9wdGlvbnMudHJpcGxlRGVsaW1pdGVycyB8fCBbXCJ7e3tcIiwgXCJ9fX1cIl0sXG4gIFx0XHQgICAgc3RhdGljRGVsaW1pdGVycyA9IG9wdGlvbnMuc3RhdGljRGVsaW1pdGVycyB8fCBbXCJbW1wiLCBcIl1dXCJdLFxuICBcdFx0ICAgIHN0YXRpY1RyaXBsZURlbGltaXRlcnMgPSBvcHRpb25zLnN0YXRpY1RyaXBsZURlbGltaXRlcnMgfHwgW1wiW1tbXCIsIFwiXV1dXCJdO1xuXG4gIFx0XHR0aGlzLnN0YW5kYXJkRGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycyB8fCBbXCJ7e1wiLCBcIn19XCJdO1xuXG4gIFx0XHR0aGlzLnRhZ3MgPSBbeyBpc1N0YXRpYzogZmFsc2UsIGlzVHJpcGxlOiBmYWxzZSwgb3BlbjogdGhpcy5zdGFuZGFyZERlbGltaXRlcnNbMF0sIGNsb3NlOiB0aGlzLnN0YW5kYXJkRGVsaW1pdGVyc1sxXSwgcmVhZGVyczogU1RBTkRBUkRfUkVBREVSUyB9LCB7IGlzU3RhdGljOiBmYWxzZSwgaXNUcmlwbGU6IHRydWUsIG9wZW46IHRyaXBsZURlbGltaXRlcnNbMF0sIGNsb3NlOiB0cmlwbGVEZWxpbWl0ZXJzWzFdLCByZWFkZXJzOiBUUklQTEVfUkVBREVSUyB9LCB7IGlzU3RhdGljOiB0cnVlLCBpc1RyaXBsZTogZmFsc2UsIG9wZW46IHN0YXRpY0RlbGltaXRlcnNbMF0sIGNsb3NlOiBzdGF0aWNEZWxpbWl0ZXJzWzFdLCByZWFkZXJzOiBTVEFUSUNfUkVBREVSUyB9LCB7IGlzU3RhdGljOiB0cnVlLCBpc1RyaXBsZTogdHJ1ZSwgb3Blbjogc3RhdGljVHJpcGxlRGVsaW1pdGVyc1swXSwgY2xvc2U6IHN0YXRpY1RyaXBsZURlbGltaXRlcnNbMV0sIHJlYWRlcnM6IFRSSVBMRV9SRUFERVJTIH1dO1xuXG4gIFx0XHR0aGlzLnNvcnRNdXN0YWNoZVRhZ3MoKTtcblxuICBcdFx0dGhpcy5zZWN0aW9uRGVwdGggPSAwO1xuICBcdFx0dGhpcy5lbGVtZW50U3RhY2sgPSBbXTtcblxuICBcdFx0dGhpcy5pbnRlcnBvbGF0ZSA9IHtcbiAgXHRcdFx0c2NyaXB0OiAhb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCBvcHRpb25zLmludGVycG9sYXRlLnNjcmlwdCAhPT0gZmFsc2UsXG4gIFx0XHRcdHN0eWxlOiAhb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCBvcHRpb25zLmludGVycG9sYXRlLnN0eWxlICE9PSBmYWxzZVxuICBcdFx0fTtcblxuICBcdFx0aWYgKG9wdGlvbnMuc2FuaXRpemUgPT09IHRydWUpIHtcbiAgXHRcdFx0b3B0aW9ucy5zYW5pdGl6ZSA9IHtcbiAgXHRcdFx0XHQvLyBibGFja2xpc3QgZnJvbSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1jYWphL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvY2FqYS9sYW5nL2h0bWwvaHRtbDQtZWxlbWVudHMtd2hpdGVsaXN0Lmpzb25cbiAgXHRcdFx0XHRlbGVtZW50czogXCJhcHBsZXQgYmFzZSBiYXNlZm9udCBib2R5IGZyYW1lIGZyYW1lc2V0IGhlYWQgaHRtbCBpc2luZGV4IGxpbmsgbWV0YSBub2ZyYW1lcyBub3NjcmlwdCBvYmplY3QgcGFyYW0gc2NyaXB0IHN0eWxlIHRpdGxlXCIuc3BsaXQoXCIgXCIpLFxuICBcdFx0XHRcdGV2ZW50QXR0cmlidXRlczogdHJ1ZVxuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnN0cmlwQ29tbWVudHMgPSBvcHRpb25zLnN0cmlwQ29tbWVudHMgIT09IGZhbHNlO1xuICBcdFx0dGhpcy5wcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZTtcbiAgXHRcdHRoaXMuc2FuaXRpemVFbGVtZW50cyA9IG9wdGlvbnMuc2FuaXRpemUgJiYgb3B0aW9ucy5zYW5pdGl6ZS5lbGVtZW50cztcbiAgXHRcdHRoaXMuc2FuaXRpemVFdmVudEF0dHJpYnV0ZXMgPSBvcHRpb25zLnNhbml0aXplICYmIG9wdGlvbnMuc2FuaXRpemUuZXZlbnRBdHRyaWJ1dGVzO1xuICBcdFx0dGhpcy5pbmNsdWRlTGluZVBvc2l0aW9ucyA9IG9wdGlvbnMuaW5jbHVkZUxpbmVQb3NpdGlvbnM7XG4gIFx0fSxcblxuICBcdHBvc3RQcm9jZXNzOiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBlbXB0eSBzdHJpbmdcbiAgXHRcdGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICBcdFx0XHRyZXR1cm4geyB0OiBbXSwgdjogVEVNUExBVEVfVkVSU0lPTiB9O1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5zZWN0aW9uRGVwdGggPiAwKSB7XG4gIFx0XHRcdHRoaXMuZXJyb3IoXCJBIHNlY3Rpb24gd2FzIGxlZnQgb3BlblwiKTtcbiAgXHRcdH1cblxuICBcdFx0dXRpbHNfY2xlYW51cChyZXN1bHRbMF0udCwgdGhpcy5zdHJpcENvbW1lbnRzLCB0aGlzLnByZXNlcnZlV2hpdGVzcGFjZSwgIXRoaXMucHJlc2VydmVXaGl0ZXNwYWNlLCAhdGhpcy5wcmVzZXJ2ZVdoaXRlc3BhY2UpO1xuXG4gIFx0XHRyZXR1cm4gcmVzdWx0WzBdO1xuICBcdH0sXG5cbiAgXHRjb252ZXJ0ZXJzOiBbY29udmVydGVyc19yZWFkVGVtcGxhdGVdLFxuXG4gIFx0c29ydE11c3RhY2hlVGFnczogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gU29ydCBpbiBvcmRlciBvZiBkZXNjZW5kaW5nIG9wZW5pbmcgZGVsaW1pdGVyIGxlbmd0aCAobG9uZ2VyIGZpcnN0KSxcbiAgXHRcdC8vIHRvIHByb3RlY3QgYWdhaW5zdCBvcGVuaW5nIGRlbGltaXRlcnMgYmVpbmcgc3Vic3RyaW5ncyBvZiBlYWNoIG90aGVyXG4gIFx0XHR0aGlzLnRhZ3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xuICBcdFx0XHRyZXR1cm4gYi5vcGVuLmxlbmd0aCAtIGEub3Blbi5sZW5ndGg7XG4gIFx0XHR9KTtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBwYXJzZU9wdGlvbnMgPSBbXCJwcmVzZXJ2ZVdoaXRlc3BhY2VcIiwgXCJzYW5pdGl6ZVwiLCBcInN0cmlwQ29tbWVudHNcIiwgXCJkZWxpbWl0ZXJzXCIsIFwidHJpcGxlRGVsaW1pdGVyc1wiLCBcImludGVycG9sYXRlXCJdO1xuXG4gIHZhciBwYXJzZXIgPSB7XG4gIFx0ZnJvbUlkOiBmcm9tSWQsIGlzSGFzaGVkSWQ6IGlzSGFzaGVkSWQsIGlzUGFyc2VkOiBpc1BhcnNlZCwgZ2V0UGFyc2VPcHRpb25zOiBnZXRQYXJzZU9wdGlvbnMsIGNyZWF0ZUhlbHBlcjogdGVtcGxhdGVfcGFyc2VyX19jcmVhdGVIZWxwZXIsXG4gIFx0cGFyc2U6IGRvUGFyc2VcbiAgfTtcblxuICBmdW5jdGlvbiB0ZW1wbGF0ZV9wYXJzZXJfX2NyZWF0ZUhlbHBlcihwYXJzZU9wdGlvbnMpIHtcbiAgXHR2YXIgaGVscGVyID0gY3JlYXRlKHBhcnNlcik7XG4gIFx0aGVscGVyLnBhcnNlID0gZnVuY3Rpb24gKHRlbXBsYXRlLCBvcHRpb25zKSB7XG4gIFx0XHRyZXR1cm4gZG9QYXJzZSh0ZW1wbGF0ZSwgb3B0aW9ucyB8fCBwYXJzZU9wdGlvbnMpO1xuICBcdH07XG4gIFx0cmV0dXJuIGhlbHBlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvUGFyc2UodGVtcGxhdGUsIHBhcnNlT3B0aW9ucykge1xuICBcdGlmICghX3BhcnNlKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIFJhY3RpdmUucGFyc2UgLSBjYW5ub3QgcGFyc2UgdGVtcGxhdGUuIEVpdGhlciBwcmVwYXJzZSBvciB1c2UgdGhlIHZlcnNpb24gdGhhdCBpbmNsdWRlcyB0aGUgcGFyc2VyXCIpO1xuICBcdH1cblxuICBcdHJldHVybiBfcGFyc2UodGVtcGxhdGUsIHBhcnNlT3B0aW9ucyB8fCB0aGlzLm9wdGlvbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJvbUlkKGlkLCBvcHRpb25zKSB7XG4gIFx0dmFyIHRlbXBsYXRlO1xuXG4gIFx0aWYgKCFpc0NsaWVudCkge1xuICBcdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub1Rocm93KSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXRyaWV2ZSB0ZW1wbGF0ZSAjXCIgKyBpZCArIFwiIGFzIFJhY3RpdmUgaXMgbm90IHJ1bm5pbmcgaW4gYSBicm93c2VyLlwiKTtcbiAgXHR9XG5cbiAgXHRpZiAoaXNIYXNoZWRJZChpZCkpIHtcbiAgXHRcdGlkID0gaWQuc3Vic3RyaW5nKDEpO1xuICBcdH1cblxuICBcdGlmICghKHRlbXBsYXRlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpKSkge1xuICBcdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub1Rocm93KSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHRlbXBsYXRlIGVsZW1lbnQgd2l0aCBpZCAjXCIgKyBpZCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRlbXBsYXRlLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gXCJTQ1JJUFRcIikge1xuICBcdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub1Rocm93KSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIlRlbXBsYXRlIGVsZW1lbnQgd2l0aCBpZCAjXCIgKyBpZCArIFwiLCBtdXN0IGJlIGEgPHNjcmlwdD4gZWxlbWVudFwiKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gXCJ0ZXh0Q29udGVudFwiIGluIHRlbXBsYXRlID8gdGVtcGxhdGUudGV4dENvbnRlbnQgOiB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hhc2hlZElkKGlkKSB7XG4gIFx0cmV0dXJuIGlkICYmIGlkWzBdID09PSBcIiNcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGFyc2VkKHRlbXBsYXRlKSB7XG4gIFx0cmV0dXJuICEodHlwZW9mIHRlbXBsYXRlID09PSBcInN0cmluZ1wiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBhcnNlT3B0aW9ucyhyYWN0aXZlKSB7XG4gIFx0Ly8gQ291bGQgYmUgUmFjdGl2ZSBvciBhIENvbXBvbmVudFxuICBcdGlmIChyYWN0aXZlLmRlZmF1bHRzKSB7XG4gIFx0XHRyYWN0aXZlID0gcmFjdGl2ZS5kZWZhdWx0cztcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcGFyc2VPcHRpb25zLnJlZHVjZShmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgXHRcdHZhbFtrZXldID0gcmFjdGl2ZVtrZXldO1xuICBcdFx0cmV0dXJuIHZhbDtcbiAgXHR9LCB7fSk7XG4gIH1cblxuICB2YXIgdGVtcGxhdGVfcGFyc2VyID0gcGFyc2VyO1xuXG4gIHZhciB0ZW1wbGF0ZUNvbmZpZ3VyYXRvciA9IHtcbiAgXHRuYW1lOiBcInRlbXBsYXRlXCIsXG5cbiAgXHRleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZChQYXJlbnQsIHByb3RvLCBvcHRpb25zKSB7XG4gIFx0XHR2YXIgdGVtcGxhdGU7XG5cbiAgXHRcdC8vIG9ubHkgYXNzaWduIGlmIGV4aXN0c1xuICBcdFx0aWYgKFwidGVtcGxhdGVcIiBpbiBvcHRpb25zKSB7XG4gIFx0XHRcdHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcblxuICBcdFx0XHRpZiAodHlwZW9mIHRlbXBsYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0XHRwcm90by50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHByb3RvLnRlbXBsYXRlID0gcGFyc2VJZlN0cmluZyh0ZW1wbGF0ZSwgcHJvdG8pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGluaXQ6IGZ1bmN0aW9uIGluaXQoUGFyZW50LCByYWN0aXZlLCBvcHRpb25zKSB7XG4gIFx0XHR2YXIgdGVtcGxhdGUsIGZuO1xuXG4gIFx0XHQvLyBUT0RPIGJlY2F1c2Ugb2YgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgd2UgbWlnaHQganVzdCBiZSBhYmxlIHRvIHVzZVxuICBcdFx0Ly8gcmFjdGl2ZS50ZW1wbGF0ZSwgYW5kIG5vdCBib3RoZXIgcGFzc2luZyB0aHJvdWdoIHRoZSBQYXJlbnQgb2JqZWN0LlxuICBcdFx0Ly8gQXQgcHJlc2VudCB0aGF0IGJyZWFrcyB0aGUgdGVzdCBtb2NrcycgZXhwZWN0YXRpb25zXG4gIFx0XHR0ZW1wbGF0ZSA9IFwidGVtcGxhdGVcIiBpbiBvcHRpb25zID8gb3B0aW9ucy50ZW1wbGF0ZSA6IFBhcmVudC5wcm90b3R5cGUudGVtcGxhdGU7XG5cbiAgXHRcdGlmICh0eXBlb2YgdGVtcGxhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRmbiA9IHRlbXBsYXRlO1xuICBcdFx0XHR0ZW1wbGF0ZSA9IGdldER5bmFtaWNUZW1wbGF0ZShyYWN0aXZlLCBmbik7XG5cbiAgXHRcdFx0cmFjdGl2ZS5fY29uZmlnLnRlbXBsYXRlID0ge1xuICBcdFx0XHRcdGZuOiBmbixcbiAgXHRcdFx0XHRyZXN1bHQ6IHRlbXBsYXRlXG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdHRlbXBsYXRlID0gcGFyc2VJZlN0cmluZyh0ZW1wbGF0ZSwgcmFjdGl2ZSk7XG5cbiAgXHRcdC8vIFRPRE8gdGhlIG5hbWluZyBvZiB0aGlzIGlzIGNvbmZ1c2luZyAtIHJhY3RpdmUudGVtcGxhdGUgcmVmZXJzIHRvIFsuLi5dLFxuICBcdFx0Ly8gYnV0IENvbXBvbmVudC5wcm90b3R5cGUudGVtcGxhdGUgcmVmZXJzIHRvIHt2OjEsdDpbXSxwOltdfS4uLlxuICBcdFx0Ly8gaXQncyB1bm5lY2Vzc2FyeSwgYmVjYXVzZSB0aGUgZGV2ZWxvcGVyIG5ldmVyIG5lZWRzIHRvIGFjY2Vzc1xuICBcdFx0Ly8gcmFjdGl2ZS50ZW1wbGF0ZVxuICBcdFx0cmFjdGl2ZS50ZW1wbGF0ZSA9IHRlbXBsYXRlLnQ7XG5cbiAgXHRcdGlmICh0ZW1wbGF0ZS5wKSB7XG4gIFx0XHRcdGV4dGVuZFBhcnRpYWxzKHJhY3RpdmUucGFydGlhbHMsIHRlbXBsYXRlLnApO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZXNldDogZnVuY3Rpb24gKHJhY3RpdmUpIHtcbiAgXHRcdHZhciByZXN1bHQgPSByZXNldFZhbHVlKHJhY3RpdmUpLFxuICBcdFx0ICAgIHBhcnNlZDtcblxuICBcdFx0aWYgKHJlc3VsdCkge1xuICBcdFx0XHRwYXJzZWQgPSBwYXJzZUlmU3RyaW5nKHJlc3VsdCwgcmFjdGl2ZSk7XG5cbiAgXHRcdFx0cmFjdGl2ZS50ZW1wbGF0ZSA9IHBhcnNlZC50O1xuICBcdFx0XHRleHRlbmRQYXJ0aWFscyhyYWN0aXZlLnBhcnRpYWxzLCBwYXJzZWQucCwgdHJ1ZSk7XG5cbiAgXHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIGZ1bmN0aW9uIHJlc2V0VmFsdWUocmFjdGl2ZSkge1xuICBcdHZhciBpbml0aWFsID0gcmFjdGl2ZS5fY29uZmlnLnRlbXBsYXRlLFxuICBcdCAgICByZXN1bHQ7XG5cbiAgXHQvLyBJZiB0aGlzIGlzbid0IGEgZHluYW1pYyB0ZW1wbGF0ZSwgdGhlcmUncyBub3RoaW5nIHRvIGRvXG4gIFx0aWYgKCFpbml0aWFsIHx8ICFpbml0aWFsLmZuKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0cmVzdWx0ID0gZ2V0RHluYW1pY1RlbXBsYXRlKHJhY3RpdmUsIGluaXRpYWwuZm4pO1xuXG4gIFx0Ly8gVE9ETyBkZWVwIGVxdWFsaXR5IGNoZWNrIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcmUtcmVuZGVyaW5nXG4gIFx0Ly8gaW4gdGhlIGNhc2Ugb2YgYWxyZWFkeS1wYXJzZWQgdGVtcGxhdGVzXG4gIFx0aWYgKHJlc3VsdCAhPT0gaW5pdGlhbC5yZXN1bHQpIHtcbiAgXHRcdGluaXRpYWwucmVzdWx0ID0gcmVzdWx0O1xuICBcdFx0cmVzdWx0ID0gcGFyc2VJZlN0cmluZyhyZXN1bHQsIHJhY3RpdmUpO1xuICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBnZXREeW5hbWljVGVtcGxhdGUocmFjdGl2ZSwgZm4pIHtcbiAgXHR2YXIgaGVscGVyID0gdGVtcGxhdGVfdGVtcGxhdGVfX2NyZWF0ZUhlbHBlcih0ZW1wbGF0ZV9wYXJzZXIuZ2V0UGFyc2VPcHRpb25zKHJhY3RpdmUpKTtcbiAgXHRyZXR1cm4gZm4uY2FsbChyYWN0aXZlLCBoZWxwZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGVtcGxhdGVfdGVtcGxhdGVfX2NyZWF0ZUhlbHBlcihwYXJzZU9wdGlvbnMpIHtcbiAgXHR2YXIgaGVscGVyID0gY3JlYXRlKHRlbXBsYXRlX3BhcnNlcik7XG4gIFx0aGVscGVyLnBhcnNlID0gZnVuY3Rpb24gKHRlbXBsYXRlLCBvcHRpb25zKSB7XG4gIFx0XHRyZXR1cm4gdGVtcGxhdGVfcGFyc2VyLnBhcnNlKHRlbXBsYXRlLCBvcHRpb25zIHx8IHBhcnNlT3B0aW9ucyk7XG4gIFx0fTtcbiAgXHRyZXR1cm4gaGVscGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VJZlN0cmluZyh0ZW1wbGF0ZSwgcmFjdGl2ZSkge1xuICBcdGlmICh0eXBlb2YgdGVtcGxhdGUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdC8vIElEIG9mIGFuIGVsZW1lbnQgY29udGFpbmluZyB0aGUgdGVtcGxhdGU/XG4gIFx0XHRpZiAodGVtcGxhdGVbMF0gPT09IFwiI1wiKSB7XG4gIFx0XHRcdHRlbXBsYXRlID0gdGVtcGxhdGVfcGFyc2VyLmZyb21JZCh0ZW1wbGF0ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRlbXBsYXRlID0gX3BhcnNlKHRlbXBsYXRlLCB0ZW1wbGF0ZV9wYXJzZXIuZ2V0UGFyc2VPcHRpb25zKHJhY3RpdmUpKTtcbiAgXHR9XG5cbiAgXHQvLyBDaGVjayB0aGF0IHRoZSB0ZW1wbGF0ZSBldmVuIGV4aXN0c1xuICBcdGVsc2UgaWYgKHRlbXBsYXRlID09IHVuZGVmaW5lZCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIHRlbXBsYXRlIGNhbm5vdCBiZSBcIiArIHRlbXBsYXRlICsgXCIuXCIpO1xuICBcdH1cblxuICBcdC8vIENoZWNrIHRoZSBwYXJzZWQgdGVtcGxhdGUgaGFzIGEgdmVyc2lvbiBhdCBhbGxcbiAgXHRlbHNlIGlmICh0eXBlb2YgdGVtcGxhdGUudiAhPT0gXCJudW1iZXJcIikge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIHRlbXBsYXRlIHBhcnNlciB3YXMgcGFzc2VkIGEgbm9uLXN0cmluZyB0ZW1wbGF0ZSwgYnV0IHRoZSB0ZW1wbGF0ZSBkb2Vzbid0IGhhdmUgYSB2ZXJzaW9uLiAgTWFrZSBzdXJlIHlvdSdyZSBwYXNzaW5nIGluIHRoZSB0ZW1wbGF0ZSB5b3UgdGhpbmsgeW91IGFyZS5cIik7XG4gIFx0fVxuXG4gIFx0Ly8gQ2hlY2sgd2UncmUgdXNpbmcgdGhlIGNvcnJlY3QgdmVyc2lvblxuICBcdGVsc2UgaWYgKHRlbXBsYXRlLnYgIT09IFRFTVBMQVRFX1ZFUlNJT04pIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgdGVtcGxhdGUgdmVyc2lvbiAoZXhwZWN0ZWQgXCIgKyBURU1QTEFURV9WRVJTSU9OICsgXCIsIGdvdCBcIiArIHRlbXBsYXRlLnYgKyBcIikgUGxlYXNlIGVuc3VyZSB5b3UgYXJlIHVzaW5nIHRoZSBsYXRlc3QgdmVyc2lvbiBvZiBSYWN0aXZlLmpzIGluIHlvdXIgYnVpbGQgcHJvY2VzcyBhcyB3ZWxsIGFzIGluIHlvdXIgYXBwXCIpO1xuICBcdH1cblxuICBcdHJldHVybiB0ZW1wbGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZFBhcnRpYWxzKGV4aXN0aW5nUGFydGlhbHMsIG5ld1BhcnRpYWxzLCBvdmVyd3JpdGUpIHtcbiAgXHRpZiAoIW5ld1BhcnRpYWxzKSByZXR1cm47XG5cbiAgXHQvLyBUT0RPIHRoZXJlJ3MgYW4gYW1iaWd1aXR5IGhlcmUgLSB3ZSBuZWVkIHRvIG92ZXJ3cml0ZSBpbiB0aGUgYHJlc2V0KClgXG4gIFx0Ly8gY2FzZSwgYnV0IG5vdCBpbml0aWFsbHkuLi5cblxuICBcdGZvciAodmFyIGtleSBpbiBuZXdQYXJ0aWFscykge1xuICBcdFx0aWYgKG92ZXJ3cml0ZSB8fCAhZXhpc3RpbmdQYXJ0aWFscy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gIFx0XHRcdGV4aXN0aW5nUGFydGlhbHNba2V5XSA9IG5ld1BhcnRpYWxzW2tleV07XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIHRlbXBsYXRlX3RlbXBsYXRlID0gdGVtcGxhdGVDb25maWd1cmF0b3I7XG5cbiAgdmFyIGNvbmZpZ19yZWdpc3RyaWVzX19yZWdpc3RyeU5hbWVzLCBSZWdpc3RyeSwgcmVnaXN0cmllcztcblxuICBjb25maWdfcmVnaXN0cmllc19fcmVnaXN0cnlOYW1lcyA9IFtcImFkYXB0b3JzXCIsIFwiY29tcG9uZW50c1wiLCBcImNvbXB1dGVkXCIsIFwiZGVjb3JhdG9yc1wiLCBcImVhc2luZ1wiLCBcImV2ZW50c1wiLCBcImludGVycG9sYXRvcnNcIiwgXCJwYXJ0aWFsc1wiLCBcInRyYW5zaXRpb25zXCJdO1xuXG4gIFJlZ2lzdHJ5ID0gZnVuY3Rpb24gKG5hbWUsIHVzZURlZmF1bHRzKSB7XG4gIFx0dGhpcy5uYW1lID0gbmFtZTtcbiAgXHR0aGlzLnVzZURlZmF1bHRzID0gdXNlRGVmYXVsdHM7XG4gIH07XG5cbiAgUmVnaXN0cnkucHJvdG90eXBlID0ge1xuICBcdGNvbnN0cnVjdG9yOiBSZWdpc3RyeSxcblxuICBcdGV4dGVuZDogZnVuY3Rpb24gKFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpIHtcbiAgXHRcdHRoaXMuY29uZmlndXJlKHRoaXMudXNlRGVmYXVsdHMgPyBQYXJlbnQuZGVmYXVsdHMgOiBQYXJlbnQsIHRoaXMudXNlRGVmYXVsdHMgPyBwcm90byA6IHByb3RvLmNvbnN0cnVjdG9yLCBvcHRpb25zKTtcbiAgXHR9LFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKCkge30sXG5cbiAgXHRjb25maWd1cmU6IGZ1bmN0aW9uIChQYXJlbnQsIHRhcmdldCwgb3B0aW9ucykge1xuICBcdFx0dmFyIG5hbWUgPSB0aGlzLm5hbWUsXG4gIFx0XHQgICAgb3B0aW9uID0gb3B0aW9uc1tuYW1lXSxcbiAgXHRcdCAgICByZWdpc3RyeTtcblxuICBcdFx0cmVnaXN0cnkgPSBjcmVhdGUoUGFyZW50W25hbWVdKTtcblxuICBcdFx0Zm9yICh2YXIga2V5IGluIG9wdGlvbikge1xuICBcdFx0XHRyZWdpc3RyeVtrZXldID0gb3B0aW9uW2tleV07XG4gIFx0XHR9XG5cbiAgXHRcdHRhcmdldFtuYW1lXSA9IHJlZ2lzdHJ5O1xuICBcdH0sXG5cbiAgXHRyZXNldDogZnVuY3Rpb24gKHJhY3RpdmUpIHtcbiAgXHRcdHZhciByZWdpc3RyeSA9IHJhY3RpdmVbdGhpcy5uYW1lXTtcbiAgXHRcdHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gIFx0XHRPYmplY3Qua2V5cyhyZWdpc3RyeSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFx0XHRcdHZhciBpdGVtID0gcmVnaXN0cnlba2V5XTtcbiAgXHRcdFx0aWYgKGl0ZW0uX2ZuKSB7XG4gIFx0XHRcdFx0aWYgKGl0ZW0uX2ZuLmlzT3duZXIpIHtcbiAgXHRcdFx0XHRcdHJlZ2lzdHJ5W2tleV0gPSBpdGVtLl9mbjtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0ZGVsZXRlIHJlZ2lzdHJ5W2tleV07XG4gIFx0XHRcdFx0fVxuICBcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuICBcdFx0XHR9XG4gIFx0XHR9KTtcbiAgXHRcdHJldHVybiBjaGFuZ2VkO1xuICBcdH1cbiAgfTtcblxuICByZWdpc3RyaWVzID0gY29uZmlnX3JlZ2lzdHJpZXNfX3JlZ2lzdHJ5TmFtZXMubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gIFx0cmV0dXJuIG5ldyBSZWdpc3RyeShuYW1lLCBuYW1lID09PSBcImNvbXB1dGVkXCIpO1xuICB9KTtcblxuICB2YXIgY29uZmlnX3JlZ2lzdHJpZXMgPSByZWdpc3RyaWVzO1xuXG4gIC8qdGhpcy5jb25maWd1cmUoXG4gIFx0dGhpcy51c2VEZWZhdWx0cyA/IFBhcmVudC5kZWZhdWx0cyA6IFBhcmVudCxcbiAgXHRyYWN0aXZlLFxuICBcdG9wdGlvbnMgKTsqL1xuXG4gIHZhciB3cmFwUHJvdG90eXBlID0gd3JhcDtcblxuICBmdW5jdGlvbiB3cmFwKHBhcmVudCwgbmFtZSwgbWV0aG9kKSB7XG4gIFx0aWYgKCEvX3N1cGVyLy50ZXN0KG1ldGhvZCkpIHtcbiAgXHRcdHJldHVybiBtZXRob2Q7XG4gIFx0fVxuXG4gIFx0dmFyIHdyYXBwZXIgPSBmdW5jdGlvbiB3cmFwU3VwZXIoKSB7XG4gIFx0XHR2YXIgc3VwZXJNZXRob2QgPSBnZXRTdXBlck1ldGhvZCh3cmFwcGVyLl9wYXJlbnQsIG5hbWUpLFxuICBcdFx0ICAgIGhhc1N1cGVyID0gKFwiX3N1cGVyXCIgaW4gdGhpcyksXG4gIFx0XHQgICAgb2xkU3VwZXIgPSB0aGlzLl9zdXBlcixcbiAgXHRcdCAgICByZXN1bHQ7XG5cbiAgXHRcdHRoaXMuX3N1cGVyID0gc3VwZXJNZXRob2Q7XG5cbiAgXHRcdHJlc3VsdCA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIFx0XHRpZiAoaGFzU3VwZXIpIHtcbiAgXHRcdFx0dGhpcy5fc3VwZXIgPSBvbGRTdXBlcjtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9zdXBlcjtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHR9O1xuXG4gIFx0d3JhcHBlci5fcGFyZW50ID0gcGFyZW50O1xuICBcdHdyYXBwZXIuX21ldGhvZCA9IG1ldGhvZDtcblxuICBcdHJldHVybiB3cmFwcGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U3VwZXJNZXRob2QocGFyZW50LCBuYW1lKSB7XG4gIFx0dmFyIHZhbHVlLCBtZXRob2Q7XG5cbiAgXHRpZiAobmFtZSBpbiBwYXJlbnQpIHtcbiAgXHRcdHZhbHVlID0gcGFyZW50W25hbWVdO1xuXG4gIFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0bWV0aG9kID0gdmFsdWU7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRtZXRob2QgPSBmdW5jdGlvbiByZXR1cm5WYWx1ZSgpIHtcbiAgXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0XHRcdH07XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdG1ldGhvZCA9IG5vb3A7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG1ldGhvZDtcbiAgfVxuXG4gIHZhciBjb25maWdfZGVwcmVjYXRlID0gZGVwcmVjYXRlO1xuICBmdW5jdGlvbiBnZXRNZXNzYWdlKGRlcHJlY2F0ZWQsIGNvcnJlY3QsIGlzRXJyb3IpIHtcbiAgXHRyZXR1cm4gXCJvcHRpb25zLlwiICsgZGVwcmVjYXRlZCArIFwiIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIG9wdGlvbnMuXCIgKyBjb3JyZWN0ICsgXCIuXCIgKyAoaXNFcnJvciA/IFwiIFlvdSBjYW5ub3Qgc3BlY2lmeSBib3RoIG9wdGlvbnMsIHBsZWFzZSB1c2Ugb3B0aW9ucy5cIiArIGNvcnJlY3QgKyBcIi5cIiA6IFwiXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVwcmVjYXRlT3B0aW9uKG9wdGlvbnMsIGRlcHJlY2F0ZWRPcHRpb24sIGNvcnJlY3QpIHtcbiAgXHRpZiAoZGVwcmVjYXRlZE9wdGlvbiBpbiBvcHRpb25zKSB7XG4gIFx0XHRpZiAoIShjb3JyZWN0IGluIG9wdGlvbnMpKSB7XG4gIFx0XHRcdHdhcm5JZkRlYnVnKGdldE1lc3NhZ2UoZGVwcmVjYXRlZE9wdGlvbiwgY29ycmVjdCkpO1xuICBcdFx0XHRvcHRpb25zW2NvcnJlY3RdID0gb3B0aW9uc1tkZXByZWNhdGVkT3B0aW9uXTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihnZXRNZXNzYWdlKGRlcHJlY2F0ZWRPcHRpb24sIGNvcnJlY3QsIHRydWUpKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cbiAgZnVuY3Rpb24gZGVwcmVjYXRlKG9wdGlvbnMpIHtcbiAgXHRkZXByZWNhdGVPcHRpb24ob3B0aW9ucywgXCJiZWZvcmVJbml0XCIsIFwib25jb25zdHJ1Y3RcIik7XG4gIFx0ZGVwcmVjYXRlT3B0aW9uKG9wdGlvbnMsIFwiaW5pdFwiLCBcIm9ucmVuZGVyXCIpO1xuICBcdGRlcHJlY2F0ZU9wdGlvbihvcHRpb25zLCBcImNvbXBsZXRlXCIsIFwib25jb21wbGV0ZVwiKTtcbiAgXHRkZXByZWNhdGVPcHRpb24ob3B0aW9ucywgXCJldmVudERlZmluaXRpb25zXCIsIFwiZXZlbnRzXCIpO1xuXG4gIFx0Ly8gVXNpbmcgZXh0ZW5kIHdpdGggQ29tcG9uZW50IGluc3RlYWQgb2Ygb3B0aW9ucyxcbiAgXHQvLyBsaWtlIEh1bWFuLmV4dGVuZCggU3BpZGVyICkgbWVhbnMgYWRhcHRvcnMgYXMgYSByZWdpc3RyeVxuICBcdC8vIGdldHMgY29waWVkIHRvIG9wdGlvbnMuIFNvIHdlIGhhdmUgdG8gY2hlY2sgaWYgYWN0dWFsbHkgYW4gYXJyYXlcbiAgXHRpZiAoaXNBcnJheShvcHRpb25zLmFkYXB0b3JzKSkge1xuICBcdFx0ZGVwcmVjYXRlT3B0aW9uKG9wdGlvbnMsIFwiYWRhcHRvcnNcIiwgXCJhZGFwdFwiKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgY29uZmlnLCBvcmRlciwgZGVmYXVsdEtleXMsIGN1c3RvbSwgaXNCbGFja2xpc3RlZCwgaXNTdGFuZGFyZEtleTtcblxuICBjdXN0b20gPSB7XG4gIFx0YWRhcHQ6IGN1c3RvbV9hZGFwdCxcbiAgXHRjc3M6IGNzc19jc3MsXG4gIFx0ZGF0YTogY3VzdG9tX2RhdGEsXG4gIFx0dGVtcGxhdGU6IHRlbXBsYXRlX3RlbXBsYXRlXG4gIH07XG5cbiAgZGVmYXVsdEtleXMgPSBPYmplY3Qua2V5cyhjb25maWdfZGVmYXVsdHMpO1xuXG4gIGlzU3RhbmRhcmRLZXkgPSBtYWtlT2JqKGRlZmF1bHRLZXlzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gIFx0cmV0dXJuICFjdXN0b21ba2V5XTtcbiAgfSkpO1xuXG4gIC8vIGJsYWNrbGlzdGVkIGtleXMgdGhhdCB3ZSBkb24ndCBkb3VibGUgZXh0ZW5kXG4gIGlzQmxhY2tsaXN0ZWQgPSBtYWtlT2JqKGRlZmF1bHRLZXlzLmNvbmNhdChjb25maWdfcmVnaXN0cmllcy5tYXAoZnVuY3Rpb24gKHIpIHtcbiAgXHRyZXR1cm4gci5uYW1lO1xuICB9KSkpO1xuXG4gIG9yZGVyID0gW10uY29uY2F0KGRlZmF1bHRLZXlzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gIFx0cmV0dXJuICFjb25maWdfcmVnaXN0cmllc1trZXldICYmICFjdXN0b21ba2V5XTtcbiAgfSksIGNvbmZpZ19yZWdpc3RyaWVzLCBjdXN0b20uZGF0YSwgY3VzdG9tLnRlbXBsYXRlLCBjdXN0b20uY3NzKTtcblxuICBjb25maWcgPSB7XG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiAoUGFyZW50LCBwcm90bywgb3B0aW9ucykge1xuICBcdFx0cmV0dXJuIGNvbmZpZ3VyZShcImV4dGVuZFwiLCBQYXJlbnQsIHByb3RvLCBvcHRpb25zKTtcbiAgXHR9LFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucykge1xuICBcdFx0cmV0dXJuIGNvbmZpZ3VyZShcImluaXRcIiwgUGFyZW50LCByYWN0aXZlLCBvcHRpb25zKTtcbiAgXHR9LFxuXG4gIFx0cmVzZXQ6IGZ1bmN0aW9uIChyYWN0aXZlKSB7XG4gIFx0XHRyZXR1cm4gb3JkZXIuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gIFx0XHRcdHJldHVybiBjLnJlc2V0ICYmIGMucmVzZXQocmFjdGl2ZSk7XG4gIFx0XHR9KS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgXHRcdFx0cmV0dXJuIGMubmFtZTtcbiAgXHRcdH0pO1xuICBcdH0sXG5cbiAgXHQvLyB0aGlzIGRlZmluZXMgdGhlIG9yZGVyLiBUT0RPIHRoaXMgaXNuJ3QgdXNlZCBhbnl3aGVyZSBpbiB0aGUgY29kZWJhc2UsXG4gIFx0Ly8gb25seSBpbiB0aGUgdGVzdCBzdWl0ZSAtIHNob3VsZCBnZXQgcmlkIG9mIGl0XG4gIFx0b3JkZXI6IG9yZGVyIH07XG5cbiAgZnVuY3Rpb24gY29uZmlndXJlKG1ldGhvZCwgUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgXHRjb25maWdfZGVwcmVjYXRlKG9wdGlvbnMpO1xuXG4gIFx0Zm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgXHRcdGlmIChpc1N0YW5kYXJkS2V5Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgXHRcdFx0dmFyIHZhbHVlID0gb3B0aW9uc1trZXldO1xuXG4gIFx0XHRcdC8vIHdhcm4gdGhlIGRldmVsb3BlciBpZiB0aGV5IHBhc3NlZCBhIGZ1bmN0aW9uIGFuZCBpZ25vcmUgaXRzIHZhbHVlXG5cbiAgXHRcdFx0Ly8gTk9URTogd2UgYWxsb3cgc29tZSBmdW5jdGlvbnMgb24gXCJlbFwiIGJlY2F1c2Ugd2UgZHVjayB0eXBlIGVsZW1lbnQgbGlzdHNcbiAgXHRcdFx0Ly8gYW5kIHNvbWUgbGlicmFyaWVzIG9yIGVmJ2VkLXVwIHZpcnR1YWwgYnJvd3NlcnMgKHBoYW50b21KUykgcmV0dXJuIGFcbiAgXHRcdFx0Ly8gZnVuY3Rpb24gb2JqZWN0IGFzIHRoZSByZXN1bHQgb2YgcXVlcnlTZWxlY3RvciBtZXRob2RzXG4gIFx0XHRcdGlmIChrZXkgIT09IFwiZWxcIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRcdHdhcm5JZkRlYnVnKFwiXCIgKyBrZXkgKyBcIiBpcyBhIFJhY3RpdmUgb3B0aW9uIHRoYXQgZG9lcyBub3QgZXhwZWN0IGEgZnVuY3Rpb24gYW5kIHdpbGwgYmUgaWdub3JlZFwiLCBtZXRob2QgPT09IFwiaW5pdFwiID8gdGFyZ2V0IDogbnVsbCk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0dGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdGNvbmZpZ19yZWdpc3RyaWVzLmZvckVhY2goZnVuY3Rpb24gKHJlZ2lzdHJ5KSB7XG4gIFx0XHRyZWdpc3RyeVttZXRob2RdKFBhcmVudCwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgXHR9KTtcblxuICBcdGN1c3RvbV9hZGFwdFttZXRob2RdKFBhcmVudCwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgXHR0ZW1wbGF0ZV90ZW1wbGF0ZVttZXRob2RdKFBhcmVudCwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgXHRjc3NfY3NzW21ldGhvZF0oUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMpO1xuXG4gIFx0ZXh0ZW5kT3RoZXJNZXRob2RzKFBhcmVudC5wcm90b3R5cGUsIHRhcmdldCwgb3B0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmRPdGhlck1ldGhvZHMocGFyZW50LCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgXHRmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICBcdFx0aWYgKCFpc0JsYWNrbGlzdGVkW2tleV0gJiYgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gIFx0XHRcdHZhciBtZW1iZXIgPSBvcHRpb25zW2tleV07XG5cbiAgXHRcdFx0Ly8gaWYgdGhpcyBpcyBhIG1ldGhvZCB0aGF0IG92ZXJ3cml0ZXMgYSBtZXRob2QsIHdyYXAgaXQ6XG4gIFx0XHRcdGlmICh0eXBlb2YgbWVtYmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0XHRtZW1iZXIgPSB3cmFwUHJvdG90eXBlKHBhcmVudCwga2V5LCBtZW1iZXIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGFyZ2V0W2tleV0gPSBtZW1iZXI7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gbWFrZU9iaihhcnJheSkge1xuICBcdHZhciBvYmogPSB7fTtcbiAgXHRhcnJheS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gIFx0XHRyZXR1cm4gb2JqW3hdID0gdHJ1ZTtcbiAgXHR9KTtcbiAgXHRyZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIGNvbmZpZ19jb25maWcgPSBjb25maWc7XG5cbiAgdmFyIHByb3RvdHlwZV9idWJibGUgPSBGcmFnbWVudCRidWJibGU7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkYnViYmxlKCkge1xuICBcdHRoaXMuZGlydHlWYWx1ZSA9IHRoaXMuZGlydHlBcmdzID0gdHJ1ZTtcblxuICBcdGlmICh0aGlzLmJvdW5kICYmIHR5cGVvZiB0aGlzLm93bmVyLmJ1YmJsZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHR0aGlzLm93bmVyLmJ1YmJsZSgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfZGV0YWNoID0gRnJhZ21lbnQkZGV0YWNoO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGRldGFjaCgpIHtcbiAgXHR2YXIgZG9jRnJhZztcblxuICBcdGlmICh0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMSkge1xuICBcdFx0cmV0dXJuIHRoaXMuaXRlbXNbMF0uZGV0YWNoKCk7XG4gIFx0fVxuXG4gIFx0ZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICBcdHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0dmFyIG5vZGUgPSBpdGVtLmRldGFjaCgpO1xuXG4gIFx0XHQvLyBUT0RPIFRoZSBpZiB7Li4ufSB3YXNuJ3QgcHJldmlvdXNseSByZXF1aXJlZCAtIGl0IGlzIG5vdywgYmVjYXVzZSB3ZSdyZVxuICBcdFx0Ly8gZm9yY2libHkgZGV0YWNoaW5nIGV2ZXJ5dGhpbmcgdG8gcmVvcmRlciBzZWN0aW9ucyBhZnRlciBhbiB1cGRhdGUuIFRoYXQnc1xuICBcdFx0Ly8gYSBub24taWRlYWwgYnJ1dGUgZm9yY2UgYXBwcm9hY2gsIGltcGxlbWVudGVkIHRvIGdldCBhbGwgdGhlIHRlc3RzIHRvIHBhc3NcbiAgXHRcdC8vIC0gYXMgc29vbiBhcyBpdCdzIHJlcGxhY2VkIHdpdGggc29tZXRoaW5nIG1vcmUgZWxlZ2FudCwgdGhpcyBzaG91bGRcbiAgXHRcdC8vIHJldmVydCB0byBgZG9jRnJhZy5hcHBlbmRDaGlsZCggaXRlbS5kZXRhY2goKSApYFxuICBcdFx0aWYgKG5vZGUpIHtcbiAgXHRcdFx0ZG9jRnJhZy5hcHBlbmRDaGlsZChub2RlKTtcbiAgXHRcdH1cbiAgXHR9KTtcblxuICBcdHJldHVybiBkb2NGcmFnO1xuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV9maW5kID0gRnJhZ21lbnQkZmluZDtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRmaW5kKHNlbGVjdG9yKSB7XG4gIFx0dmFyIGksIGxlbiwgaXRlbSwgcXVlcnlSZXN1bHQ7XG5cbiAgXHRpZiAodGhpcy5pdGVtcykge1xuICBcdFx0bGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbaV07XG5cbiAgXHRcdFx0aWYgKGl0ZW0uZmluZCAmJiAocXVlcnlSZXN1bHQgPSBpdGVtLmZpbmQoc2VsZWN0b3IpKSkge1xuICBcdFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX2ZpbmRBbGwgPSBGcmFnbWVudCRmaW5kQWxsO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0dmFyIGksIGxlbiwgaXRlbTtcblxuICBcdGlmICh0aGlzLml0ZW1zKSB7XG4gIFx0XHRsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRpdGVtID0gdGhpcy5pdGVtc1tpXTtcblxuICBcdFx0XHRpZiAoaXRlbS5maW5kQWxsKSB7XG4gIFx0XHRcdFx0aXRlbS5maW5kQWxsKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gcXVlcnk7XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX2ZpbmRBbGxDb21wb25lbnRzID0gRnJhZ21lbnQkZmluZEFsbENvbXBvbmVudHM7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0dmFyIGksIGxlbiwgaXRlbTtcblxuICBcdGlmICh0aGlzLml0ZW1zKSB7XG4gIFx0XHRsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRpdGVtID0gdGhpcy5pdGVtc1tpXTtcblxuICBcdFx0XHRpZiAoaXRlbS5maW5kQWxsQ29tcG9uZW50cykge1xuICBcdFx0XHRcdGl0ZW0uZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfZmluZENvbXBvbmVudCA9IEZyYWdtZW50JGZpbmRDb21wb25lbnQ7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkZmluZENvbXBvbmVudChzZWxlY3Rvcikge1xuICBcdHZhciBsZW4sIGksIGl0ZW0sIHF1ZXJ5UmVzdWx0O1xuXG4gIFx0aWYgKHRoaXMuaXRlbXMpIHtcbiAgXHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zW2ldO1xuXG4gIFx0XHRcdGlmIChpdGVtLmZpbmRDb21wb25lbnQgJiYgKHF1ZXJ5UmVzdWx0ID0gaXRlbS5maW5kQ29tcG9uZW50KHNlbGVjdG9yKSkpIHtcbiAgXHRcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9maW5kTmV4dE5vZGUgPSBGcmFnbWVudCRmaW5kTmV4dE5vZGU7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkZmluZE5leHROb2RlKGl0ZW0pIHtcbiAgXHR2YXIgaW5kZXggPSBpdGVtLmluZGV4LFxuICBcdCAgICBub2RlO1xuXG4gIFx0aWYgKHRoaXMuaXRlbXNbaW5kZXggKyAxXSkge1xuICBcdFx0bm9kZSA9IHRoaXMuaXRlbXNbaW5kZXggKyAxXS5maXJzdE5vZGUoKTtcbiAgXHR9XG5cbiAgXHQvLyBpZiB0aGlzIGlzIHRoZSByb290IGZyYWdtZW50LCBhbmQgdGhlcmUgYXJlIG5vIG1vcmUgaXRlbXMsXG4gIFx0Ly8gaXQgbWVhbnMgd2UncmUgYXQgdGhlIGVuZC4uLlxuICBcdGVsc2UgaWYgKHRoaXMub3duZXIgPT09IHRoaXMucm9vdCkge1xuICBcdFx0aWYgKCF0aGlzLm93bmVyLmNvbXBvbmVudCkge1xuICBcdFx0XHQvLyBUT0RPIGJ1dCBzb21ldGhpbmcgZWxzZSBjb3VsZCBoYXZlIGJlZW4gYXBwZW5kZWQgdG9cbiAgXHRcdFx0Ly8gdGhpcy5yb290LmVsLCBubz9cbiAgXHRcdFx0bm9kZSA9IG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIC4uLnVubGVzcyB0aGlzIGlzIGEgY29tcG9uZW50XG4gIFx0XHRlbHNlIHtcbiAgXHRcdFx0bm9kZSA9IHRoaXMub3duZXIuY29tcG9uZW50LmZpbmROZXh0Tm9kZSgpO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHRub2RlID0gdGhpcy5vd25lci5maW5kTmV4dE5vZGUodGhpcyk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG5vZGU7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2ZpcnN0Tm9kZSA9IEZyYWdtZW50JGZpcnN0Tm9kZTtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRmaXJzdE5vZGUoKSB7XG4gIFx0aWYgKHRoaXMuaXRlbXMgJiYgdGhpcy5pdGVtc1swXSkge1xuICBcdFx0cmV0dXJuIHRoaXMuaXRlbXNbMF0uZmlyc3ROb2RlKCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgc2hhcmVkX3Byb2Nlc3NJdGVtcyA9IHByb2Nlc3NJdGVtcztcblxuICBmdW5jdGlvbiBwcm9jZXNzSXRlbXMoaXRlbXMsIHZhbHVlcywgZ3VpZCwgY291bnRlcikge1xuICBcdGNvdW50ZXIgPSBjb3VudGVyIHx8IDA7XG5cbiAgXHRyZXR1cm4gaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gIFx0XHR2YXIgcGxhY2Vob2xkZXJJZCwgd3JhcHBlZCwgdmFsdWU7XG5cbiAgXHRcdGlmIChpdGVtLnRleHQpIHtcbiAgXHRcdFx0cmV0dXJuIGl0ZW0udGV4dDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGl0ZW0uZnJhZ21lbnRzKSB7XG4gIFx0XHRcdHJldHVybiBpdGVtLmZyYWdtZW50cy5tYXAoZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gIFx0XHRcdFx0cmV0dXJuIHByb2Nlc3NJdGVtcyhmcmFnbWVudC5pdGVtcywgdmFsdWVzLCBndWlkLCBjb3VudGVyKTtcbiAgXHRcdFx0fSkuam9pbihcIlwiKTtcbiAgXHRcdH1cblxuICBcdFx0cGxhY2Vob2xkZXJJZCA9IGd1aWQgKyBcIi1cIiArIGNvdW50ZXIrKztcblxuICBcdFx0aWYgKGl0ZW0ua2V5cGF0aCAmJiAod3JhcHBlZCA9IGl0ZW0ucm9vdC52aWV3bW9kZWwud3JhcHBlZFtpdGVtLmtleXBhdGguc3RyXSkpIHtcbiAgXHRcdFx0dmFsdWUgPSB3cmFwcGVkLnZhbHVlO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dmFsdWUgPSBpdGVtLmdldFZhbHVlKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHZhbHVlc1twbGFjZWhvbGRlcklkXSA9IHZhbHVlO1xuXG4gIFx0XHRyZXR1cm4gXCIke1wiICsgcGxhY2Vob2xkZXJJZCArIFwifVwiO1xuICBcdH0pLmpvaW4oXCJcIik7XG4gIH1cblxuICB2YXIgZ2V0QXJnc0xpc3QgPSBGcmFnbWVudCRnZXRBcmdzTGlzdDtcbiAgZnVuY3Rpb24gRnJhZ21lbnQkZ2V0QXJnc0xpc3QoKSB7XG4gIFx0dmFyIHZhbHVlcywgc291cmNlLCBwYXJzZWQsIHJlc3VsdDtcblxuICBcdGlmICh0aGlzLmRpcnR5QXJncykge1xuICBcdFx0c291cmNlID0gc2hhcmVkX3Byb2Nlc3NJdGVtcyh0aGlzLml0ZW1zLCB2YWx1ZXMgPSB7fSwgdGhpcy5yb290Ll9ndWlkKTtcbiAgXHRcdHBhcnNlZCA9IHBhcnNlSlNPTihcIltcIiArIHNvdXJjZSArIFwiXVwiLCB2YWx1ZXMpO1xuXG4gIFx0XHRpZiAoIXBhcnNlZCkge1xuICBcdFx0XHRyZXN1bHQgPSBbdGhpcy50b1N0cmluZygpXTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJlc3VsdCA9IHBhcnNlZC52YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5hcmdzTGlzdCA9IHJlc3VsdDtcbiAgXHRcdHRoaXMuZGlydHlBcmdzID0gZmFsc2U7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMuYXJnc0xpc3Q7XG4gIH1cblxuICB2YXIgZ2V0Tm9kZSA9IEZyYWdtZW50JGdldE5vZGU7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkZ2V0Tm9kZSgpIHtcbiAgXHR2YXIgZnJhZ21lbnQgPSB0aGlzO1xuXG4gIFx0ZG8ge1xuICBcdFx0aWYgKGZyYWdtZW50LnBFbGVtZW50KSB7XG4gIFx0XHRcdHJldHVybiBmcmFnbWVudC5wRWxlbWVudC5ub2RlO1xuICBcdFx0fVxuICBcdH0gd2hpbGUgKGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50KTtcblxuICBcdHJldHVybiB0aGlzLnJvb3QuZGV0YWNoZWQgfHwgdGhpcy5yb290LmVsO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9nZXRWYWx1ZSA9IEZyYWdtZW50JGdldFZhbHVlO1xuICBmdW5jdGlvbiBGcmFnbWVudCRnZXRWYWx1ZSgpIHtcbiAgXHR2YXIgdmFsdWVzLCBzb3VyY2UsIHBhcnNlZCwgcmVzdWx0O1xuXG4gIFx0aWYgKHRoaXMuZGlydHlWYWx1ZSkge1xuICBcdFx0c291cmNlID0gc2hhcmVkX3Byb2Nlc3NJdGVtcyh0aGlzLml0ZW1zLCB2YWx1ZXMgPSB7fSwgdGhpcy5yb290Ll9ndWlkKTtcbiAgXHRcdHBhcnNlZCA9IHBhcnNlSlNPTihzb3VyY2UsIHZhbHVlcyk7XG5cbiAgXHRcdGlmICghcGFyc2VkKSB7XG4gIFx0XHRcdHJlc3VsdCA9IHRoaXMudG9TdHJpbmcoKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJlc3VsdCA9IHBhcnNlZC52YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy52YWx1ZSA9IHJlc3VsdDtcbiAgXHRcdHRoaXMuZGlydHlWYWx1ZSA9IGZhbHNlO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG5cbiAgdmFyIHNoYXJlZF9kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIFx0cmV0dXJuIGRldGFjaE5vZGUodGhpcy5ub2RlKTtcbiAgfTtcblxuICB2YXIgVGV4dCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy50eXBlID0gVEVYVDtcbiAgXHR0aGlzLnRleHQgPSBvcHRpb25zLnRlbXBsYXRlO1xuICB9O1xuXG4gIFRleHQucHJvdG90eXBlID0ge1xuICBcdGRldGFjaDogc2hhcmVkX2RldGFjaCxcblxuICBcdGZpcnN0Tm9kZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMubm9kZTtcbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMubm9kZSkge1xuICBcdFx0XHR0aGlzLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuICBcdH0sXG5cbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKGVzY2FwZSkge1xuICBcdFx0cmV0dXJuIGVzY2FwZSA/IGVzY2FwZUh0bWwodGhpcy50ZXh0KSA6IHRoaXMudGV4dDtcbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHRpZiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5kZXRhY2goKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIGl0ZW1zX1RleHQgPSBUZXh0O1xuXG4gIHZhciBzaGFyZWRfdW5iaW5kID0gc2hhcmVkX3VuYmluZF9fdW5iaW5kO1xuXG4gIGZ1bmN0aW9uIHNoYXJlZF91bmJpbmRfX3VuYmluZCgpIHtcbiAgXHRpZiAodGhpcy5yZWdpc3RlcmVkKSB7XG4gIFx0XHQvLyB0aGlzIHdhcyByZWdpc3RlcmVkIGFzIGEgZGVwZW5kYW50XG4gIFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnVucmVnaXN0ZXIodGhpcy5rZXlwYXRoLCB0aGlzKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5yZXNvbHZlcikge1xuICBcdFx0dGhpcy5yZXNvbHZlci51bmJpbmQoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgTXVzdGFjaGVfZ2V0VmFsdWUgPSBNdXN0YWNoZSRnZXRWYWx1ZTtcblxuICBmdW5jdGlvbiBNdXN0YWNoZSRnZXRWYWx1ZSgpIHtcbiAgXHRyZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxuXG4gIHZhciBSZWZlcmVuY2VSZXNvbHZlciA9IGZ1bmN0aW9uIChvd25lciwgcmVmLCBjYWxsYmFjaykge1xuICBcdHZhciBrZXlwYXRoO1xuXG4gIFx0dGhpcy5yZWYgPSByZWY7XG4gIFx0dGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xuXG4gIFx0dGhpcy5yb290ID0gb3duZXIucm9vdDtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gb3duZXIucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gIFx0a2V5cGF0aCA9IHNoYXJlZF9yZXNvbHZlUmVmKG93bmVyLnJvb3QsIHJlZiwgb3duZXIucGFyZW50RnJhZ21lbnQpO1xuICBcdGlmIChrZXlwYXRoICE9IHVuZGVmaW5lZCkge1xuICBcdFx0dGhpcy5yZXNvbHZlKGtleXBhdGgpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5hZGRVbnJlc29sdmVkKHRoaXMpO1xuICBcdH1cbiAgfTtcblxuICBSZWZlcmVuY2VSZXNvbHZlci5wcm90b3R5cGUgPSB7XG4gIFx0cmVzb2x2ZTogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdGlmICh0aGlzLmtleXBhdGggJiYgIWtleXBhdGgpIHtcbiAgXHRcdFx0Ly8gaXQgd2FzIHJlc29sdmVkLCBhbmQgbm93IGl0J3Mgbm90LiBDYW4gaGFwcGVuIGlmIGUuZy4gYGJhcmAgaW5cbiAgXHRcdFx0Ly8gYHt7Zm9vW2Jhcl19fWAgYmVjb21lcyB1bmRlZmluZWRcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVW5yZXNvbHZlZCh0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5yZXNvbHZlZCA9IHRydWU7XG5cbiAgXHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0XHR0aGlzLmNhbGxiYWNrKGtleXBhdGgpO1xuICBcdH0sXG5cbiAgXHRmb3JjZVJlc29sdXRpb246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMucmVzb2x2ZShnZXRLZXlwYXRoKHRoaXMucmVmKSk7XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdHZhciBrZXlwYXRoO1xuXG4gIFx0XHRpZiAodGhpcy5rZXlwYXRoICE9IHVuZGVmaW5lZCkge1xuICBcdFx0XHRrZXlwYXRoID0gdGhpcy5rZXlwYXRoLnJlcGxhY2Uob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHRcdC8vIHdhcyBhIG5ldyBrZXlwYXRoIGNyZWF0ZWQ/XG4gIFx0XHRcdGlmIChrZXlwYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHQvLyByZXNvbHZlIGl0XG4gIFx0XHRcdFx0dGhpcy5yZXNvbHZlKGtleXBhdGgpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLnJlc29sdmVkKSB7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLnJlbW92ZVVucmVzb2x2ZWQodGhpcyk7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBSZXNvbHZlcnNfUmVmZXJlbmNlUmVzb2x2ZXIgPSBSZWZlcmVuY2VSZXNvbHZlcjtcblxuICB2YXIgU3BlY2lhbFJlc29sdmVyID0gZnVuY3Rpb24gKG93bmVyLCByZWYsIGNhbGxiYWNrKSB7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IG93bmVyLnBhcmVudEZyYWdtZW50O1xuICBcdHRoaXMucmVmID0gcmVmO1xuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICBcdHRoaXMucmViaW5kKCk7XG4gIH07XG5cbiAgdmFyIHByb3BzID0ge1xuICBcdFwiQGtleXBhdGhcIjogeyBwcmVmaXg6IFwiY1wiLCBwcm9wOiBbXCJjb250ZXh0XCJdIH0sXG4gIFx0XCJAaW5kZXhcIjogeyBwcmVmaXg6IFwiaVwiLCBwcm9wOiBbXCJpbmRleFwiXSB9LFxuICBcdFwiQGtleVwiOiB7IHByZWZpeDogXCJrXCIsIHByb3A6IFtcImtleVwiLCBcImluZGV4XCJdIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRQcm9wKHRhcmdldCwgcHJvcCkge1xuICBcdHZhciB2YWx1ZTtcbiAgXHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3AucHJvcC5sZW5ndGg7IGkrKykge1xuICBcdFx0aWYgKCh2YWx1ZSA9IHRhcmdldFtwcm9wLnByb3BbaV1dKSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHJldHVybiB2YWx1ZTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBTcGVjaWFsUmVzb2x2ZXIucHJvdG90eXBlID0ge1xuICBcdHJlYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHJlZiA9IHRoaXMucmVmLFxuICBcdFx0ICAgIGZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudCxcbiAgXHRcdCAgICBwcm9wID0gcHJvcHNbcmVmXSxcbiAgXHRcdCAgICB2YWx1ZTtcblxuICBcdFx0aWYgKCFwcm9wKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlVua25vd24gc3BlY2lhbCByZWZlcmVuY2UgXFxcIlwiICsgcmVmICsgXCJcXFwiIC0gdmFsaWQgcmVmZXJlbmNlcyBhcmUgQGluZGV4LCBAa2V5IGFuZCBAa2V5cGF0aFwiKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gaGF2ZSB3ZSBhbHJlYWR5IGZvdW5kIHRoZSBuZWFyZXN0IHBhcmVudD9cbiAgXHRcdGlmICh0aGlzLmNhY2hlZCkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5jYWxsYmFjayhnZXRLZXlwYXRoKFwiQFwiICsgcHJvcC5wcmVmaXggKyBnZXRQcm9wKHRoaXMuY2FjaGVkLCBwcm9wKSkpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgZm9yIGluZGljZXMsIHdoaWNoIG1heSBjcm9zcyBjb21wb25lbnQgYm91bmRhcmllc1xuICBcdFx0aWYgKHByb3AucHJvcC5pbmRleE9mKFwiaW5kZXhcIikgIT09IC0xIHx8IHByb3AucHJvcC5pbmRleE9mKFwia2V5XCIpICE9PSAtMSkge1xuICBcdFx0XHR3aGlsZSAoZnJhZ21lbnQpIHtcbiAgXHRcdFx0XHRpZiAoZnJhZ21lbnQub3duZXIuY3VycmVudFN1YnR5cGUgPT09IFNFQ1RJT05fRUFDSCAmJiAodmFsdWUgPSBnZXRQcm9wKGZyYWdtZW50LCBwcm9wKSkgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdFx0dGhpcy5jYWNoZWQgPSBmcmFnbWVudDtcblxuICBcdFx0XHRcdFx0ZnJhZ21lbnQucmVnaXN0ZXJJbmRleFJlZih0aGlzKTtcblxuICBcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY2FsbGJhY2soZ2V0S2V5cGF0aChcIkBcIiArIHByb3AucHJlZml4ICsgdmFsdWUpKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHQvLyB3YXRjaCBmb3IgY29tcG9uZW50IGJvdW5kYXJpZXNcbiAgXHRcdFx0XHRpZiAoIWZyYWdtZW50LnBhcmVudCAmJiBmcmFnbWVudC5vd25lciAmJiBmcmFnbWVudC5vd25lci5jb21wb25lbnQgJiYgZnJhZ21lbnQub3duZXIuY29tcG9uZW50LnBhcmVudEZyYWdtZW50ICYmICFmcmFnbWVudC5vd25lci5jb21wb25lbnQuaW5zdGFuY2UuaXNvbGF0ZWQpIHtcbiAgXHRcdFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQub3duZXIuY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudDtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHdoaWxlIChmcmFnbWVudCkge1xuICBcdFx0XHRcdGlmICgodmFsdWUgPSBnZXRQcm9wKGZyYWdtZW50LCBwcm9wKSkgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY2FsbGJhY2soZ2V0S2V5cGF0aChcIkBcIiArIHByb3AucHJlZml4ICsgdmFsdWUuc3RyKSk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQ7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5jYWNoZWQpIHtcbiAgXHRcdFx0dGhpcy5jYWNoZWQudW5yZWdpc3RlckluZGV4UmVmKHRoaXMpO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgUmVzb2x2ZXJzX1NwZWNpYWxSZXNvbHZlciA9IFNwZWNpYWxSZXNvbHZlcjtcblxuICB2YXIgSW5kZXhSZXNvbHZlciA9IGZ1bmN0aW9uIChvd25lciwgcmVmLCBjYWxsYmFjaykge1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBvd25lci5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLnJlZiA9IHJlZjtcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgXHRyZWYucmVmLmZyYWdtZW50LnJlZ2lzdGVySW5kZXhSZWYodGhpcyk7XG5cbiAgXHR0aGlzLnJlYmluZCgpO1xuICB9O1xuXG4gIEluZGV4UmVzb2x2ZXIucHJvdG90eXBlID0ge1xuICBcdHJlYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGluZGV4LFxuICBcdFx0ICAgIHJlZiA9IHRoaXMucmVmLnJlZjtcblxuICBcdFx0aWYgKHJlZi5yZWYudCA9PT0gXCJrXCIpIHtcbiAgXHRcdFx0aW5kZXggPSBcImtcIiArIHJlZi5mcmFnbWVudC5rZXk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRpbmRleCA9IFwiaVwiICsgcmVmLmZyYWdtZW50LmluZGV4O1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0aGlzLmNhbGxiYWNrKGdldEtleXBhdGgoXCJAXCIgKyBpbmRleCkpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMucmVmLnJlZi5mcmFnbWVudC51bnJlZ2lzdGVySW5kZXhSZWYodGhpcyk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBSZXNvbHZlcnNfSW5kZXhSZXNvbHZlciA9IEluZGV4UmVzb2x2ZXI7XG5cbiAgdmFyIFJlc29sdmVyc19maW5kSW5kZXhSZWZzID0gZmluZEluZGV4UmVmcztcblxuICBmdW5jdGlvbiBmaW5kSW5kZXhSZWZzKGZyYWdtZW50LCByZWZOYW1lKSB7XG4gIFx0dmFyIHJlc3VsdCA9IHt9LFxuICBcdCAgICByZWZzLFxuICBcdCAgICBmcmFnUmVmcyxcbiAgXHQgICAgcmVmLFxuICBcdCAgICBpLFxuICBcdCAgICBvd25lcixcbiAgXHQgICAgaGl0ID0gZmFsc2U7XG5cbiAgXHRpZiAoIXJlZk5hbWUpIHtcbiAgXHRcdHJlc3VsdC5yZWZzID0gcmVmcyA9IHt9O1xuICBcdH1cblxuICBcdHdoaWxlIChmcmFnbWVudCkge1xuICBcdFx0aWYgKChvd25lciA9IGZyYWdtZW50Lm93bmVyKSAmJiAoZnJhZ1JlZnMgPSBvd25lci5pbmRleFJlZnMpKSB7XG5cbiAgXHRcdFx0Ly8gd2UncmUgbG9va2luZyBmb3IgYSBwYXJ0aWN1bGFyIHJlZiwgYW5kIGl0J3MgaGVyZVxuICBcdFx0XHRpZiAocmVmTmFtZSAmJiAocmVmID0gb3duZXIuZ2V0SW5kZXhSZWYocmVmTmFtZSkpKSB7XG4gIFx0XHRcdFx0cmVzdWx0LnJlZiA9IHtcbiAgXHRcdFx0XHRcdGZyYWdtZW50OiBmcmFnbWVudCxcbiAgXHRcdFx0XHRcdHJlZjogcmVmXG4gIFx0XHRcdFx0fTtcbiAgXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gd2UncmUgY29sbGVjdGluZyByZWZzIHVwLXRyZWVcbiAgXHRcdFx0ZWxzZSBpZiAoIXJlZk5hbWUpIHtcbiAgXHRcdFx0XHRmb3IgKGkgaW4gZnJhZ1JlZnMpIHtcbiAgXHRcdFx0XHRcdHJlZiA9IGZyYWdSZWZzW2ldO1xuXG4gIFx0XHRcdFx0XHQvLyBkb24ndCBvdmVyd3JpdGUgZXhpc3RpbmcgcmVmcyAtIHRoZXkgc2hvdWxkIHNoYWRvdyBwYXJlbnRzXG4gIFx0XHRcdFx0XHRpZiAoIXJlZnNbcmVmLm5dKSB7XG4gIFx0XHRcdFx0XHRcdGhpdCA9IHRydWU7XG4gIFx0XHRcdFx0XHRcdHJlZnNbcmVmLm5dID0ge1xuICBcdFx0XHRcdFx0XHRcdGZyYWdtZW50OiBmcmFnbWVudCxcbiAgXHRcdFx0XHRcdFx0XHRyZWY6IHJlZlxuICBcdFx0XHRcdFx0XHR9O1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyB3YXRjaCBmb3IgY29tcG9uZW50IGJvdW5kYXJpZXNcbiAgXHRcdGlmICghZnJhZ21lbnQucGFyZW50ICYmIGZyYWdtZW50Lm93bmVyICYmIGZyYWdtZW50Lm93bmVyLmNvbXBvbmVudCAmJiBmcmFnbWVudC5vd25lci5jb21wb25lbnQucGFyZW50RnJhZ21lbnQgJiYgIWZyYWdtZW50Lm93bmVyLmNvbXBvbmVudC5pbnN0YW5jZS5pc29sYXRlZCkge1xuICBcdFx0XHRyZXN1bHQuY29tcG9uZW50Qm91bmRhcnkgPSB0cnVlO1xuICBcdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50Lm93bmVyLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50O1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICghaGl0KSB7XG4gIFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdH1cbiAgfVxuXG4gIGZpbmRJbmRleFJlZnMucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoaW5kaWNlcykge1xuICBcdHZhciByZWZzID0ge30sXG4gIFx0ICAgIGssXG4gIFx0ICAgIHJlZjtcblxuICBcdGZvciAoayBpbiBpbmRpY2VzLnJlZnMpIHtcbiAgXHRcdHJlZiA9IGluZGljZXMucmVmc1trXTtcbiAgXHRcdHJlZnNbcmVmLnJlZi5uXSA9IHJlZi5yZWYudCA9PT0gXCJrXCIgPyByZWYuZnJhZ21lbnQua2V5IDogcmVmLmZyYWdtZW50LmluZGV4O1xuICBcdH1cblxuICBcdHJldHVybiByZWZzO1xuICB9O1xuXG4gIHZhciBSZXNvbHZlcnNfY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIgPSBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlcjtcbiAgZnVuY3Rpb24gY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIob3duZXIsIHJlZiwgY2FsbGJhY2spIHtcbiAgXHR2YXIgaW5kZXhSZWY7XG5cbiAgXHRpZiAocmVmLmNoYXJBdCgwKSA9PT0gXCJAXCIpIHtcbiAgXHRcdHJldHVybiBuZXcgUmVzb2x2ZXJzX1NwZWNpYWxSZXNvbHZlcihvd25lciwgcmVmLCBjYWxsYmFjayk7XG4gIFx0fVxuXG4gIFx0aWYgKGluZGV4UmVmID0gUmVzb2x2ZXJzX2ZpbmRJbmRleFJlZnMob3duZXIucGFyZW50RnJhZ21lbnQsIHJlZikpIHtcbiAgXHRcdHJldHVybiBuZXcgUmVzb2x2ZXJzX0luZGV4UmVzb2x2ZXIob3duZXIsIGluZGV4UmVmLCBjYWxsYmFjayk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG5ldyBSZXNvbHZlcnNfUmVmZXJlbmNlUmVzb2x2ZXIob3duZXIsIHJlZiwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIHNoYXJlZF9nZXRGdW5jdGlvbkZyb21TdHJpbmcgPSBnZXRGdW5jdGlvbkZyb21TdHJpbmc7XG4gIHZhciBjYWNoZSA9IHt9O1xuICBmdW5jdGlvbiBnZXRGdW5jdGlvbkZyb21TdHJpbmcoc3RyLCBpKSB7XG4gIFx0dmFyIGZuLCBhcmdzO1xuXG4gIFx0aWYgKGNhY2hlW3N0cl0pIHtcbiAgXHRcdHJldHVybiBjYWNoZVtzdHJdO1xuICBcdH1cblxuICBcdGFyZ3MgPSBbXTtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRhcmdzW2ldID0gXCJfXCIgKyBpO1xuICBcdH1cblxuICBcdGZuID0gbmV3IEZ1bmN0aW9uKGFyZ3Muam9pbihcIixcIiksIFwicmV0dXJuKFwiICsgc3RyICsgXCIpXCIpO1xuXG4gIFx0Y2FjaGVbc3RyXSA9IGZuO1xuICBcdHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciBFeHByZXNzaW9uUmVzb2x2ZXIsXG4gICAgICBSZXNvbHZlcnNfRXhwcmVzc2lvblJlc29sdmVyX19iaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQ7XG5cbiAgRXhwcmVzc2lvblJlc29sdmVyID0gZnVuY3Rpb24gKG93bmVyLCBwYXJlbnRGcmFnbWVudCwgZXhwcmVzc2lvbiwgY2FsbGJhY2spIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIHJhY3RpdmU7XG5cbiAgXHRyYWN0aXZlID0gb3duZXIucm9vdDtcblxuICBcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IHBhcmVudEZyYWdtZW50O1xuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgXHR0aGlzLm93bmVyID0gb3duZXI7XG4gIFx0dGhpcy5zdHIgPSBleHByZXNzaW9uLnM7XG4gIFx0dGhpcy5rZXlwYXRocyA9IFtdO1xuXG4gIFx0Ly8gQ3JlYXRlIHJlc29sdmVycyBmb3IgZWFjaCByZWZlcmVuY2VcbiAgXHR0aGlzLnBlbmRpbmcgPSBleHByZXNzaW9uLnIubGVuZ3RoO1xuICBcdHRoaXMucmVmUmVzb2x2ZXJzID0gZXhwcmVzc2lvbi5yLm1hcChmdW5jdGlvbiAocmVmLCBpKSB7XG4gIFx0XHRyZXR1cm4gUmVzb2x2ZXJzX2NyZWF0ZVJlZmVyZW5jZVJlc29sdmVyKF90aGlzLCByZWYsIGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdF90aGlzLnJlc29sdmUoaSwga2V5cGF0aCk7XG4gIFx0XHR9KTtcbiAgXHR9KTtcblxuICBcdHRoaXMucmVhZHkgPSB0cnVlO1xuICBcdHRoaXMuYnViYmxlKCk7XG4gIH07XG5cbiAgRXhwcmVzc2lvblJlc29sdmVyLnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5yZWFkeSkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMudW5pcXVlU3RyaW5nID0gZ2V0VW5pcXVlU3RyaW5nKHRoaXMuc3RyLCB0aGlzLmtleXBhdGhzKTtcbiAgXHRcdHRoaXMua2V5cGF0aCA9IGNyZWF0ZUV4cHJlc3Npb25LZXlwYXRoKHRoaXMudW5pcXVlU3RyaW5nKTtcblxuICBcdFx0dGhpcy5jcmVhdGVFdmFsdWF0b3IoKTtcbiAgXHRcdHRoaXMuY2FsbGJhY2sodGhpcy5rZXlwYXRoKTtcbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcmVzb2x2ZXI7XG5cbiAgXHRcdHdoaWxlIChyZXNvbHZlciA9IHRoaXMucmVmUmVzb2x2ZXJzLnBvcCgpKSB7XG4gIFx0XHRcdHJlc29sdmVyLnVuYmluZCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZXNvbHZlOiBmdW5jdGlvbiAoaW5kZXgsIGtleXBhdGgpIHtcbiAgXHRcdHRoaXMua2V5cGF0aHNbaW5kZXhdID0ga2V5cGF0aDtcbiAgXHRcdHRoaXMuYnViYmxlKCk7XG4gIFx0fSxcblxuICBcdGNyZWF0ZUV2YWx1YXRvcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0dmFyIGNvbXB1dGF0aW9uLCB2YWx1ZUdldHRlcnMsIHNpZ25hdHVyZSwga2V5cGF0aCwgZm47XG5cbiAgXHRcdGtleXBhdGggPSB0aGlzLmtleXBhdGg7XG4gIFx0XHRjb21wdXRhdGlvbiA9IHRoaXMucm9vdC52aWV3bW9kZWwuY29tcHV0YXRpb25zW2tleXBhdGguc3RyXTtcblxuICBcdFx0Ly8gb25seSBpZiBpdCBkb2Vzbid0IGV4aXN0IHlldCFcbiAgXHRcdGlmICghY29tcHV0YXRpb24pIHtcbiAgXHRcdFx0Zm4gPSBzaGFyZWRfZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nKHRoaXMuc3RyLCB0aGlzLnJlZlJlc29sdmVycy5sZW5ndGgpO1xuXG4gIFx0XHRcdHZhbHVlR2V0dGVycyA9IHRoaXMua2V5cGF0aHMubWFwKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdFx0dmFyIHZhbHVlO1xuXG4gIFx0XHRcdFx0aWYgKGtleXBhdGggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG4gIFx0XHRcdFx0XHR9O1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdC8vICdzcGVjaWFsJyBrZXlwYXRocyBlbmNvZGUgYSB2YWx1ZVxuICBcdFx0XHRcdGlmIChrZXlwYXRoLmlzU3BlY2lhbCkge1xuICBcdFx0XHRcdFx0dmFsdWUgPSBrZXlwYXRoLnZhbHVlO1xuICBcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuICBcdFx0XHRcdFx0fTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0dmFyIHZhbHVlID0gX3RoaXMucm9vdC52aWV3bW9kZWwuZ2V0KGtleXBhdGgsIHsgbm9VbndyYXA6IHRydWUsIGZ1bGxSb290R2V0OiB0cnVlIH0pO1xuICBcdFx0XHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdFx0XHRcdHZhbHVlID0gd3JhcEZ1bmN0aW9uKHZhbHVlLCBfdGhpcy5yb290KTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcbiAgXHRcdFx0XHR9O1xuICBcdFx0XHR9KTtcblxuICBcdFx0XHRzaWduYXR1cmUgPSB7XG4gIFx0XHRcdFx0ZGVwczogdGhpcy5rZXlwYXRocy5maWx0ZXIoaXNWYWxpZERlcGVuZGVuY3kpLFxuICBcdFx0XHRcdGdldHRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0dmFyIGFyZ3MgPSB2YWx1ZUdldHRlcnMubWFwKGNhbGwpO1xuICBcdFx0XHRcdFx0cmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fTtcblxuICBcdFx0XHRjb21wdXRhdGlvbiA9IHRoaXMucm9vdC52aWV3bW9kZWwuY29tcHV0ZShrZXlwYXRoLCBzaWduYXR1cmUpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5tYXJrKGtleXBhdGgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHQvLyBUT0RPIG9ubHkgYnViYmxlIG9uY2UsIG5vIG1hdHRlciBob3cgbWFueSByZWZlcmVuY2VzIGFyZSBhZmZlY3RlZCBieSB0aGUgcmViaW5kXG4gIFx0XHR0aGlzLnJlZlJlc29sdmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gIFx0XHRcdHJldHVybiByLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdH0pO1xuICBcdH1cbiAgfTtcblxuICB2YXIgUmVzb2x2ZXJzX0V4cHJlc3Npb25SZXNvbHZlciA9IEV4cHJlc3Npb25SZXNvbHZlcjtcblxuICBmdW5jdGlvbiBjYWxsKHZhbHVlKSB7XG4gIFx0cmV0dXJuIHZhbHVlLmNhbGwoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFVuaXF1ZVN0cmluZyhzdHIsIGtleXBhdGhzKSB7XG4gIFx0Ly8gZ2V0IHN0cmluZyB0aGF0IGlzIHVuaXF1ZSB0byB0aGlzIGV4cHJlc3Npb25cbiAgXHRyZXR1cm4gc3RyLnJlcGxhY2UoL18oWzAtOV0rKS9nLCBmdW5jdGlvbiAobWF0Y2gsICQxKSB7XG4gIFx0XHR2YXIga2V5cGF0aCwgdmFsdWU7XG5cbiAgXHRcdC8vIG1ha2Ugc3VyZSB3ZSdyZSBub3QgcmVwbGFjaW5nIGEgbm9uLWtleXBhdGggX1swLTldXG4gIFx0XHRpZiAoKyQxID49IGtleXBhdGhzLmxlbmd0aCkge1xuICBcdFx0XHRyZXR1cm4gXCJfXCIgKyAkMTtcbiAgXHRcdH1cblxuICBcdFx0a2V5cGF0aCA9IGtleXBhdGhzWyQxXTtcblxuICBcdFx0aWYgKGtleXBhdGggPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRyZXR1cm4gXCJ1bmRlZmluZWRcIjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGtleXBhdGguaXNTcGVjaWFsKSB7XG4gIFx0XHRcdHZhbHVlID0ga2V5cGF0aC52YWx1ZTtcbiAgXHRcdFx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiA/IHZhbHVlIDogXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ga2V5cGF0aC5zdHI7XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFeHByZXNzaW9uS2V5cGF0aCh1bmlxdWVTdHJpbmcpIHtcbiAgXHQvLyBTYW5pdGl6ZSBieSByZW1vdmluZyBhbnkgcGVyaW9kcyBvciBzcXVhcmUgYnJhY2tldHMuIE90aGVyd2lzZVxuICBcdC8vIHdlIGNhbid0IHNwbGl0IHRoZSBrZXlwYXRoIGludG8ga2V5cyFcbiAgXHQvLyBSZW1vdmUgYXN0ZXJpc2tzIHRvbywgc2luY2UgdGhleSBtZXNzIHdpdGggcGF0dGVybiBvYnNlcnZlcnNcbiAgXHRyZXR1cm4gZ2V0S2V5cGF0aChcIiR7XCIgKyB1bmlxdWVTdHJpbmcucmVwbGFjZSgvW1xcLlxcW1xcXV0vZywgXCItXCIpLnJlcGxhY2UoL1xcKi8sIFwiI01VTCNcIikgKyBcIn1cIik7XG4gIH1cblxuICBmdW5jdGlvbiBpc1ZhbGlkRGVwZW5kZW5jeShrZXlwYXRoKSB7XG4gIFx0cmV0dXJuIGtleXBhdGggIT09IHVuZGVmaW5lZCAmJiBrZXlwYXRoWzBdICE9PSBcIkBcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBGdW5jdGlvbihmbiwgcmFjdGl2ZSkge1xuICBcdHZhciB3cmFwcGVkLCBwcm9wLCBrZXk7XG5cbiAgXHRpZiAoZm4uX19yYWN0aXZlX25vd3JhcCkge1xuICBcdFx0cmV0dXJuIGZuO1xuICBcdH1cblxuICBcdHByb3AgPSBcIl9fcmFjdGl2ZV9cIiArIHJhY3RpdmUuX2d1aWQ7XG4gIFx0d3JhcHBlZCA9IGZuW3Byb3BdO1xuXG4gIFx0aWYgKHdyYXBwZWQpIHtcbiAgXHRcdHJldHVybiB3cmFwcGVkO1xuICBcdH0gZWxzZSBpZiAoL3RoaXMvLnRlc3QoZm4udG9TdHJpbmcoKSkpIHtcbiAgXHRcdGRlZmluZVByb3BlcnR5KGZuLCBwcm9wLCB7XG4gIFx0XHRcdHZhbHVlOiBSZXNvbHZlcnNfRXhwcmVzc2lvblJlc29sdmVyX19iaW5kLmNhbGwoZm4sIHJhY3RpdmUpLFxuICBcdFx0XHRjb25maWd1cmFibGU6IHRydWVcbiAgXHRcdH0pO1xuXG4gIFx0XHQvLyBBZGQgcHJvcGVydGllcy9tZXRob2RzIHRvIHdyYXBwZWQgZnVuY3Rpb25cbiAgXHRcdGZvciAoa2V5IGluIGZuKSB7XG4gIFx0XHRcdGlmIChmbi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gIFx0XHRcdFx0Zm5bcHJvcF1ba2V5XSA9IGZuW2tleV07XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmFjdGl2ZS5fYm91bmRGdW5jdGlvbnMucHVzaCh7XG4gIFx0XHRcdGZuOiBmbixcbiAgXHRcdFx0cHJvcDogcHJvcFxuICBcdFx0fSk7XG5cbiAgXHRcdHJldHVybiBmbltwcm9wXTtcbiAgXHR9XG5cbiAgXHRkZWZpbmVQcm9wZXJ0eShmbiwgXCJfX3JhY3RpdmVfbm93cmFwXCIsIHtcbiAgXHRcdHZhbHVlOiBmblxuICBcdH0pO1xuXG4gIFx0cmV0dXJuIGZuLl9fcmFjdGl2ZV9ub3dyYXA7XG4gIH1cblxuICB2YXIgTWVtYmVyUmVzb2x2ZXIgPSBmdW5jdGlvbiAodGVtcGxhdGUsIHJlc29sdmVyLCBwYXJlbnRGcmFnbWVudCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR0aGlzLnJlc29sdmVyID0gcmVzb2x2ZXI7XG4gIFx0dGhpcy5yb290ID0gcmVzb2x2ZXIucm9vdDtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gcGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy52aWV3bW9kZWwgPSByZXNvbHZlci5yb290LnZpZXdtb2RlbDtcblxuICBcdGlmICh0eXBlb2YgdGVtcGxhdGUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHRoaXMudmFsdWUgPSB0ZW1wbGF0ZTtcbiAgXHR9XG5cbiAgXHQvLyBTaW1wbGUgcmVmZXJlbmNlP1xuICBcdGVsc2UgaWYgKHRlbXBsYXRlLnQgPT09IFJFRkVSRU5DRSkge1xuICBcdFx0dGhpcy5yZWZSZXNvbHZlciA9IFJlc29sdmVyc19jcmVhdGVSZWZlcmVuY2VSZXNvbHZlcih0aGlzLCB0ZW1wbGF0ZS5uLCBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRfdGhpcy5yZXNvbHZlKGtleXBhdGgpO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0Ly8gT3RoZXJ3aXNlIHdlIGhhdmUgYW4gZXhwcmVzc2lvbiBpbiBpdHMgb3duIHJpZ2h0XG4gIFx0ZWxzZSB7XG4gIFx0XHRuZXcgUmVzb2x2ZXJzX0V4cHJlc3Npb25SZXNvbHZlcihyZXNvbHZlciwgcGFyZW50RnJhZ21lbnQsIHRlbXBsYXRlLCBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRfdGhpcy5yZXNvbHZlKGtleXBhdGgpO1xuICBcdFx0fSk7XG4gIFx0fVxuICB9O1xuXG4gIE1lbWJlclJlc29sdmVyLnByb3RvdHlwZSA9IHtcbiAgXHRyZXNvbHZlOiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0aWYgKHRoaXMua2V5cGF0aCkge1xuICBcdFx0XHR0aGlzLnZpZXdtb2RlbC51bnJlZ2lzdGVyKHRoaXMua2V5cGF0aCwgdGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0XHR0aGlzLnZhbHVlID0gdGhpcy52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuXG4gIFx0XHR0aGlzLmJpbmQoKTtcblxuICBcdFx0dGhpcy5yZXNvbHZlci5idWJibGUoKTtcbiAgXHR9LFxuXG4gIFx0YmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy52aWV3bW9kZWwucmVnaXN0ZXIodGhpcy5rZXlwYXRoLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0aWYgKHRoaXMucmVmUmVzb2x2ZXIpIHtcbiAgXHRcdFx0dGhpcy5yZWZSZXNvbHZlci5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgXHRcdHRoaXMucmVzb2x2ZXIuYnViYmxlKCk7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMua2V5cGF0aCkge1xuICBcdFx0XHR0aGlzLnZpZXdtb2RlbC51bnJlZ2lzdGVyKHRoaXMua2V5cGF0aCwgdGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLnJlZlJlc29sdmVyKSB7XG4gIFx0XHRcdHRoaXMucmVmUmVzb2x2ZXIudW5iaW5kKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGZvcmNlUmVzb2x1dGlvbjogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMucmVmUmVzb2x2ZXIpIHtcbiAgXHRcdFx0dGhpcy5yZWZSZXNvbHZlci5mb3JjZVJlc29sdXRpb24oKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9NZW1iZXJSZXNvbHZlciA9IE1lbWJlclJlc29sdmVyO1xuXG4gIHZhciBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIgPSBmdW5jdGlvbiAobXVzdGFjaGUsIHRlbXBsYXRlLCBjYWxsYmFjaykge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgcmFjdGl2ZSwgcmVmLCBrZXlwYXRoLCBwYXJlbnRGcmFnbWVudDtcblxuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudCA9IG11c3RhY2hlLnBhcmVudEZyYWdtZW50O1xuICBcdHRoaXMucm9vdCA9IHJhY3RpdmUgPSBtdXN0YWNoZS5yb290O1xuICBcdHRoaXMubXVzdGFjaGUgPSBtdXN0YWNoZTtcblxuICBcdHRoaXMucmVmID0gcmVmID0gdGVtcGxhdGUucjtcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgXHR0aGlzLnVucmVzb2x2ZWQgPSBbXTtcblxuICBcdC8vIEZpbmQgYmFzZSBrZXlwYXRoXG4gIFx0aWYgKGtleXBhdGggPSBzaGFyZWRfcmVzb2x2ZVJlZihyYWN0aXZlLCByZWYsIHBhcmVudEZyYWdtZW50KSkge1xuICBcdFx0dGhpcy5iYXNlID0ga2V5cGF0aDtcbiAgXHR9IGVsc2Uge1xuICBcdFx0dGhpcy5iYXNlUmVzb2x2ZXIgPSBuZXcgUmVzb2x2ZXJzX1JlZmVyZW5jZVJlc29sdmVyKHRoaXMsIHJlZiwgZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0X3RoaXMuYmFzZSA9IGtleXBhdGg7XG4gIFx0XHRcdF90aGlzLmJhc2VSZXNvbHZlciA9IG51bGw7XG4gIFx0XHRcdF90aGlzLmJ1YmJsZSgpO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0Ly8gRmluZCB2YWx1ZXMgZm9yIG1lbWJlcnMsIG9yIG1hcmsgdGhlbSBhcyB1bnJlc29sdmVkXG4gIFx0dGhpcy5tZW1iZXJzID0gdGVtcGxhdGUubS5tYXAoZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gIFx0XHRyZXR1cm4gbmV3IFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9NZW1iZXJSZXNvbHZlcih0ZW1wbGF0ZSwgX3RoaXMsIHBhcmVudEZyYWdtZW50KTtcbiAgXHR9KTtcblxuICBcdHRoaXMucmVhZHkgPSB0cnVlO1xuICBcdHRoaXMuYnViYmxlKCk7IC8vIHRyaWdnZXIgaW5pdGlhbCByZXNvbHV0aW9uIGlmIHBvc3NpYmxlXG4gIH07XG5cbiAgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyLnByb3RvdHlwZSA9IHtcbiAgXHRnZXRLZXlwYXRoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgdmFsdWVzID0gdGhpcy5tZW1iZXJzLm1hcChSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXJfUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX19nZXRWYWx1ZSk7XG5cbiAgXHRcdGlmICghdmFsdWVzLmV2ZXJ5KGlzRGVmaW5lZCkgfHwgdGhpcy5iYXNlUmVzb2x2ZXIpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzLmJhc2Uuam9pbih2YWx1ZXMuam9pbihcIi5cIikpO1xuICBcdH0sXG5cbiAgXHRidWJibGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5yZWFkeSB8fCB0aGlzLmJhc2VSZXNvbHZlcikge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuY2FsbGJhY2sodGhpcy5nZXRLZXlwYXRoKCkpO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMubWVtYmVycy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdHZhciBjaGFuZ2VkO1xuXG4gIFx0XHRpZiAodGhpcy5iYXNlKSB7XG4gIFx0XHRcdHZhciBuZXdCYXNlID0gdGhpcy5iYXNlLnJlcGxhY2Uob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHRcdGlmIChuZXdCYXNlICYmIG5ld0Jhc2UgIT09IHRoaXMuYmFzZSkge1xuICBcdFx0XHRcdHRoaXMuYmFzZSA9IG5ld0Jhc2U7XG4gIFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0dGhpcy5tZW1iZXJzLmZvckVhY2goZnVuY3Rpb24gKG1lbWJlcnMpIHtcbiAgXHRcdFx0aWYgKG1lbWJlcnMucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpKSB7XG4gIFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuXG4gIFx0XHRpZiAoY2hhbmdlZCkge1xuICBcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRmb3JjZVJlc29sdXRpb246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLmJhc2VSZXNvbHZlcikge1xuICBcdFx0XHR0aGlzLmJhc2UgPSBnZXRLZXlwYXRoKHRoaXMucmVmKTtcblxuICBcdFx0XHR0aGlzLmJhc2VSZXNvbHZlci51bmJpbmQoKTtcbiAgXHRcdFx0dGhpcy5iYXNlUmVzb2x2ZXIgPSBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLm1lbWJlcnMuZm9yRWFjaChmb3JjZVJlc29sdXRpb24pO1xuICBcdFx0dGhpcy5idWJibGUoKTtcbiAgXHR9XG4gIH07XG5cbiAgZnVuY3Rpb24gUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX1JlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9fZ2V0VmFsdWUobWVtYmVyKSB7XG4gIFx0cmV0dXJuIG1lbWJlci52YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICBcdHJldHVybiB2YWx1ZSAhPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JjZVJlc29sdXRpb24obWVtYmVyKSB7XG4gIFx0bWVtYmVyLmZvcmNlUmVzb2x1dGlvbigpO1xuICB9XG5cbiAgdmFyIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9SZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIgPSBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXI7XG5cbiAgdmFyIE11c3RhY2hlX2luaXRpYWxpc2UgPSBNdXN0YWNoZSRpbml0O1xuICBmdW5jdGlvbiBNdXN0YWNoZSRpbml0KG11c3RhY2hlLCBvcHRpb25zKSB7XG5cbiAgXHR2YXIgcmVmLCBwYXJlbnRGcmFnbWVudCwgdGVtcGxhdGU7XG5cbiAgXHRwYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuXG4gIFx0bXVzdGFjaGUucm9vdCA9IHBhcmVudEZyYWdtZW50LnJvb3Q7XG4gIFx0bXVzdGFjaGUucGFyZW50RnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudDtcbiAgXHRtdXN0YWNoZS5wRWxlbWVudCA9IHBhcmVudEZyYWdtZW50LnBFbGVtZW50O1xuXG4gIFx0bXVzdGFjaGUudGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICBcdG11c3RhY2hlLmluZGV4ID0gb3B0aW9ucy5pbmRleCB8fCAwO1xuICBcdG11c3RhY2hlLmlzU3RhdGljID0gb3B0aW9ucy50ZW1wbGF0ZS5zO1xuXG4gIFx0bXVzdGFjaGUudHlwZSA9IG9wdGlvbnMudGVtcGxhdGUudDtcblxuICBcdG11c3RhY2hlLnJlZ2lzdGVyZWQgPSBmYWxzZTtcblxuICBcdC8vIGlmIHRoaXMgaXMgYSBzaW1wbGUgbXVzdGFjaGUsIHdpdGggYSByZWZlcmVuY2UsIHdlIGp1c3QgbmVlZCB0byByZXNvbHZlXG4gIFx0Ly8gdGhlIHJlZmVyZW5jZSB0byBhIGtleXBhdGhcbiAgXHRpZiAocmVmID0gdGVtcGxhdGUucikge1xuICBcdFx0bXVzdGFjaGUucmVzb2x2ZXIgPSBSZXNvbHZlcnNfY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIobXVzdGFjaGUsIHJlZiwgcmVzb2x2ZSk7XG4gIFx0fVxuXG4gIFx0Ly8gaWYgaXQncyBhbiBleHByZXNzaW9uLCB3ZSBoYXZlIGEgYml0IG1vcmUgd29yayB0byBkb1xuICBcdGlmIChvcHRpb25zLnRlbXBsYXRlLngpIHtcbiAgXHRcdG11c3RhY2hlLnJlc29sdmVyID0gbmV3IFJlc29sdmVyc19FeHByZXNzaW9uUmVzb2x2ZXIobXVzdGFjaGUsIHBhcmVudEZyYWdtZW50LCBvcHRpb25zLnRlbXBsYXRlLngsIHJlc29sdmVBbmRSZWJpbmRDaGlsZHJlbik7XG4gIFx0fVxuXG4gIFx0aWYgKG9wdGlvbnMudGVtcGxhdGUucngpIHtcbiAgXHRcdG11c3RhY2hlLnJlc29sdmVyID0gbmV3IFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9SZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIobXVzdGFjaGUsIG9wdGlvbnMudGVtcGxhdGUucngsIHJlc29sdmVBbmRSZWJpbmRDaGlsZHJlbik7XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gaW52ZXJ0ZWQgc2VjdGlvbnNcbiAgXHRpZiAobXVzdGFjaGUudGVtcGxhdGUubiA9PT0gU0VDVElPTl9VTkxFU1MgJiYgIW11c3RhY2hlLmhhc093blByb3BlcnR5KFwidmFsdWVcIikpIHtcbiAgXHRcdG11c3RhY2hlLnNldFZhbHVlKHVuZGVmaW5lZCk7XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gcmVzb2x2ZShrZXlwYXRoKSB7XG4gIFx0XHRtdXN0YWNoZS5yZXNvbHZlKGtleXBhdGgpO1xuICBcdH1cblxuICBcdGZ1bmN0aW9uIHJlc29sdmVBbmRSZWJpbmRDaGlsZHJlbihuZXdLZXlwYXRoKSB7XG4gIFx0XHR2YXIgb2xkS2V5cGF0aCA9IG11c3RhY2hlLmtleXBhdGg7XG5cbiAgXHRcdGlmIChuZXdLZXlwYXRoICE9IG9sZEtleXBhdGgpIHtcbiAgXHRcdFx0bXVzdGFjaGUucmVzb2x2ZShuZXdLZXlwYXRoKTtcblxuICBcdFx0XHRpZiAob2xkS2V5cGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0bXVzdGFjaGUuZnJhZ21lbnRzICYmIG11c3RhY2hlLmZyYWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gIFx0XHRcdFx0XHRmLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdFx0XHR9KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBNdXN0YWNoZV9yZXNvbHZlID0gTXVzdGFjaGUkcmVzb2x2ZTtcblxuICBmdW5jdGlvbiBNdXN0YWNoZSRyZXNvbHZlKGtleXBhdGgpIHtcbiAgXHR2YXIgd2FzUmVzb2x2ZWQsIHZhbHVlLCB0d293YXlCaW5kaW5nO1xuXG4gIFx0Ly8gJ1NwZWNpYWwnIGtleXBhdGhzLCBlLmcuIEBmb28gb3IgQDcsIGVuY29kZSBhIHZhbHVlXG4gIFx0aWYgKGtleXBhdGggJiYga2V5cGF0aC5pc1NwZWNpYWwpIHtcbiAgXHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0XHR0aGlzLnNldFZhbHVlKGtleXBhdGgudmFsdWUpO1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIElmIHdlIHJlc29sdmVkIHByZXZpb3VzbHksIHdlIG5lZWQgdG8gdW5yZWdpc3RlclxuICBcdGlmICh0aGlzLnJlZ2lzdGVyZWQpIHtcbiAgXHRcdC8vIHVuZGVmaW5lZCBvciBudWxsXG4gIFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnVucmVnaXN0ZXIodGhpcy5rZXlwYXRoLCB0aGlzKTtcbiAgXHRcdHRoaXMucmVnaXN0ZXJlZCA9IGZhbHNlO1xuXG4gIFx0XHR3YXNSZXNvbHZlZCA9IHRydWU7XG4gIFx0fVxuXG4gIFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblxuICBcdC8vIElmIHRoZSBuZXcga2V5cGF0aCBleGlzdHMsIHdlIG5lZWQgdG8gcmVnaXN0ZXJcbiAgXHQvLyB3aXRoIHRoZSB2aWV3bW9kZWxcbiAgXHRpZiAoa2V5cGF0aCAhPSB1bmRlZmluZWQpIHtcbiAgXHRcdC8vIHVuZGVmaW5lZCBvciBudWxsXG4gIFx0XHR2YWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuICBcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5yZWdpc3RlcihrZXlwYXRoLCB0aGlzKTtcblxuICBcdFx0dGhpcy5yZWdpc3RlcmVkID0gdHJ1ZTtcbiAgXHR9XG5cbiAgXHQvLyBFaXRoZXIgd2F5IHdlIG5lZWQgdG8gcXVldWUgdXAgYSByZW5kZXIgKGB2YWx1ZWBcbiAgXHQvLyB3aWxsIGJlIGB1bmRlZmluZWRgIGlmIHRoZXJlJ3Mgbm8ga2V5cGF0aClcbiAgXHR0aGlzLnNldFZhbHVlKHZhbHVlKTtcblxuICBcdC8vIFR3by13YXkgYmluZGluZ3MgbmVlZCB0byBwb2ludCB0byB0aGVpciBuZXcgdGFyZ2V0IGtleXBhdGhcbiAgXHRpZiAod2FzUmVzb2x2ZWQgJiYgKHR3b3dheUJpbmRpbmcgPSB0aGlzLnR3b3dheUJpbmRpbmcpKSB7XG4gIFx0XHR0d293YXlCaW5kaW5nLnJlYm91bmQoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgTXVzdGFjaGVfcmViaW5kID0gTXVzdGFjaGUkcmViaW5kO1xuXG4gIGZ1bmN0aW9uIE11c3RhY2hlJHJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0Ly8gQ2hpbGRyZW4gZmlyc3RcbiAgXHRpZiAodGhpcy5mcmFnbWVudHMpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgXHRcdFx0cmV0dXJuIGYucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0Ly8gRXhwcmVzc2lvbiBtdXN0YWNoZT9cbiAgXHRpZiAodGhpcy5yZXNvbHZlcikge1xuICBcdFx0dGhpcy5yZXNvbHZlci5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIE11c3RhY2hlID0ge1xuICBcdGdldFZhbHVlOiBNdXN0YWNoZV9nZXRWYWx1ZSxcbiAgXHRpbml0OiBNdXN0YWNoZV9pbml0aWFsaXNlLFxuICBcdHJlc29sdmU6IE11c3RhY2hlX3Jlc29sdmUsXG4gIFx0cmViaW5kOiBNdXN0YWNoZV9yZWJpbmRcbiAgfTtcblxuICB2YXIgSW50ZXJwb2xhdG9yID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLnR5cGUgPSBJTlRFUlBPTEFUT1I7XG4gIFx0TXVzdGFjaGUuaW5pdCh0aGlzLCBvcHRpb25zKTtcbiAgfTtcblxuICBJbnRlcnBvbGF0b3IucHJvdG90eXBlID0ge1xuICBcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5ub2RlLmRhdGEgPSB0aGlzLnZhbHVlID09IHVuZGVmaW5lZCA/IFwiXCIgOiB0aGlzLnZhbHVlO1xuICBcdH0sXG4gIFx0cmVzb2x2ZTogTXVzdGFjaGUucmVzb2x2ZSxcbiAgXHRyZWJpbmQ6IE11c3RhY2hlLnJlYmluZCxcbiAgXHRkZXRhY2g6IHNoYXJlZF9kZXRhY2gsXG5cbiAgXHR1bmJpbmQ6IHNoYXJlZF91bmJpbmQsXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5ub2RlKSB7XG4gIFx0XHRcdHRoaXMubm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHNhZmVUb1N0cmluZ1ZhbHVlKHRoaXMudmFsdWUpKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXMubm9kZTtcbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHRpZiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0XHRkZXRhY2hOb2RlKHRoaXMubm9kZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBNdXN0YWNoZS5nZXRWYWx1ZSxcblxuICBcdC8vIFRFTVBcbiAgXHRzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHR2YXIgd3JhcHBlcjtcblxuICBcdFx0Ly8gVE9ETyBpcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gYXBwcm9hY2ggdGhpcz9cbiAgXHRcdGlmICh0aGlzLmtleXBhdGggJiYgKHdyYXBwZXIgPSB0aGlzLnJvb3Qudmlld21vZGVsLndyYXBwZWRbdGhpcy5rZXlwYXRoLnN0cl0pKSB7XG4gIFx0XHRcdHZhbHVlID0gd3JhcHBlci5nZXQoKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFpc0VxdWFsKHZhbHVlLCB0aGlzLnZhbHVlKSkge1xuICBcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG4gIFx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG5cbiAgXHRcdFx0aWYgKHRoaXMubm9kZSkge1xuICBcdFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFZpZXcodGhpcyk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Zmlyc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuICBcdH0sXG5cbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKGVzY2FwZSkge1xuICBcdFx0dmFyIHN0cmluZyA9IFwiXCIgKyBzYWZlVG9TdHJpbmdWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgXHRcdHJldHVybiBlc2NhcGUgPyBlc2NhcGVIdG1sKHN0cmluZykgOiBzdHJpbmc7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBpdGVtc19JbnRlcnBvbGF0b3IgPSBJbnRlcnBvbGF0b3I7XG5cbiAgdmFyIFNlY3Rpb25fcHJvdG90eXBlX2J1YmJsZSA9IFNlY3Rpb24kYnViYmxlO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kYnViYmxlKCkge1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG4gIH1cblxuICB2YXIgU2VjdGlvbl9wcm90b3R5cGVfZGV0YWNoID0gU2VjdGlvbiRkZXRhY2g7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRkZXRhY2goKSB7XG4gIFx0dmFyIGRvY0ZyYWc7XG5cbiAgXHRpZiAodGhpcy5mcmFnbWVudHMubGVuZ3RoID09PSAxKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudHNbMF0uZGV0YWNoKCk7XG4gIFx0fVxuXG4gIFx0ZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICBcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgXHRcdGRvY0ZyYWcuYXBwZW5kQ2hpbGQoaXRlbS5kZXRhY2goKSk7XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gZG9jRnJhZztcbiAgfVxuXG4gIHZhciBmaW5kID0gU2VjdGlvbiRmaW5kO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kZmluZChzZWxlY3Rvcikge1xuICBcdHZhciBpLCBsZW4sIHF1ZXJ5UmVzdWx0O1xuXG4gIFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0aWYgKHF1ZXJ5UmVzdWx0ID0gdGhpcy5mcmFnbWVudHNbaV0uZmluZChzZWxlY3RvcikpIHtcbiAgXHRcdFx0cmV0dXJuIHF1ZXJ5UmVzdWx0O1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGZpbmRBbGwgPSBTZWN0aW9uJGZpbmRBbGw7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRmaW5kQWxsKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdHZhciBpLCBsZW47XG5cbiAgXHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50c1tpXS5maW5kQWxsKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGZpbmRBbGxDb21wb25lbnRzID0gU2VjdGlvbiRmaW5kQWxsQ29tcG9uZW50cztcblxuICBmdW5jdGlvbiBTZWN0aW9uJGZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdHZhciBpLCBsZW47XG5cbiAgXHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50c1tpXS5maW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBmaW5kQ29tcG9uZW50ID0gU2VjdGlvbiRmaW5kQ29tcG9uZW50O1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kZmluZENvbXBvbmVudChzZWxlY3Rvcikge1xuICBcdHZhciBpLCBsZW4sIHF1ZXJ5UmVzdWx0O1xuXG4gIFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0aWYgKHF1ZXJ5UmVzdWx0ID0gdGhpcy5mcmFnbWVudHNbaV0uZmluZENvbXBvbmVudChzZWxlY3RvcikpIHtcbiAgXHRcdFx0cmV0dXJuIHF1ZXJ5UmVzdWx0O1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGZpbmROZXh0Tm9kZSA9IFNlY3Rpb24kZmluZE5leHROb2RlO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kZmluZE5leHROb2RlKGZyYWdtZW50KSB7XG4gIFx0aWYgKHRoaXMuZnJhZ21lbnRzW2ZyYWdtZW50LmluZGV4ICsgMV0pIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50c1tmcmFnbWVudC5pbmRleCArIDFdLmZpcnN0Tm9kZSgpO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgfVxuXG4gIHZhciBmaXJzdE5vZGUgPSBTZWN0aW9uJGZpcnN0Tm9kZTtcblxuICBmdW5jdGlvbiBTZWN0aW9uJGZpcnN0Tm9kZSgpIHtcbiAgXHR2YXIgbGVuLCBpLCBub2RlO1xuXG4gIFx0aWYgKGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdGlmIChub2RlID0gdGhpcy5mcmFnbWVudHNbaV0uZmlyc3ROb2RlKCkpIHtcbiAgXHRcdFx0XHRyZXR1cm4gbm9kZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgfVxuXG4gIHZhciBzaHVmZmxlID0gU2VjdGlvbiRzaHVmZmxlO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kc2h1ZmZsZShuZXdJbmRpY2VzKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciBwYXJlbnRGcmFnbWVudCwgZmlyc3RDaGFuZ2UsIGksIG5ld0xlbmd0aCwgcmVib3VuZEZyYWdtZW50cywgZnJhZ21lbnRPcHRpb25zLCBmcmFnbWVudDtcblxuICBcdC8vIHNob3J0IGNpcmN1aXQgYW55IGRvdWJsZS11cGRhdGVzLCBhbmQgZW5zdXJlIHRoYXQgdGhpcyBpc24ndCBhcHBsaWVkIHRvXG4gIFx0Ly8gbm9uLWxpc3Qgc2VjdGlvbnNcbiAgXHRpZiAodGhpcy5zaHVmZmxpbmcgfHwgdGhpcy51bmJvdW5kIHx8IHRoaXMuY3VycmVudFN1YnR5cGUgIT09IFNFQ1RJT05fRUFDSCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHRoaXMuc2h1ZmZsaW5nID0gdHJ1ZTtcbiAgXHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIF90aGlzLnNodWZmbGluZyA9IGZhbHNlO1xuICBcdH0pO1xuXG4gIFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50O1xuXG4gIFx0cmVib3VuZEZyYWdtZW50cyA9IFtdO1xuXG4gIFx0Ly8gVE9ETzogbmVlZCB0byB1cGRhdGUgdGhpc1xuICBcdC8vIGZpcnN0LCByZWJpbmQgZXhpc3RpbmcgZnJhZ21lbnRzXG4gIFx0bmV3SW5kaWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZXdJbmRleCwgb2xkSW5kZXgpIHtcbiAgXHRcdHZhciBmcmFnbWVudCwgYnksIG9sZEtleXBhdGgsIG5ld0tleXBhdGgsIGRlcHM7XG5cbiAgXHRcdGlmIChuZXdJbmRleCA9PT0gb2xkSW5kZXgpIHtcbiAgXHRcdFx0cmVib3VuZEZyYWdtZW50c1tuZXdJbmRleF0gPSBfdGhpcy5mcmFnbWVudHNbb2xkSW5kZXhdO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGZyYWdtZW50ID0gX3RoaXMuZnJhZ21lbnRzW29sZEluZGV4XTtcblxuICBcdFx0aWYgKGZpcnN0Q2hhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0Zmlyc3RDaGFuZ2UgPSBvbGRJbmRleDtcbiAgXHRcdH1cblxuICBcdFx0Ly8gZG9lcyB0aGlzIGZyYWdtZW50IG5lZWQgdG8gYmUgdG9ybiBkb3duP1xuICBcdFx0aWYgKG5ld0luZGV4ID09PSAtMSkge1xuICBcdFx0XHRfdGhpcy5mcmFnbWVudHNUb1VucmVuZGVyLnB1c2goZnJhZ21lbnQpO1xuICBcdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBPdGhlcndpc2UsIGl0IG5lZWRzIHRvIGJlIHJlYm91bmQgdG8gYSBuZXcgaW5kZXhcbiAgXHRcdGJ5ID0gbmV3SW5kZXggLSBvbGRJbmRleDtcbiAgXHRcdG9sZEtleXBhdGggPSBfdGhpcy5rZXlwYXRoLmpvaW4ob2xkSW5kZXgpO1xuICBcdFx0bmV3S2V5cGF0aCA9IF90aGlzLmtleXBhdGguam9pbihuZXdJbmRleCk7XG5cbiAgXHRcdGZyYWdtZW50LmluZGV4ID0gbmV3SW5kZXg7XG5cbiAgXHRcdC8vIG5vdGlmeSBhbnkgcmVnaXN0ZXJlZCBpbmRleCByZWZzIGRpcmVjdGx5XG4gIFx0XHRpZiAoZGVwcyA9IGZyYWdtZW50LnJlZ2lzdGVyZWRJbmRleFJlZnMpIHtcbiAgXHRcdFx0ZGVwcy5mb3JFYWNoKHNodWZmbGVfX2JsaW5kUmViaW5kKTtcbiAgXHRcdH1cblxuICBcdFx0ZnJhZ21lbnQucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0cmVib3VuZEZyYWdtZW50c1tuZXdJbmRleF0gPSBmcmFnbWVudDtcbiAgXHR9KTtcblxuICBcdG5ld0xlbmd0aCA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KHRoaXMua2V5cGF0aCkubGVuZ3RoO1xuXG4gIFx0Ly8gSWYgbm90aGluZyBjaGFuZ2VkIHdpdGggdGhlIGV4aXN0aW5nIGZyYWdtZW50cywgdGhlbiB3ZSBzdGFydCBhZGRpbmdcbiAgXHQvLyBuZXcgZnJhZ21lbnRzIGF0IHRoZSBlbmQuLi5cbiAgXHRpZiAoZmlyc3RDaGFuZ2UgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0Ly8gLi4udW5sZXNzIHRoZXJlIGFyZSBubyBuZXcgZnJhZ21lbnRzIHRvIGFkZFxuICBcdFx0aWYgKHRoaXMubGVuZ3RoID09PSBuZXdMZW5ndGgpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRmaXJzdENoYW5nZSA9IHRoaXMubGVuZ3RoO1xuICBcdH1cblxuICBcdHRoaXMubGVuZ3RoID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoID0gbmV3TGVuZ3RoO1xuXG4gIFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLmFkZFZpZXcodGhpcyk7XG4gIFx0fVxuXG4gIFx0Ly8gUHJlcGFyZSBuZXcgZnJhZ21lbnQgb3B0aW9uc1xuICBcdGZyYWdtZW50T3B0aW9ucyA9IHtcbiAgXHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLmYsXG4gIFx0XHRyb290OiB0aGlzLnJvb3QsXG4gIFx0XHRvd25lcjogdGhpc1xuICBcdH07XG5cbiAgXHQvLyBBZGQgYXMgbWFueSBuZXcgZnJhZ21lbnRzIGFzIHdlIG5lZWQgdG8sIG9yIGFkZCBiYWNrIGV4aXN0aW5nXG4gIFx0Ly8gKGRldGFjaGVkKSBmcmFnbWVudHNcbiAgXHRmb3IgKGkgPSBmaXJzdENoYW5nZTsgaSA8IG5ld0xlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRmcmFnbWVudCA9IHJlYm91bmRGcmFnbWVudHNbaV07XG5cbiAgXHRcdGlmICghZnJhZ21lbnQpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudHNUb0NyZWF0ZS5wdXNoKGkpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmZyYWdtZW50c1tpXSA9IGZyYWdtZW50O1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNodWZmbGVfX2JsaW5kUmViaW5kKGRlcCkge1xuICBcdC8vIHRoZSBrZXlwYXRoIGRvZXNuJ3QgYWN0dWFsbHkgbWF0dGVyIGhlcmUgYXMgaXQgd29uJ3QgaGF2ZSBjaGFuZ2VkXG4gIFx0ZGVwLnJlYmluZChcIlwiLCBcIlwiKTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfcmViaW5kID0gZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRNdXN0YWNoZS5yZWJpbmQuY2FsbCh0aGlzLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgfTtcblxuICB2YXIgU2VjdGlvbl9wcm90b3R5cGVfcmVuZGVyID0gU2VjdGlvbiRyZW5kZXI7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRyZW5kZXIoKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHRoaXMuZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICBcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgXHRcdHJldHVybiBfdGhpcy5kb2NGcmFnLmFwcGVuZENoaWxkKGYucmVuZGVyKCkpO1xuICBcdH0pO1xuXG4gIFx0dGhpcy5yZW5kZXJlZEZyYWdtZW50cyA9IHRoaXMuZnJhZ21lbnRzLnNsaWNlKCk7XG4gIFx0dGhpcy5mcmFnbWVudHNUb1JlbmRlciA9IFtdO1xuXG4gIFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gIFx0cmV0dXJuIHRoaXMuZG9jRnJhZztcbiAgfVxuXG4gIHZhciBzZXRWYWx1ZSA9IFNlY3Rpb24kc2V0VmFsdWU7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRzZXRWYWx1ZSh2YWx1ZSkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgd3JhcHBlciwgZnJhZ21lbnRPcHRpb25zO1xuXG4gIFx0aWYgKHRoaXMudXBkYXRpbmcpIHtcbiAgXHRcdC8vIElmIGEgY2hpbGQgb2YgdGhpcyBzZWN0aW9uIGNhdXNlcyBhIHJlLWV2YWx1YXRpb24gLSBmb3IgZXhhbXBsZSwgYW5cbiAgXHRcdC8vIGV4cHJlc3Npb24gcmVmZXJzIHRvIGEgZnVuY3Rpb24gdGhhdCBtdXRhdGVzIHRoZSBhcnJheSB0aGF0IHRoaXNcbiAgXHRcdC8vIHNlY3Rpb24gZGVwZW5kcyBvbiAtIHdlJ2xsIGVuZCB1cCB3aXRoIGEgZG91YmxlIHJlbmRlcmluZyBidWcgKHNlZVxuICBcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3Vlcy83NDgpLiBUaGlzIHByZXZlbnRzIGl0LlxuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuXG4gIFx0Ly8gd2l0aCBzZWN0aW9ucywgd2UgbmVlZCB0byBnZXQgdGhlIGZha2UgdmFsdWUgaWYgd2UgaGF2ZSBhIHdyYXBwZWQgb2JqZWN0XG4gIFx0aWYgKHRoaXMua2V5cGF0aCAmJiAod3JhcHBlciA9IHRoaXMucm9vdC52aWV3bW9kZWwud3JhcHBlZFt0aGlzLmtleXBhdGguc3RyXSkpIHtcbiAgXHRcdHZhbHVlID0gd3JhcHBlci5nZXQoKTtcbiAgXHR9XG5cbiAgXHQvLyBJZiBhbnkgZnJhZ21lbnRzIGFyZSBhd2FpdGluZyBjcmVhdGlvbiBhZnRlciBhIHNwbGljZSxcbiAgXHQvLyB0aGlzIGlzIHRoZSBwbGFjZSB0byBkbyBpdFxuICBcdGlmICh0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLmxlbmd0aCkge1xuICBcdFx0ZnJhZ21lbnRPcHRpb25zID0ge1xuICBcdFx0XHR0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZS5mIHx8IFtdLFxuICBcdFx0XHRyb290OiB0aGlzLnJvb3QsXG4gIFx0XHRcdHBFbGVtZW50OiB0aGlzLnBFbGVtZW50LFxuICBcdFx0XHRvd25lcjogdGhpc1xuICBcdFx0fTtcblxuICBcdFx0dGhpcy5mcmFnbWVudHNUb0NyZWF0ZS5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICBcdFx0XHR2YXIgZnJhZ21lbnQ7XG5cbiAgXHRcdFx0ZnJhZ21lbnRPcHRpb25zLmNvbnRleHQgPSBfdGhpcy5rZXlwYXRoLmpvaW4oaW5kZXgpO1xuICBcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSBpbmRleDtcblxuICBcdFx0XHRmcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KGZyYWdtZW50T3B0aW9ucyk7XG4gIFx0XHRcdF90aGlzLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goX3RoaXMuZnJhZ21lbnRzW2luZGV4XSA9IGZyYWdtZW50KTtcbiAgXHRcdH0pO1xuXG4gIFx0XHR0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLmxlbmd0aCA9IDA7XG4gIFx0fSBlbHNlIGlmIChyZWV2YWx1YXRlU2VjdGlvbih0aGlzLCB2YWx1ZSkpIHtcbiAgXHRcdHRoaXMuYnViYmxlKCk7XG5cbiAgXHRcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFZpZXcodGhpcyk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuICBcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoYW5nZUN1cnJlbnRTdWJ0eXBlKHNlY3Rpb24sIHZhbHVlLCBvYmopIHtcbiAgXHRpZiAodmFsdWUgPT09IFNFQ1RJT05fRUFDSCkge1xuICBcdFx0Ly8gbWFrZSBzdXJlIHJlZiB0eXBlIGlzIHVwIHRvIGRhdGUgZm9yIGtleSBvciB2YWx1ZSBpbmRpY2VzXG4gIFx0XHRpZiAoc2VjdGlvbi5pbmRleFJlZnMgJiYgc2VjdGlvbi5pbmRleFJlZnNbMF0pIHtcbiAgXHRcdFx0dmFyIHJlZiA9IHNlY3Rpb24uaW5kZXhSZWZzWzBdO1xuXG4gIFx0XHRcdC8vIHdoZW4gc3dpdGNoaW5nIGZsYXZvcnMsIG1ha2Ugc3VyZSB0aGUgc2VjdGlvbiBnZXRzIHVwZGF0ZWRcbiAgXHRcdFx0aWYgKG9iaiAmJiByZWYudCA9PT0gXCJpXCIgfHwgIW9iaiAmJiByZWYudCA9PT0gXCJrXCIpIHtcbiAgXHRcdFx0XHQvLyBpZiBzd2l0Y2hpbmcgZnJvbSBvYmplY3QgdG8gbGlzdCwgdW5iaW5kIGFsbCBvZiB0aGUgb2xkIGZyYWdtZW50c1xuICBcdFx0XHRcdGlmICghb2JqKSB7XG4gIFx0XHRcdFx0XHRzZWN0aW9uLmxlbmd0aCA9IDA7XG4gIFx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBzZWN0aW9uLmZyYWdtZW50cy5zbGljZSgwKTtcbiAgXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gIFx0XHRcdFx0XHRcdHJldHVybiBmLnVuYmluZCgpO1xuICBcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmVmLnQgPSBvYmogPyBcImtcIiA6IFwiaVwiO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHNlY3Rpb24uY3VycmVudFN1YnR5cGUgPSB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZXZhbHVhdGVTZWN0aW9uKHNlY3Rpb24sIHZhbHVlKSB7XG4gIFx0dmFyIGZyYWdtZW50T3B0aW9ucyA9IHtcbiAgXHRcdHRlbXBsYXRlOiBzZWN0aW9uLnRlbXBsYXRlLmYgfHwgW10sXG4gIFx0XHRyb290OiBzZWN0aW9uLnJvb3QsXG4gIFx0XHRwRWxlbWVudDogc2VjdGlvbi5wYXJlbnRGcmFnbWVudC5wRWxlbWVudCxcbiAgXHRcdG93bmVyOiBzZWN0aW9uXG4gIFx0fTtcblxuICBcdHNlY3Rpb24uaGFzQ29udGV4dCA9IHRydWU7XG5cbiAgXHQvLyBJZiB3ZSBhbHJlYWR5IGtub3cgdGhlIHNlY3Rpb24gdHlwZSwgZ3JlYXRcbiAgXHQvLyBUT0RPIGNhbiB0aGlzIGJlIG9wdGltaXNlZD8gaS5lLiBwaWNrIGFuIHJlZXZhbHVhdGVTZWN0aW9uIGZ1bmN0aW9uIGR1cmluZyBpbml0XG4gIFx0Ly8gYW5kIGF2b2lkIGRvaW5nIHRoaXMgZWFjaCB0aW1lP1xuICBcdGlmIChzZWN0aW9uLnN1YnR5cGUpIHtcbiAgXHRcdHN3aXRjaCAoc2VjdGlvbi5zdWJ0eXBlKSB7XG4gIFx0XHRcdGNhc2UgU0VDVElPTl9JRjpcbiAgXHRcdFx0XHRzZWN0aW9uLmhhc0NvbnRleHQgPSBmYWxzZTtcbiAgXHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbmRpdGlvbmFsU2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgZmFsc2UsIGZyYWdtZW50T3B0aW9ucyk7XG5cbiAgXHRcdFx0Y2FzZSBTRUNUSU9OX1VOTEVTUzpcbiAgXHRcdFx0XHRzZWN0aW9uLmhhc0NvbnRleHQgPSBmYWxzZTtcbiAgXHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbmRpdGlvbmFsU2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgdHJ1ZSwgZnJhZ21lbnRPcHRpb25zKTtcblxuICBcdFx0XHRjYXNlIFNFQ1RJT05fV0lUSDpcbiAgXHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbnRleHRTZWN0aW9uKHNlY3Rpb24sIGZyYWdtZW50T3B0aW9ucyk7XG5cbiAgXHRcdFx0Y2FzZSBTRUNUSU9OX0lGX1dJVEg6XG4gIFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb25kaXRpb25hbENvbnRleHRTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMpO1xuXG4gIFx0XHRcdGNhc2UgU0VDVElPTl9FQUNIOlxuICBcdFx0XHRcdGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgXHRcdFx0XHRcdGNoYW5nZUN1cnJlbnRTdWJ0eXBlKHNlY3Rpb24sIHNlY3Rpb24uc3VidHlwZSwgdHJ1ZSk7XG4gIFx0XHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUxpc3RPYmplY3RTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdC8vIEZhbGx0aHJvdWdoIC0gaWYgaXQncyBhIGNvbmRpdGlvbmFsIG9yIGFuIGFycmF5IHdlIG5lZWQgdG8gY29udGludWVcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byB3b3JrIG91dCB3aGF0IHNvcnQgb2Ygc2VjdGlvbiB3ZSdyZSBkZWFsaW5nIHdpdGhcbiAgXHRzZWN0aW9uLm9yZGVyZWQgPSAhIWlzQXJyYXlMaWtlKHZhbHVlKTtcblxuICBcdC8vIE9yZGVyZWQgbGlzdCBzZWN0aW9uXG4gIFx0aWYgKHNlY3Rpb24ub3JkZXJlZCkge1xuICBcdFx0Y2hhbmdlQ3VycmVudFN1YnR5cGUoc2VjdGlvbiwgU0VDVElPTl9FQUNILCBmYWxzZSk7XG4gIFx0XHRyZXR1cm4gcmVldmFsdWF0ZUxpc3RTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMpO1xuICBcdH1cblxuICBcdC8vIFVub3JkZXJlZCBsaXN0LCBvciBjb250ZXh0XG4gIFx0aWYgKGlzT2JqZWN0KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0Ly8gSW5kZXggcmVmZXJlbmNlIGluZGljYXRlcyBzZWN0aW9uIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgbGlzdFxuICBcdFx0aWYgKHNlY3Rpb24udGVtcGxhdGUuaSkge1xuICBcdFx0XHRjaGFuZ2VDdXJyZW50U3VidHlwZShzZWN0aW9uLCBTRUNUSU9OX0VBQ0gsIHRydWUpO1xuICBcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUxpc3RPYmplY3RTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBPdGhlcndpc2UsIG9iamVjdCBwcm92aWRlcyBjb250ZXh0IGZvciBjb250ZW50c1xuICBcdFx0Y2hhbmdlQ3VycmVudFN1YnR5cGUoc2VjdGlvbiwgU0VDVElPTl9XSVRILCBmYWxzZSk7XG4gIFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbnRleHRTZWN0aW9uKHNlY3Rpb24sIGZyYWdtZW50T3B0aW9ucyk7XG4gIFx0fVxuXG4gIFx0Ly8gQ29uZGl0aW9uYWwgc2VjdGlvblxuICBcdGNoYW5nZUN1cnJlbnRTdWJ0eXBlKHNlY3Rpb24sIFNFQ1RJT05fSUYsIGZhbHNlKTtcbiAgXHRzZWN0aW9uLmhhc0NvbnRleHQgPSBmYWxzZTtcbiAgXHRyZXR1cm4gcmVldmFsdWF0ZUNvbmRpdGlvbmFsU2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgZmFsc2UsIGZyYWdtZW50T3B0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiByZWV2YWx1YXRlTGlzdFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucykge1xuICBcdHZhciBpLCBsZW5ndGgsIGZyYWdtZW50O1xuXG4gIFx0bGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXG4gIFx0aWYgKGxlbmd0aCA9PT0gc2VjdGlvbi5sZW5ndGgpIHtcbiAgXHRcdC8vIE5vdGhpbmcgdG8gZG9cbiAgXHRcdHJldHVybiBmYWxzZTtcbiAgXHR9XG5cbiAgXHQvLyBpZiB0aGUgYXJyYXkgaXMgc2hvcnRlciB0aGFuIGl0IHdhcyBwcmV2aW91c2x5LCByZW1vdmUgaXRlbXNcbiAgXHRpZiAobGVuZ3RoIDwgc2VjdGlvbi5sZW5ndGgpIHtcbiAgXHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlciA9IHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZShsZW5ndGgsIHNlY3Rpb24ubGVuZ3RoIC0gbGVuZ3RoKTtcbiAgXHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIFx0fVxuXG4gIFx0Ly8gb3RoZXJ3aXNlLi4uXG4gIFx0ZWxzZSB7XG4gIFx0XHRpZiAobGVuZ3RoID4gc2VjdGlvbi5sZW5ndGgpIHtcbiAgXHRcdFx0Ly8gYWRkIGFueSBuZXcgb25lc1xuICBcdFx0XHRmb3IgKGkgPSBzZWN0aW9uLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRcdFx0Ly8gYXBwZW5kIGxpc3QgaXRlbSB0byBjb250ZXh0IHN0YWNrXG4gIFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmNvbnRleHQgPSBzZWN0aW9uLmtleXBhdGguam9pbihpKTtcbiAgXHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSBpO1xuXG4gIFx0XHRcdFx0ZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudChmcmFnbWVudE9wdGlvbnMpO1xuICBcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9SZW5kZXIucHVzaChzZWN0aW9uLmZyYWdtZW50c1tpXSA9IGZyYWdtZW50KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHNlY3Rpb24ubGVuZ3RoID0gbGVuZ3RoO1xuICBcdHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVldmFsdWF0ZUxpc3RPYmplY3RTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMpIHtcbiAgXHR2YXIgaWQsIGksIGhhc0tleSwgZnJhZ21lbnQsIGNoYW5nZWQsIGRlcHM7XG5cbiAgXHRoYXNLZXkgPSBzZWN0aW9uLmhhc0tleSB8fCAoc2VjdGlvbi5oYXNLZXkgPSB7fSk7XG5cbiAgXHQvLyByZW1vdmUgYW55IGZyYWdtZW50cyB0aGF0IHNob3VsZCBubyBsb25nZXIgZXhpc3RcbiAgXHRpID0gc2VjdGlvbi5mcmFnbWVudHMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGZyYWdtZW50ID0gc2VjdGlvbi5mcmFnbWVudHNbaV07XG5cbiAgXHRcdGlmICghKGZyYWdtZW50LmtleSBpbiB2YWx1ZSkpIHtcbiAgXHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cbiAgXHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5wdXNoKGZyYWdtZW50KTtcbiAgXHRcdFx0c2VjdGlvbi5mcmFnbWVudHMuc3BsaWNlKGksIDEpO1xuXG4gIFx0XHRcdGhhc0tleVtmcmFnbWVudC5rZXldID0gZmFsc2U7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gbm90aWZ5IGFueSBkZXBlbmRlbnRzIGFib3V0IGNoYW5nZWQgaW5kaWNlc1xuICBcdGkgPSBzZWN0aW9uLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0ZnJhZ21lbnQgPSBzZWN0aW9uLmZyYWdtZW50c1tpXTtcblxuICBcdFx0aWYgKGZyYWdtZW50LmluZGV4ICE9PSBpKSB7XG4gIFx0XHRcdGZyYWdtZW50LmluZGV4ID0gaTtcbiAgXHRcdFx0aWYgKGRlcHMgPSBmcmFnbWVudC5yZWdpc3RlcmVkSW5kZXhSZWZzKSB7XG4gIFx0XHRcdFx0ZGVwcy5mb3JFYWNoKHNldFZhbHVlX19ibGluZFJlYmluZCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBhZGQgYW55IHRoYXQgaGF2ZW4ndCBiZWVuIGNyZWF0ZWQgeWV0XG4gIFx0aSA9IHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHRmb3IgKGlkIGluIHZhbHVlKSB7XG4gIFx0XHRpZiAoIWhhc0tleVtpZF0pIHtcbiAgXHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cbiAgXHRcdFx0ZnJhZ21lbnRPcHRpb25zLmNvbnRleHQgPSBzZWN0aW9uLmtleXBhdGguam9pbihpZCk7XG4gIFx0XHRcdGZyYWdtZW50T3B0aW9ucy5rZXkgPSBpZDtcbiAgXHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gaSsrO1xuXG4gIFx0XHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoZnJhZ21lbnRPcHRpb25zKTtcblxuICBcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goZnJhZ21lbnQpO1xuICBcdFx0XHRzZWN0aW9uLmZyYWdtZW50cy5wdXNoKGZyYWdtZW50KTtcbiAgXHRcdFx0aGFzS2V5W2lkXSA9IHRydWU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0c2VjdGlvbi5sZW5ndGggPSBzZWN0aW9uLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0cmV0dXJuIGNoYW5nZWQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWV2YWx1YXRlQ29uZGl0aW9uYWxDb250ZXh0U2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zKSB7XG4gIFx0aWYgKHZhbHVlKSB7XG4gIFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbnRleHRTZWN0aW9uKHNlY3Rpb24sIGZyYWdtZW50T3B0aW9ucyk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJldHVybiByZW1vdmVTZWN0aW9uRnJhZ21lbnRzKHNlY3Rpb24pO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZXZhbHVhdGVDb250ZXh0U2VjdGlvbihzZWN0aW9uLCBmcmFnbWVudE9wdGlvbnMpIHtcbiAgXHR2YXIgZnJhZ21lbnQ7XG5cbiAgXHQvLyAuLi50aGVuIGlmIGl0IGlzbid0IHJlbmRlcmVkLCByZW5kZXIgaXQsIGFkZGluZyBzZWN0aW9uLmtleXBhdGggdG8gdGhlIGNvbnRleHQgc3RhY2tcbiAgXHQvLyAoaWYgaXQgaXMgYWxyZWFkeSByZW5kZXJlZCwgdGhlbiBhbnkgY2hpbGRyZW4gZGVwZW5kZW50IG9uIHRoZSBjb250ZXh0IHN0YWNrXG4gIFx0Ly8gd2lsbCB1cGRhdGUgdGhlbXNlbHZlcyB3aXRob3V0IGFueSBwcm9tcHRpbmcpXG4gIFx0aWYgKCFzZWN0aW9uLmxlbmd0aCkge1xuICBcdFx0Ly8gYXBwZW5kIHRoaXMgc2VjdGlvbiB0byB0aGUgY29udGV4dCBzdGFja1xuICBcdFx0ZnJhZ21lbnRPcHRpb25zLmNvbnRleHQgPSBzZWN0aW9uLmtleXBhdGg7XG4gIFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSAwO1xuXG4gIFx0XHRmcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KGZyYWdtZW50T3B0aW9ucyk7XG5cbiAgXHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9SZW5kZXIucHVzaChzZWN0aW9uLmZyYWdtZW50c1swXSA9IGZyYWdtZW50KTtcbiAgXHRcdHNlY3Rpb24ubGVuZ3RoID0gMTtcblxuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVldmFsdWF0ZUNvbmRpdGlvbmFsU2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgaW52ZXJ0ZWQsIGZyYWdtZW50T3B0aW9ucykge1xuICBcdHZhciBkb1JlbmRlciwgZW1wdHlBcnJheSwgZW1wdHlPYmplY3QsIGZyYWdtZW50LCBuYW1lO1xuXG4gIFx0ZW1wdHlBcnJheSA9IGlzQXJyYXlMaWtlKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDA7XG4gIFx0ZW1wdHlPYmplY3QgPSBmYWxzZTtcbiAgXHRpZiAoIWlzQXJyYXlMaWtlKHZhbHVlKSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgXHRcdGVtcHR5T2JqZWN0ID0gdHJ1ZTtcbiAgXHRcdGZvciAobmFtZSBpbiB2YWx1ZSkge1xuICBcdFx0XHRlbXB0eU9iamVjdCA9IGZhbHNlO1xuICBcdFx0XHRicmVhaztcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoaW52ZXJ0ZWQpIHtcbiAgXHRcdGRvUmVuZGVyID0gZW1wdHlBcnJheSB8fCBlbXB0eU9iamVjdCB8fCAhdmFsdWU7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGRvUmVuZGVyID0gdmFsdWUgJiYgIWVtcHR5QXJyYXkgJiYgIWVtcHR5T2JqZWN0O1xuICBcdH1cblxuICBcdGlmIChkb1JlbmRlcikge1xuICBcdFx0aWYgKCFzZWN0aW9uLmxlbmd0aCkge1xuICBcdFx0XHQvLyBubyBjaGFuZ2UgdG8gY29udGV4dCBzdGFja1xuICBcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSAwO1xuXG4gIFx0XHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoZnJhZ21lbnRPcHRpb25zKTtcbiAgXHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5wdXNoKHNlY3Rpb24uZnJhZ21lbnRzWzBdID0gZnJhZ21lbnQpO1xuICBcdFx0XHRzZWN0aW9uLmxlbmd0aCA9IDE7XG5cbiAgXHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChzZWN0aW9uLmxlbmd0aCA+IDEpIHtcbiAgXHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyID0gc2VjdGlvbi5mcmFnbWVudHMuc3BsaWNlKDEpO1xuICBcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuXG4gIFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXR1cm4gcmVtb3ZlU2VjdGlvbkZyYWdtZW50cyhzZWN0aW9uKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVTZWN0aW9uRnJhZ21lbnRzKHNlY3Rpb24pIHtcbiAgXHRpZiAoc2VjdGlvbi5sZW5ndGgpIHtcbiAgXHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlciA9IHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZSgwLCBzZWN0aW9uLmZyYWdtZW50cy5sZW5ndGgpLmZpbHRlcihpc1JlbmRlcmVkKTtcbiAgXHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIFx0XHRzZWN0aW9uLmxlbmd0aCA9IHNlY3Rpb24uZnJhZ21lbnRzVG9SZW5kZXIubGVuZ3RoID0gMDtcbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUmVuZGVyZWQoZnJhZ21lbnQpIHtcbiAgXHRyZXR1cm4gZnJhZ21lbnQucmVuZGVyZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRWYWx1ZV9fYmxpbmRSZWJpbmQoZGVwKSB7XG4gIFx0Ly8gdGhlIGtleXBhdGggZG9lc24ndCBhY3R1YWxseSBtYXR0ZXIgaGVyZSBhcyBpdCB3b24ndCBoYXZlIGNoYW5nZWRcbiAgXHRkZXAucmViaW5kKFwiXCIsIFwiXCIpO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV90b1N0cmluZyA9IFNlY3Rpb24kdG9TdHJpbmc7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiR0b1N0cmluZyhlc2NhcGUpIHtcbiAgXHR2YXIgc3RyLCBpLCBsZW47XG5cbiAgXHRzdHIgPSBcIlwiO1xuXG4gIFx0aSA9IDA7XG4gIFx0bGVuID0gdGhpcy5sZW5ndGg7XG5cbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdHN0ciArPSB0aGlzLmZyYWdtZW50c1tpXS50b1N0cmluZyhlc2NhcGUpO1xuICBcdH1cblxuICBcdHJldHVybiBzdHI7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3VuYmluZCA9IFNlY3Rpb24kdW5iaW5kO1xuICBmdW5jdGlvbiBTZWN0aW9uJHVuYmluZCgpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuICBcdHRoaXMuZnJhZ21lbnRzVG9SZW5kZXIuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICBcdFx0cmV0dXJuIHJlbW92ZUZyb21BcnJheShfdGhpcy5mcmFnbWVudHMsIGYpO1xuICBcdH0pO1xuICBcdHRoaXMuZnJhZ21lbnRzVG9SZW5kZXIgPSBbXTtcbiAgXHRzaGFyZWRfdW5iaW5kLmNhbGwodGhpcyk7XG5cbiAgXHR0aGlzLmxlbmd0aCA9IDA7XG4gIFx0dGhpcy51bmJvdW5kID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfdW5yZW5kZXIgPSBTZWN0aW9uJHVucmVuZGVyO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kdW5yZW5kZXIoc2hvdWxkRGVzdHJveSkge1xuICBcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2goc2hvdWxkRGVzdHJveSA/IHVucmVuZGVyQW5kRGVzdHJveSA6IHByb3RvdHlwZV91bnJlbmRlcl9fdW5yZW5kZXIpO1xuICBcdHRoaXMucmVuZGVyZWRGcmFnbWVudHMgPSBbXTtcbiAgXHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiB1bnJlbmRlckFuZERlc3Ryb3koZnJhZ21lbnQpIHtcbiAgXHRmcmFnbWVudC51bnJlbmRlcih0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb3RvdHlwZV91bnJlbmRlcl9fdW5yZW5kZXIoZnJhZ21lbnQpIHtcbiAgXHRmcmFnbWVudC51bnJlbmRlcihmYWxzZSk7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3VwZGF0ZSA9IFNlY3Rpb24kdXBkYXRlO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kdXBkYXRlKCkge1xuICBcdHZhciBmcmFnbWVudCwgcmVuZGVySW5kZXgsIHJlbmRlcmVkRnJhZ21lbnRzLCBhbmNob3IsIHRhcmdldCwgaSwgbGVuO1xuXG4gIFx0Ly8gYHRoaXMucmVuZGVyZWRGcmFnbWVudHNgIGlzIGluIHRoZSBvcmRlciBvZiB0aGUgcHJldmlvdXMgcmVuZGVyLlxuICBcdC8vIElmIGZyYWdtZW50cyBoYXZlIHNodWZmbGVkIGFib3V0LCB0aGlzIGFsbG93cyB1cyB0byBxdWlja2x5XG4gIFx0Ly8gcmVpbnNlcnQgdGhlbSBpbiB0aGUgY29ycmVjdCBwbGFjZVxuICBcdHJlbmRlcmVkRnJhZ21lbnRzID0gdGhpcy5yZW5kZXJlZEZyYWdtZW50cztcblxuICBcdC8vIFJlbW92ZSBmcmFnbWVudHMgdGhhdCBoYXZlIGJlZW4gbWFya2VkIGZvciBkZXN0cnVjdGlvblxuICBcdHdoaWxlIChmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRzVG9VbnJlbmRlci5wb3AoKSkge1xuICBcdFx0ZnJhZ21lbnQudW5yZW5kZXIodHJ1ZSk7XG4gIFx0XHRyZW5kZXJlZEZyYWdtZW50cy5zcGxpY2UocmVuZGVyZWRGcmFnbWVudHMuaW5kZXhPZihmcmFnbWVudCksIDEpO1xuICBcdH1cblxuICBcdC8vIFJlbmRlciBuZXcgZnJhZ21lbnRzIChidXQgZG9uJ3QgaW5zZXJ0IHRoZW0geWV0KVxuICBcdHdoaWxlIChmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRzVG9SZW5kZXIuc2hpZnQoKSkge1xuICBcdFx0ZnJhZ21lbnQucmVuZGVyKCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdHRhcmdldCA9IHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpO1xuICBcdH1cblxuICBcdGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudHNbaV07XG4gIFx0XHRyZW5kZXJJbmRleCA9IHJlbmRlcmVkRnJhZ21lbnRzLmluZGV4T2YoZnJhZ21lbnQsIGkpOyAvLyBzZWFyY2ggZnJvbSBjdXJyZW50IGluZGV4IC0gaXQncyBndWFyYW50ZWVkIHRvIGJlIHRoZSBzYW1lIG9yIGhpZ2hlclxuXG4gIFx0XHRpZiAocmVuZGVySW5kZXggPT09IGkpIHtcbiAgXHRcdFx0Ly8gYWxyZWFkeSBpbiB0aGUgcmlnaHQgcGxhY2UuIGluc2VydCBhY2N1bXVsYXRlZCBub2RlcyAoaWYgYW55KSBhbmQgY2Fycnkgb25cbiAgXHRcdFx0aWYgKHRoaXMuZG9jRnJhZy5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICBcdFx0XHRcdGFuY2hvciA9IGZyYWdtZW50LmZpcnN0Tm9kZSgpO1xuICBcdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUodGhpcy5kb2NGcmFnLCBhbmNob3IpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Y29udGludWU7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZG9jRnJhZy5hcHBlbmRDaGlsZChmcmFnbWVudC5kZXRhY2goKSk7XG5cbiAgXHRcdC8vIHVwZGF0ZSByZW5kZXJlZEZyYWdtZW50c1xuICBcdFx0aWYgKHJlbmRlckluZGV4ICE9PSAtMSkge1xuICBcdFx0XHRyZW5kZXJlZEZyYWdtZW50cy5zcGxpY2UocmVuZGVySW5kZXgsIDEpO1xuICBcdFx0fVxuICBcdFx0cmVuZGVyZWRGcmFnbWVudHMuc3BsaWNlKGksIDAsIGZyYWdtZW50KTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5yZW5kZXJlZCAmJiB0aGlzLmRvY0ZyYWcuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgXHRcdGFuY2hvciA9IHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICBcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSh0aGlzLmRvY0ZyYWcsIGFuY2hvcik7XG4gIFx0fVxuXG4gIFx0Ly8gU2F2ZSB0aGUgcmVuZGVyaW5nIG9yZGVyIGZvciBuZXh0IHRpbWVcbiAgXHR0aGlzLnJlbmRlcmVkRnJhZ21lbnRzID0gdGhpcy5mcmFnbWVudHMuc2xpY2UoKTtcbiAgfVxuXG4gIHZhciBTZWN0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLnR5cGUgPSBTRUNUSU9OO1xuICBcdHRoaXMuc3VidHlwZSA9IHRoaXMuY3VycmVudFN1YnR5cGUgPSBvcHRpb25zLnRlbXBsYXRlLm47XG4gIFx0dGhpcy5pbnZlcnRlZCA9IHRoaXMuc3VidHlwZSA9PT0gU0VDVElPTl9VTkxFU1M7XG5cbiAgXHR0aGlzLnBFbGVtZW50ID0gb3B0aW9ucy5wRWxlbWVudDtcblxuICBcdHRoaXMuZnJhZ21lbnRzID0gW107XG4gIFx0dGhpcy5mcmFnbWVudHNUb0NyZWF0ZSA9IFtdO1xuICBcdHRoaXMuZnJhZ21lbnRzVG9SZW5kZXIgPSBbXTtcbiAgXHR0aGlzLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBbXTtcblxuICBcdGlmIChvcHRpb25zLnRlbXBsYXRlLmkpIHtcbiAgXHRcdHRoaXMuaW5kZXhSZWZzID0gb3B0aW9ucy50ZW1wbGF0ZS5pLnNwbGl0KFwiLFwiKS5tYXAoZnVuY3Rpb24gKGssIGkpIHtcbiAgXHRcdFx0cmV0dXJuIHsgbjogaywgdDogaSA9PT0gMCA/IFwia1wiIDogXCJpXCIgfTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdHRoaXMucmVuZGVyZWRGcmFnbWVudHMgPSBbXTtcblxuICBcdHRoaXMubGVuZ3RoID0gMDsgLy8gbnVtYmVyIG9mIHRpbWVzIHRoaXMgc2VjdGlvbiBpcyByZW5kZXJlZFxuXG4gIFx0TXVzdGFjaGUuaW5pdCh0aGlzLCBvcHRpb25zKTtcbiAgfTtcblxuICBTZWN0aW9uLnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IFNlY3Rpb25fcHJvdG90eXBlX2J1YmJsZSxcbiAgXHRkZXRhY2g6IFNlY3Rpb25fcHJvdG90eXBlX2RldGFjaCxcbiAgXHRmaW5kOiBmaW5kLFxuICBcdGZpbmRBbGw6IGZpbmRBbGwsXG4gIFx0ZmluZEFsbENvbXBvbmVudHM6IGZpbmRBbGxDb21wb25lbnRzLFxuICBcdGZpbmRDb21wb25lbnQ6IGZpbmRDb21wb25lbnQsXG4gIFx0ZmluZE5leHROb2RlOiBmaW5kTmV4dE5vZGUsXG4gIFx0Zmlyc3ROb2RlOiBmaXJzdE5vZGUsXG4gIFx0Z2V0SW5kZXhSZWY6IGZ1bmN0aW9uIChuYW1lKSB7XG4gIFx0XHRpZiAodGhpcy5pbmRleFJlZnMpIHtcbiAgXHRcdFx0dmFyIGkgPSB0aGlzLmluZGV4UmVmcy5sZW5ndGg7XG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHR2YXIgcmVmID0gdGhpcy5pbmRleFJlZnNbaV07XG4gIFx0XHRcdFx0aWYgKHJlZi5uID09PSBuYW1lKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gcmVmO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG4gIFx0Z2V0VmFsdWU6IE11c3RhY2hlLmdldFZhbHVlLFxuICBcdHNodWZmbGU6IHNodWZmbGUsXG4gIFx0cmViaW5kOiBwcm90b3R5cGVfcmViaW5kLFxuICBcdHJlbmRlcjogU2VjdGlvbl9wcm90b3R5cGVfcmVuZGVyLFxuICBcdHJlc29sdmU6IE11c3RhY2hlLnJlc29sdmUsXG4gIFx0c2V0VmFsdWU6IHNldFZhbHVlLFxuICBcdHRvU3RyaW5nOiBwcm90b3R5cGVfdG9TdHJpbmcsXG4gIFx0dW5iaW5kOiBwcm90b3R5cGVfdW5iaW5kLFxuICBcdHVucmVuZGVyOiBwcm90b3R5cGVfdW5yZW5kZXIsXG4gIFx0dXBkYXRlOiBwcm90b3R5cGVfdXBkYXRlXG4gIH07XG5cbiAgdmFyIF9TZWN0aW9uID0gU2VjdGlvbjtcblxuICB2YXIgVHJpcGxlX3Byb3RvdHlwZV9kZXRhY2ggPSBUcmlwbGUkZGV0YWNoO1xuXG4gIGZ1bmN0aW9uIFRyaXBsZSRkZXRhY2goKSB7XG4gIFx0dmFyIGxlbiwgaTtcblxuICBcdGlmICh0aGlzLmRvY0ZyYWcpIHtcbiAgXHRcdGxlbiA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdHRoaXMuZG9jRnJhZy5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzW2ldKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXMuZG9jRnJhZztcbiAgXHR9XG4gIH1cblxuICB2YXIgVHJpcGxlX3Byb3RvdHlwZV9maW5kID0gVHJpcGxlJGZpbmQ7XG4gIGZ1bmN0aW9uIFRyaXBsZSRmaW5kKHNlbGVjdG9yKSB7XG4gIFx0dmFyIGksIGxlbiwgbm9kZSwgcXVlcnlSZXN1bHQ7XG5cbiAgXHRsZW4gPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdG5vZGUgPSB0aGlzLm5vZGVzW2ldO1xuXG4gIFx0XHRpZiAobm9kZS5ub2RlVHlwZSAhPT0gMSkge1xuICBcdFx0XHRjb250aW51ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKG1hdGNoZXMobm9kZSwgc2VsZWN0b3IpKSB7XG4gIFx0XHRcdHJldHVybiBub2RlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAocXVlcnlSZXN1bHQgPSBub2RlLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpKSB7XG4gIFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBUcmlwbGVfcHJvdG90eXBlX2ZpbmRBbGwgPSBUcmlwbGUkZmluZEFsbDtcbiAgZnVuY3Rpb24gVHJpcGxlJGZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5UmVzdWx0KSB7XG4gIFx0dmFyIGksIGxlbiwgbm9kZSwgcXVlcnlBbGxSZXN1bHQsIG51bU5vZGVzLCBqO1xuXG4gIFx0bGVuID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRub2RlID0gdGhpcy5ub2Rlc1tpXTtcblxuICBcdFx0aWYgKG5vZGUubm9kZVR5cGUgIT09IDEpIHtcbiAgXHRcdFx0Y29udGludWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChtYXRjaGVzKG5vZGUsIHNlbGVjdG9yKSkge1xuICBcdFx0XHRxdWVyeVJlc3VsdC5wdXNoKG5vZGUpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAocXVlcnlBbGxSZXN1bHQgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKSB7XG4gIFx0XHRcdG51bU5vZGVzID0gcXVlcnlBbGxSZXN1bHQubGVuZ3RoO1xuICBcdFx0XHRmb3IgKGogPSAwOyBqIDwgbnVtTm9kZXM7IGogKz0gMSkge1xuICBcdFx0XHRcdHF1ZXJ5UmVzdWx0LnB1c2gocXVlcnlBbGxSZXN1bHRbal0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIFRyaXBsZV9wcm90b3R5cGVfZmlyc3ROb2RlID0gVHJpcGxlJGZpcnN0Tm9kZTtcblxuICBmdW5jdGlvbiBUcmlwbGUkZmlyc3ROb2RlKCkge1xuICBcdGlmICh0aGlzLnJlbmRlcmVkICYmIHRoaXMubm9kZXNbMF0pIHtcbiAgXHRcdHJldHVybiB0aGlzLm5vZGVzWzBdO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgfVxuXG4gIHZhciBlbGVtZW50Q2FjaGUgPSB7fSxcbiAgICAgIGllQnVnLFxuICAgICAgaWVCbGFja2xpc3Q7XG5cbiAgdHJ5IHtcbiAgXHRjcmVhdGVFbGVtZW50KFwidGFibGVcIikuaW5uZXJIVE1MID0gXCJmb29cIjtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gIFx0aWVCdWcgPSB0cnVlO1xuXG4gIFx0aWVCbGFja2xpc3QgPSB7XG4gIFx0XHRUQUJMRTogW1wiPHRhYmxlIGNsYXNzPVxcXCJ4XFxcIj5cIiwgXCI8L3RhYmxlPlwiXSxcbiAgXHRcdFRIRUFEOiBbXCI8dGFibGU+PHRoZWFkIGNsYXNzPVxcXCJ4XFxcIj5cIiwgXCI8L3RoZWFkPjwvdGFibGU+XCJdLFxuICBcdFx0VEJPRFk6IFtcIjx0YWJsZT48dGJvZHkgY2xhc3M9XFxcInhcXFwiPlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIl0sXG4gIFx0XHRUUjogW1wiPHRhYmxlPjx0ciBjbGFzcz1cXFwieFxcXCI+XCIsIFwiPC90cj48L3RhYmxlPlwiXSxcbiAgXHRcdFNFTEVDVDogW1wiPHNlbGVjdCBjbGFzcz1cXFwieFxcXCI+XCIsIFwiPC9zZWxlY3Q+XCJdXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBpbnNlcnRIdG1sID0gZnVuY3Rpb24gKGh0bWwsIG5vZGUsIGRvY0ZyYWcpIHtcbiAgXHR2YXIgY29udGFpbmVyLFxuICBcdCAgICBub2RlcyA9IFtdLFxuICBcdCAgICB3cmFwcGVyLFxuICBcdCAgICBzZWxlY3RlZE9wdGlvbixcbiAgXHQgICAgY2hpbGQsXG4gIFx0ICAgIGk7XG5cbiAgXHQvLyByZW5kZXIgMCBhbmQgZmFsc2VcbiAgXHRpZiAoaHRtbCAhPSBudWxsICYmIGh0bWwgIT09IFwiXCIpIHtcbiAgXHRcdGlmIChpZUJ1ZyAmJiAod3JhcHBlciA9IGllQmxhY2tsaXN0W25vZGUudGFnTmFtZV0pKSB7XG4gIFx0XHRcdGNvbnRhaW5lciA9IGVsZW1lbnQoXCJESVZcIik7XG4gIFx0XHRcdGNvbnRhaW5lci5pbm5lckhUTUwgPSB3cmFwcGVyWzBdICsgaHRtbCArIHdyYXBwZXJbMV07XG4gIFx0XHRcdGNvbnRhaW5lciA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLnhcIik7XG5cbiAgXHRcdFx0aWYgKGNvbnRhaW5lci50YWdOYW1lID09PSBcIlNFTEVDVFwiKSB7XG4gIFx0XHRcdFx0c2VsZWN0ZWRPcHRpb24gPSBjb250YWluZXIub3B0aW9uc1tjb250YWluZXIuc2VsZWN0ZWRJbmRleF07XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSBpZiAobm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuc3ZnKSB7XG4gIFx0XHRcdGNvbnRhaW5lciA9IGVsZW1lbnQoXCJESVZcIik7XG4gIFx0XHRcdGNvbnRhaW5lci5pbm5lckhUTUwgPSBcIjxzdmcgY2xhc3M9XFxcInhcXFwiPlwiICsgaHRtbCArIFwiPC9zdmc+XCI7XG4gIFx0XHRcdGNvbnRhaW5lciA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLnhcIik7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRjb250YWluZXIgPSBlbGVtZW50KG5vZGUudGFnTmFtZSk7XG4gIFx0XHRcdGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuXG4gIFx0XHRcdGlmIChjb250YWluZXIudGFnTmFtZSA9PT0gXCJTRUxFQ1RcIikge1xuICBcdFx0XHRcdHNlbGVjdGVkT3B0aW9uID0gY29udGFpbmVyLm9wdGlvbnNbY29udGFpbmVyLnNlbGVjdGVkSW5kZXhdO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHdoaWxlIChjaGlsZCA9IGNvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gIFx0XHRcdG5vZGVzLnB1c2goY2hpbGQpO1xuICBcdFx0XHRkb2NGcmFnLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gVGhpcyBpcyByZWFsbHkgYW5ub3lpbmcuIEV4dHJhY3RpbmcgPG9wdGlvbj4gbm9kZXMgZnJvbSB0aGVcbiAgXHRcdC8vIHRlbXBvcmFyeSBjb250YWluZXIgPHNlbGVjdD4gY2F1c2VzIHRoZSByZW1haW5pbmcgb25lcyB0b1xuICBcdFx0Ly8gYmVjb21lIHNlbGVjdGVkLiBTbyBub3cgd2UgaGF2ZSB0byBkZXNlbGVjdCB0aGVtLiBJRTgsIHlvdVxuICBcdFx0Ly8gYW1hemUgbWUuIFlvdSByZWFsbHkgZG9cbiAgXHRcdC8vIC4uLmFuZCBub3cgQ2hyb21lIHRvb1xuICBcdFx0aWYgKG5vZGUudGFnTmFtZSA9PT0gXCJTRUxFQ1RcIikge1xuICBcdFx0XHRpID0gbm9kZXMubGVuZ3RoO1xuICBcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0aWYgKG5vZGVzW2ldICE9PSBzZWxlY3RlZE9wdGlvbikge1xuICBcdFx0XHRcdFx0bm9kZXNbaV0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gbm9kZXM7XG4gIH07XG5cbiAgZnVuY3Rpb24gZWxlbWVudCh0YWdOYW1lKSB7XG4gIFx0cmV0dXJuIGVsZW1lbnRDYWNoZVt0YWdOYW1lXSB8fCAoZWxlbWVudENhY2hlW3RhZ05hbWVdID0gY3JlYXRlRWxlbWVudCh0YWdOYW1lKSk7XG4gIH1cblxuICB2YXIgaGVscGVyc191cGRhdGVTZWxlY3QgPSB1cGRhdGVTZWxlY3Q7XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2VsZWN0KHBhcmVudEVsZW1lbnQpIHtcbiAgXHR2YXIgc2VsZWN0ZWRPcHRpb25zLCBvcHRpb24sIHZhbHVlO1xuXG4gIFx0aWYgKCFwYXJlbnRFbGVtZW50IHx8IHBhcmVudEVsZW1lbnQubmFtZSAhPT0gXCJzZWxlY3RcIiB8fCAhcGFyZW50RWxlbWVudC5iaW5kaW5nKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0c2VsZWN0ZWRPcHRpb25zID0gdG9BcnJheShwYXJlbnRFbGVtZW50Lm5vZGUub3B0aW9ucykuZmlsdGVyKGlzU2VsZWN0ZWQpO1xuXG4gIFx0Ly8gSWYgb25lIG9mIHRoZW0gaGFkIGEgYHNlbGVjdGVkYCBhdHRyaWJ1dGUsIHdlIG5lZWQgdG8gc3luY1xuICBcdC8vIHRoZSBtb2RlbCB0byB0aGUgdmlld1xuICBcdGlmIChwYXJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIpKSB7XG4gIFx0XHR2YWx1ZSA9IHNlbGVjdGVkT3B0aW9ucy5tYXAoZnVuY3Rpb24gKG8pIHtcbiAgXHRcdFx0cmV0dXJuIG8udmFsdWU7XG4gIFx0XHR9KTtcbiAgXHR9IGVsc2UgaWYgKG9wdGlvbiA9IHNlbGVjdGVkT3B0aW9uc1swXSkge1xuICBcdFx0dmFsdWUgPSBvcHRpb24udmFsdWU7XG4gIFx0fVxuXG4gIFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdHBhcmVudEVsZW1lbnQuYmluZGluZy5zZXRWYWx1ZSh2YWx1ZSk7XG4gIFx0fVxuXG4gIFx0cGFyZW50RWxlbWVudC5idWJibGUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU2VsZWN0ZWQob3B0aW9uKSB7XG4gIFx0cmV0dXJuIG9wdGlvbi5zZWxlY3RlZDtcbiAgfVxuXG4gIHZhciBUcmlwbGVfcHJvdG90eXBlX3JlbmRlciA9IFRyaXBsZSRyZW5kZXI7XG4gIGZ1bmN0aW9uIFRyaXBsZSRyZW5kZXIoKSB7XG4gIFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byByZW5kZXIgYW4gaXRlbSB0aGF0IHdhcyBhbHJlYWR5IHJlbmRlcmVkXCIpO1xuICBcdH1cblxuICBcdHRoaXMuZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgXHR0aGlzLm5vZGVzID0gaW5zZXJ0SHRtbCh0aGlzLnZhbHVlLCB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKSwgdGhpcy5kb2NGcmFnKTtcblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHdlJ3JlIGluc2VydGluZyB0aGUgY29udGVudHMgb2YgYSA8c2VsZWN0PlxuICBcdGhlbHBlcnNfdXBkYXRlU2VsZWN0KHRoaXMucEVsZW1lbnQpO1xuXG4gIFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gIFx0cmV0dXJuIHRoaXMuZG9jRnJhZztcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfc2V0VmFsdWUgPSBUcmlwbGUkc2V0VmFsdWU7XG4gIGZ1bmN0aW9uIFRyaXBsZSRzZXRWYWx1ZSh2YWx1ZSkge1xuICBcdHZhciB3cmFwcGVyO1xuXG4gIFx0Ly8gVE9ETyBpcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gYXBwcm9hY2ggdGhpcz9cbiAgXHRpZiAod3JhcHBlciA9IHRoaXMucm9vdC52aWV3bW9kZWwud3JhcHBlZFt0aGlzLmtleXBhdGguc3RyXSkge1xuICBcdFx0dmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuICBcdH1cblxuICBcdGlmICh2YWx1ZSAhPT0gdGhpcy52YWx1ZSkge1xuICBcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuICBcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblxuICBcdFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVmlldyh0aGlzKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgVHJpcGxlX3Byb3RvdHlwZV90b1N0cmluZyA9IFRyaXBsZSR0b1N0cmluZztcbiAgZnVuY3Rpb24gVHJpcGxlJHRvU3RyaW5nKCkge1xuICBcdHJldHVybiB0aGlzLnZhbHVlICE9IHVuZGVmaW5lZCA/IGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMoXCJcIiArIHRoaXMudmFsdWUpIDogXCJcIjtcbiAgfVxuXG4gIHZhciBUcmlwbGVfcHJvdG90eXBlX3VucmVuZGVyID0gVHJpcGxlJHVucmVuZGVyO1xuICBmdW5jdGlvbiBUcmlwbGUkdW5yZW5kZXIoc2hvdWxkRGVzdHJveSkge1xuICBcdGlmICh0aGlzLnJlbmRlcmVkICYmIHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdHRoaXMubm9kZXMuZm9yRWFjaChkZXRhY2hOb2RlKTtcbiAgXHRcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcbiAgXHR9XG5cbiAgXHQvLyBUT0RPIHVwZGF0ZSBsaXZlIHF1ZXJpZXNcbiAgfVxuXG4gIHZhciBUcmlwbGVfcHJvdG90eXBlX3VwZGF0ZSA9IFRyaXBsZSR1cGRhdGU7XG4gIGZ1bmN0aW9uIFRyaXBsZSR1cGRhdGUoKSB7XG4gIFx0dmFyIG5vZGUsIHBhcmVudE5vZGU7XG5cbiAgXHRpZiAoIXRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHQvLyBSZW1vdmUgZXhpc3Rpbmcgbm9kZXNcbiAgXHR3aGlsZSAodGhpcy5ub2RlcyAmJiB0aGlzLm5vZGVzLmxlbmd0aCkge1xuICBcdFx0bm9kZSA9IHRoaXMubm9kZXMucG9wKCk7XG4gIFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gIFx0fVxuXG4gIFx0Ly8gSW5zZXJ0IG5ldyBub2Rlc1xuICBcdHBhcmVudE5vZGUgPSB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKTtcblxuICBcdHRoaXMubm9kZXMgPSBpbnNlcnRIdG1sKHRoaXMudmFsdWUsIHBhcmVudE5vZGUsIHRoaXMuZG9jRnJhZyk7XG4gIFx0cGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5kb2NGcmFnLCB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKSk7XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSB3ZSdyZSBpbnNlcnRpbmcgdGhlIGNvbnRlbnRzIG9mIGEgPHNlbGVjdD5cbiAgXHRoZWxwZXJzX3VwZGF0ZVNlbGVjdCh0aGlzLnBFbGVtZW50KTtcbiAgfVxuXG4gIHZhciBUcmlwbGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHRoaXMudHlwZSA9IFRSSVBMRTtcbiAgXHRNdXN0YWNoZS5pbml0KHRoaXMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIFRyaXBsZS5wcm90b3R5cGUgPSB7XG4gIFx0ZGV0YWNoOiBUcmlwbGVfcHJvdG90eXBlX2RldGFjaCxcbiAgXHRmaW5kOiBUcmlwbGVfcHJvdG90eXBlX2ZpbmQsXG4gIFx0ZmluZEFsbDogVHJpcGxlX3Byb3RvdHlwZV9maW5kQWxsLFxuICBcdGZpcnN0Tm9kZTogVHJpcGxlX3Byb3RvdHlwZV9maXJzdE5vZGUsXG4gIFx0Z2V0VmFsdWU6IE11c3RhY2hlLmdldFZhbHVlLFxuICBcdHJlYmluZDogTXVzdGFjaGUucmViaW5kLFxuICBcdHJlbmRlcjogVHJpcGxlX3Byb3RvdHlwZV9yZW5kZXIsXG4gIFx0cmVzb2x2ZTogTXVzdGFjaGUucmVzb2x2ZSxcbiAgXHRzZXRWYWx1ZTogcHJvdG90eXBlX3NldFZhbHVlLFxuICBcdHRvU3RyaW5nOiBUcmlwbGVfcHJvdG90eXBlX3RvU3RyaW5nLFxuICBcdHVuYmluZDogc2hhcmVkX3VuYmluZCxcbiAgXHR1bnJlbmRlcjogVHJpcGxlX3Byb3RvdHlwZV91bnJlbmRlcixcbiAgXHR1cGRhdGU6IFRyaXBsZV9wcm90b3R5cGVfdXBkYXRlXG4gIH07XG5cbiAgdmFyIF9UcmlwbGUgPSBUcmlwbGU7XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2J1YmJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuICB9O1xuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9kZXRhY2ggPSBFbGVtZW50JGRldGFjaDtcblxuICBmdW5jdGlvbiBFbGVtZW50JGRldGFjaCgpIHtcbiAgXHR2YXIgbm9kZSA9IHRoaXMubm9kZSxcbiAgXHQgICAgcGFyZW50Tm9kZTtcblxuICBcdGlmIChub2RlKSB7XG4gIFx0XHQvLyBuZWVkIHRvIGNoZWNrIGZvciBwYXJlbnQgbm9kZSAtIERPTSBtYXkgaGF2ZSBiZWVuIGFsdGVyZWRcbiAgXHRcdC8vIGJ5IHNvbWV0aGluZyBvdGhlciB0aGFuIFJhY3RpdmUhIGUuZy4galF1ZXJ5IFVJLi4uXG4gIFx0XHRpZiAocGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZSkge1xuICBcdFx0XHRwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbm9kZTtcbiAgXHR9XG4gIH1cblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfZmluZCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICBcdGlmICghdGhpcy5ub2RlKSB7XG4gIFx0XHQvLyB0aGlzIGVsZW1lbnQgaGFzbid0IGJlZW4gcmVuZGVyZWQgeWV0XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAobWF0Y2hlcyh0aGlzLm5vZGUsIHNlbGVjdG9yKSkge1xuICBcdFx0cmV0dXJuIHRoaXMubm9kZTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5mcmFnbWVudCAmJiB0aGlzLmZyYWdtZW50LmZpbmQpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoc2VsZWN0b3IpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfZmluZEFsbCA9IGZ1bmN0aW9uIChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHQvLyBBZGQgdGhpcyBub2RlIHRvIHRoZSBxdWVyeSwgaWYgYXBwbGljYWJsZSwgYW5kIHJlZ2lzdGVyIHRoZVxuICBcdC8vIHF1ZXJ5IG9uIHRoaXMgZWxlbWVudFxuICBcdGlmIChxdWVyeS5fdGVzdCh0aGlzLCB0cnVlKSAmJiBxdWVyeS5saXZlKSB7XG4gIFx0XHQodGhpcy5saXZlUXVlcmllcyB8fCAodGhpcy5saXZlUXVlcmllcyA9IFtdKSkucHVzaChxdWVyeSk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQuZmluZEFsbChzZWxlY3RvciwgcXVlcnkpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2ZpbmRDb21wb25lbnQgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudChzZWxlY3Rvcik7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9maW5kTmV4dE5vZGUgPSBFbGVtZW50JGZpbmROZXh0Tm9kZTtcblxuICBmdW5jdGlvbiBFbGVtZW50JGZpbmROZXh0Tm9kZSgpIHtcbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9maXJzdE5vZGUgPSBFbGVtZW50JGZpcnN0Tm9kZTtcblxuICBmdW5jdGlvbiBFbGVtZW50JGZpcnN0Tm9kZSgpIHtcbiAgXHRyZXR1cm4gdGhpcy5ub2RlO1xuICB9XG5cbiAgdmFyIGdldEF0dHJpYnV0ZSA9IEVsZW1lbnQkZ2V0QXR0cmlidXRlO1xuXG4gIGZ1bmN0aW9uIEVsZW1lbnQkZ2V0QXR0cmlidXRlKG5hbWUpIHtcbiAgXHRpZiAoIXRoaXMuYXR0cmlidXRlcyB8fCAhdGhpcy5hdHRyaWJ1dGVzW25hbWVdKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlc1tuYW1lXS52YWx1ZTtcbiAgfVxuXG4gIHZhciB0cnV0aHkgPSAvXnRydWV8b258eWVzfDEkL2k7XG4gIHZhciBwcm9jZXNzQmluZGluZ0F0dHJpYnV0ZXNfX2lzTnVtZXJpYyA9IC9eWzAtOV0rJC87XG5cbiAgdmFyIHByb2Nlc3NCaW5kaW5nQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChlbGVtZW50LCB0ZW1wbGF0ZSkge1xuICBcdHZhciB2YWwsIGF0dHJzLCBhdHRyaWJ1dGVzO1xuXG4gIFx0YXR0cmlidXRlcyA9IHRlbXBsYXRlLmEgfHwge307XG4gIFx0YXR0cnMgPSB7fTtcblxuICBcdC8vIGF0dHJpYnV0ZXMgdGhhdCBhcmUgcHJlc2VudCBidXQgZG9uJ3QgaGF2ZSBhIHZhbHVlICg9KVxuICBcdC8vIHdpbGwgYmUgc2V0IHRvIHRoZSBudW1iZXIgMCwgd2hpY2ggd2UgY29uZGlkZXIgdG8gYmUgdHJ1ZVxuICBcdC8vIHRoZSBzdHJpbmcgJzAnLCBob3dldmVyIGlzIGZhbHNlXG5cbiAgXHR2YWwgPSBhdHRyaWJ1dGVzLnR3b3dheTtcbiAgXHRpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdGF0dHJzLnR3b3dheSA9IHZhbCA9PT0gMCB8fCB0cnV0aHkudGVzdCh2YWwpO1xuICBcdH1cblxuICBcdHZhbCA9IGF0dHJpYnV0ZXMubGF6eTtcbiAgXHRpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdC8vIGNoZWNrIGZvciB0aW1lb3V0IHZhbHVlXG4gIFx0XHRpZiAodmFsICE9PSAwICYmIHByb2Nlc3NCaW5kaW5nQXR0cmlidXRlc19faXNOdW1lcmljLnRlc3QodmFsKSkge1xuICBcdFx0XHRhdHRycy5sYXp5ID0gcGFyc2VJbnQodmFsKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGF0dHJzLmxhenkgPSB2YWwgPT09IDAgfHwgdHJ1dGh5LnRlc3QodmFsKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gYXR0cnM7XG4gIH07XG5cbiAgdmFyIEF0dHJpYnV0ZV9wcm90b3R5cGVfYnViYmxlID0gQXR0cmlidXRlJGJ1YmJsZTtcbiAgZnVuY3Rpb24gQXR0cmlidXRlJGJ1YmJsZSgpIHtcbiAgXHR2YXIgdmFsdWUgPSB0aGlzLnVzZVByb3BlcnR5IHx8ICF0aGlzLnJlbmRlcmVkID8gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpIDogdGhpcy5mcmFnbWVudC50b1N0cmluZygpO1xuXG4gIFx0Ly8gVE9ETyB0aGlzIGNhbiByZWdpc3RlciB0aGUgYXR0cmlidXRlIG11bHRpcGxlIHRpbWVzIChzZWUgcmVuZGVyIHRlc3RcbiAgXHQvLyAnQXR0cmlidXRlIHdpdGggbmVzdGVkIG11c3RhY2hlcycpXG4gIFx0aWYgKCFpc0VxdWFsKHZhbHVlLCB0aGlzLnZhbHVlKSkge1xuXG4gIFx0XHQvLyBOZWVkIHRvIGNsZWFyIG9sZCBpZCBmcm9tIHJhY3RpdmUubm9kZXNcbiAgXHRcdGlmICh0aGlzLm5hbWUgPT09IFwiaWRcIiAmJiB0aGlzLnZhbHVlKSB7XG4gIFx0XHRcdGRlbGV0ZSB0aGlzLnJvb3Qubm9kZXNbdGhpcy52YWx1ZV07XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICBcdFx0aWYgKHRoaXMubmFtZSA9PT0gXCJ2YWx1ZVwiICYmIHRoaXMubm9kZSkge1xuICBcdFx0XHQvLyBXZSBuZWVkIHRvIHN0b3JlIHRoZSB2YWx1ZSBvbiB0aGUgRE9NIGxpa2UgdGhpcyBzbyB3ZVxuICBcdFx0XHQvLyBjYW4gcmV0cmlldmUgaXQgbGF0ZXIgd2l0aG91dCBpdCBiZWluZyBjb2VyY2VkIHRvIGEgc3RyaW5nXG4gIFx0XHRcdHRoaXMubm9kZS5fcmFjdGl2ZS52YWx1ZSA9IHZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRWaWV3KHRoaXMpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBzdmdDYW1lbENhc2VFbGVtZW50cywgc3ZnQ2FtZWxDYXNlQXR0cmlidXRlcywgY3JlYXRlTWFwLCBtYXA7XG4gIHN2Z0NhbWVsQ2FzZUVsZW1lbnRzID0gXCJhbHRHbHlwaCBhbHRHbHlwaERlZiBhbHRHbHlwaEl0ZW0gYW5pbWF0ZUNvbG9yIGFuaW1hdGVNb3Rpb24gYW5pbWF0ZVRyYW5zZm9ybSBjbGlwUGF0aCBmZUJsZW5kIGZlQ29sb3JNYXRyaXggZmVDb21wb25lbnRUcmFuc2ZlciBmZUNvbXBvc2l0ZSBmZUNvbnZvbHZlTWF0cml4IGZlRGlmZnVzZUxpZ2h0aW5nIGZlRGlzcGxhY2VtZW50TWFwIGZlRGlzdGFudExpZ2h0IGZlRmxvb2QgZmVGdW5jQSBmZUZ1bmNCIGZlRnVuY0cgZmVGdW5jUiBmZUdhdXNzaWFuQmx1ciBmZUltYWdlIGZlTWVyZ2UgZmVNZXJnZU5vZGUgZmVNb3JwaG9sb2d5IGZlT2Zmc2V0IGZlUG9pbnRMaWdodCBmZVNwZWN1bGFyTGlnaHRpbmcgZmVTcG90TGlnaHQgZmVUaWxlIGZlVHVyYnVsZW5jZSBmb3JlaWduT2JqZWN0IGdseXBoUmVmIGxpbmVhckdyYWRpZW50IHJhZGlhbEdyYWRpZW50IHRleHRQYXRoIHZrZXJuXCIuc3BsaXQoXCIgXCIpO1xuICBzdmdDYW1lbENhc2VBdHRyaWJ1dGVzID0gXCJhdHRyaWJ1dGVOYW1lIGF0dHJpYnV0ZVR5cGUgYmFzZUZyZXF1ZW5jeSBiYXNlUHJvZmlsZSBjYWxjTW9kZSBjbGlwUGF0aFVuaXRzIGNvbnRlbnRTY3JpcHRUeXBlIGNvbnRlbnRTdHlsZVR5cGUgZGlmZnVzZUNvbnN0YW50IGVkZ2VNb2RlIGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQgZmlsdGVyUmVzIGZpbHRlclVuaXRzIGdseXBoUmVmIGdyYWRpZW50VHJhbnNmb3JtIGdyYWRpZW50VW5pdHMga2VybmVsTWF0cml4IGtlcm5lbFVuaXRMZW5ndGgga2V5UG9pbnRzIGtleVNwbGluZXMga2V5VGltZXMgbGVuZ3RoQWRqdXN0IGxpbWl0aW5nQ29uZUFuZ2xlIG1hcmtlckhlaWdodCBtYXJrZXJVbml0cyBtYXJrZXJXaWR0aCBtYXNrQ29udGVudFVuaXRzIG1hc2tVbml0cyBudW1PY3RhdmVzIHBhdGhMZW5ndGggcGF0dGVybkNvbnRlbnRVbml0cyBwYXR0ZXJuVHJhbnNmb3JtIHBhdHRlcm5Vbml0cyBwb2ludHNBdFggcG9pbnRzQXRZIHBvaW50c0F0WiBwcmVzZXJ2ZUFscGhhIHByZXNlcnZlQXNwZWN0UmF0aW8gcHJpbWl0aXZlVW5pdHMgcmVmWCByZWZZIHJlcGVhdENvdW50IHJlcGVhdER1ciByZXF1aXJlZEV4dGVuc2lvbnMgcmVxdWlyZWRGZWF0dXJlcyBzcGVjdWxhckNvbnN0YW50IHNwZWN1bGFyRXhwb25lbnQgc3ByZWFkTWV0aG9kIHN0YXJ0T2Zmc2V0IHN0ZERldmlhdGlvbiBzdGl0Y2hUaWxlcyBzdXJmYWNlU2NhbGUgc3lzdGVtTGFuZ3VhZ2UgdGFibGVWYWx1ZXMgdGFyZ2V0WCB0YXJnZXRZIHRleHRMZW5ndGggdmlld0JveCB2aWV3VGFyZ2V0IHhDaGFubmVsU2VsZWN0b3IgeUNoYW5uZWxTZWxlY3RvciB6b29tQW5kUGFuXCIuc3BsaXQoXCIgXCIpO1xuXG4gIGNyZWF0ZU1hcCA9IGZ1bmN0aW9uIChpdGVtcykge1xuICBcdHZhciBtYXAgPSB7fSxcbiAgXHQgICAgaSA9IGl0ZW1zLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRtYXBbaXRlbXNbaV0udG9Mb3dlckNhc2UoKV0gPSBpdGVtc1tpXTtcbiAgXHR9XG4gIFx0cmV0dXJuIG1hcDtcbiAgfTtcblxuICBtYXAgPSBjcmVhdGVNYXAoc3ZnQ2FtZWxDYXNlRWxlbWVudHMuY29uY2F0KHN2Z0NhbWVsQ2FzZUF0dHJpYnV0ZXMpKTtcblxuICB2YXIgZW5mb3JjZUNhc2UgPSBmdW5jdGlvbiAoZWxlbWVudE5hbWUpIHtcbiAgXHR2YXIgbG93ZXJDYXNlRWxlbWVudE5hbWUgPSBlbGVtZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICBcdHJldHVybiBtYXBbbG93ZXJDYXNlRWxlbWVudE5hbWVdIHx8IGxvd2VyQ2FzZUVsZW1lbnROYW1lO1xuICB9O1xuXG4gIHZhciBkZXRlcm1pbmVOYW1lQW5kTmFtZXNwYWNlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgbmFtZSkge1xuICBcdHZhciBjb2xvbkluZGV4LCBuYW1lc3BhY2VQcmVmaXg7XG5cbiAgXHQvLyBhcmUgd2UgZGVhbGluZyB3aXRoIGEgbmFtZXNwYWNlZCBhdHRyaWJ1dGUsIGUuZy4geGxpbms6aHJlZj9cbiAgXHRjb2xvbkluZGV4ID0gbmFtZS5pbmRleE9mKFwiOlwiKTtcbiAgXHRpZiAoY29sb25JbmRleCAhPT0gLTEpIHtcblxuICBcdFx0Ly8gbG9va3MgbGlrZSB3ZSBhcmUsIHllcy4uLlxuICBcdFx0bmFtZXNwYWNlUHJlZml4ID0gbmFtZS5zdWJzdHIoMCwgY29sb25JbmRleCk7XG5cbiAgXHRcdC8vIC4uLnVubGVzcyBpdCdzIGEgbmFtZXNwYWNlICpkZWNsYXJhdGlvbiosIHdoaWNoIHdlIGlnbm9yZSAob24gdGhlIGFzc3VtcHRpb25cbiAgXHRcdC8vIHRoYXQgb25seSB2YWxpZCBuYW1lc3BhY2VzIHdpbGwgYmUgdXNlZClcbiAgXHRcdGlmIChuYW1lc3BhY2VQcmVmaXggIT09IFwieG1sbnNcIikge1xuICBcdFx0XHRuYW1lID0gbmFtZS5zdWJzdHJpbmcoY29sb25JbmRleCArIDEpO1xuXG4gIFx0XHRcdGF0dHJpYnV0ZS5uYW1lID0gZW5mb3JjZUNhc2UobmFtZSk7XG4gIFx0XHRcdGF0dHJpYnV0ZS5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzW25hbWVzcGFjZVByZWZpeC50b0xvd2VyQ2FzZSgpXTtcbiAgXHRcdFx0YXR0cmlidXRlLm5hbWVzcGFjZVByZWZpeCA9IG5hbWVzcGFjZVByZWZpeDtcblxuICBcdFx0XHRpZiAoIWF0dHJpYnV0ZS5uYW1lc3BhY2UpIHtcbiAgXHRcdFx0XHR0aHJvdyBcIlVua25vd24gbmFtZXNwYWNlIChcXFwiXCIgKyBuYW1lc3BhY2VQcmVmaXggKyBcIlxcXCIpXCI7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gU1ZHIGF0dHJpYnV0ZSBuYW1lcyBhcmUgY2FzZSBzZW5zaXRpdmVcbiAgXHRhdHRyaWJ1dGUubmFtZSA9IGF0dHJpYnV0ZS5lbGVtZW50Lm5hbWVzcGFjZSAhPT0gbmFtZXNwYWNlcy5odG1sID8gZW5mb3JjZUNhc2UobmFtZSkgOiBuYW1lO1xuICB9O1xuXG4gIHZhciBoZWxwZXJzX2dldEludGVycG9sYXRvciA9IGdldEludGVycG9sYXRvcjtcbiAgZnVuY3Rpb24gZ2V0SW50ZXJwb2xhdG9yKGF0dHJpYnV0ZSkge1xuICBcdHZhciBpdGVtcyA9IGF0dHJpYnV0ZS5mcmFnbWVudC5pdGVtcztcblxuICBcdGlmIChpdGVtcy5sZW5ndGggIT09IDEpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRpZiAoaXRlbXNbMF0udHlwZSA9PT0gSU5URVJQT0xBVE9SKSB7XG4gIFx0XHRyZXR1cm4gaXRlbXNbMF07XG4gIFx0fVxuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9pbml0ID0gQXR0cmlidXRlJGluaXQ7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSRpbml0KG9wdGlvbnMpIHtcbiAgXHR0aGlzLnR5cGUgPSBBVFRSSUJVVEU7XG4gIFx0dGhpcy5lbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50O1xuICBcdHRoaXMucm9vdCA9IG9wdGlvbnMucm9vdDtcblxuICBcdGRldGVybWluZU5hbWVBbmROYW1lc3BhY2UodGhpcywgb3B0aW9ucy5uYW1lKTtcbiAgXHR0aGlzLmlzQm9vbGVhbiA9IGJvb2xlYW5BdHRyaWJ1dGVzLnRlc3QodGhpcy5uYW1lKTtcblxuICBcdC8vIGlmIGl0J3MgYW4gZW1wdHkgYXR0cmlidXRlLCBvciBqdXN0IGEgc3RyYWlnaHQga2V5LXZhbHVlIHBhaXIsIHdpdGggbm9cbiAgXHQvLyBtdXN0YWNoZSBzaGVuYW5pZ2Fucywgc2V0IHRoZSBhdHRyaWJ1dGUgYWNjb3JkaW5nbHkgYW5kIGdvIGhvbWVcbiAgXHRpZiAoIW9wdGlvbnMudmFsdWUgfHwgdHlwZW9mIG9wdGlvbnMudmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHRoaXMudmFsdWUgPSB0aGlzLmlzQm9vbGVhbiA/IHRydWUgOiBvcHRpb25zLnZhbHVlIHx8IFwiXCI7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0Ly8gb3RoZXJ3aXNlIHdlIG5lZWQgdG8gZG8gc29tZSB3b3JrXG5cbiAgXHQvLyBzaGFyZSBwYXJlbnRGcmFnbWVudCB3aXRoIHBhcmVudCBlbGVtZW50XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IHRoaXMuZWxlbWVudC5wYXJlbnRGcmFnbWVudDtcblxuICBcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHR0ZW1wbGF0ZTogb3B0aW9ucy52YWx1ZSxcbiAgXHRcdHJvb3Q6IHRoaXMucm9vdCxcbiAgXHRcdG93bmVyOiB0aGlzXG4gIFx0fSk7XG5cbiAgXHQvLyBUT0RPIGNhbiB3ZSB1c2UgdGhpcy5mcmFnbWVudC50b1N0cmluZygpIGluIHNvbWUgY2FzZXM/IEl0J3MgcXVpY2tlclxuICBcdHRoaXMudmFsdWUgPSB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCk7XG5cbiAgXHQvLyBTdG9yZSBhIHJlZmVyZW5jZSB0byB0aGlzIGF0dHJpYnV0ZSdzIGludGVycG9sYXRvciwgaWYgaXRzIGZyYWdtZW50XG4gIFx0Ly8gdGFrZXMgdGhlIGZvcm0gYHt7Zm9vfX1gLiBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgdHdvLXdheSBiaW5kaW5nIGFuZFxuICBcdC8vIGZvciBjb3JyZWN0bHkgcmVuZGVyaW5nIEhUTUwgbGF0ZXJcbiAgXHR0aGlzLmludGVycG9sYXRvciA9IGhlbHBlcnNfZ2V0SW50ZXJwb2xhdG9yKHRoaXMpO1xuICBcdHRoaXMuaXNCaW5kYWJsZSA9ICEhdGhpcy5pbnRlcnBvbGF0b3IgJiYgIXRoaXMuaW50ZXJwb2xhdG9yLmlzU3RhdGljO1xuXG4gIFx0Ly8gbWFyayBhcyByZWFkeVxuICBcdHRoaXMucmVhZHkgPSB0cnVlO1xuICB9XG5cbiAgdmFyIEF0dHJpYnV0ZV9wcm90b3R5cGVfcmViaW5kID0gQXR0cmlidXRlJHJlYmluZDtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkcmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIEF0dHJpYnV0ZV9wcm90b3R5cGVfcmVuZGVyID0gQXR0cmlidXRlJHJlbmRlcjtcbiAgdmFyIHByb3BlcnR5TmFtZXMgPSB7XG4gIFx0XCJhY2NlcHQtY2hhcnNldFwiOiBcImFjY2VwdENoYXJzZXRcIixcbiAgXHRhY2Nlc3NrZXk6IFwiYWNjZXNzS2V5XCIsXG4gIFx0Ymdjb2xvcjogXCJiZ0NvbG9yXCIsXG4gIFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiLFxuICBcdGNvZGViYXNlOiBcImNvZGVCYXNlXCIsXG4gIFx0Y29sc3BhbjogXCJjb2xTcGFuXCIsXG4gIFx0Y29udGVudGVkaXRhYmxlOiBcImNvbnRlbnRFZGl0YWJsZVwiLFxuICBcdGRhdGV0aW1lOiBcImRhdGVUaW1lXCIsXG4gIFx0ZGlybmFtZTogXCJkaXJOYW1lXCIsXG4gIFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG4gIFx0XCJodHRwLWVxdWl2XCI6IFwiaHR0cEVxdWl2XCIsXG4gIFx0aXNtYXA6IFwiaXNNYXBcIixcbiAgXHRtYXhsZW5ndGg6IFwibWF4TGVuZ3RoXCIsXG4gIFx0bm92YWxpZGF0ZTogXCJub1ZhbGlkYXRlXCIsXG4gIFx0cHViZGF0ZTogXCJwdWJEYXRlXCIsXG4gIFx0cmVhZG9ubHk6IFwicmVhZE9ubHlcIixcbiAgXHRyb3dzcGFuOiBcInJvd1NwYW5cIixcbiAgXHR0YWJpbmRleDogXCJ0YWJJbmRleFwiLFxuICBcdHVzZW1hcDogXCJ1c2VNYXBcIlxuICB9O1xuICBmdW5jdGlvbiBBdHRyaWJ1dGUkcmVuZGVyKG5vZGUpIHtcbiAgXHR2YXIgcHJvcGVydHlOYW1lO1xuXG4gIFx0dGhpcy5ub2RlID0gbm9kZTtcblxuICBcdC8vIHNob3VsZCB3ZSB1c2UgZGlyZWN0IHByb3BlcnR5IGFjY2Vzcywgb3Igc2V0QXR0cmlidXRlP1xuICBcdGlmICghbm9kZS5uYW1lc3BhY2VVUkkgfHwgbm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuaHRtbCkge1xuICBcdFx0cHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lc1t0aGlzLm5hbWVdIHx8IHRoaXMubmFtZTtcblxuICBcdFx0aWYgKG5vZGVbcHJvcGVydHlOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHRoaXMucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBpcyBhdHRyaWJ1dGUgYSBib29sZWFuIGF0dHJpYnV0ZSBvciAndmFsdWUnPyBJZiBzbyB3ZSdyZSBiZXR0ZXIgb2ZmIGRvaW5nIGUuZy5cbiAgXHRcdC8vIG5vZGUuc2VsZWN0ZWQgPSB0cnVlIHJhdGhlciB0aGFuIG5vZGUuc2V0QXR0cmlidXRlKCAnc2VsZWN0ZWQnLCAnJyApXG4gIFx0XHRpZiAodGhpcy5pc0Jvb2xlYW4gfHwgdGhpcy5pc1R3b3dheSkge1xuICBcdFx0XHR0aGlzLnVzZVByb3BlcnR5ID0gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHByb3BlcnR5TmFtZSA9PT0gXCJ2YWx1ZVwiKSB7XG4gIFx0XHRcdG5vZGUuX3JhY3RpdmUudmFsdWUgPSB0aGlzLnZhbHVlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICBcdHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICB2YXIgQXR0cmlidXRlX3Byb3RvdHlwZV90b1N0cmluZyA9IEF0dHJpYnV0ZSR0b1N0cmluZztcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdG9TdHJpbmcoKSB7XG4gIFx0dmFyIF9yZWYgPSB0aGlzO1xuXG4gIFx0dmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gIFx0dmFyIG5hbWVzcGFjZVByZWZpeCA9IF9yZWYubmFtZXNwYWNlUHJlZml4O1xuICBcdHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG4gIFx0dmFyIGludGVycG9sYXRvciA9IF9yZWYuaW50ZXJwb2xhdG9yO1xuICBcdHZhciBmcmFnbWVudCA9IF9yZWYuZnJhZ21lbnQ7XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSBzZWxlY3QgYW5kIHRleHRhcmVhIHZhbHVlcyAoc2hvdWxkIG5vdCBiZSBzdHJpbmdpZmllZClcbiAgXHRpZiAobmFtZSA9PT0gXCJ2YWx1ZVwiICYmICh0aGlzLmVsZW1lbnQubmFtZSA9PT0gXCJzZWxlY3RcIiB8fCB0aGlzLmVsZW1lbnQubmFtZSA9PT0gXCJ0ZXh0YXJlYVwiKSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIGNvbnRlbnQgZWRpdGFibGVcbiAgXHRpZiAobmFtZSA9PT0gXCJ2YWx1ZVwiICYmIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHJhZGlvIG5hbWVzXG4gIFx0aWYgKG5hbWUgPT09IFwibmFtZVwiICYmIHRoaXMuZWxlbWVudC5uYW1lID09PSBcImlucHV0XCIgJiYgaW50ZXJwb2xhdG9yKSB7XG4gIFx0XHRyZXR1cm4gXCJuYW1lPXt7XCIgKyAoaW50ZXJwb2xhdG9yLmtleXBhdGguc3RyIHx8IGludGVycG9sYXRvci5yZWYpICsgXCJ9fVwiO1xuICBcdH1cblxuICBcdC8vIEJvb2xlYW4gYXR0cmlidXRlc1xuICBcdGlmICh0aGlzLmlzQm9vbGVhbikge1xuICBcdFx0cmV0dXJuIHZhbHVlID8gbmFtZSA6IFwiXCI7XG4gIFx0fVxuXG4gIFx0aWYgKGZyYWdtZW50KSB7XG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSB0aGlzIGNhdGNoZXMgdW5kZWZpbmVkL251bGwgdmFsdWVzICgjMTIxMSlcbiAgXHRcdGlmIChmcmFnbWVudC5pdGVtcy5sZW5ndGggPT09IDEgJiYgZnJhZ21lbnQuaXRlbXNbMF0udmFsdWUgPT0gbnVsbCkge1xuICBcdFx0XHRyZXR1cm4gXCJcIjtcbiAgXHRcdH1cblxuICBcdFx0dmFsdWUgPSBmcmFnbWVudC50b1N0cmluZygpO1xuICBcdH1cblxuICBcdGlmIChuYW1lc3BhY2VQcmVmaXgpIHtcbiAgXHRcdG5hbWUgPSBuYW1lc3BhY2VQcmVmaXggKyBcIjpcIiArIG5hbWU7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHZhbHVlID8gbmFtZSArIFwiPVxcXCJcIiArIEF0dHJpYnV0ZV9wcm90b3R5cGVfdG9TdHJpbmdfX2VzY2FwZSh2YWx1ZSkgKyBcIlxcXCJcIiA6IG5hbWU7XG4gIH1cblxuICBmdW5jdGlvbiBBdHRyaWJ1dGVfcHJvdG90eXBlX3RvU3RyaW5nX19lc2NhcGUodmFsdWUpIHtcbiAgXHRyZXR1cm4gdmFsdWUucmVwbGFjZSgvJi9nLCBcIiZhbXA7XCIpLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpLnJlcGxhY2UoLycvZywgXCImIzM5O1wiKTtcbiAgfVxuXG4gIHZhciBBdHRyaWJ1dGVfcHJvdG90eXBlX3VuYmluZCA9IEF0dHJpYnV0ZSR1bmJpbmQ7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVuYmluZCgpIHtcbiAgXHQvLyBpZ25vcmUgbm9uLWR5bmFtaWMgYXR0cmlidXRlc1xuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLm5hbWUgPT09IFwiaWRcIikge1xuICBcdFx0ZGVsZXRlIHRoaXMucm9vdC5ub2Rlc1t0aGlzLnZhbHVlXTtcbiAgXHR9XG4gIH1cblxuICB2YXIgdXBkYXRlU2VsZWN0VmFsdWUgPSBBdHRyaWJ1dGUkdXBkYXRlU2VsZWN0O1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVTZWxlY3QoKSB7XG4gIFx0dmFyIHZhbHVlID0gdGhpcy52YWx1ZSxcbiAgXHQgICAgb3B0aW9ucyxcbiAgXHQgICAgb3B0aW9uLFxuICBcdCAgICBvcHRpb25WYWx1ZSxcbiAgXHQgICAgaTtcblxuICBcdGlmICghdGhpcy5sb2NrZWQpIHtcbiAgXHRcdHRoaXMubm9kZS5fcmFjdGl2ZS52YWx1ZSA9IHZhbHVlO1xuXG4gIFx0XHRvcHRpb25zID0gdGhpcy5ub2RlLm9wdGlvbnM7XG4gIFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0b3B0aW9uID0gb3B0aW9uc1tpXTtcbiAgXHRcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7IC8vIG9wdGlvbnMgaW5zZXJ0ZWQgdmlhIGEgdHJpcGxlIGRvbid0IGhhdmUgX3JhY3RpdmVcblxuICBcdFx0XHRpZiAob3B0aW9uVmFsdWUgPT0gdmFsdWUpIHtcbiAgXHRcdFx0XHQvLyBkb3VibGUgZXF1YWxzIGFzIHdlIG1heSBiZSBjb21wYXJpbmcgbnVtYmVycyB3aXRoIHN0cmluZ3NcbiAgXHRcdFx0XHRvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuICBcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gaWYgd2UncmUgc3RpbGwgaGVyZSwgaXQgbWVhbnMgdGhlIG5ldyB2YWx1ZSBkaWRuJ3QgbWF0Y2ggYW55IG9mIHRoZSBvcHRpb25zLi4uXG4gIFx0Ly8gVE9ETyBmaWd1cmUgb3V0IHdoYXQgdG8gZG8gaW4gdGhpcyBzaXR1YXRpb25cbiAgfVxuXG4gIHZhciB1cGRhdGVNdWx0aXBsZVNlbGVjdFZhbHVlID0gQXR0cmlidXRlJHVwZGF0ZU11bHRpcGxlU2VsZWN0O1xuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlTXVsdGlwbGVTZWxlY3QoKSB7XG4gIFx0dmFyIHZhbHVlID0gdGhpcy52YWx1ZSxcbiAgXHQgICAgb3B0aW9ucyxcbiAgXHQgICAgaSxcbiAgXHQgICAgb3B0aW9uLFxuICBcdCAgICBvcHRpb25WYWx1ZTtcblxuICBcdGlmICghaXNBcnJheSh2YWx1ZSkpIHtcbiAgXHRcdHZhbHVlID0gW3ZhbHVlXTtcbiAgXHR9XG5cbiAgXHRvcHRpb25zID0gdGhpcy5ub2RlLm9wdGlvbnM7XG4gIFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0b3B0aW9uID0gb3B0aW9uc1tpXTtcbiAgXHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLl9yYWN0aXZlID8gb3B0aW9uLl9yYWN0aXZlLnZhbHVlIDogb3B0aW9uLnZhbHVlOyAvLyBvcHRpb25zIGluc2VydGVkIHZpYSBhIHRyaXBsZSBkb24ndCBoYXZlIF9yYWN0aXZlXG4gIFx0XHRvcHRpb24uc2VsZWN0ZWQgPSBhcnJheUNvbnRhaW5zKHZhbHVlLCBvcHRpb25WYWx1ZSk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHVwZGF0ZVJhZGlvTmFtZSA9IEF0dHJpYnV0ZSR1cGRhdGVSYWRpb05hbWU7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZVJhZGlvTmFtZSgpIHtcbiAgXHR2YXIgX3JlZiA9IHRoaXM7XG5cbiAgXHR2YXIgbm9kZSA9IF9yZWYubm9kZTtcbiAgXHR2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuXG4gIFx0bm9kZS5jaGVja2VkID0gdmFsdWUgPT0gbm9kZS5fcmFjdGl2ZS52YWx1ZTtcbiAgfVxuXG4gIHZhciB1cGRhdGVSYWRpb1ZhbHVlID0gQXR0cmlidXRlJHVwZGF0ZVJhZGlvVmFsdWU7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVSYWRpb1ZhbHVlKCkge1xuICBcdHZhciB3YXNDaGVja2VkLFxuICBcdCAgICBub2RlID0gdGhpcy5ub2RlLFxuICBcdCAgICBiaW5kaW5nLFxuICBcdCAgICBiaW5kaW5ncyxcbiAgXHQgICAgaTtcblxuICBcdHdhc0NoZWNrZWQgPSBub2RlLmNoZWNrZWQ7XG5cbiAgXHRub2RlLnZhbHVlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICBcdG5vZGUuY2hlY2tlZCA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSA9PT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG5cbiAgXHQvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIC0gaWYgdGhlIGlucHV0IHdhcyBjaGVja2VkLCBhbmQgdGhlIHZhbHVlXG4gIFx0Ly8gY2hhbmdlZCBzbyB0aGF0IGl0J3Mgbm8gbG9uZ2VyIGNoZWNrZWQsIHRoZSB0d293YXkgYmluZGluZyBpc1xuICBcdC8vIG1vc3QgbGlrZWx5IG91dCBvZiBkYXRlLiBUbyBmaXggaXQgd2UgaGF2ZSB0byBqdW1wIHRocm91Z2ggc29tZVxuICBcdC8vIGhvb3BzLi4uIHRoaXMgaXMgYSBsaXR0bGUga2x1ZGd5IGJ1dCBpdCB3b3Jrc1xuICBcdGlmICh3YXNDaGVja2VkICYmICFub2RlLmNoZWNrZWQgJiYgdGhpcy5lbGVtZW50LmJpbmRpbmcpIHtcbiAgXHRcdGJpbmRpbmdzID0gdGhpcy5lbGVtZW50LmJpbmRpbmcuc2libGluZ3M7XG5cbiAgXHRcdGlmIChpID0gYmluZGluZ3MubGVuZ3RoKSB7XG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRiaW5kaW5nID0gYmluZGluZ3NbaV07XG5cbiAgXHRcdFx0XHRpZiAoIWJpbmRpbmcuZWxlbWVudC5ub2RlKSB7XG4gIFx0XHRcdFx0XHQvLyB0aGlzIGlzIHRoZSBpbml0aWFsIHJlbmRlciwgc2libGluZ3MgYXJlIHN0aWxsIHJlbmRlcmluZyFcbiAgXHRcdFx0XHRcdC8vIHdlJ2xsIGNvbWUgYmFjayBsYXRlci4uLlxuICBcdFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGlmIChiaW5kaW5nLmVsZW1lbnQubm9kZS5jaGVja2VkKSB7XG4gIFx0XHRcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRSYWN0aXZlKGJpbmRpbmcucm9vdCk7XG4gIFx0XHRcdFx0XHRyZXR1cm4gYmluZGluZy5oYW5kbGVDaGFuZ2UoKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldChiaW5kaW5nLmtleXBhdGgsIHVuZGVmaW5lZCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIHVwZGF0ZUNoZWNrYm94TmFtZSA9IEF0dHJpYnV0ZSR1cGRhdGVDaGVja2JveE5hbWU7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVDaGVja2JveE5hbWUoKSB7XG4gIFx0dmFyIF9yZWYgPSB0aGlzO1xuXG4gIFx0dmFyIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQ7XG4gIFx0dmFyIG5vZGUgPSBfcmVmLm5vZGU7XG4gIFx0dmFyIHZhbHVlID0gX3JlZi52YWx1ZTt2YXIgYmluZGluZyA9IGVsZW1lbnQuYmluZGluZzt2YXIgdmFsdWVBdHRyaWJ1dGU7dmFyIGk7XG5cbiAgXHR2YWx1ZUF0dHJpYnV0ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cbiAgXHRpZiAoIWlzQXJyYXkodmFsdWUpKSB7XG4gIFx0XHRiaW5kaW5nLmlzQ2hlY2tlZCA9IG5vZGUuY2hlY2tlZCA9IHZhbHVlID09IHZhbHVlQXR0cmlidXRlO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRpID0gdmFsdWUubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRpZiAodmFsdWVBdHRyaWJ1dGUgPT0gdmFsdWVbaV0pIHtcbiAgXHRcdFx0XHRiaW5kaW5nLmlzQ2hlY2tlZCA9IG5vZGUuY2hlY2tlZCA9IHRydWU7XG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHRiaW5kaW5nLmlzQ2hlY2tlZCA9IG5vZGUuY2hlY2tlZCA9IGZhbHNlO1xuICBcdH1cbiAgfVxuXG4gIHZhciB1cGRhdGVDbGFzc05hbWUgPSBBdHRyaWJ1dGUkdXBkYXRlQ2xhc3NOYW1lO1xuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlQ2xhc3NOYW1lKCkge1xuICBcdHRoaXMubm9kZS5jbGFzc05hbWUgPSBzYWZlVG9TdHJpbmdWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVJZEF0dHJpYnV0ZSA9IEF0dHJpYnV0ZSR1cGRhdGVJZEF0dHJpYnV0ZTtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlSWRBdHRyaWJ1dGUoKSB7XG4gIFx0dmFyIF9yZWYgPSB0aGlzO1xuXG4gIFx0dmFyIG5vZGUgPSBfcmVmLm5vZGU7XG4gIFx0dmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcblxuICBcdHRoaXMucm9vdC5ub2Rlc1t2YWx1ZV0gPSBub2RlO1xuICBcdG5vZGUuaWQgPSB2YWx1ZTtcbiAgfVxuXG4gIHZhciB1cGRhdGVJRVN0eWxlQXR0cmlidXRlID0gQXR0cmlidXRlJHVwZGF0ZUlFU3R5bGVBdHRyaWJ1dGU7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUlFU3R5bGVBdHRyaWJ1dGUoKSB7XG4gIFx0dmFyIG5vZGUsIHZhbHVlO1xuXG4gIFx0bm9kZSA9IHRoaXMubm9kZTtcbiAgXHR2YWx1ZSA9IHRoaXMudmFsdWU7XG5cbiAgXHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0dmFsdWUgPSBcIlwiO1xuICBcdH1cblxuICBcdG5vZGUuc3R5bGUuc2V0QXR0cmlidXRlKFwiY3NzVGV4dFwiLCB2YWx1ZSk7XG4gIH1cblxuICB2YXIgdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWUgPSBBdHRyaWJ1dGUkdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWU7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlKCkge1xuICBcdHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG5cbiAgXHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0dmFsdWUgPSBcIlwiO1xuICBcdH1cblxuICBcdGlmICghdGhpcy5sb2NrZWQpIHtcbiAgXHRcdHRoaXMubm9kZS5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgXHR9XG4gIH1cblxuICB2YXIgdXBkYXRlVmFsdWUgPSBBdHRyaWJ1dGUkdXBkYXRlVmFsdWU7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZVZhbHVlKCkge1xuICBcdHZhciBfcmVmID0gdGhpcztcblxuICBcdHZhciBub2RlID0gX3JlZi5ub2RlO1xuICBcdHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG5cbiAgXHQvLyBzdG9yZSBhY3R1YWwgdmFsdWUsIHNvIGl0IGRvZXNuJ3QgZ2V0IGNvZXJjZWQgdG8gYSBzdHJpbmdcbiAgXHRub2RlLl9yYWN0aXZlLnZhbHVlID0gdmFsdWU7XG5cbiAgXHQvLyB3aXRoIHR3by13YXkgYmluZGluZywgb25seSB1cGRhdGUgaWYgdGhlIGNoYW5nZSB3YXNuJ3QgaW5pdGlhdGVkIGJ5IHRoZSB1c2VyXG4gIFx0Ly8gb3RoZXJ3aXNlIHRoZSBjdXJzb3Igd2lsbCBvZnRlbiBiZSBzZW50IHRvIHRoZSB3cm9uZyBwbGFjZVxuICBcdGlmICghdGhpcy5sb2NrZWQpIHtcbiAgXHRcdG5vZGUudmFsdWUgPSB2YWx1ZSA9PSB1bmRlZmluZWQgPyBcIlwiIDogdmFsdWU7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHVwZGF0ZUJvb2xlYW4gPSBBdHRyaWJ1dGUkdXBkYXRlQm9vbGVhbkF0dHJpYnV0ZTtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlQm9vbGVhbkF0dHJpYnV0ZSgpIHtcbiAgXHQvLyB3aXRoIHR3by13YXkgYmluZGluZywgb25seSB1cGRhdGUgaWYgdGhlIGNoYW5nZSB3YXNuJ3QgaW5pdGlhdGVkIGJ5IHRoZSB1c2VyXG4gIFx0Ly8gb3RoZXJ3aXNlIHRoZSBjdXJzb3Igd2lsbCBvZnRlbiBiZSBzZW50IHRvIHRoZSB3cm9uZyBwbGFjZVxuICBcdGlmICghdGhpcy5sb2NrZWQpIHtcbiAgXHRcdHRoaXMubm9kZVt0aGlzLnByb3BlcnR5TmFtZV0gPSB0aGlzLnZhbHVlO1xuICBcdH1cbiAgfVxuXG4gIHZhciB1cGRhdGVFdmVyeXRoaW5nRWxzZSA9IEF0dHJpYnV0ZSR1cGRhdGVFdmVyeXRoaW5nRWxzZTtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlRXZlcnl0aGluZ0Vsc2UoKSB7XG4gIFx0dmFyIF9yZWYgPSB0aGlzO1xuXG4gIFx0dmFyIG5vZGUgPSBfcmVmLm5vZGU7XG4gIFx0dmFyIG5hbWVzcGFjZSA9IF9yZWYubmFtZXNwYWNlO1xuICBcdHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICBcdHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG4gIFx0dmFyIGZyYWdtZW50ID0gX3JlZi5mcmFnbWVudDtcblxuICBcdGlmIChuYW1lc3BhY2UpIHtcbiAgXHRcdG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBuYW1lLCAoZnJhZ21lbnQgfHwgdmFsdWUpLnRvU3RyaW5nKCkpO1xuICBcdH0gZWxzZSBpZiAoIXRoaXMuaXNCb29sZWFuKSB7XG4gIFx0XHRpZiAodmFsdWUgPT0gbnVsbCkge1xuICBcdFx0XHRub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIChmcmFnbWVudCB8fCB2YWx1ZSkudG9TdHJpbmcoKSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIC0gdHJ1dGh5IGJlY29tZXMgJycsIGZhbHN5IG1lYW5zICdyZW1vdmUgYXR0cmlidXRlJ1xuICBcdGVsc2Uge1xuICBcdFx0aWYgKHZhbHVlKSB7XG4gIFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIFwiXCIpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0bm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgLy8gVGhlcmUgYXJlIGEgZmV3IHNwZWNpYWwgY2FzZXMgd2hlbiBpdCBjb21lcyB0byB1cGRhdGluZyBhdHRyaWJ1dGVzLiBGb3IgdGhpcyByZWFzb24sXG4gIC8vIHRoZSBwcm90b3R5cGUgLnVwZGF0ZSgpIG1ldGhvZCBwb2ludHMgdG8gdGhpcyBtZXRob2QsIHdoaWNoIHdhaXRzIHVudGlsIHRoZVxuICAvLyBhdHRyaWJ1dGUgaGFzIGZpbmlzaGVkIGluaXRpYWxpc2luZywgdGhlbiByZXBsYWNlcyB0aGUgcHJvdG90eXBlIG1ldGhvZCB3aXRoIGEgbW9yZVxuICAvLyBzdWl0YWJsZSBvbmUuIFRoYXQgd2F5LCB3ZSBzYXZlIG91cnNlbHZlcyBkb2luZyBhIGJ1bmNoIG9mIHRlc3RzIG9uIGVhY2ggY2FsbFxuICB2YXIgQXR0cmlidXRlX3Byb3RvdHlwZV91cGRhdGUgPSBBdHRyaWJ1dGUkdXBkYXRlO1xuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlKCkge1xuICBcdHZhciBfcmVmID0gdGhpcztcblxuICBcdHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICBcdHZhciBlbGVtZW50ID0gX3JlZi5lbGVtZW50O1xuICBcdHZhciBub2RlID0gX3JlZi5ub2RlO3ZhciB0eXBlO3ZhciB1cGRhdGVNZXRob2Q7XG5cbiAgXHRpZiAobmFtZSA9PT0gXCJpZFwiKSB7XG4gIFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVJZEF0dHJpYnV0ZTtcbiAgXHR9IGVsc2UgaWYgKG5hbWUgPT09IFwidmFsdWVcIikge1xuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gc2VsZWN0c1xuICBcdFx0aWYgKGVsZW1lbnQubmFtZSA9PT0gXCJzZWxlY3RcIiAmJiBuYW1lID09PSBcInZhbHVlXCIpIHtcbiAgXHRcdFx0dXBkYXRlTWV0aG9kID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSA/IHVwZGF0ZU11bHRpcGxlU2VsZWN0VmFsdWUgOiB1cGRhdGVTZWxlY3RWYWx1ZTtcbiAgXHRcdH0gZWxzZSBpZiAoZWxlbWVudC5uYW1lID09PSBcInRleHRhcmVhXCIpIHtcbiAgXHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlVmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIGNvbnRlbnRlZGl0YWJsZVxuICBcdFx0ZWxzZSBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikgIT0gbnVsbCkge1xuICBcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gPGlucHV0PlxuICBcdFx0ZWxzZSBpZiAoZWxlbWVudC5uYW1lID09PSBcImlucHV0XCIpIHtcbiAgXHRcdFx0dHlwZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKTtcblxuICBcdFx0XHQvLyB0eXBlPSdmaWxlJyB2YWx1ZT0ne3tmaWxlTGlzdH19Jz5cbiAgXHRcdFx0aWYgKHR5cGUgPT09IFwiZmlsZVwiKSB7XG4gIFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gbm9vcDsgLy8gcmVhZC1vbmx5XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyB0eXBlPSdyYWRpbycgbmFtZT0ne3t0d293YXl9fSdcbiAgXHRcdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCJyYWRpb1wiICYmIGVsZW1lbnQuYmluZGluZyAmJiBlbGVtZW50LmJpbmRpbmcubmFtZSA9PT0gXCJuYW1lXCIpIHtcbiAgXHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVSYWRpb1ZhbHVlO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZVZhbHVlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gc3BlY2lhbCBjYXNlIC0gPGlucHV0IHR5cGU9J3JhZGlvJyBuYW1lPSd7e3R3b3dheX19JyB2YWx1ZT0nZm9vJz5cbiAgXHRlbHNlIGlmICh0aGlzLmlzVHdvd2F5ICYmIG5hbWUgPT09IFwibmFtZVwiKSB7XG4gIFx0XHRpZiAobm9kZS50eXBlID09PSBcInJhZGlvXCIpIHtcbiAgXHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlUmFkaW9OYW1lO1xuICBcdFx0fSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuICBcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVDaGVja2JveE5hbWU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gc3BlY2lhbCBjYXNlIC0gc3R5bGUgYXR0cmlidXRlcyBpbiBJbnRlcm5ldCBFeHBsb2RlclxuICBcdGVsc2UgaWYgKG5hbWUgPT09IFwic3R5bGVcIiAmJiBub2RlLnN0eWxlLnNldEF0dHJpYnV0ZSkge1xuICBcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZTtcbiAgXHR9XG5cbiAgXHQvLyBzcGVjaWFsIGNhc2UgLSBjbGFzcyBuYW1lcy4gSUUgZnVja3MgdGhpbmdzIHVwLCBhZ2FpblxuICBcdGVsc2UgaWYgKG5hbWUgPT09IFwiY2xhc3NcIiAmJiAoIW5vZGUubmFtZXNwYWNlVVJJIHx8IG5vZGUubmFtZXNwYWNlVVJJID09PSBuYW1lc3BhY2VzLmh0bWwpKSB7XG4gIFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVDbGFzc05hbWU7XG4gIFx0fSBlbHNlIGlmICh0aGlzLnVzZVByb3BlcnR5KSB7XG4gIFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVCb29sZWFuO1xuICBcdH1cblxuICBcdGlmICghdXBkYXRlTWV0aG9kKSB7XG4gIFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVFdmVyeXRoaW5nRWxzZTtcbiAgXHR9XG5cbiAgXHR0aGlzLnVwZGF0ZSA9IHVwZGF0ZU1ldGhvZDtcbiAgXHR0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgdmFyIEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy5pbml0KG9wdGlvbnMpO1xuICB9O1xuXG4gIEF0dHJpYnV0ZS5wcm90b3R5cGUgPSB7XG4gIFx0YnViYmxlOiBBdHRyaWJ1dGVfcHJvdG90eXBlX2J1YmJsZSxcbiAgXHRpbml0OiBwcm90b3R5cGVfaW5pdCxcbiAgXHRyZWJpbmQ6IEF0dHJpYnV0ZV9wcm90b3R5cGVfcmViaW5kLFxuICBcdHJlbmRlcjogQXR0cmlidXRlX3Byb3RvdHlwZV9yZW5kZXIsXG4gIFx0dG9TdHJpbmc6IEF0dHJpYnV0ZV9wcm90b3R5cGVfdG9TdHJpbmcsXG4gIFx0dW5iaW5kOiBBdHRyaWJ1dGVfcHJvdG90eXBlX3VuYmluZCxcbiAgXHR1cGRhdGU6IEF0dHJpYnV0ZV9wcm90b3R5cGVfdXBkYXRlXG4gIH07XG5cbiAgdmFyIF9BdHRyaWJ1dGUgPSBBdHRyaWJ1dGU7XG5cbiAgdmFyIGNyZWF0ZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICBcdHZhciBuYW1lLFxuICBcdCAgICBhdHRyaWJ1dGUsXG4gIFx0ICAgIHJlc3VsdCA9IFtdO1xuXG4gIFx0Zm9yIChuYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgXHRcdC8vIHNraXAgYmluZGluZyBhdHRyaWJ1dGVzXG4gIFx0XHRpZiAobmFtZSA9PT0gXCJ0d293YXlcIiB8fCBuYW1lID09PSBcImxhenlcIikge1xuICBcdFx0XHRjb250aW51ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgXHRcdFx0YXR0cmlidXRlID0gbmV3IF9BdHRyaWJ1dGUoe1xuICBcdFx0XHRcdGVsZW1lbnQ6IGVsZW1lbnQsXG4gIFx0XHRcdFx0bmFtZTogbmFtZSxcbiAgXHRcdFx0XHR2YWx1ZTogYXR0cmlidXRlc1tuYW1lXSxcbiAgXHRcdFx0XHRyb290OiBlbGVtZW50LnJvb3RcbiAgXHRcdFx0fSk7XG5cbiAgXHRcdFx0cmVzdWx0W25hbWVdID0gYXR0cmlidXRlO1xuXG4gIFx0XHRcdGlmIChuYW1lICE9PSBcInZhbHVlXCIpIHtcbiAgXHRcdFx0XHRyZXN1bHQucHVzaChhdHRyaWJ1dGUpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gdmFsdWUgYXR0cmlidXRlIGdvZXMgbGFzdC4gVGhpcyBpcyBiZWNhdXNlIGl0XG4gIFx0Ly8gbWF5IGdldCBjbGFtcGVkIG9uIHJlbmRlciBvdGhlcndpc2UsIGUuZy4gaW5cbiAgXHQvLyBgPGlucHV0IHR5cGU9J3JhbmdlJyB2YWx1ZT0nOTk5JyBtaW49JzAnIG1heD0nMTAwMCc+YFxuICBcdC8vIHNpbmNlIGRlZmF1bHQgbWF4IGlzIDEwMFxuICBcdGlmIChhdHRyaWJ1dGUgPSByZXN1bHQudmFsdWUpIHtcbiAgXHRcdHJlc3VsdC5wdXNoKGF0dHJpYnV0ZSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgX0NvbmRpdGlvbmFsQXR0cmlidXRlX19kaXY7XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBcdF9Db25kaXRpb25hbEF0dHJpYnV0ZV9fZGl2ID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgfVxuXG4gIHZhciBDb25kaXRpb25hbEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCB0ZW1wbGF0ZSkge1xuICBcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIFx0dGhpcy5yb290ID0gZWxlbWVudC5yb290O1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBlbGVtZW50LnBhcmVudEZyYWdtZW50O1xuXG4gIFx0dGhpcy5hdHRyaWJ1dGVzID0gW107XG5cbiAgXHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0cm9vdDogZWxlbWVudC5yb290LFxuICBcdFx0b3duZXI6IHRoaXMsXG4gIFx0XHR0ZW1wbGF0ZTogW3RlbXBsYXRlXVxuICBcdH0pO1xuICB9O1xuXG4gIENvbmRpdGlvbmFsQXR0cmlidXRlLnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLm5vZGUpIHtcbiAgXHRcdFx0dGhpcy51cGRhdGUoKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5lbGVtZW50LmJ1YmJsZSgpO1xuICBcdH0sXG5cbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICBcdFx0dGhpcy5ub2RlID0gbm9kZTtcbiAgXHRcdHRoaXMuaXNTdmcgPSBub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5zdmc7XG5cbiAgXHRcdHRoaXMudXBkYXRlKCk7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHR9LFxuXG4gIFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgc3RyLCBhdHRycztcblxuICBcdFx0c3RyID0gdGhpcy5mcmFnbWVudC50b1N0cmluZygpO1xuICBcdFx0YXR0cnMgPSBwYXJzZUF0dHJpYnV0ZXMoc3RyLCB0aGlzLmlzU3ZnKTtcblxuICBcdFx0Ly8gYW55IGF0dHJpYnV0ZXMgdGhhdCBwcmV2aW91c2x5IGV4aXN0ZWQgYnV0IG5vIGxvbmdlciBkb1xuICBcdFx0Ly8gbXVzdCBiZSByZW1vdmVkXG4gIFx0XHR0aGlzLmF0dHJpYnV0ZXMuZmlsdGVyKGZ1bmN0aW9uIChhKSB7XG4gIFx0XHRcdHJldHVybiBub3RJbihhdHRycywgYSk7XG4gIFx0XHR9KS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gIFx0XHRcdF90aGlzLm5vZGUucmVtb3ZlQXR0cmlidXRlKGEubmFtZSk7XG4gIFx0XHR9KTtcblxuICBcdFx0YXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICBcdFx0XHRfdGhpcy5ub2RlLnNldEF0dHJpYnV0ZShhLm5hbWUsIGEudmFsdWUpO1xuICBcdFx0fSk7XG5cbiAgXHRcdHRoaXMuYXR0cmlidXRlcyA9IGF0dHJzO1xuICBcdH0sXG5cbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIF9Db25kaXRpb25hbEF0dHJpYnV0ZSA9IENvbmRpdGlvbmFsQXR0cmlidXRlO1xuXG4gIGZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlcyhzdHIsIGlzU3ZnKSB7XG4gIFx0dmFyIHRhZyA9IGlzU3ZnID8gXCJzdmdcIiA6IFwiZGl2XCI7XG4gIFx0X0NvbmRpdGlvbmFsQXR0cmlidXRlX19kaXYuaW5uZXJIVE1MID0gXCI8XCIgKyB0YWcgKyBcIiBcIiArIHN0ciArIFwiPjwvXCIgKyB0YWcgKyBcIj5cIjtcblxuICBcdHJldHVybiB0b0FycmF5KF9Db25kaXRpb25hbEF0dHJpYnV0ZV9fZGl2LmNoaWxkTm9kZXNbMF0uYXR0cmlidXRlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBub3RJbihoYXlzdGFjaywgbmVlZGxlKSB7XG4gIFx0dmFyIGkgPSBoYXlzdGFjay5sZW5ndGg7XG5cbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpZiAoaGF5c3RhY2tbaV0ubmFtZSA9PT0gbmVlZGxlLm5hbWUpIHtcbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGNyZWF0ZUNvbmRpdGlvbmFsQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gIFx0aWYgKCFhdHRyaWJ1dGVzKSB7XG4gIFx0XHRyZXR1cm4gW107XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGF0dHJpYnV0ZXMubWFwKGZ1bmN0aW9uIChhKSB7XG4gIFx0XHRyZXR1cm4gbmV3IF9Db25kaXRpb25hbEF0dHJpYnV0ZShlbGVtZW50LCBhKTtcbiAgXHR9KTtcbiAgfTtcblxuICB2YXIgQmluZGluZyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIFx0dmFyIGludGVycG9sYXRvciwga2V5cGF0aCwgdmFsdWUsIHBhcmVudEZvcm07XG5cbiAgXHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICBcdHRoaXMucm9vdCA9IGVsZW1lbnQucm9vdDtcbiAgXHR0aGlzLmF0dHJpYnV0ZSA9IGVsZW1lbnQuYXR0cmlidXRlc1t0aGlzLm5hbWUgfHwgXCJ2YWx1ZVwiXTtcblxuICBcdGludGVycG9sYXRvciA9IHRoaXMuYXR0cmlidXRlLmludGVycG9sYXRvcjtcbiAgXHRpbnRlcnBvbGF0b3IudHdvd2F5QmluZGluZyA9IHRoaXM7XG5cbiAgXHRpZiAoa2V5cGF0aCA9IGludGVycG9sYXRvci5rZXlwYXRoKSB7XG4gIFx0XHRpZiAoa2V5cGF0aC5zdHIuc2xpY2UoLTEpID09PSBcIn1cIikge1xuICBcdFx0XHR3YXJuT25jZUlmRGVidWcoXCJUd28td2F5IGJpbmRpbmcgZG9lcyBub3Qgd29yayB3aXRoIGV4cHJlc3Npb25zIChgJXNgIG9uIDwlcz4pXCIsIGludGVycG9sYXRvci5yZXNvbHZlci51bmlxdWVTdHJpbmcsIGVsZW1lbnQubmFtZSwgeyByYWN0aXZlOiB0aGlzLnJvb3QgfSk7XG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGtleXBhdGguaXNTcGVjaWFsKSB7XG4gIFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyhcIlR3by13YXkgYmluZGluZyBkb2VzIG5vdCB3b3JrIHdpdGggJXNcIiwgaW50ZXJwb2xhdG9yLnJlc29sdmVyLnJlZiwgeyByYWN0aXZlOiB0aGlzLnJvb3QgfSk7XG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0Ly8gQSBtdXN0YWNoZSBtYXkgYmUgKmFtYmlndW91cyouIExldCdzIHNheSB3ZSB3ZXJlIGdpdmVuXG4gIFx0XHQvLyBgdmFsdWU9XCJ7e2Jhcn19XCJgLiBJZiB0aGUgY29udGV4dCB3YXMgYGZvb2AsIGFuZCBgZm9vLmJhcmBcbiAgXHRcdC8vICp3YXNuJ3QqIGB1bmRlZmluZWRgLCB0aGUga2V5cGF0aCB3b3VsZCBiZSBgZm9vLmJhcmAuXG4gIFx0XHQvLyBUaGVuLCBhbnkgdXNlciBpbnB1dCB3b3VsZCByZXN1bHQgaW4gYGZvby5iYXJgIGJlaW5nIHVwZGF0ZWQuXG4gIFx0XHQvL1xuICBcdFx0Ly8gSWYsIGhvd2V2ZXIsIGBmb28uYmFyYCAqd2FzKiB1bmRlZmluZWQsIGFuZCBzbyB3YXMgYGJhcmAsIHdlIHdvdWxkIGJlXG4gIFx0XHQvLyBsZWZ0IHdpdGggYW4gdW5yZXNvbHZlZCBwYXJ0aWFsIGtleXBhdGggLSBzbyB3ZSBhcmUgZm9yY2VkIHRvIG1ha2UgYW5cbiAgXHRcdC8vIGFzc3VtcHRpb24uIFRoYXQgYXNzdW1wdGlvbiBpcyB0aGF0IHRoZSBpbnB1dCBpbiBxdWVzdGlvbiBzaG91bGRcbiAgXHRcdC8vIGJlIGZvcmNlZCB0byByZXNvbHZlIHRvIGBiYXJgLCBhbmQgYW55IHVzZXIgaW5wdXQgd291bGQgYWZmZWN0IGBiYXJgXG4gIFx0XHQvLyBhbmQgbm90IGBmb28uYmFyYC5cbiAgXHRcdC8vXG4gIFx0XHQvLyBEaWQgdGhhdCBtYWtlIGFueSBzZW5zZT8gTm8/IE9oLiBTb3JyeS4gV2VsbCB0aGUgbW9yYWwgb2YgdGhlIHN0b3J5IGlzXG4gIFx0XHQvLyBiZSBleHBsaWNpdCB3aGVuIHVzaW5nIHR3by13YXkgZGF0YS1iaW5kaW5nIGFib3V0IHdoYXQga2V5cGF0aCB5b3UncmVcbiAgXHRcdC8vIHVwZGF0aW5nLiBVc2luZyBpdCBpbiBsaXN0cyBpcyBwcm9iYWJseSBhIHJlY2lwZSBmb3IgY29uZnVzaW9uLi4uXG4gIFx0XHR2YXIgcmVmID0gaW50ZXJwb2xhdG9yLnRlbXBsYXRlLnIgPyBcIidcIiArIGludGVycG9sYXRvci50ZW1wbGF0ZS5yICsgXCInIHJlZmVyZW5jZVwiIDogXCJleHByZXNzaW9uXCI7XG4gIFx0XHR3YXJuSWZEZWJ1ZyhcIlRoZSAlcyBiZWluZyB1c2VkIGZvciB0d28td2F5IGJpbmRpbmcgaXMgYW1iaWd1b3VzLCBhbmQgbWF5IGNhdXNlIHVuZXhwZWN0ZWQgcmVzdWx0cy4gQ29uc2lkZXIgaW5pdGlhbGlzaW5nIHlvdXIgZGF0YSB0byBlbGltaW5hdGUgdGhlIGFtYmlndWl0eVwiLCByZWYsIHsgcmFjdGl2ZTogdGhpcy5yb290IH0pO1xuICBcdFx0aW50ZXJwb2xhdG9yLnJlc29sdmVyLmZvcmNlUmVzb2x1dGlvbigpO1xuICBcdFx0a2V5cGF0aCA9IGludGVycG9sYXRvci5rZXlwYXRoO1xuICBcdH1cblxuICBcdHRoaXMuYXR0cmlidXRlLmlzVHdvd2F5ID0gdHJ1ZTtcbiAgXHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXG4gIFx0Ly8gaW5pdGlhbGlzZSB2YWx1ZSwgaWYgaXQncyB1bmRlZmluZWRcbiAgXHR2YWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuXG4gIFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgdGhpcy5nZXRJbml0aWFsVmFsdWUpIHtcbiAgXHRcdHZhbHVlID0gdGhpcy5nZXRJbml0aWFsVmFsdWUoKTtcblxuICBcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoa2V5cGF0aCwgdmFsdWUpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChwYXJlbnRGb3JtID0gZmluZFBhcmVudEZvcm0oZWxlbWVudCkpIHtcbiAgXHRcdHRoaXMucmVzZXRWYWx1ZSA9IHZhbHVlO1xuICBcdFx0cGFyZW50Rm9ybS5mb3JtQmluZGluZ3MucHVzaCh0aGlzKTtcbiAgXHR9XG4gIH07XG5cbiAgQmluZGluZy5wcm90b3R5cGUgPSB7XG4gIFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLnJvb3QpO1xuICBcdFx0dGhpcy5hdHRyaWJ1dGUubG9ja2VkID0gdHJ1ZTtcbiAgXHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KHRoaXMua2V5cGF0aCwgdGhpcy5nZXRWYWx1ZSgpKTtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHJldHVybiBfdGhpcy5hdHRyaWJ1dGUubG9ja2VkID0gZmFsc2U7XG4gIFx0XHR9KTtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuICBcdH0sXG5cbiAgXHRyZWJvdW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgYmluZGluZ3MsIG9sZEtleXBhdGgsIG5ld0tleXBhdGg7XG5cbiAgXHRcdG9sZEtleXBhdGggPSB0aGlzLmtleXBhdGg7XG4gIFx0XHRuZXdLZXlwYXRoID0gdGhpcy5hdHRyaWJ1dGUuaW50ZXJwb2xhdG9yLmtleXBhdGg7XG5cbiAgXHRcdC8vIFRoZSBhdHRyaWJ1dGUgdGhpcyBiaW5kaW5nIGlzIGxpbmtlZCB0byBoYXMgYWxyZWFkeSBkb25lIHRoZSB3b3JrXG4gIFx0XHRpZiAob2xkS2V5cGF0aCA9PT0gbmV3S2V5cGF0aCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHJlbW92ZUZyb21BcnJheSh0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzW29sZEtleXBhdGguc3RyXSwgdGhpcyk7XG5cbiAgXHRcdHRoaXMua2V5cGF0aCA9IG5ld0tleXBhdGg7XG5cbiAgXHRcdGJpbmRpbmdzID0gdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1tuZXdLZXlwYXRoLnN0cl0gfHwgKHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3NbbmV3S2V5cGF0aC5zdHJdID0gW10pO1xuICBcdFx0YmluZGluZ3MucHVzaCh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7fVxuICB9O1xuXG4gIEJpbmRpbmcuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcbiAgXHR2YXIgUGFyZW50ID0gdGhpcyxcbiAgXHQgICAgU3BlY2lhbGlzZWRCaW5kaW5nO1xuXG4gIFx0U3BlY2lhbGlzZWRCaW5kaW5nID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgXHRcdEJpbmRpbmcuY2FsbCh0aGlzLCBlbGVtZW50KTtcblxuICBcdFx0aWYgKHRoaXMuaW5pdCkge1xuICBcdFx0XHR0aGlzLmluaXQoKTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0U3BlY2lhbGlzZWRCaW5kaW5nLnByb3RvdHlwZSA9IGNyZWF0ZShQYXJlbnQucHJvdG90eXBlKTtcbiAgXHR1dGlsc19vYmplY3RfX2V4dGVuZChTcGVjaWFsaXNlZEJpbmRpbmcucHJvdG90eXBlLCBwcm9wZXJ0aWVzKTtcblxuICBcdFNwZWNpYWxpc2VkQmluZGluZy5leHRlbmQgPSBCaW5kaW5nLmV4dGVuZDtcblxuICBcdHJldHVybiBTcGVjaWFsaXNlZEJpbmRpbmc7XG4gIH07XG5cbiAgdmFyIEJpbmRpbmdfQmluZGluZyA9IEJpbmRpbmc7XG5cbiAgZnVuY3Rpb24gZmluZFBhcmVudEZvcm0oZWxlbWVudCkge1xuICBcdHdoaWxlIChlbGVtZW50ID0gZWxlbWVudC5wYXJlbnQpIHtcbiAgXHRcdGlmIChlbGVtZW50Lm5hbWUgPT09IFwiZm9ybVwiKSB7XG4gIFx0XHRcdHJldHVybiBlbGVtZW50O1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIC8vIHRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIGVsZW1lbnQgaXMgdW5ib3VuZC5cbiAgLy8gU3BlY2lhbGlzZWQgYmluZGluZ3MgY2FuIG92ZXJyaWRlIGl0XG5cbiAgLy8gVGhpcyBpcyB0aGUgaGFuZGxlciBmb3IgRE9NIGV2ZW50cyB0aGF0IHdvdWxkIGxlYWQgdG8gYSBjaGFuZ2UgaW4gdGhlIG1vZGVsXG4gIC8vIChpLmUuIGNoYW5nZSwgc29tZXRpbWVzLCBpbnB1dCwgYW5kIG9jY2FzaW9uYWxseSBjbGljayBhbmQga2V5dXApXG4gIHZhciBoYW5kbGVEb21FdmVudCA9IGhhbmRsZUNoYW5nZTtcblxuICBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UoKSB7XG4gIFx0dGhpcy5fcmFjdGl2ZS5iaW5kaW5nLmhhbmRsZUNoYW5nZSgpO1xuICB9XG5cbiAgdmFyIEdlbmVyaWNCaW5kaW5nO1xuXG4gIEdlbmVyaWNCaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gXCJcIjtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS52YWx1ZTtcbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlLFxuICBcdFx0ICAgIGxhenksXG4gIFx0XHQgICAgdGltZW91dCA9IGZhbHNlO1xuICBcdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG5cbiAgXHRcdC8vIGFueSBsYXp5IHNldHRpbmcgZm9yIHRoaXMgZWxlbWVudCBvdmVycmlkZXMgdGhlIHJvb3RcbiAgXHRcdC8vIGlmIHRoZSB2YWx1ZSBpcyBhIG51bWJlciwgaXQncyBhIHRpbWVvdXRcbiAgXHRcdGxhenkgPSB0aGlzLnJvb3QubGF6eTtcbiAgXHRcdGlmICh0aGlzLmVsZW1lbnQubGF6eSA9PT0gdHJ1ZSkge1xuICBcdFx0XHRsYXp5ID0gdHJ1ZTtcbiAgXHRcdH0gZWxzZSBpZiAodGhpcy5lbGVtZW50LmxhenkgPT09IGZhbHNlKSB7XG4gIFx0XHRcdGxhenkgPSBmYWxzZTtcbiAgXHRcdH0gZWxzZSBpZiAoaXNfX2lzTnVtZXJpYyh0aGlzLmVsZW1lbnQubGF6eSkpIHtcbiAgXHRcdFx0bGF6eSA9IGZhbHNlO1xuICBcdFx0XHR0aW1lb3V0ID0gK3RoaXMuZWxlbWVudC5sYXp5O1xuICBcdFx0fSBlbHNlIGlmIChpc19faXNOdW1lcmljKGxhenkgfHwgXCJcIikpIHtcbiAgXHRcdFx0dGltZW91dCA9ICtsYXp5O1xuICBcdFx0XHRsYXp5ID0gZmFsc2U7XG5cbiAgXHRcdFx0Ly8gbWFrZSBzdXJlIHRoZSB0aW1lb3V0IGlzIGF2YWlsYWJsZSB0byB0aGUgaGFuZGxlclxuICBcdFx0XHR0aGlzLmVsZW1lbnQubGF6eSA9IHRpbWVvdXQ7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuaGFuZGxlciA9IHRpbWVvdXQgPyBoYW5kbGVEZWxheSA6IGhhbmRsZURvbUV2ZW50O1xuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcblxuICBcdFx0aWYgKCFsYXp5KSB7XG4gIFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuaGFuZGxlciwgZmFsc2UpO1xuXG4gIFx0XHRcdGlmIChub2RlLmF0dGFjaEV2ZW50KSB7XG4gIFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5oYW5kbGVyLCBmYWxzZSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBoYW5kbGVCbHVyLCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuICBcdFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuXG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuaGFuZGxlciwgZmFsc2UpO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5oYW5kbGVyLCBmYWxzZSk7XG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGhhbmRsZUJsdXIsIGZhbHNlKTtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBCaW5kaW5nX0dlbmVyaWNCaW5kaW5nID0gR2VuZXJpY0JpbmRpbmc7XG5cbiAgZnVuY3Rpb24gaGFuZGxlQmx1cigpIHtcbiAgXHR2YXIgdmFsdWU7XG5cbiAgXHRoYW5kbGVEb21FdmVudC5jYWxsKHRoaXMpO1xuXG4gIFx0dmFsdWUgPSB0aGlzLl9yYWN0aXZlLnJvb3Qudmlld21vZGVsLmdldCh0aGlzLl9yYWN0aXZlLmJpbmRpbmcua2V5cGF0aCk7XG4gIFx0dGhpcy52YWx1ZSA9IHZhbHVlID09IHVuZGVmaW5lZCA/IFwiXCIgOiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZURlbGF5KCkge1xuICBcdHZhciBiaW5kaW5nID0gdGhpcy5fcmFjdGl2ZS5iaW5kaW5nLFxuICBcdCAgICBlbCA9IHRoaXM7XG5cbiAgXHRpZiAoISFiaW5kaW5nLl90aW1lb3V0KSBjbGVhclRpbWVvdXQoYmluZGluZy5fdGltZW91dCk7XG5cbiAgXHRiaW5kaW5nLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoYmluZGluZy5yZW5kZXJlZCkgaGFuZGxlRG9tRXZlbnQuY2FsbChlbCk7XG4gIFx0XHRiaW5kaW5nLl90aW1lb3V0ID0gdW5kZWZpbmVkO1xuICBcdH0sIGJpbmRpbmcuZWxlbWVudC5sYXp5KTtcbiAgfVxuXG4gIHZhciBDb250ZW50RWRpdGFibGVCaW5kaW5nID0gQmluZGluZ19HZW5lcmljQmluZGluZy5leHRlbmQoe1xuICBcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5mcmFnbWVudCA/IHRoaXMuZWxlbWVudC5mcmFnbWVudC50b1N0cmluZygpIDogXCJcIjtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS5pbm5lckhUTUw7XG4gIFx0fVxuICB9KTtcblxuICB2YXIgQmluZGluZ19Db250ZW50RWRpdGFibGVCaW5kaW5nID0gQ29udGVudEVkaXRhYmxlQmluZGluZztcblxuICB2YXIgc2hhcmVkX2dldFNpYmxpbmdzID0gZ2V0U2libGluZ3M7XG4gIHZhciBzZXRzID0ge307XG4gIGZ1bmN0aW9uIGdldFNpYmxpbmdzKGlkLCBncm91cCwga2V5cGF0aCkge1xuICBcdHZhciBoYXNoID0gaWQgKyBncm91cCArIGtleXBhdGg7XG4gIFx0cmV0dXJuIHNldHNbaGFzaF0gfHwgKHNldHNbaGFzaF0gPSBbXSk7XG4gIH1cblxuICB2YXIgUmFkaW9CaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0bmFtZTogXCJjaGVja2VkXCIsXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLnNpYmxpbmdzID0gc2hhcmVkX2dldFNpYmxpbmdzKHRoaXMucm9vdC5fZ3VpZCwgXCJyYWRpb1wiLCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibmFtZVwiKSk7XG4gIFx0XHR0aGlzLnNpYmxpbmdzLnB1c2godGhpcyk7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblxuICBcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG5cbiAgXHRcdGlmIChub2RlLmF0dGFjaEV2ZW50KSB7XG4gIFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24gKCkge1xuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcy5yb290KTtcblxuICBcdFx0dGhpcy5zaWJsaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gIFx0XHRcdGJpbmRpbmcucm9vdC52aWV3bW9kZWwuc2V0KGJpbmRpbmcua2V5cGF0aCwgYmluZGluZy5nZXRWYWx1ZSgpKTtcbiAgXHRcdH0pO1xuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS5jaGVja2VkO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheSh0aGlzLnNpYmxpbmdzLCB0aGlzKTtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBCaW5kaW5nX1JhZGlvQmluZGluZyA9IFJhZGlvQmluZGluZztcblxuICB2YXIgUmFkaW9OYW1lQmluZGluZyA9IEJpbmRpbmdfQmluZGluZy5leHRlbmQoe1xuICBcdG5hbWU6IFwibmFtZVwiLFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5zaWJsaW5ncyA9IHNoYXJlZF9nZXRTaWJsaW5ncyh0aGlzLnJvb3QuX2d1aWQsIFwicmFkaW9uYW1lXCIsIHRoaXMua2V5cGF0aC5zdHIpO1xuICBcdFx0dGhpcy5zaWJsaW5ncy5wdXNoKHRoaXMpO1xuXG4gIFx0XHR0aGlzLnJhZGlvTmFtZSA9IHRydWU7IC8vIHNvIHRoYXQgcmFjdGl2ZS51cGRhdGVNb2RlbCgpIGtub3dzIHdoYXQgdG8gZG8gd2l0aCB0aGlzXG4gIFx0fSxcblxuICBcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIpKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblxuICBcdFx0bm9kZS5uYW1lID0gXCJ7e1wiICsgdGhpcy5rZXlwYXRoLnN0ciArIFwifX1cIjtcbiAgXHRcdG5vZGUuY2hlY2tlZCA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KHRoaXMua2V5cGF0aCkgPT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcblxuICBcdFx0aWYgKG5vZGUuYXR0YWNoRXZlbnQpIHtcbiAgXHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG4gIFx0XHRyZXR1cm4gbm9kZS5fcmFjdGl2ZSA/IG5vZGUuX3JhY3RpdmUudmFsdWUgOiBub2RlLnZhbHVlO1xuICBcdH0sXG5cbiAgXHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIElmIHRoaXMgPGlucHV0PiBpcyB0aGUgb25lIHRoYXQncyBjaGVja2VkLCB0aGVuIHRoZSB2YWx1ZSBvZiBpdHNcbiAgXHRcdC8vIGBuYW1lYCBrZXlwYXRoIGdldHMgc2V0IHRvIGl0cyB2YWx1ZVxuICBcdFx0aWYgKHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQpIHtcbiAgXHRcdFx0QmluZGluZ19CaW5kaW5nLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UuY2FsbCh0aGlzKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmVib3VuZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdHZhciBub2RlO1xuXG4gIFx0XHRCaW5kaW5nX0JpbmRpbmcucHJvdG90eXBlLnJlYm91bmQuY2FsbCh0aGlzLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcblxuICBcdFx0aWYgKG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZSkge1xuICBcdFx0XHRub2RlLm5hbWUgPSBcInt7XCIgKyB0aGlzLmtleXBhdGguc3RyICsgXCJ9fVwiO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheSh0aGlzLnNpYmxpbmdzLCB0aGlzKTtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBCaW5kaW5nX1JhZGlvTmFtZUJpbmRpbmcgPSBSYWRpb05hbWVCaW5kaW5nO1xuXG4gIHZhciBDaGVja2JveE5hbWVCaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0bmFtZTogXCJuYW1lXCIsXG5cbiAgXHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIFRoaXMgb25seSBnZXRzIGNhbGxlZCBvbmNlIHBlciBncm91cCAob2YgaW5wdXRzIHRoYXRcbiAgXHRcdC8vIHNoYXJlIGEgbmFtZSksIGJlY2F1c2UgaXQgb25seSBnZXRzIGNhbGxlZCBpZiB0aGVyZVxuICBcdFx0Ly8gaXNuJ3QgYW4gaW5pdGlhbCB2YWx1ZS4gQnkgdGhlIHNhbWUgdG9rZW4sIHdlIGNhbiBtYWtlXG4gIFx0XHQvLyBhIG5vdGUgb2YgdGhhdCBmYWN0IHRoYXQgdGhlcmUgd2FzIG5vIGluaXRpYWwgdmFsdWUsXG4gIFx0XHQvLyBhbmQgcG9wdWxhdGUgaXQgdXNpbmcgYW55IGBjaGVja2VkYCBhdHRyaWJ1dGVzIHRoYXRcbiAgXHRcdC8vIGV4aXN0ICh3aGljaCB1c2VycyBzaG91bGQgYXZvaWQsIGJ1dCB3aGljaCB3ZSBzaG91bGRcbiAgXHRcdC8vIHN1cHBvcnQgYW55d2F5IHRvIGF2b2lkIGJyZWFraW5nIGV4cGVjdGF0aW9ucylcbiAgXHRcdHRoaXMubm9Jbml0aWFsVmFsdWUgPSB0cnVlO1xuICBcdFx0cmV0dXJuIFtdO1xuICBcdH0sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZXhpc3RpbmdWYWx1ZSwgYmluZGluZ1ZhbHVlO1xuXG4gIFx0XHR0aGlzLmNoZWNrYm94TmFtZSA9IHRydWU7IC8vIHNvIHRoYXQgcmFjdGl2ZS51cGRhdGVNb2RlbCgpIGtub3dzIHdoYXQgdG8gZG8gd2l0aCB0aGlzXG5cbiAgXHRcdC8vIEVhY2ggaW5wdXQgaGFzIGEgcmVmZXJlbmNlIHRvIGFuIGFycmF5IGNvbnRhaW5pbmcgaXQgYW5kIGl0c1xuICBcdFx0Ly8gc2libGluZ3MsIGFzIHR3by13YXkgYmluZGluZyBkZXBlbmRzIG9uIGJlaW5nIGFibGUgdG8gYXNjZXJ0YWluXG4gIFx0XHQvLyB0aGUgc3RhdHVzIG9mIGFsbCBpbnB1dHMgd2l0aGluIHRoZSBncm91cFxuICBcdFx0dGhpcy5zaWJsaW5ncyA9IHNoYXJlZF9nZXRTaWJsaW5ncyh0aGlzLnJvb3QuX2d1aWQsIFwiY2hlY2tib3hlc1wiLCB0aGlzLmtleXBhdGguc3RyKTtcbiAgXHRcdHRoaXMuc2libGluZ3MucHVzaCh0aGlzKTtcblxuICBcdFx0aWYgKHRoaXMubm9Jbml0aWFsVmFsdWUpIHtcbiAgXHRcdFx0dGhpcy5zaWJsaW5ncy5ub0luaXRpYWxWYWx1ZSA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIElmIG5vIGluaXRpYWwgdmFsdWUgd2FzIHNldCwgYW5kIHRoaXMgaW5wdXQgaXMgY2hlY2tlZCwgd2VcbiAgXHRcdC8vIHVwZGF0ZSB0aGUgbW9kZWxcbiAgXHRcdGlmICh0aGlzLnNpYmxpbmdzLm5vSW5pdGlhbFZhbHVlICYmIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIpKSB7XG4gIFx0XHRcdGV4aXN0aW5nVmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCh0aGlzLmtleXBhdGgpO1xuICBcdFx0XHRiaW5kaW5nVmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cbiAgXHRcdFx0ZXhpc3RpbmdWYWx1ZS5wdXNoKGJpbmRpbmdWYWx1ZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMuc2libGluZ3MsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGUsXG4gIFx0XHQgICAgZXhpc3RpbmdWYWx1ZSxcbiAgXHRcdCAgICBiaW5kaW5nVmFsdWU7XG5cbiAgXHRcdGV4aXN0aW5nVmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCh0aGlzLmtleXBhdGgpO1xuICBcdFx0YmluZGluZ1ZhbHVlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuXG4gIFx0XHRpZiAoaXNBcnJheShleGlzdGluZ1ZhbHVlKSkge1xuICBcdFx0XHR0aGlzLmlzQ2hlY2tlZCA9IGFycmF5Q29udGFpbnMoZXhpc3RpbmdWYWx1ZSwgYmluZGluZ1ZhbHVlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuaXNDaGVja2VkID0gZXhpc3RpbmdWYWx1ZSA9PSBiaW5kaW5nVmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdG5vZGUubmFtZSA9IFwie3tcIiArIHRoaXMua2V5cGF0aC5zdHIgKyBcIn19XCI7XG4gIFx0XHRub2RlLmNoZWNrZWQgPSB0aGlzLmlzQ2hlY2tlZDtcblxuICBcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG5cbiAgXHRcdC8vIGluIGNhc2Ugb2YgSUUgZW1lcmdlbmN5LCBiaW5kIHRvIGNsaWNrIGV2ZW50IGFzIHdlbGxcbiAgXHRcdGlmIChub2RlLmF0dGFjaEV2ZW50KSB7XG4gIFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdGNoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciB3YXNDaGVja2VkID0gISF0aGlzLmlzQ2hlY2tlZDtcbiAgXHRcdHRoaXMuaXNDaGVja2VkID0gdGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZDtcbiAgXHRcdHJldHVybiB0aGlzLmlzQ2hlY2tlZCA9PT0gd2FzQ2hlY2tlZDtcbiAgXHR9LFxuXG4gIFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmlzQ2hlY2tlZCA9IHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG4gIFx0XHRCaW5kaW5nX0JpbmRpbmcucHJvdG90eXBlLmhhbmRsZUNoYW5nZS5jYWxsKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuc2libGluZ3MuZmlsdGVyKGlzQ2hlY2tlZCkubWFwKEJpbmRpbmdfQ2hlY2tib3hOYW1lQmluZGluZ19fZ2V0VmFsdWUpO1xuICBcdH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gaXNDaGVja2VkKGJpbmRpbmcpIHtcbiAgXHRyZXR1cm4gYmluZGluZy5pc0NoZWNrZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBCaW5kaW5nX0NoZWNrYm94TmFtZUJpbmRpbmdfX2dldFZhbHVlKGJpbmRpbmcpIHtcbiAgXHRyZXR1cm4gYmluZGluZy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICB9XG5cbiAgdmFyIEJpbmRpbmdfQ2hlY2tib3hOYW1lQmluZGluZyA9IENoZWNrYm94TmFtZUJpbmRpbmc7XG5cbiAgdmFyIENoZWNrYm94QmluZGluZyA9IEJpbmRpbmdfQmluZGluZy5leHRlbmQoe1xuICBcdG5hbWU6IFwiY2hlY2tlZFwiLFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcblxuICBcdFx0aWYgKG5vZGUuYXR0YWNoRXZlbnQpIHtcbiAgXHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS5jaGVja2VkO1xuICBcdH1cbiAgfSk7XG5cbiAgdmFyIEJpbmRpbmdfQ2hlY2tib3hCaW5kaW5nID0gQ2hlY2tib3hCaW5kaW5nO1xuXG4gIHZhciBTZWxlY3RCaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuZWxlbWVudC5vcHRpb25zLFxuICBcdFx0ICAgIGxlbixcbiAgXHRcdCAgICBpLFxuICBcdFx0ICAgIHZhbHVlLFxuICBcdFx0ICAgIG9wdGlvbldhc1NlbGVjdGVkO1xuXG4gIFx0XHRpZiAodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpID0gbGVuID0gb3B0aW9ucy5sZW5ndGg7XG5cbiAgXHRcdGlmICghbGVuKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Ly8gdGFrZSB0aGUgZmluYWwgc2VsZWN0ZWQgb3B0aW9uLi4uXG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGlmIChvcHRpb25zW2ldLmdldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIpKSB7XG4gIFx0XHRcdFx0dmFsdWUgPSBvcHRpb25zW2ldLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICBcdFx0XHRcdG9wdGlvbldhc1NlbGVjdGVkID0gdHJ1ZTtcbiAgXHRcdFx0XHRicmVhaztcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBvciB0aGUgZmlyc3Qgbm9uLWRpc2FibGVkIG9wdGlvbiwgaWYgbm9uZSBhcmUgc2VsZWN0ZWRcbiAgXHRcdGlmICghb3B0aW9uV2FzU2VsZWN0ZWQpIHtcbiAgXHRcdFx0d2hpbGUgKCsraSA8IGxlbikge1xuICBcdFx0XHRcdGlmICghb3B0aW9uc1tpXS5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSkge1xuICBcdFx0XHRcdFx0dmFsdWUgPSBvcHRpb25zW2ldLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICBcdFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIFRoaXMgaXMgYW4gb3B0aW1pc2F0aW9uIChha2EgaGFjaykgdGhhdCBhbGxvd3MgdXMgdG8gZm9yZ28gc29tZVxuICBcdFx0Ly8gb3RoZXIgbW9yZSBleHBlbnNpdmUgd29ya1xuICBcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy5lbGVtZW50LmF0dHJpYnV0ZXMudmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHZhbHVlO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuZWxlbWVudC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuZWxlbWVudC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0Ly8gVE9ETyB0aGlzIG1ldGhvZCBpcyBhbiBhbm9tYWx5Li4uIGlzIGl0IG5lY2Vzc2FyeT9cbiAgXHRzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCh0aGlzLmtleXBhdGgsIHZhbHVlKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBvcHRpb25zLCBpLCBsZW4sIG9wdGlvbiwgb3B0aW9uVmFsdWU7XG5cbiAgXHRcdG9wdGlvbnMgPSB0aGlzLmVsZW1lbnQubm9kZS5vcHRpb25zO1xuICBcdFx0bGVuID0gb3B0aW9ucy5sZW5ndGg7XG5cbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRvcHRpb24gPSBvcHRpb25zW2ldO1xuXG4gIFx0XHRcdGlmIChvcHRpb25zW2ldLnNlbGVjdGVkKSB7XG4gIFx0XHRcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7XG4gIFx0XHRcdFx0cmV0dXJuIG9wdGlvblZhbHVlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cbiAgXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHRoaXMuYXR0cmlidXRlLmxvY2tlZCA9IHRydWU7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIF90aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSBmYWxzZTtcbiAgXHRcdFx0fSk7XG4gIFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KHRoaXMua2V5cGF0aCwgdmFsdWUpO1xuICBcdFx0fVxuICBcdH1cbiAgfSk7XG5cbiAgdmFyIEJpbmRpbmdfU2VsZWN0QmluZGluZyA9IFNlbGVjdEJpbmRpbmc7XG5cbiAgdmFyIE11bHRpcGxlU2VsZWN0QmluZGluZyA9IEJpbmRpbmdfU2VsZWN0QmluZGluZy5leHRlbmQoe1xuICBcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5vcHRpb25zLmZpbHRlcihmdW5jdGlvbiAob3B0aW9uKSB7XG4gIFx0XHRcdHJldHVybiBvcHRpb24uZ2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIik7XG4gIFx0XHR9KS5tYXAoZnVuY3Rpb24gKG9wdGlvbikge1xuICBcdFx0XHRyZXR1cm4gb3B0aW9uLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICBcdFx0fSk7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHZhbHVlRnJvbU1vZGVsO1xuXG4gIFx0XHR0aGlzLmVsZW1lbnQubm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG5cbiAgXHRcdHZhbHVlRnJvbU1vZGVsID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQodGhpcy5rZXlwYXRoKTtcblxuICBcdFx0aWYgKHZhbHVlRnJvbU1vZGVsID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0Ly8gZ2V0IHZhbHVlIGZyb20gRE9NLCBpZiBwb3NzaWJsZVxuICBcdFx0XHR0aGlzLmhhbmRsZUNoYW5nZSgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5lbGVtZW50Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHRzZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiVE9ETyBub3QgaW1wbGVtZW50ZWQgeWV0XCIpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHNlbGVjdGVkVmFsdWVzLCBvcHRpb25zLCBpLCBsZW4sIG9wdGlvbiwgb3B0aW9uVmFsdWU7XG5cbiAgXHRcdHNlbGVjdGVkVmFsdWVzID0gW107XG4gIFx0XHRvcHRpb25zID0gdGhpcy5lbGVtZW50Lm5vZGUub3B0aW9ucztcbiAgXHRcdGxlbiA9IG9wdGlvbnMubGVuZ3RoO1xuXG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0b3B0aW9uID0gb3B0aW9uc1tpXTtcblxuICBcdFx0XHRpZiAob3B0aW9uLnNlbGVjdGVkKSB7XG4gIFx0XHRcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7XG4gIFx0XHRcdFx0c2VsZWN0ZWRWYWx1ZXMucHVzaChvcHRpb25WYWx1ZSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHNlbGVjdGVkVmFsdWVzO1xuICBcdH0sXG5cbiAgXHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBhdHRyaWJ1dGUsIHByZXZpb3VzVmFsdWUsIHZhbHVlO1xuXG4gIFx0XHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZTtcbiAgXHRcdHByZXZpb3VzVmFsdWUgPSBhdHRyaWJ1dGUudmFsdWU7XG5cbiAgXHRcdHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXG4gIFx0XHRpZiAocHJldmlvdXNWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICFhcnJheUNvbnRlbnRzTWF0Y2godmFsdWUsIHByZXZpb3VzVmFsdWUpKSB7XG4gIFx0XHRcdEJpbmRpbmdfU2VsZWN0QmluZGluZy5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlLmNhbGwodGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHRmb3JjZVVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0dmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXG4gIFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSB0cnVlO1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdHJldHVybiBfdGhpcy5hdHRyaWJ1dGUubG9ja2VkID0gZmFsc2U7XG4gIFx0XHRcdH0pO1xuICBcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCh0aGlzLmtleXBhdGgsIHZhbHVlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dXBkYXRlTW9kZWw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLmF0dHJpYnV0ZS52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICF0aGlzLmF0dHJpYnV0ZS52YWx1ZS5sZW5ndGgpIHtcbiAgXHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQodGhpcy5rZXlwYXRoLCB0aGlzLmluaXRpYWxWYWx1ZSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9KTtcblxuICB2YXIgQmluZGluZ19NdWx0aXBsZVNlbGVjdEJpbmRpbmcgPSBNdWx0aXBsZVNlbGVjdEJpbmRpbmc7XG5cbiAgdmFyIEZpbGVMaXN0QmluZGluZyA9IEJpbmRpbmdfQmluZGluZy5leHRlbmQoe1xuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5lbGVtZW50Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5lbGVtZW50Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmZpbGVzO1xuICBcdH1cbiAgfSk7XG5cbiAgdmFyIEJpbmRpbmdfRmlsZUxpc3RCaW5kaW5nID0gRmlsZUxpc3RCaW5kaW5nO1xuXG4gIHZhciBOdW1lcmljQmluZGluZyA9IEJpbmRpbmdfR2VuZXJpY0JpbmRpbmcuZXh0ZW5kKHtcbiAgXHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB1bmRlZmluZWQ7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgdmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMuZWxlbWVudC5ub2RlLnZhbHVlKTtcbiAgXHRcdHJldHVybiBpc05hTih2YWx1ZSkgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBpbml0X2NyZWF0ZVR3b3dheUJpbmRpbmcgPSBjcmVhdGVUd293YXlCaW5kaW5nO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVR3b3dheUJpbmRpbmcoZWxlbWVudCkge1xuICBcdHZhciBhdHRyaWJ1dGVzID0gZWxlbWVudC5hdHRyaWJ1dGVzLFxuICBcdCAgICB0eXBlLFxuICBcdCAgICBCaW5kaW5nLFxuICBcdCAgICBiaW5kTmFtZSxcbiAgXHQgICAgYmluZENoZWNrZWQsXG4gIFx0ICAgIGJpbmRpbmc7XG5cbiAgXHQvLyBpZiB0aGlzIGlzIGEgbGF0ZSBiaW5kaW5nLCBhbmQgdGhlcmUncyBhbHJlYWR5IG9uZSwgaXRcbiAgXHQvLyBuZWVkcyB0byBiZSB0b3JuIGRvd25cbiAgXHRpZiAoZWxlbWVudC5iaW5kaW5nKSB7XG4gIFx0XHRlbGVtZW50LmJpbmRpbmcudGVhcmRvd24oKTtcbiAgXHRcdGVsZW1lbnQuYmluZGluZyA9IG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gY29udGVudGVkaXRhYmxlXG4gIFx0aWYgKFxuICBcdC8vIGlmIHRoZSBjb250ZW50ZWRpdGFibGUgYXR0cmlidXRlIGlzIHRydWUgb3IgaXMgYmluZGFibGUgYW5kIG1heSB0aHVzIGJlY29tZSB0cnVlXG4gIFx0KGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpIHx8ICEhYXR0cmlidXRlcy5jb250ZW50ZWRpdGFibGUgJiYgaXNCaW5kYWJsZShhdHRyaWJ1dGVzLmNvbnRlbnRlZGl0YWJsZSkpICYmIGlzQmluZGFibGUoYXR0cmlidXRlcy52YWx1ZSkpIHtcbiAgXHRcdEJpbmRpbmcgPSBCaW5kaW5nX0NvbnRlbnRFZGl0YWJsZUJpbmRpbmc7XG4gIFx0fVxuXG4gIFx0Ly8gPGlucHV0PlxuICBcdGVsc2UgaWYgKGVsZW1lbnQubmFtZSA9PT0gXCJpbnB1dFwiKSB7XG4gIFx0XHR0eXBlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuXG4gIFx0XHRpZiAodHlwZSA9PT0gXCJyYWRpb1wiIHx8IHR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuICBcdFx0XHRiaW5kTmFtZSA9IGlzQmluZGFibGUoYXR0cmlidXRlcy5uYW1lKTtcbiAgXHRcdFx0YmluZENoZWNrZWQgPSBpc0JpbmRhYmxlKGF0dHJpYnV0ZXMuY2hlY2tlZCk7XG5cbiAgXHRcdFx0Ly8gd2UgY2FuIGVpdGhlciBiaW5kIHRoZSBuYW1lIGF0dHJpYnV0ZSwgb3IgdGhlIGNoZWNrZWQgYXR0cmlidXRlIC0gbm90IGJvdGhcbiAgXHRcdFx0aWYgKGJpbmROYW1lICYmIGJpbmRDaGVja2VkKSB7XG4gIFx0XHRcdFx0d2FybklmRGVidWcoXCJBIHJhZGlvIGlucHV0IGNhbiBoYXZlIHR3by13YXkgYmluZGluZyBvbiBpdHMgbmFtZSBhdHRyaWJ1dGUsIG9yIGl0cyBjaGVja2VkIGF0dHJpYnV0ZSAtIG5vdCBib3RoXCIsIHsgcmFjdGl2ZTogZWxlbWVudC5yb290IH0pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGJpbmROYW1lKSB7XG4gIFx0XHRcdFx0QmluZGluZyA9IHR5cGUgPT09IFwicmFkaW9cIiA/IEJpbmRpbmdfUmFkaW9OYW1lQmluZGluZyA6IEJpbmRpbmdfQ2hlY2tib3hOYW1lQmluZGluZztcbiAgXHRcdFx0fSBlbHNlIGlmIChiaW5kQ2hlY2tlZCkge1xuICBcdFx0XHRcdEJpbmRpbmcgPSB0eXBlID09PSBcInJhZGlvXCIgPyBCaW5kaW5nX1JhZGlvQmluZGluZyA6IEJpbmRpbmdfQ2hlY2tib3hCaW5kaW5nO1xuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IFwiZmlsZVwiICYmIGlzQmluZGFibGUoYXR0cmlidXRlcy52YWx1ZSkpIHtcbiAgXHRcdFx0QmluZGluZyA9IEJpbmRpbmdfRmlsZUxpc3RCaW5kaW5nO1xuICBcdFx0fSBlbHNlIGlmIChpc0JpbmRhYmxlKGF0dHJpYnV0ZXMudmFsdWUpKSB7XG4gIFx0XHRcdEJpbmRpbmcgPSB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwicmFuZ2VcIiA/IE51bWVyaWNCaW5kaW5nIDogQmluZGluZ19HZW5lcmljQmluZGluZztcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyA8c2VsZWN0PlxuICBcdGVsc2UgaWYgKGVsZW1lbnQubmFtZSA9PT0gXCJzZWxlY3RcIiAmJiBpc0JpbmRhYmxlKGF0dHJpYnV0ZXMudmFsdWUpKSB7XG4gIFx0XHRCaW5kaW5nID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSA/IEJpbmRpbmdfTXVsdGlwbGVTZWxlY3RCaW5kaW5nIDogQmluZGluZ19TZWxlY3RCaW5kaW5nO1xuICBcdH1cblxuICBcdC8vIDx0ZXh0YXJlYT5cbiAgXHRlbHNlIGlmIChlbGVtZW50Lm5hbWUgPT09IFwidGV4dGFyZWFcIiAmJiBpc0JpbmRhYmxlKGF0dHJpYnV0ZXMudmFsdWUpKSB7XG4gIFx0XHRCaW5kaW5nID0gQmluZGluZ19HZW5lcmljQmluZGluZztcbiAgXHR9XG5cbiAgXHRpZiAoQmluZGluZyAmJiAoYmluZGluZyA9IG5ldyBCaW5kaW5nKGVsZW1lbnQpKSAmJiBiaW5kaW5nLmtleXBhdGgpIHtcbiAgXHRcdHJldHVybiBiaW5kaW5nO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQmluZGFibGUoYXR0cmlidXRlKSB7XG4gIFx0cmV0dXJuIGF0dHJpYnV0ZSAmJiBhdHRyaWJ1dGUuaXNCaW5kYWJsZTtcbiAgfVxuXG4gIC8vIGFuZCB0aGlzIGVsZW1lbnQgYWxzbyBoYXMgYSB2YWx1ZSBhdHRyaWJ1dGUgdG8gYmluZFxuXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX2J1YmJsZSA9IEV2ZW50SGFuZGxlciRidWJibGU7XG5cbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGJ1YmJsZSgpIHtcbiAgXHR2YXIgaGFzQWN0aW9uID0gdGhpcy5nZXRBY3Rpb24oKTtcblxuICBcdGlmIChoYXNBY3Rpb24gJiYgIXRoaXMuaGFzTGlzdGVuZXIpIHtcbiAgXHRcdHRoaXMubGlzdGVuKCk7XG4gIFx0fSBlbHNlIGlmICghaGFzQWN0aW9uICYmIHRoaXMuaGFzTGlzdGVuZXIpIHtcbiAgXHRcdHRoaXMudW5yZW5kZXIoKTtcbiAgXHR9XG4gIH1cblxuICAvLyBUaGlzIGZ1bmN0aW9uIG1heSBiZSBvdmVyd3JpdHRlbiwgaWYgdGhlIGV2ZW50IGRpcmVjdGl2ZVxuICAvLyBpbmNsdWRlcyBwYXJhbWV0ZXJzXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX2ZpcmUgPSBFdmVudEhhbmRsZXIkZmlyZTtcbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGZpcmUoZXZlbnQpIHtcbiAgXHRzaGFyZWRfZmlyZUV2ZW50KHRoaXMucm9vdCwgdGhpcy5nZXRBY3Rpb24oKSwgeyBldmVudDogZXZlbnQgfSk7XG4gIH1cblxuICB2YXIgZ2V0QWN0aW9uID0gRXZlbnRIYW5kbGVyJGdldEFjdGlvbjtcblxuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkZ2V0QWN0aW9uKCkge1xuICBcdHJldHVybiB0aGlzLmFjdGlvbi50b1N0cmluZygpLnRyaW0oKTtcbiAgfVxuXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX2luaXQgPSBFdmVudEhhbmRsZXIkaW5pdDtcblxuICB2YXIgZXZlbnRQYXR0ZXJuID0gL15ldmVudCg/OlxcLiguKykpPy87XG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRpbml0KGVsZW1lbnQsIG5hbWUsIHRlbXBsYXRlKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciBhY3Rpb24sIHJlZnMsIHJhY3RpdmU7XG5cbiAgXHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICBcdHRoaXMucm9vdCA9IGVsZW1lbnQucm9vdDtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gZWxlbWVudC5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLm5hbWUgPSBuYW1lO1xuXG4gIFx0aWYgKG5hbWUuaW5kZXhPZihcIipcIikgIT09IC0xKSB7XG4gIFx0XHRmYXRhbChcIk9ubHkgY29tcG9uZW50IHByb3h5LWV2ZW50cyBtYXkgY29udGFpbiBcXFwiKlxcXCIgd2lsZGNhcmRzLCA8JXMgb24tJXM9XFxcIi4uLlxcXCIvPiBpcyBub3QgdmFsaWRcIiwgZWxlbWVudC5uYW1lLCBuYW1lKTtcbiAgXHRcdHRoaXMuaW52YWxpZCA9IHRydWU7XG4gIFx0fVxuXG4gIFx0aWYgKHRlbXBsYXRlLm0pIHtcbiAgXHRcdHJlZnMgPSB0ZW1wbGF0ZS5hLnI7XG5cbiAgXHRcdC8vIFRoaXMgaXMgYSBtZXRob2QgY2FsbFxuICBcdFx0dGhpcy5tZXRob2QgPSB0ZW1wbGF0ZS5tO1xuICBcdFx0dGhpcy5rZXlwYXRocyA9IFtdO1xuICBcdFx0dGhpcy5mbiA9IHNoYXJlZF9nZXRGdW5jdGlvbkZyb21TdHJpbmcodGVtcGxhdGUuYS5zLCByZWZzLmxlbmd0aCk7XG5cbiAgXHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBlbGVtZW50LnBhcmVudEZyYWdtZW50O1xuICBcdFx0cmFjdGl2ZSA9IHRoaXMucm9vdDtcblxuICBcdFx0Ly8gQ3JlYXRlIHJlc29sdmVycyBmb3IgZWFjaCByZWZlcmVuY2VcbiAgXHRcdHRoaXMucmVmUmVzb2x2ZXJzID0gW107XG4gIFx0XHRyZWZzLmZvckVhY2goZnVuY3Rpb24gKHJlZiwgaSkge1xuICBcdFx0XHR2YXIgbWF0Y2ggPSB1bmRlZmluZWQ7XG5cbiAgXHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gdGhlIGBldmVudGAgb2JqZWN0XG4gIFx0XHRcdGlmIChtYXRjaCA9IGV2ZW50UGF0dGVybi5leGVjKHJlZikpIHtcbiAgXHRcdFx0XHRfdGhpcy5rZXlwYXRoc1tpXSA9IHtcbiAgXHRcdFx0XHRcdGV2ZW50T2JqZWN0OiB0cnVlLFxuICBcdFx0XHRcdFx0cmVmaW5lbWVudHM6IG1hdGNoWzFdID8gbWF0Y2hbMV0uc3BsaXQoXCIuXCIpIDogW11cbiAgXHRcdFx0XHR9O1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdF90aGlzLnJlZlJlc29sdmVycy5wdXNoKFJlc29sdmVyc19jcmVhdGVSZWZlcmVuY2VSZXNvbHZlcihfdGhpcywgcmVmLCBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRcdFx0cmV0dXJuIF90aGlzLnJlc29sdmUoaSwga2V5cGF0aCk7XG4gIFx0XHRcdFx0fSkpO1xuICBcdFx0XHR9XG4gIFx0XHR9KTtcblxuICBcdFx0dGhpcy5maXJlID0gZmlyZU1ldGhvZENhbGw7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdC8vIEdldCBhY3Rpb24gKCdmb28nIGluICdvbi1jbGljaz0nZm9vJylcbiAgXHRcdGFjdGlvbiA9IHRlbXBsYXRlLm4gfHwgdGVtcGxhdGU7XG4gIFx0XHRpZiAodHlwZW9mIGFjdGlvbiAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRhY3Rpb24gPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdFx0dGVtcGxhdGU6IGFjdGlvbixcbiAgXHRcdFx0XHRyb290OiB0aGlzLnJvb3QsXG4gIFx0XHRcdFx0b3duZXI6IHRoaXNcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuYWN0aW9uID0gYWN0aW9uO1xuXG4gIFx0XHQvLyBHZXQgcGFyYW1ldGVyc1xuICBcdFx0aWYgKHRlbXBsYXRlLmQpIHtcbiAgXHRcdFx0dGhpcy5keW5hbWljUGFyYW1zID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5kLFxuICBcdFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcbiAgXHRcdFx0XHRvd25lcjogdGhpcy5lbGVtZW50XG4gIFx0XHRcdH0pO1xuXG4gIFx0XHRcdHRoaXMuZmlyZSA9IGZpcmVFdmVudFdpdGhEeW5hbWljUGFyYW1zO1xuICBcdFx0fSBlbHNlIGlmICh0ZW1wbGF0ZS5hKSB7XG4gIFx0XHRcdHRoaXMucGFyYW1zID0gdGVtcGxhdGUuYTtcbiAgXHRcdFx0dGhpcy5maXJlID0gZmlyZUV2ZW50V2l0aFBhcmFtcztcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlTWV0aG9kQ2FsbChldmVudCkge1xuICBcdHZhciByYWN0aXZlLCB2YWx1ZXMsIGFyZ3M7XG5cbiAgXHRyYWN0aXZlID0gdGhpcy5yb290O1xuXG4gIFx0aWYgKHR5cGVvZiByYWN0aXZlW3RoaXMubWV0aG9kXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gY2FsbCBhIG5vbi1leGlzdGVudCBtZXRob2QgKFxcXCJcIiArIHRoaXMubWV0aG9kICsgXCJcXFwiKVwiKTtcbiAgXHR9XG5cbiAgXHR2YWx1ZXMgPSB0aGlzLmtleXBhdGhzLm1hcChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0dmFyIHZhbHVlLCBsZW4sIGk7XG5cbiAgXHRcdGlmIChrZXlwYXRoID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0Ly8gbm90IHlldCByZXNvbHZlZFxuICBcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBUT0RPIHRoZSByZWZpbmVtZW50cyBzdHVmZiB3b3VsZCBiZSBiZXR0ZXIgaGFuZGxlZCBhdCBwYXJzZSB0aW1lXG4gIFx0XHRpZiAoa2V5cGF0aC5ldmVudE9iamVjdCkge1xuICBcdFx0XHR2YWx1ZSA9IGV2ZW50O1xuXG4gIFx0XHRcdGlmIChsZW4gPSBrZXlwYXRoLnJlZmluZW1lbnRzLmxlbmd0aCkge1xuICBcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtrZXlwYXRoLnJlZmluZW1lbnRzW2ldXTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHZhbHVlID0gcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0fSk7XG5cbiAgXHRzaGFyZWRfZXZlbnRTdGFjay5lbnF1ZXVlKHJhY3RpdmUsIGV2ZW50KTtcblxuICBcdGFyZ3MgPSB0aGlzLmZuLmFwcGx5KG51bGwsIHZhbHVlcyk7XG4gIFx0cmFjdGl2ZVt0aGlzLm1ldGhvZF0uYXBwbHkocmFjdGl2ZSwgYXJncyk7XG5cbiAgXHRzaGFyZWRfZXZlbnRTdGFjay5kZXF1ZXVlKHJhY3RpdmUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyZUV2ZW50V2l0aFBhcmFtcyhldmVudCkge1xuICBcdHNoYXJlZF9maXJlRXZlbnQodGhpcy5yb290LCB0aGlzLmdldEFjdGlvbigpLCB7IGV2ZW50OiBldmVudCwgYXJnczogdGhpcy5wYXJhbXMgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlRXZlbnRXaXRoRHluYW1pY1BhcmFtcyhldmVudCkge1xuICBcdHZhciBhcmdzID0gdGhpcy5keW5hbWljUGFyYW1zLmdldEFyZ3NMaXN0KCk7XG5cbiAgXHQvLyBuZWVkIHRvIHN0cmlwIFtdIGZyb20gZW5kcyBpZiBhIHN0cmluZyFcbiAgXHRpZiAodHlwZW9mIGFyZ3MgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGFyZ3MgPSBhcmdzLnN1YnN0cigxLCBhcmdzLmxlbmd0aCAtIDIpO1xuICBcdH1cblxuICBcdHNoYXJlZF9maXJlRXZlbnQodGhpcy5yb290LCB0aGlzLmdldEFjdGlvbigpLCB7IGV2ZW50OiBldmVudCwgYXJnczogYXJncyB9KTtcbiAgfVxuXG4gIHZhciBzaGFyZWRfZ2VuZXJpY0hhbmRsZXIgPSBnZW5lcmljSGFuZGxlcjtcbiAgZnVuY3Rpb24gZ2VuZXJpY0hhbmRsZXIoZXZlbnQpIHtcbiAgXHR2YXIgc3RvcmFnZSxcbiAgXHQgICAgaGFuZGxlcixcbiAgXHQgICAgaW5kaWNlcyxcbiAgXHQgICAgaW5kZXggPSB7fTtcblxuICBcdHN0b3JhZ2UgPSB0aGlzLl9yYWN0aXZlO1xuICBcdGhhbmRsZXIgPSBzdG9yYWdlLmV2ZW50c1tldmVudC50eXBlXTtcblxuICBcdGlmIChpbmRpY2VzID0gUmVzb2x2ZXJzX2ZpbmRJbmRleFJlZnMoaGFuZGxlci5lbGVtZW50LnBhcmVudEZyYWdtZW50KSkge1xuICBcdFx0aW5kZXggPSBSZXNvbHZlcnNfZmluZEluZGV4UmVmcy5yZXNvbHZlKGluZGljZXMpO1xuICBcdH1cblxuICBcdGhhbmRsZXIuZmlyZSh7XG4gIFx0XHRub2RlOiB0aGlzLFxuICBcdFx0b3JpZ2luYWw6IGV2ZW50LFxuICBcdFx0aW5kZXg6IGluZGV4LFxuICBcdFx0a2V5cGF0aDogc3RvcmFnZS5rZXlwYXRoLnN0cixcbiAgXHRcdGNvbnRleHQ6IHN0b3JhZ2Uucm9vdC52aWV3bW9kZWwuZ2V0KHN0b3JhZ2Uua2V5cGF0aClcbiAgXHR9KTtcbiAgfVxuXG4gIHZhciBsaXN0ZW4gPSBFdmVudEhhbmRsZXIkbGlzdGVuO1xuXG4gIHZhciBjdXN0b21IYW5kbGVycyA9IHt9LFxuICAgICAgdG91Y2hFdmVudHMgPSB7XG4gIFx0dG91Y2hzdGFydDogdHJ1ZSxcbiAgXHR0b3VjaG1vdmU6IHRydWUsXG4gIFx0dG91Y2hlbmQ6IHRydWUsXG4gIFx0dG91Y2hjYW5jZWw6IHRydWUsXG4gIFx0Ly9ub3QgdzNjLCBidXQgc3VwcG9ydGVkIGluIHNvbWUgYnJvd3NlcnNcbiAgXHR0b3VjaGxlYXZlOiB0cnVlXG4gIH07XG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRsaXN0ZW4oKSB7XG4gIFx0dmFyIGRlZmluaXRpb24sXG4gIFx0ICAgIG5hbWUgPSB0aGlzLm5hbWU7XG5cbiAgXHRpZiAodGhpcy5pbnZhbGlkKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKGRlZmluaXRpb24gPSBmaW5kSW5WaWV3SGllcmFyY2h5KFwiZXZlbnRzXCIsIHRoaXMucm9vdCwgbmFtZSkpIHtcbiAgXHRcdHRoaXMuY3VzdG9tID0gZGVmaW5pdGlvbih0aGlzLm5vZGUsIGdldEN1c3RvbUhhbmRsZXIobmFtZSkpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHQvLyBMb29rcyBsaWtlIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIHN0YW5kYXJkIERPTSBldmVudC4uLiBidXQgbGV0J3MgY2hlY2tcbiAgXHRcdGlmICghKFwib25cIiArIG5hbWUgaW4gdGhpcy5ub2RlKSAmJiAhKHdpbmRvdyAmJiBcIm9uXCIgKyBuYW1lIGluIHdpbmRvdykgJiYgIWlzSnNkb20pIHtcblxuICBcdFx0XHQvLyBva2F5IHRvIHVzZSB0b3VjaCBldmVudHMgaWYgdGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGVtXG4gIFx0XHRcdGlmICghdG91Y2hFdmVudHNbbmFtZV0pIHtcbiAgXHRcdFx0XHR3YXJuT25jZUlmRGVidWcobWlzc2luZ1BsdWdpbihuYW1lLCBcImV2ZW50XCIpLCB7IG5vZGU6IHRoaXMubm9kZSB9KTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgc2hhcmVkX2dlbmVyaWNIYW5kbGVyLCBmYWxzZSk7XG4gIFx0fVxuXG4gIFx0dGhpcy5oYXNMaXN0ZW5lciA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDdXN0b21IYW5kbGVyKG5hbWUpIHtcbiAgXHRpZiAoIWN1c3RvbUhhbmRsZXJzW25hbWVdKSB7XG4gIFx0XHRjdXN0b21IYW5kbGVyc1tuYW1lXSA9IGZ1bmN0aW9uIChldmVudCkge1xuICBcdFx0XHR2YXIgc3RvcmFnZSA9IGV2ZW50Lm5vZGUuX3JhY3RpdmU7XG5cbiAgXHRcdFx0ZXZlbnQuaW5kZXggPSBzdG9yYWdlLmluZGV4O1xuICBcdFx0XHRldmVudC5rZXlwYXRoID0gc3RvcmFnZS5rZXlwYXRoLnN0cjtcbiAgXHRcdFx0ZXZlbnQuY29udGV4dCA9IHN0b3JhZ2Uucm9vdC52aWV3bW9kZWwuZ2V0KHN0b3JhZ2Uua2V5cGF0aCk7XG5cbiAgXHRcdFx0c3RvcmFnZS5ldmVudHNbbmFtZV0uZmlyZShldmVudCk7XG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHJldHVybiBjdXN0b21IYW5kbGVyc1tuYW1lXTtcbiAgfVxuXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3JlYmluZCA9IEV2ZW50SGFuZGxlciRyZWJpbmQ7XG5cbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0dmFyIGZyYWdtZW50O1xuICBcdGlmICh0aGlzLm1ldGhvZCkge1xuICBcdFx0ZnJhZ21lbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50RnJhZ21lbnQ7XG4gIFx0XHR0aGlzLnJlZlJlc29sdmVycy5mb3JFYWNoKHJlYmluZCk7XG5cbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRpZiAodHlwZW9mIHRoaXMuYWN0aW9uICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRyZWJpbmQodGhpcy5hY3Rpb24pO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmR5bmFtaWNQYXJhbXMpIHtcbiAgXHRcdHJlYmluZCh0aGlzLmR5bmFtaWNQYXJhbXMpO1xuICBcdH1cblxuICBcdGZ1bmN0aW9uIHJlYmluZCh0aGluZykge1xuICBcdFx0dGhpbmcgJiYgdGhpbmcucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3JlbmRlciA9IEV2ZW50SGFuZGxlciRyZW5kZXI7XG5cbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHJlbmRlcigpIHtcbiAgXHR0aGlzLm5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcbiAgXHQvLyBzdG9yZSB0aGlzIG9uIHRoZSBub2RlIGl0c2VsZiwgc28gaXQgY2FuIGJlIHJldHJpZXZlZCBieSBhXG4gIFx0Ly8gdW5pdmVyc2FsIGhhbmRsZXJcbiAgXHR0aGlzLm5vZGUuX3JhY3RpdmUuZXZlbnRzW3RoaXMubmFtZV0gPSB0aGlzO1xuXG4gIFx0aWYgKHRoaXMubWV0aG9kIHx8IHRoaXMuZ2V0QWN0aW9uKCkpIHtcbiAgXHRcdHRoaXMubGlzdGVuKCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9yZXNvbHZlID0gRXZlbnRIYW5kbGVyJHJlc29sdmU7XG5cbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHJlc29sdmUoaW5kZXgsIGtleXBhdGgpIHtcbiAgXHR0aGlzLmtleXBhdGhzW2luZGV4XSA9IGtleXBhdGg7XG4gIH1cblxuICB2YXIgRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV91bmJpbmQgPSBFdmVudEhhbmRsZXIkdW5iaW5kO1xuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkdW5iaW5kKCkge1xuICBcdGlmICh0aGlzLm1ldGhvZCkge1xuICBcdFx0dGhpcy5yZWZSZXNvbHZlcnMuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIFRlYXIgZG93biBkeW5hbWljIG5hbWVcbiAgXHRpZiAodHlwZW9mIHRoaXMuYWN0aW9uICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHR0aGlzLmFjdGlvbi51bmJpbmQoKTtcbiAgXHR9XG5cbiAgXHQvLyBUZWFyIGRvd24gZHluYW1pYyBwYXJhbWV0ZXJzXG4gIFx0aWYgKHRoaXMuZHluYW1pY1BhcmFtcykge1xuICBcdFx0dGhpcy5keW5hbWljUGFyYW1zLnVuYmluZCgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3VucmVuZGVyID0gRXZlbnRIYW5kbGVyJHVucmVuZGVyO1xuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkdW5yZW5kZXIoKSB7XG5cbiAgXHRpZiAodGhpcy5jdXN0b20pIHtcbiAgXHRcdHRoaXMuY3VzdG9tLnRlYXJkb3duKCk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMubmFtZSwgc2hhcmVkX2dlbmVyaWNIYW5kbGVyLCBmYWxzZSk7XG4gIFx0fVxuXG4gIFx0dGhpcy5oYXNMaXN0ZW5lciA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIEV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lLCB0ZW1wbGF0ZSkge1xuICBcdHRoaXMuaW5pdChlbGVtZW50LCBuYW1lLCB0ZW1wbGF0ZSk7XG4gIH07XG5cbiAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfYnViYmxlLFxuICBcdGZpcmU6IEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfZmlyZSxcbiAgXHRnZXRBY3Rpb246IGdldEFjdGlvbixcbiAgXHRpbml0OiBFdmVudEhhbmRsZXJfcHJvdG90eXBlX2luaXQsXG4gIFx0bGlzdGVuOiBsaXN0ZW4sXG4gIFx0cmViaW5kOiBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3JlYmluZCxcbiAgXHRyZW5kZXI6IEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfcmVuZGVyLFxuICBcdHJlc29sdmU6IHByb3RvdHlwZV9yZXNvbHZlLFxuICBcdHVuYmluZDogRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV91bmJpbmQsXG4gIFx0dW5yZW5kZXI6IEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfdW5yZW5kZXJcbiAgfTtcblxuICB2YXIgX0V2ZW50SGFuZGxlciA9IEV2ZW50SGFuZGxlcjtcblxuICB2YXIgY3JlYXRlRXZlbnRIYW5kbGVycyA9IGZ1bmN0aW9uIChlbGVtZW50LCB0ZW1wbGF0ZSkge1xuICBcdHZhciBpLFxuICBcdCAgICBuYW1lLFxuICBcdCAgICBuYW1lcyxcbiAgXHQgICAgaGFuZGxlcixcbiAgXHQgICAgcmVzdWx0ID0gW107XG5cbiAgXHRmb3IgKG5hbWUgaW4gdGVtcGxhdGUpIHtcbiAgXHRcdGlmICh0ZW1wbGF0ZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICBcdFx0XHRuYW1lcyA9IG5hbWUuc3BsaXQoXCItXCIpO1xuICBcdFx0XHRpID0gbmFtZXMubGVuZ3RoO1xuXG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRoYW5kbGVyID0gbmV3IF9FdmVudEhhbmRsZXIoZWxlbWVudCwgbmFtZXNbaV0sIHRlbXBsYXRlW25hbWVdKTtcbiAgXHRcdFx0XHRyZXN1bHQucHVzaChoYW5kbGVyKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIERlY29yYXRvciA9IGZ1bmN0aW9uIChlbGVtZW50LCB0ZW1wbGF0ZSkge1xuICBcdHZhciBzZWxmID0gdGhpcyxcbiAgXHQgICAgcmFjdGl2ZSxcbiAgXHQgICAgbmFtZSxcbiAgXHQgICAgZnJhZ21lbnQ7XG5cbiAgXHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICBcdHRoaXMucm9vdCA9IHJhY3RpdmUgPSBlbGVtZW50LnJvb3Q7XG5cbiAgXHRuYW1lID0gdGVtcGxhdGUubiB8fCB0ZW1wbGF0ZTtcblxuICBcdGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0ZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdHRlbXBsYXRlOiBuYW1lLFxuICBcdFx0XHRyb290OiByYWN0aXZlLFxuICBcdFx0XHRvd25lcjogZWxlbWVudFxuICBcdFx0fSk7XG5cbiAgXHRcdG5hbWUgPSBmcmFnbWVudC50b1N0cmluZygpO1xuICBcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cbiAgXHRcdGlmIChuYW1lID09PSBcIlwiKSB7XG4gIFx0XHRcdC8vIGVtcHR5IHN0cmluZyBva2F5LCBqdXN0IG5vIGRlY29yYXRvclxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKHRlbXBsYXRlLmEpIHtcbiAgXHRcdHRoaXMucGFyYW1zID0gdGVtcGxhdGUuYTtcbiAgXHR9IGVsc2UgaWYgKHRlbXBsYXRlLmQpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5kLFxuICBcdFx0XHRyb290OiByYWN0aXZlLFxuICBcdFx0XHRvd25lcjogZWxlbWVudFxuICBcdFx0fSk7XG5cbiAgXHRcdHRoaXMucGFyYW1zID0gdGhpcy5mcmFnbWVudC5nZXRBcmdzTGlzdCgpO1xuXG4gIFx0XHR0aGlzLmZyYWdtZW50LmJ1YmJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dGhpcy5kaXJ0eUFyZ3MgPSB0aGlzLmRpcnR5VmFsdWUgPSB0cnVlO1xuICBcdFx0XHRzZWxmLnBhcmFtcyA9IHRoaXMuZ2V0QXJnc0xpc3QoKTtcblxuICBcdFx0XHRpZiAoc2VsZi5yZWFkeSkge1xuICBcdFx0XHRcdHNlbGYudXBkYXRlKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0dGhpcy5mbiA9IGZpbmRJblZpZXdIaWVyYXJjaHkoXCJkZWNvcmF0b3JzXCIsIHJhY3RpdmUsIG5hbWUpO1xuXG4gIFx0aWYgKCF0aGlzLmZuKSB7XG4gIFx0XHRmYXRhbChtaXNzaW5nUGx1Z2luKG5hbWUsIFwiZGVjb3JhdG9yXCIpKTtcbiAgXHR9XG4gIH07XG5cbiAgRGVjb3JhdG9yLnByb3RvdHlwZSA9IHtcbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSwgcmVzdWx0LCBhcmdzO1xuXG4gIFx0XHRub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdGlmICh0aGlzLnBhcmFtcykge1xuICBcdFx0XHRhcmdzID0gW25vZGVdLmNvbmNhdCh0aGlzLnBhcmFtcyk7XG4gIFx0XHRcdHJlc3VsdCA9IHRoaXMuZm4uYXBwbHkodGhpcy5yb290LCBhcmdzKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJlc3VsdCA9IHRoaXMuZm4uY2FsbCh0aGlzLnJvb3QsIG5vZGUpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LnRlYXJkb3duKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkRlY29yYXRvciBkZWZpbml0aW9uIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aXRoIGEgdGVhcmRvd24gbWV0aG9kXCIpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBUT0RPIGRvZXMgdGhpcyBtYWtlIHNlbnNlP1xuICBcdFx0dGhpcy5hY3R1YWwgPSByZXN1bHQ7XG4gIFx0XHR0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgXHR9LFxuXG4gIFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5hY3R1YWwudXBkYXRlKSB7XG4gIFx0XHRcdHRoaXMuYWN0dWFsLnVwZGF0ZS5hcHBseSh0aGlzLnJvb3QsIHRoaXMucGFyYW1zKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuYWN0dWFsLnRlYXJkb3duKHRydWUpO1xuICBcdFx0XHR0aGlzLmluaXQoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHRlYXJkb3duOiBmdW5jdGlvbiAodXBkYXRpbmcpIHtcbiAgXHRcdHRoaXMudG9ybmRvd24gPSB0cnVlO1xuICBcdFx0aWYgKHRoaXMucmVhZHkpIHtcbiAgXHRcdFx0dGhpcy5hY3R1YWwudGVhcmRvd24oKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCF1cGRhdGluZyAmJiB0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBfRGVjb3JhdG9yID0gRGVjb3JhdG9yO1xuXG4gIGZ1bmN0aW9uIHNlbGVjdF9fYnViYmxlKCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRpZiAoIXRoaXMuZGlydHkpIHtcbiAgXHRcdHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRzeW5jKF90aGlzKTtcbiAgXHRcdFx0X3RoaXMuZGlydHkgPSBmYWxzZTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7IC8vIGRlZmF1bHQgYmVoYXZpb3VyXG4gIH1cblxuICBmdW5jdGlvbiBzeW5jKHNlbGVjdEVsZW1lbnQpIHtcbiAgXHR2YXIgc2VsZWN0Tm9kZSwgc2VsZWN0VmFsdWUsIGlzTXVsdGlwbGUsIG9wdGlvbnMsIG9wdGlvbldhc1NlbGVjdGVkO1xuXG4gIFx0c2VsZWN0Tm9kZSA9IHNlbGVjdEVsZW1lbnQubm9kZTtcblxuICBcdGlmICghc2VsZWN0Tm9kZSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdG9wdGlvbnMgPSB0b0FycmF5KHNlbGVjdE5vZGUub3B0aW9ucyk7XG5cbiAgXHRzZWxlY3RWYWx1ZSA9IHNlbGVjdEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIFx0aXNNdWx0aXBsZSA9IHNlbGVjdEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIik7XG5cbiAgXHQvLyBJZiB0aGUgPHNlbGVjdD4gaGFzIGEgc3BlY2lmaWVkIHZhbHVlLCB0aGF0IHNob3VsZCBvdmVycmlkZVxuICBcdC8vIHRoZXNlIG9wdGlvbnNcbiAgXHRpZiAoc2VsZWN0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0b3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gIFx0XHRcdHZhciBvcHRpb25WYWx1ZSwgc2hvdWxkU2VsZWN0O1xuXG4gIFx0XHRcdG9wdGlvblZhbHVlID0gby5fcmFjdGl2ZSA/IG8uX3JhY3RpdmUudmFsdWUgOiBvLnZhbHVlO1xuICBcdFx0XHRzaG91bGRTZWxlY3QgPSBpc011bHRpcGxlID8gdmFsdWVDb250YWlucyhzZWxlY3RWYWx1ZSwgb3B0aW9uVmFsdWUpIDogc2VsZWN0VmFsdWUgPT0gb3B0aW9uVmFsdWU7XG5cbiAgXHRcdFx0aWYgKHNob3VsZFNlbGVjdCkge1xuICBcdFx0XHRcdG9wdGlvbldhc1NlbGVjdGVkID0gdHJ1ZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdG8uc2VsZWN0ZWQgPSBzaG91bGRTZWxlY3Q7XG4gIFx0XHR9KTtcblxuICBcdFx0aWYgKCFvcHRpb25XYXNTZWxlY3RlZCkge1xuICBcdFx0XHRpZiAob3B0aW9uc1swXSkge1xuICBcdFx0XHRcdG9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKHNlbGVjdEVsZW1lbnQuYmluZGluZykge1xuICBcdFx0XHRcdHNlbGVjdEVsZW1lbnQuYmluZGluZy5mb3JjZVVwZGF0ZSgpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gT3RoZXJ3aXNlIHRoZSB2YWx1ZSBzaG91bGQgYmUgaW5pdGlhbGlzZWQgYWNjb3JkaW5nIHRvIHdoaWNoXG4gIFx0Ly8gPG9wdGlvbj4gZWxlbWVudCBpcyBzZWxlY3RlZCwgaWYgdHdvd2F5IGJpbmRpbmcgaXMgaW4gZWZmZWN0XG4gIFx0ZWxzZSBpZiAoc2VsZWN0RWxlbWVudC5iaW5kaW5nKSB7XG4gIFx0XHRzZWxlY3RFbGVtZW50LmJpbmRpbmcuZm9yY2VVcGRhdGUoKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiB2YWx1ZUNvbnRhaW5zKHNlbGVjdFZhbHVlLCBvcHRpb25WYWx1ZSkge1xuICBcdHZhciBpID0gc2VsZWN0VmFsdWUubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGlmIChzZWxlY3RWYWx1ZVtpXSA9PSBvcHRpb25WYWx1ZSkge1xuICBcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBzcGVjaWFsX29wdGlvbl9faW5pdChvcHRpb24sIHRlbXBsYXRlKSB7XG4gIFx0b3B0aW9uLnNlbGVjdCA9IGZpbmRQYXJlbnRTZWxlY3Qob3B0aW9uLnBhcmVudCk7XG5cbiAgXHQvLyB3ZSBtaWdodCBiZSBpbnNpZGUgYSA8ZGF0YWxpc3Q+IGVsZW1lbnRcbiAgXHRpZiAoIW9wdGlvbi5zZWxlY3QpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRvcHRpb24uc2VsZWN0Lm9wdGlvbnMucHVzaChvcHRpb24pO1xuXG4gIFx0Ly8gSWYgdGhlIHZhbHVlIGF0dHJpYnV0ZSBpcyBtaXNzaW5nLCB1c2UgdGhlIGVsZW1lbnQncyBjb250ZW50XG4gIFx0aWYgKCF0ZW1wbGF0ZS5hKSB7XG4gIFx0XHR0ZW1wbGF0ZS5hID0ge307XG4gIFx0fVxuXG4gIFx0Ly8gLi4uYXMgbG9uZyBhcyBpdCBpc24ndCBkaXNhYmxlZFxuICBcdGlmICh0ZW1wbGF0ZS5hLnZhbHVlID09PSB1bmRlZmluZWQgJiYgIXRlbXBsYXRlLmEuaGFzT3duUHJvcGVydHkoXCJkaXNhYmxlZFwiKSkge1xuICBcdFx0dGVtcGxhdGUuYS52YWx1ZSA9IHRlbXBsYXRlLmY7XG4gIFx0fVxuXG4gIFx0Ly8gSWYgdGhlcmUgaXMgYSBgc2VsZWN0ZWRgIGF0dHJpYnV0ZSwgYnV0IHRoZSA8c2VsZWN0PlxuICBcdC8vIGFscmVhZHkgaGFzIGEgdmFsdWUsIGRlbGV0ZSBpdFxuICBcdGlmIChcInNlbGVjdGVkXCIgaW4gdGVtcGxhdGUuYSAmJiBvcHRpb24uc2VsZWN0LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdGRlbGV0ZSB0ZW1wbGF0ZS5hLnNlbGVjdGVkO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNwZWNpYWxfb3B0aW9uX191bmJpbmQob3B0aW9uKSB7XG4gIFx0aWYgKG9wdGlvbi5zZWxlY3QpIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheShvcHRpb24uc2VsZWN0Lm9wdGlvbnMsIG9wdGlvbik7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZFBhcmVudFNlbGVjdChlbGVtZW50KSB7XG4gIFx0aWYgKCFlbGVtZW50KSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0ZG8ge1xuICBcdFx0aWYgKGVsZW1lbnQubmFtZSA9PT0gXCJzZWxlY3RcIikge1xuICBcdFx0XHRyZXR1cm4gZWxlbWVudDtcbiAgXHRcdH1cbiAgXHR9IHdoaWxlIChlbGVtZW50ID0gZWxlbWVudC5wYXJlbnQpO1xuICB9XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2luaXQgPSBFbGVtZW50JGluaXQ7XG4gIGZ1bmN0aW9uIEVsZW1lbnQkaW5pdChvcHRpb25zKSB7XG4gIFx0dmFyIHBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZSwgcmFjdGl2ZSwgYmluZGluZywgYmluZGluZ3MsIHR3b3dheSwgYmluZGluZ0F0dHJzO1xuXG4gIFx0dGhpcy50eXBlID0gRUxFTUVOVDtcblxuICBcdC8vIHN0dWZmIHdlJ2xsIG5lZWQgbGF0ZXJcbiAgXHRwYXJlbnRGcmFnbWVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuICBcdHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG5cbiAgXHR0aGlzLnBhcmVudCA9IG9wdGlvbnMucEVsZW1lbnQgfHwgcGFyZW50RnJhZ21lbnQucEVsZW1lbnQ7XG5cbiAgXHR0aGlzLnJvb3QgPSByYWN0aXZlID0gcGFyZW50RnJhZ21lbnQucm9vdDtcbiAgXHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcbiAgXHR0aGlzLmtleSA9IG9wdGlvbnMua2V5O1xuXG4gIFx0dGhpcy5uYW1lID0gZW5mb3JjZUNhc2UodGVtcGxhdGUuZSk7XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSA8b3B0aW9uPiBlbGVtZW50c1xuICBcdGlmICh0aGlzLm5hbWUgPT09IFwib3B0aW9uXCIpIHtcbiAgXHRcdHNwZWNpYWxfb3B0aW9uX19pbml0KHRoaXMsIHRlbXBsYXRlKTtcbiAgXHR9XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSA8c2VsZWN0PiBlbGVtZW50c1xuICBcdGlmICh0aGlzLm5hbWUgPT09IFwic2VsZWN0XCIpIHtcbiAgXHRcdHRoaXMub3B0aW9ucyA9IFtdO1xuICBcdFx0dGhpcy5idWJibGUgPSBzZWxlY3RfX2J1YmJsZTsgLy8gVE9ETyB0aGlzIGlzIGEga2x1ZGdlXG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gPGZvcm0+IGVsZW1lbnRzXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJmb3JtXCIpIHtcbiAgXHRcdHRoaXMuZm9ybUJpbmRpbmdzID0gW107XG4gIFx0fVxuXG4gIFx0Ly8gaGFuZGxlIGJpbmRpbmcgYXR0cmlidXRlcyBmaXJzdCAodHdvd2F5LCBsYXp5KVxuICBcdGJpbmRpbmdBdHRycyA9IHByb2Nlc3NCaW5kaW5nQXR0cmlidXRlcyh0aGlzLCB0ZW1wbGF0ZSk7XG5cbiAgXHQvLyBjcmVhdGUgYXR0cmlidXRlc1xuICBcdHRoaXMuYXR0cmlidXRlcyA9IGNyZWF0ZUF0dHJpYnV0ZXModGhpcywgdGVtcGxhdGUuYSk7XG4gIFx0dGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMgPSBjcmVhdGVDb25kaXRpb25hbEF0dHJpYnV0ZXModGhpcywgdGVtcGxhdGUubSk7XG5cbiAgXHQvLyBhcHBlbmQgY2hpbGRyZW4sIGlmIHRoZXJlIGFyZSBhbnlcbiAgXHRpZiAodGVtcGxhdGUuZikge1xuICBcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLmYsXG4gIFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG4gIFx0XHRcdG93bmVyOiB0aGlzLFxuICBcdFx0XHRwRWxlbWVudDogdGhpcyxcbiAgXHRcdFx0Y3NzSWRzOiBudWxsXG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHQvLyB0aGUgZWxlbWVudCBzZXR0aW5nIHNob3VsZCBvdmVycmlkZSB0aGUgcmFjdGl2ZSBzZXR0aW5nXG4gIFx0dHdvd2F5ID0gcmFjdGl2ZS50d293YXk7XG4gIFx0aWYgKGJpbmRpbmdBdHRycy50d293YXkgPT09IGZhbHNlKSB0d293YXkgPSBmYWxzZTtlbHNlIGlmIChiaW5kaW5nQXR0cnMudHdvd2F5ID09PSB0cnVlKSB0d293YXkgPSB0cnVlO1xuXG4gIFx0dGhpcy50d293YXkgPSB0d293YXk7XG4gIFx0dGhpcy5sYXp5ID0gYmluZGluZ0F0dHJzLmxhenk7XG5cbiAgXHQvLyBjcmVhdGUgdHdvd2F5IGJpbmRpbmdcbiAgXHRpZiAodHdvd2F5ICYmIChiaW5kaW5nID0gaW5pdF9jcmVhdGVUd293YXlCaW5kaW5nKHRoaXMsIHRlbXBsYXRlLmEpKSkge1xuICBcdFx0dGhpcy5iaW5kaW5nID0gYmluZGluZztcblxuICBcdFx0Ly8gcmVnaXN0ZXIgdGhpcyB3aXRoIHRoZSByb290LCBzbyB0aGF0IHdlIGNhbiBkbyByYWN0aXZlLnVwZGF0ZU1vZGVsKClcbiAgXHRcdGJpbmRpbmdzID0gdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1tiaW5kaW5nLmtleXBhdGguc3RyXSB8fCAodGhpcy5yb290Ll90d293YXlCaW5kaW5nc1tiaW5kaW5nLmtleXBhdGguc3RyXSA9IFtdKTtcbiAgXHRcdGJpbmRpbmdzLnB1c2goYmluZGluZyk7XG4gIFx0fVxuXG4gIFx0Ly8gY3JlYXRlIGV2ZW50IHByb3hpZXNcbiAgXHRpZiAodGVtcGxhdGUudikge1xuICBcdFx0dGhpcy5ldmVudEhhbmRsZXJzID0gY3JlYXRlRXZlbnRIYW5kbGVycyh0aGlzLCB0ZW1wbGF0ZS52KTtcbiAgXHR9XG5cbiAgXHQvLyBjcmVhdGUgZGVjb3JhdG9yXG4gIFx0aWYgKHRlbXBsYXRlLm8pIHtcbiAgXHRcdHRoaXMuZGVjb3JhdG9yID0gbmV3IF9EZWNvcmF0b3IodGhpcywgdGVtcGxhdGUubyk7XG4gIFx0fVxuXG4gIFx0Ly8gY3JlYXRlIHRyYW5zaXRpb25zXG4gIFx0dGhpcy5pbnRybyA9IHRlbXBsYXRlLnQwIHx8IHRlbXBsYXRlLnQxO1xuICBcdHRoaXMub3V0cm8gPSB0ZW1wbGF0ZS50MCB8fCB0ZW1wbGF0ZS50MjtcbiAgfVxuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9yZWJpbmQgPSBFbGVtZW50JHJlYmluZDtcbiAgZnVuY3Rpb24gRWxlbWVudCRyZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdHZhciBpLCBzdG9yYWdlLCBsaXZlUXVlcmllcywgcmFjdGl2ZTtcblxuICBcdGlmICh0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgXHRcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKHJlYmluZCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzKSB7XG4gIFx0XHR0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcy5mb3JFYWNoKHJlYmluZCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZXZlbnRIYW5kbGVycykge1xuICBcdFx0dGhpcy5ldmVudEhhbmRsZXJzLmZvckVhY2gocmViaW5kKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5kZWNvcmF0b3IpIHtcbiAgXHRcdHJlYmluZCh0aGlzLmRlY29yYXRvcik7XG4gIFx0fVxuXG4gIFx0Ly8gcmViaW5kIGNoaWxkcmVuXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdHJlYmluZCh0aGlzLmZyYWdtZW50KTtcbiAgXHR9XG5cbiAgXHQvLyBVcGRhdGUgbGl2ZSBxdWVyaWVzLCBpZiBuZWNlc3NhcnlcbiAgXHRpZiAobGl2ZVF1ZXJpZXMgPSB0aGlzLmxpdmVRdWVyaWVzKSB7XG4gIFx0XHRyYWN0aXZlID0gdGhpcy5yb290O1xuXG4gIFx0XHRpID0gbGl2ZVF1ZXJpZXMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRsaXZlUXVlcmllc1tpXS5fbWFrZURpcnR5KCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMubm9kZSAmJiAoc3RvcmFnZSA9IHRoaXMubm9kZS5fcmFjdGl2ZSkpIHtcblxuICBcdFx0Ly8gYWRqdXN0IGtleXBhdGggaWYgbmVlZGVkXG4gIFx0XHRhc3NpZ25OZXdLZXlwYXRoKHN0b3JhZ2UsIFwia2V5cGF0aFwiLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiByZWJpbmQodGhpbmcpIHtcbiAgXHRcdHRoaW5nLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBzcGVjaWFsX2ltZ19fcmVuZGVyKGltZykge1xuICBcdHZhciBsb2FkSGFuZGxlcjtcblxuICBcdC8vIGlmIHRoaXMgaXMgYW4gPGltZz4sIGFuZCB3ZSdyZSBpbiBhIGNyYXAgYnJvd3Nlciwgd2UgbWF5IG5lZWQgdG8gcHJldmVudCBpdFxuICBcdC8vIGZyb20gb3ZlcnJpZGluZyB3aWR0aCBhbmQgaGVpZ2h0IHdoZW4gaXQgbG9hZHMgdGhlIHNyY1xuICBcdGlmIChpbWcuYXR0cmlidXRlcy53aWR0aCB8fCBpbWcuYXR0cmlidXRlcy5oZWlnaHQpIHtcbiAgXHRcdGltZy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGxvYWRIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICBcdFx0XHR2YXIgd2lkdGggPSBpbWcuZ2V0QXR0cmlidXRlKFwid2lkdGhcIiksXG4gIFx0XHRcdCAgICBoZWlnaHQgPSBpbWcuZ2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIpO1xuXG4gIFx0XHRcdGlmICh3aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0aW1nLm5vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgd2lkdGgpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0aW1nLm5vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpbWcubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCBsb2FkSGFuZGxlciwgZmFsc2UpO1xuICBcdFx0fSwgZmFsc2UpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1fX3JlbmRlcihlbGVtZW50KSB7XG4gIFx0ZWxlbWVudC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldFwiLCBoYW5kbGVSZXNldCwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybV9fdW5yZW5kZXIoZWxlbWVudCkge1xuICBcdGVsZW1lbnQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzZXRcIiwgaGFuZGxlUmVzZXQsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVJlc2V0KCkge1xuICBcdHZhciBlbGVtZW50ID0gdGhpcy5fcmFjdGl2ZS5wcm94eTtcblxuICBcdGdsb2JhbF9ydW5sb29wLnN0YXJ0KCk7XG4gIFx0ZWxlbWVudC5mb3JtQmluZGluZ3MuZm9yRWFjaCh1cGRhdGVNb2RlbCk7XG4gIFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVNb2RlbChiaW5kaW5nKSB7XG4gIFx0YmluZGluZy5yb290LnZpZXdtb2RlbC5zZXQoYmluZGluZy5rZXlwYXRoLCBiaW5kaW5nLnJlc2V0VmFsdWUpO1xuICB9XG5cbiAgdmFyIFRyYW5zaXRpb25fcHJvdG90eXBlX2luaXQgPSBUcmFuc2l0aW9uJGluaXQ7XG4gIGZ1bmN0aW9uIFRyYW5zaXRpb24kaW5pdChlbGVtZW50LCB0ZW1wbGF0ZSwgaXNJbnRybykge1xuICBcdHZhciByYWN0aXZlLCBuYW1lLCBmcmFnbWVudDtcblxuICBcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIFx0dGhpcy5yb290ID0gcmFjdGl2ZSA9IGVsZW1lbnQucm9vdDtcbiAgXHR0aGlzLmlzSW50cm8gPSBpc0ludHJvO1xuXG4gIFx0bmFtZSA9IHRlbXBsYXRlLm4gfHwgdGVtcGxhdGU7XG5cbiAgXHRpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHR0ZW1wbGF0ZTogbmFtZSxcbiAgXHRcdFx0cm9vdDogcmFjdGl2ZSxcbiAgXHRcdFx0b3duZXI6IGVsZW1lbnRcbiAgXHRcdH0pO1xuXG4gIFx0XHRuYW1lID0gZnJhZ21lbnQudG9TdHJpbmcoKTtcbiAgXHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXG4gIFx0XHRpZiAobmFtZSA9PT0gXCJcIikge1xuICBcdFx0XHQvLyBlbXB0eSBzdHJpbmcgb2theSwganVzdCBubyB0cmFuc2l0aW9uXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHR0aGlzLm5hbWUgPSBuYW1lO1xuXG4gIFx0aWYgKHRlbXBsYXRlLmEpIHtcbiAgXHRcdHRoaXMucGFyYW1zID0gdGVtcGxhdGUuYTtcbiAgXHR9IGVsc2UgaWYgKHRlbXBsYXRlLmQpIHtcbiAgXHRcdC8vIFRPRE8gaXMgdGhlcmUgYSB3YXkgdG8gaW50ZXJwcmV0IGR5bmFtaWMgYXJndW1lbnRzIHdpdGhvdXQgYWxsIHRoZVxuICBcdFx0Ly8gJ2RlcGVuZGVuY3kgdGhyYXNoaW5nJz9cbiAgXHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUuZCxcbiAgXHRcdFx0cm9vdDogcmFjdGl2ZSxcbiAgXHRcdFx0b3duZXI6IGVsZW1lbnRcbiAgXHRcdH0pO1xuXG4gIFx0XHR0aGlzLnBhcmFtcyA9IGZyYWdtZW50LmdldEFyZ3NMaXN0KCk7XG4gIFx0XHRmcmFnbWVudC51bmJpbmQoKTtcbiAgXHR9XG5cbiAgXHR0aGlzLl9mbiA9IGZpbmRJblZpZXdIaWVyYXJjaHkoXCJ0cmFuc2l0aW9uc1wiLCByYWN0aXZlLCBuYW1lKTtcblxuICBcdGlmICghdGhpcy5fZm4pIHtcbiAgXHRcdHdhcm5PbmNlSWZEZWJ1ZyhtaXNzaW5nUGx1Z2luKG5hbWUsIFwidHJhbnNpdGlvblwiKSwgeyByYWN0aXZlOiB0aGlzLnJvb3QgfSk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGNhbWVsQ2FzZSA9IGZ1bmN0aW9uIChoeXBoZW5hdGVkU3RyKSB7XG4gIFx0cmV0dXJuIGh5cGhlbmF0ZWRTdHIucmVwbGFjZSgvLShbYS16QS1aXSkvZywgZnVuY3Rpb24gKG1hdGNoLCAkMSkge1xuICBcdFx0cmV0dXJuICQxLnRvVXBwZXJDYXNlKCk7XG4gIFx0fSk7XG4gIH07XG5cbiAgdmFyIGhlbHBlcnNfcHJlZml4X19wcmVmaXgsIHByZWZpeENhY2hlLCBoZWxwZXJzX3ByZWZpeF9fdGVzdFN0eWxlO1xuXG4gIGlmICghaXNDbGllbnQpIHtcbiAgXHRoZWxwZXJzX3ByZWZpeF9fcHJlZml4ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgXHRwcmVmaXhDYWNoZSA9IHt9O1xuICBcdGhlbHBlcnNfcHJlZml4X190ZXN0U3R5bGUgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlO1xuXG4gIFx0aGVscGVyc19wcmVmaXhfX3ByZWZpeCA9IGZ1bmN0aW9uIChwcm9wKSB7XG4gIFx0XHR2YXIgaSwgdmVuZG9yLCBjYXBwZWQ7XG5cbiAgXHRcdHByb3AgPSBjYW1lbENhc2UocHJvcCk7XG5cbiAgXHRcdGlmICghcHJlZml4Q2FjaGVbcHJvcF0pIHtcbiAgXHRcdFx0aWYgKGhlbHBlcnNfcHJlZml4X190ZXN0U3R5bGVbcHJvcF0gIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdHByZWZpeENhY2hlW3Byb3BdID0gcHJvcDtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHQvLyB0ZXN0IHZlbmRvcnMuLi5cbiAgXHRcdFx0XHRjYXBwZWQgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zdWJzdHJpbmcoMSk7XG5cbiAgXHRcdFx0XHRpID0gdmVuZG9ycy5sZW5ndGg7XG4gIFx0XHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdFx0dmVuZG9yID0gdmVuZG9yc1tpXTtcbiAgXHRcdFx0XHRcdGlmIChoZWxwZXJzX3ByZWZpeF9fdGVzdFN0eWxlW3ZlbmRvciArIGNhcHBlZF0gIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdFx0XHRwcmVmaXhDYWNoZVtwcm9wXSA9IHZlbmRvciArIGNhcHBlZDtcbiAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBwcmVmaXhDYWNoZVtwcm9wXTtcbiAgXHR9O1xuICB9XG5cbiAgdmFyIGhlbHBlcnNfcHJlZml4ID0gaGVscGVyc19wcmVmaXhfX3ByZWZpeDtcblxuICB2YXIgZ2V0U3R5bGUsIHByb3RvdHlwZV9nZXRTdHlsZV9fZ2V0Q29tcHV0ZWRTdHlsZTtcblxuICBpZiAoIWlzQ2xpZW50KSB7XG4gIFx0Z2V0U3R5bGUgPSBudWxsO1xuICB9IGVsc2Uge1xuICBcdHByb3RvdHlwZV9nZXRTdHlsZV9fZ2V0Q29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlIHx8IGxlZ2FjeS5nZXRDb21wdXRlZFN0eWxlO1xuXG4gIFx0Z2V0U3R5bGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgXHRcdHZhciBjb21wdXRlZFN0eWxlLCBzdHlsZXMsIGksIHByb3AsIHZhbHVlO1xuXG4gIFx0XHRjb21wdXRlZFN0eWxlID0gcHJvdG90eXBlX2dldFN0eWxlX19nZXRDb21wdXRlZFN0eWxlKHRoaXMubm9kZSk7XG5cbiAgXHRcdGlmICh0eXBlb2YgcHJvcHMgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0dmFsdWUgPSBjb21wdXRlZFN0eWxlW2hlbHBlcnNfcHJlZml4KHByb3BzKV07XG4gIFx0XHRcdGlmICh2YWx1ZSA9PT0gXCIwcHhcIikge1xuICBcdFx0XHRcdHZhbHVlID0gMDtcbiAgXHRcdFx0fVxuICBcdFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghaXNBcnJheShwcm9wcykpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVHJhbnNpdGlvbiRnZXRTdHlsZSBtdXN0IGJlIHBhc3NlZCBhIHN0cmluZywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyByZXByZXNlbnRpbmcgQ1NTIHByb3BlcnRpZXNcIik7XG4gIFx0XHR9XG5cbiAgXHRcdHN0eWxlcyA9IHt9O1xuXG4gIFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRwcm9wID0gcHJvcHNbaV07XG4gIFx0XHRcdHZhbHVlID0gY29tcHV0ZWRTdHlsZVtoZWxwZXJzX3ByZWZpeChwcm9wKV07XG4gIFx0XHRcdGlmICh2YWx1ZSA9PT0gXCIwcHhcIikge1xuICBcdFx0XHRcdHZhbHVlID0gMDtcbiAgXHRcdFx0fVxuICBcdFx0XHRzdHlsZXNbcHJvcF0gPSB2YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHN0eWxlcztcbiAgXHR9O1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9nZXRTdHlsZSA9IGdldFN0eWxlO1xuXG4gIHZhciBzZXRTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSwgdmFsdWUpIHtcbiAgXHR2YXIgcHJvcDtcblxuICBcdGlmICh0eXBlb2Ygc3R5bGUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHRoaXMubm9kZS5zdHlsZVtoZWxwZXJzX3ByZWZpeChzdHlsZSldID0gdmFsdWU7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGZvciAocHJvcCBpbiBzdHlsZSkge1xuICBcdFx0XHRpZiAoc3R5bGUuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgXHRcdFx0XHR0aGlzLm5vZGUuc3R5bGVbaGVscGVyc19wcmVmaXgocHJvcCldID0gc3R5bGVbcHJvcF07XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgVGlja2VyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR2YXIgZWFzaW5nO1xuXG4gIFx0dGhpcy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb247XG4gIFx0dGhpcy5zdGVwID0gb3B0aW9ucy5zdGVwO1xuICBcdHRoaXMuY29tcGxldGUgPSBvcHRpb25zLmNvbXBsZXRlO1xuXG4gIFx0Ly8gZWFzaW5nXG4gIFx0aWYgKHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0ZWFzaW5nID0gb3B0aW9ucy5yb290LmVhc2luZ1tvcHRpb25zLmVhc2luZ107XG5cbiAgXHRcdGlmICghZWFzaW5nKSB7XG4gIFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyhtaXNzaW5nUGx1Z2luKG9wdGlvbnMuZWFzaW5nLCBcImVhc2luZ1wiKSk7XG4gIFx0XHRcdGVhc2luZyA9IGxpbmVhcjtcbiAgXHRcdH1cbiAgXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRlYXNpbmcgPSBvcHRpb25zLmVhc2luZztcbiAgXHR9IGVsc2Uge1xuICBcdFx0ZWFzaW5nID0gbGluZWFyO1xuICBcdH1cblxuICBcdHRoaXMuZWFzaW5nID0gZWFzaW5nO1xuXG4gIFx0dGhpcy5zdGFydCA9IHV0aWxzX2dldFRpbWUoKTtcbiAgXHR0aGlzLmVuZCA9IHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuXG4gIFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgXHRzaGFyZWRfYW5pbWF0aW9ucy5hZGQodGhpcyk7XG4gIH07XG5cbiAgVGlja2VyLnByb3RvdHlwZSA9IHtcbiAgXHR0aWNrOiBmdW5jdGlvbiAobm93KSB7XG4gIFx0XHR2YXIgZWxhcHNlZCwgZWFzZWQ7XG5cbiAgXHRcdGlmICghdGhpcy5ydW5uaW5nKSB7XG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKG5vdyA+IHRoaXMuZW5kKSB7XG4gIFx0XHRcdGlmICh0aGlzLnN0ZXApIHtcbiAgXHRcdFx0XHR0aGlzLnN0ZXAoMSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAodGhpcy5jb21wbGV0ZSkge1xuICBcdFx0XHRcdHRoaXMuY29tcGxldGUoMSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdGVsYXBzZWQgPSBub3cgLSB0aGlzLnN0YXJ0O1xuICBcdFx0ZWFzZWQgPSB0aGlzLmVhc2luZyhlbGFwc2VkIC8gdGhpcy5kdXJhdGlvbik7XG5cbiAgXHRcdGlmICh0aGlzLnN0ZXApIHtcbiAgXHRcdFx0dGhpcy5zdGVwKGVhc2VkKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fSxcblxuICBcdHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLmFib3J0KSB7XG4gIFx0XHRcdHRoaXMuYWJvcnQoKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBzaGFyZWRfVGlja2VyID0gVGlja2VyO1xuICBmdW5jdGlvbiBsaW5lYXIodCkge1xuICBcdHJldHVybiB0O1xuICB9XG5cbiAgdmFyIHVucHJlZml4UGF0dGVybiA9IG5ldyBSZWdFeHAoXCJeLSg/OlwiICsgdmVuZG9ycy5qb2luKFwifFwiKSArIFwiKS1cIik7XG5cbiAgdmFyIHVucHJlZml4ID0gZnVuY3Rpb24gKHByb3ApIHtcbiAgXHRyZXR1cm4gcHJvcC5yZXBsYWNlKHVucHJlZml4UGF0dGVybiwgXCJcIik7XG4gIH07XG5cbiAgdmFyIHZlbmRvclBhdHRlcm4gPSBuZXcgUmVnRXhwKFwiXig/OlwiICsgdmVuZG9ycy5qb2luKFwifFwiKSArIFwiKShbQS1aXSlcIik7XG5cbiAgdmFyIGh5cGhlbmF0ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgXHR2YXIgaHlwaGVuYXRlZDtcblxuICBcdGlmICghc3RyKSB7XG4gIFx0XHRyZXR1cm4gXCJcIjsgLy8gZWRnZSBjYXNlXG4gIFx0fVxuXG4gIFx0aWYgKHZlbmRvclBhdHRlcm4udGVzdChzdHIpKSB7XG4gIFx0XHRzdHIgPSBcIi1cIiArIHN0cjtcbiAgXHR9XG5cbiAgXHRoeXBoZW5hdGVkID0gc3RyLnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICBcdFx0cmV0dXJuIFwiLVwiICsgbWF0Y2gudG9Mb3dlckNhc2UoKTtcbiAgXHR9KTtcblxuICBcdHJldHVybiBoeXBoZW5hdGVkO1xuICB9O1xuXG4gIHZhciBjcmVhdGVUcmFuc2l0aW9ucyxcbiAgICAgIGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9uc19fdGVzdFN0eWxlLFxuICAgICAgVFJBTlNJVElPTixcbiAgICAgIFRSQU5TSVRJT05FTkQsXG4gICAgICBDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCxcbiAgICAgIFRSQU5TSVRJT05fRFVSQVRJT04sXG4gICAgICBUUkFOU0lUSU9OX1BST1BFUlRZLFxuICAgICAgVFJBTlNJVElPTl9USU1JTkdfRlVOQ1RJT04sXG4gICAgICBjYW5Vc2VDc3NUcmFuc2l0aW9ucyA9IHt9LFxuICAgICAgY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnMgPSB7fTtcblxuICBpZiAoIWlzQ2xpZW50KSB7XG4gIFx0Y3JlYXRlVHJhbnNpdGlvbnMgPSBudWxsO1xuICB9IGVsc2Uge1xuICBcdGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9uc19fdGVzdFN0eWxlID0gY3JlYXRlRWxlbWVudChcImRpdlwiKS5zdHlsZTtcblxuICBcdC8vIGRldGVybWluZSBzb21lIGZhY3RzIGFib3V0IG91ciBlbnZpcm9ubWVudFxuICBcdChmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoYW5pbWF0ZVN0eWxlX2NyZWF0ZVRyYW5zaXRpb25zX190ZXN0U3R5bGUudHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFRSQU5TSVRJT04gPSBcInRyYW5zaXRpb25cIjtcbiAgXHRcdFx0VFJBTlNJVElPTkVORCA9IFwidHJhbnNpdGlvbmVuZFwiO1xuICBcdFx0XHRDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCA9IHRydWU7XG4gIFx0XHR9IGVsc2UgaWYgKGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9uc19fdGVzdFN0eWxlLndlYmtpdFRyYW5zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRUUkFOU0lUSU9OID0gXCJ3ZWJraXRUcmFuc2l0aW9uXCI7XG4gIFx0XHRcdFRSQU5TSVRJT05FTkQgPSBcIndlYmtpdFRyYW5zaXRpb25FbmRcIjtcbiAgXHRcdFx0Q1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgPSB0cnVlO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Q1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgPSBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9KSgpO1xuXG4gIFx0aWYgKFRSQU5TSVRJT04pIHtcbiAgXHRcdFRSQU5TSVRJT05fRFVSQVRJT04gPSBUUkFOU0lUSU9OICsgXCJEdXJhdGlvblwiO1xuICBcdFx0VFJBTlNJVElPTl9QUk9QRVJUWSA9IFRSQU5TSVRJT04gKyBcIlByb3BlcnR5XCI7XG4gIFx0XHRUUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTiA9IFRSQU5TSVRJT04gKyBcIlRpbWluZ0Z1bmN0aW9uXCI7XG4gIFx0fVxuXG4gIFx0Y3JlYXRlVHJhbnNpdGlvbnMgPSBmdW5jdGlvbiAodCwgdG8sIG9wdGlvbnMsIGNoYW5nZWRQcm9wZXJ0aWVzLCByZXNvbHZlKSB7XG5cbiAgXHRcdC8vIFdhaXQgYSBiZWF0IChvdGhlcndpc2UgdGhlIHRhcmdldCBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkIGltbWVkaWF0ZWx5KVxuICBcdFx0Ly8gVE9ETyB1c2UgYSBmYXN0ZG9tLXN0eWxlIG1lY2hhbmlzbT9cbiAgXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXG4gIFx0XHRcdHZhciBoYXNoUHJlZml4LCBqc1RyYW5zaXRpb25zQ29tcGxldGUsIGNzc1RyYW5zaXRpb25zQ29tcGxldGUsIGNoZWNrQ29tcGxldGUsIHRyYW5zaXRpb25FbmRIYW5kbGVyO1xuXG4gIFx0XHRcdGNoZWNrQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0aWYgKGpzVHJhbnNpdGlvbnNDb21wbGV0ZSAmJiBjc3NUcmFuc2l0aW9uc0NvbXBsZXRlKSB7XG4gIFx0XHRcdFx0XHQvLyB3aWxsIGNoYW5nZXMgdG8gZXZlbnRzIGFuZCBmaXJlIGhhdmUgYW4gdW5leHBlY3RlZCBjb25zZXF1ZW5jZSBoZXJlP1xuICBcdFx0XHRcdFx0dC5yb290LmZpcmUodC5uYW1lICsgXCI6ZW5kXCIsIHQubm9kZSwgdC5pc0ludHJvKTtcbiAgXHRcdFx0XHRcdHJlc29sdmUoKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0Ly8gdGhpcyBpcyB1c2VkIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggZWxlbWVudHMgY2FuIHVzZSBDU1MgdG8gYW5pbWF0ZVxuICBcdFx0XHQvLyB3aGljaCBwcm9wZXJ0aWVzXG4gIFx0XHRcdGhhc2hQcmVmaXggPSAodC5ub2RlLm5hbWVzcGFjZVVSSSB8fCBcIlwiKSArIHQubm9kZS50YWdOYW1lO1xuXG4gIFx0XHRcdHQubm9kZS5zdHlsZVtUUkFOU0lUSU9OX1BST1BFUlRZXSA9IGNoYW5nZWRQcm9wZXJ0aWVzLm1hcChoZWxwZXJzX3ByZWZpeCkubWFwKGh5cGhlbmF0ZSkuam9pbihcIixcIik7XG4gIFx0XHRcdHQubm9kZS5zdHlsZVtUUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTl0gPSBoeXBoZW5hdGUob3B0aW9ucy5lYXNpbmcgfHwgXCJsaW5lYXJcIik7XG4gIFx0XHRcdHQubm9kZS5zdHlsZVtUUkFOU0lUSU9OX0RVUkFUSU9OXSA9IG9wdGlvbnMuZHVyYXRpb24gLyAxMDAwICsgXCJzXCI7XG5cbiAgXHRcdFx0dHJhbnNpdGlvbkVuZEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgXHRcdFx0XHR2YXIgaW5kZXg7XG5cbiAgXHRcdFx0XHRpbmRleCA9IGNoYW5nZWRQcm9wZXJ0aWVzLmluZGV4T2YoY2FtZWxDYXNlKHVucHJlZml4KGV2ZW50LnByb3BlcnR5TmFtZSkpKTtcbiAgXHRcdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG4gIFx0XHRcdFx0XHRjaGFuZ2VkUHJvcGVydGllcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGlmIChjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRcdC8vIHN0aWxsIHRyYW5zaXRpb25pbmcuLi5cbiAgXHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHR0Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9ORU5ELCB0cmFuc2l0aW9uRW5kSGFuZGxlciwgZmFsc2UpO1xuXG4gIFx0XHRcdFx0Y3NzVHJhbnNpdGlvbnNDb21wbGV0ZSA9IHRydWU7XG4gIFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuICBcdFx0XHR9O1xuXG4gIFx0XHRcdHQubm9kZS5hZGRFdmVudExpc3RlbmVyKFRSQU5TSVRJT05FTkQsIHRyYW5zaXRpb25FbmRIYW5kbGVyLCBmYWxzZSk7XG5cbiAgXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0dmFyIGkgPSBjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGgsXG4gIFx0XHRcdFx0ICAgIGhhc2gsXG4gIFx0XHRcdFx0ICAgIG9yaWdpbmFsVmFsdWUsXG4gIFx0XHRcdFx0ICAgIGluZGV4LFxuICBcdFx0XHRcdCAgICBwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5KcyA9IFtdLFxuICBcdFx0XHRcdCAgICBwcm9wLFxuICBcdFx0XHRcdCAgICBzdWZmaXg7XG5cbiAgXHRcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0XHRwcm9wID0gY2hhbmdlZFByb3BlcnRpZXNbaV07XG4gIFx0XHRcdFx0XHRoYXNoID0gaGFzaFByZWZpeCArIHByb3A7XG5cbiAgXHRcdFx0XHRcdGlmIChDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCAmJiAhY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbaGFzaF0pIHtcbiAgXHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlW2hlbHBlcnNfcHJlZml4KHByb3ApXSA9IHRvW3Byb3BdO1xuXG4gIFx0XHRcdFx0XHRcdC8vIElmIHdlJ3JlIG5vdCBzdXJlIGlmIENTUyB0cmFuc2l0aW9ucyBhcmUgc3VwcG9ydGVkIGZvclxuICBcdFx0XHRcdFx0XHQvLyB0aGlzIHRhZy9wcm9wZXJ0eSBjb21ibywgZmluZCBvdXQgbm93XG4gIFx0XHRcdFx0XHRcdGlmICghY2FuVXNlQ3NzVHJhbnNpdGlvbnNbaGFzaF0pIHtcbiAgXHRcdFx0XHRcdFx0XHRvcmlnaW5hbFZhbHVlID0gdC5nZXRTdHlsZShwcm9wKTtcblxuICBcdFx0XHRcdFx0XHRcdC8vIGlmIHRoaXMgcHJvcGVydHkgaXMgdHJhbnNpdGlvbmFibGUgaW4gdGhpcyBicm93c2VyLFxuICBcdFx0XHRcdFx0XHRcdC8vIHRoZSBjdXJyZW50IHN0eWxlIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gdGhlIHRhcmdldCBzdHlsZVxuICBcdFx0XHRcdFx0XHRcdGNhblVzZUNzc1RyYW5zaXRpb25zW2hhc2hdID0gdC5nZXRTdHlsZShwcm9wKSAhPSB0b1twcm9wXTtcbiAgXHRcdFx0XHRcdFx0XHRjYW5ub3RVc2VDc3NUcmFuc2l0aW9uc1toYXNoXSA9ICFjYW5Vc2VDc3NUcmFuc2l0aW9uc1toYXNoXTtcblxuICBcdFx0XHRcdFx0XHRcdC8vIFJlc2V0LCBpZiB3ZSdyZSBnb2luZyB0byB1c2UgdGltZXJzIGFmdGVyIGFsbFxuICBcdFx0XHRcdFx0XHRcdGlmIChjYW5ub3RVc2VDc3NUcmFuc2l0aW9uc1toYXNoXSkge1xuICBcdFx0XHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlW2hlbHBlcnNfcHJlZml4KHByb3ApXSA9IG9yaWdpbmFsVmFsdWU7XG4gIFx0XHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdGlmICghQ1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgfHwgY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbaGFzaF0pIHtcbiAgXHRcdFx0XHRcdFx0Ly8gd2UgbmVlZCB0byBmYWxsIGJhY2sgdG8gdGltZXItYmFzZWQgc3R1ZmZcbiAgXHRcdFx0XHRcdFx0aWYgKG9yaWdpbmFsVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdFx0XHRcdG9yaWdpbmFsVmFsdWUgPSB0LmdldFN0eWxlKHByb3ApO1xuICBcdFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdFx0Ly8gbmVlZCB0byByZW1vdmUgdGhpcyBmcm9tIGNoYW5nZWRQcm9wZXJ0aWVzLCBvdGhlcndpc2UgdHJhbnNpdGlvbkVuZEhhbmRsZXJcbiAgXHRcdFx0XHRcdFx0Ly8gd2lsbCBnZXQgY29uZnVzZWRcbiAgXHRcdFx0XHRcdFx0aW5kZXggPSBjaGFuZ2VkUHJvcGVydGllcy5pbmRleE9mKHByb3ApO1xuICBcdFx0XHRcdFx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdFx0XHRcdFx0d2FybklmRGVidWcoXCJTb21ldGhpbmcgdmVyeSBzdHJhbmdlIGhhcHBlbmVkIHdpdGggdHJhbnNpdGlvbnMuIFBsZWFzZSByYWlzZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzIC0gdGhhbmtzIVwiLCB7IG5vZGU6IHQubm9kZSB9KTtcbiAgXHRcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0XHRjaGFuZ2VkUHJvcGVydGllcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdFx0Ly8gVE9ETyBEZXRlcm1pbmUgd2hldGhlciB0aGlzIHByb3BlcnR5IGlzIGFuaW1hdGFibGUgYXQgYWxsXG5cbiAgXHRcdFx0XHRcdFx0c3VmZml4ID0gL1teXFxkXSokLy5leGVjKHRvW3Byb3BdKVswXTtcblxuICBcdFx0XHRcdFx0XHQvLyAuLi50aGVuIGtpY2sgb2ZmIGEgdGltZXItYmFzZWQgdHJhbnNpdGlvblxuICBcdFx0XHRcdFx0XHRwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kcy5wdXNoKHtcbiAgXHRcdFx0XHRcdFx0XHRuYW1lOiBoZWxwZXJzX3ByZWZpeChwcm9wKSxcbiAgXHRcdFx0XHRcdFx0XHRpbnRlcnBvbGF0b3I6IHNoYXJlZF9pbnRlcnBvbGF0ZShwYXJzZUZsb2F0KG9yaWdpbmFsVmFsdWUpLCBwYXJzZUZsb2F0KHRvW3Byb3BdKSksXG4gIFx0XHRcdFx0XHRcdFx0c3VmZml4OiBzdWZmaXhcbiAgXHRcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0Ly8gamF2YXNjcmlwdCB0cmFuc2l0aW9uc1xuICBcdFx0XHRcdGlmIChwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kcy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRcdG5ldyBzaGFyZWRfVGlja2VyKHtcbiAgXHRcdFx0XHRcdFx0cm9vdDogdC5yb290LFxuICBcdFx0XHRcdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcbiAgXHRcdFx0XHRcdFx0ZWFzaW5nOiBjYW1lbENhc2Uob3B0aW9ucy5lYXNpbmcgfHwgXCJcIiksXG4gIFx0XHRcdFx0XHRcdHN0ZXA6IGZ1bmN0aW9uIChwb3MpIHtcbiAgXHRcdFx0XHRcdFx0XHR2YXIgcHJvcCwgaTtcblxuICBcdFx0XHRcdFx0XHRcdGkgPSBwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kcy5sZW5ndGg7XG4gIFx0XHRcdFx0XHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdFx0XHRcdFx0cHJvcCA9IHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzW2ldO1xuICBcdFx0XHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlW3Byb3AubmFtZV0gPSBwcm9wLmludGVycG9sYXRvcihwb3MpICsgcHJvcC5zdWZmaXg7XG4gIFx0XHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0XHR9LFxuICBcdFx0XHRcdFx0XHRjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0XHRcdGpzVHJhbnNpdGlvbnNDb21wbGV0ZSA9IHRydWU7XG4gIFx0XHRcdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuICBcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0anNUcmFuc2l0aW9uc0NvbXBsZXRlID0gdHJ1ZTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAoIWNoYW5nZWRQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICBcdFx0XHRcdFx0Ly8gV2UgbmVlZCB0byBjYW5jZWwgdGhlIHRyYW5zaXRpb25FbmRIYW5kbGVyLCBhbmQgZGVhbCB3aXRoXG4gIFx0XHRcdFx0XHQvLyB0aGUgZmFjdCB0aGF0IGl0IHdpbGwgbmV2ZXIgZmlyZVxuICBcdFx0XHRcdFx0dC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoVFJBTlNJVElPTkVORCwgdHJhbnNpdGlvbkVuZEhhbmRsZXIsIGZhbHNlKTtcbiAgXHRcdFx0XHRcdGNzc1RyYW5zaXRpb25zQ29tcGxldGUgPSB0cnVlO1xuICBcdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSwgMCk7XG4gIFx0XHR9LCBvcHRpb25zLmRlbGF5IHx8IDApO1xuICBcdH07XG4gIH1cblxuICB2YXIgYW5pbWF0ZVN0eWxlX2NyZWF0ZVRyYW5zaXRpb25zID0gY3JlYXRlVHJhbnNpdGlvbnM7XG5cbiAgdmFyIGhpZGRlbiwgdmVuZG9yLCBhbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9fcHJlZml4LCBhbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9faSwgdmlzaWJpbGl0eTtcblxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIFx0aGlkZGVuID0gXCJoaWRkZW5cIjtcblxuICBcdHZpc2liaWxpdHkgPSB7fTtcblxuICBcdGlmIChoaWRkZW4gaW4gZG9jdW1lbnQpIHtcbiAgXHRcdGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19wcmVmaXggPSBcIlwiO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRhbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9faSA9IHZlbmRvcnMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19pLS0pIHtcbiAgXHRcdFx0dmVuZG9yID0gdmVuZG9yc1thbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9faV07XG4gIFx0XHRcdGhpZGRlbiA9IHZlbmRvciArIFwiSGlkZGVuXCI7XG5cbiAgXHRcdFx0aWYgKGhpZGRlbiBpbiBkb2N1bWVudCkge1xuICBcdFx0XHRcdGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19wcmVmaXggPSB2ZW5kb3I7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHlfX3ByZWZpeCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19wcmVmaXggKyBcInZpc2liaWxpdHljaGFuZ2VcIiwgb25DaGFuZ2UpO1xuXG4gIFx0XHQvLyBpbml0aWFsaXNlXG4gIFx0XHRvbkNoYW5nZSgpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHQvLyBnYWgsIHdlJ3JlIGluIGFuIG9sZCBicm93c2VyXG4gIFx0XHRpZiAoXCJvbmZvY3Vzb3V0XCIgaW4gZG9jdW1lbnQpIHtcbiAgXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIG9uSGlkZSk7XG4gIFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIG9uU2hvdyk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIG9uSGlkZSk7XG4gIFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBvbkhpZGUpO1xuXG4gIFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZXNob3dcIiwgb25TaG93KTtcbiAgXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBvblNob3cpO1xuICBcdFx0fVxuXG4gIFx0XHR2aXNpYmlsaXR5LmhpZGRlbiA9IGZhbHNlOyAvLyB1bnRpbCBwcm92ZW4gb3RoZXJ3aXNlLiBOb3QgaWRlYWwgYnV0IGhleVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICBcdHZpc2liaWxpdHkuaGlkZGVuID0gZG9jdW1lbnRbaGlkZGVuXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uSGlkZSgpIHtcbiAgXHR2aXNpYmlsaXR5LmhpZGRlbiA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBvblNob3coKSB7XG4gIFx0dmlzaWJpbGl0eS5oaWRkZW4gPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBhbmltYXRlU3R5bGVfdmlzaWJpbGl0eSA9IHZpc2liaWxpdHk7XG5cbiAgdmFyIGFuaW1hdGVTdHlsZSwgX2FuaW1hdGVTdHlsZV9fZ2V0Q29tcHV0ZWRTdHlsZSwgcmVzb2x2ZWQ7XG5cbiAgaWYgKCFpc0NsaWVudCkge1xuICBcdGFuaW1hdGVTdHlsZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gIFx0X2FuaW1hdGVTdHlsZV9fZ2V0Q29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlIHx8IGxlZ2FjeS5nZXRDb21wdXRlZFN0eWxlO1xuXG4gIFx0YW5pbWF0ZVN0eWxlID0gZnVuY3Rpb24gKHN0eWxlLCB2YWx1ZSwgb3B0aW9ucykge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0dmFyIHRvO1xuXG4gIFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ0LmFuaW1hdGVTdHlsZSgpIHJldHVybnMgYSBwcm9taXNlIC0gdXNlIC50aGVuKCkgaW5zdGVhZCBvZiBwYXNzaW5nIGEgY2FsbGJhY2tcIik7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIFNwZWNpYWwgY2FzZSAtIHBhZ2UgaXNuJ3QgdmlzaWJsZS4gRG9uJ3QgYW5pbWF0ZSBhbnl0aGluZywgYmVjYXVzZVxuICBcdFx0Ly8gdGhhdCB3YXkgeW91J2xsIG5ldmVyIGdldCBDU1MgdHJhbnNpdGlvbmVuZCBldmVudHNcbiAgXHRcdGlmIChhbmltYXRlU3R5bGVfdmlzaWJpbGl0eS5oaWRkZW4pIHtcbiAgXHRcdFx0dGhpcy5zZXRTdHlsZShzdHlsZSwgdmFsdWUpO1xuICBcdFx0XHRyZXR1cm4gcmVzb2x2ZWQgfHwgKHJlc29sdmVkID0gdXRpbHNfUHJvbWlzZS5yZXNvbHZlKCkpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodHlwZW9mIHN0eWxlID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdHRvID0ge307XG4gIFx0XHRcdHRvW3N0eWxlXSA9IHZhbHVlO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dG8gPSBzdHlsZTtcblxuICBcdFx0XHQvLyBzaHVmZmxlIGFyZ3VtZW50c1xuICBcdFx0XHRvcHRpb25zID0gdmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIEFzIG9mIDAuMy45LCB0cmFuc2l0aW9uIGF1dGhvcnMgc2hvdWxkIHN1cHBseSBhbiBgb3B0aW9uYCBvYmplY3Qgd2l0aFxuICBcdFx0Ly8gYGR1cmF0aW9uYCBhbmQgYGVhc2luZ2AgcHJvcGVydGllcyAoYW5kIG9wdGlvbmFsIGBkZWxheWApLCBwbHVzIGFcbiAgXHRcdC8vIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBjb21wbGV0ZXNcblxuICBcdFx0Ly8gVE9ETyByZW1vdmUgdGhpcyBjaGVjayBpbiBhIGZ1dHVyZSB2ZXJzaW9uXG4gIFx0XHRpZiAoIW9wdGlvbnMpIHtcbiAgXHRcdFx0d2Fybk9uY2VJZkRlYnVnKFwiVGhlIFxcXCIlc1xcXCIgdHJhbnNpdGlvbiBkb2VzIG5vdCBzdXBwbHkgYW4gb3B0aW9ucyBvYmplY3QgdG8gYHQuYW5pbWF0ZVN0eWxlKClgLiBUaGlzIHdpbGwgYnJlYWsgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSYWN0aXZlLiBGb3IgbW9yZSBpbmZvIHNlZSBodHRwczovL2dpdGh1Yi5jb20vUmFjdGl2ZUpTL1JhY3RpdmUvaXNzdWVzLzM0MFwiLCB0aGlzLm5hbWUpO1xuICBcdFx0XHRvcHRpb25zID0gdGhpcztcbiAgXHRcdH1cblxuICBcdFx0dmFyIHByb21pc2UgPSBuZXcgdXRpbHNfUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICBcdFx0XHR2YXIgcHJvcGVydHlOYW1lcywgY2hhbmdlZFByb3BlcnRpZXMsIGNvbXB1dGVkU3R5bGUsIGN1cnJlbnQsIGZyb20sIGksIHByb3A7XG5cbiAgXHRcdFx0Ly8gRWRnZSBjYXNlIC0gaWYgZHVyYXRpb24gaXMgemVybywgc2V0IHN0eWxlIHN5bmNocm9ub3VzbHkgYW5kIGNvbXBsZXRlXG4gIFx0XHRcdGlmICghb3B0aW9ucy5kdXJhdGlvbikge1xuICBcdFx0XHRcdF90aGlzLnNldFN0eWxlKHRvKTtcbiAgXHRcdFx0XHRyZXNvbHZlKCk7XG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gR2V0IGEgbGlzdCBvZiB0aGUgcHJvcGVydGllcyB3ZSdyZSBhbmltYXRpbmdcbiAgXHRcdFx0cHJvcGVydHlOYW1lcyA9IE9iamVjdC5rZXlzKHRvKTtcbiAgXHRcdFx0Y2hhbmdlZFByb3BlcnRpZXMgPSBbXTtcblxuICBcdFx0XHQvLyBTdG9yZSB0aGUgY3VycmVudCBzdHlsZXNcbiAgXHRcdFx0Y29tcHV0ZWRTdHlsZSA9IF9hbmltYXRlU3R5bGVfX2dldENvbXB1dGVkU3R5bGUoX3RoaXMubm9kZSk7XG5cbiAgXHRcdFx0ZnJvbSA9IHt9O1xuICBcdFx0XHRpID0gcHJvcGVydHlOYW1lcy5sZW5ndGg7XG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRwcm9wID0gcHJvcGVydHlOYW1lc1tpXTtcbiAgXHRcdFx0XHRjdXJyZW50ID0gY29tcHV0ZWRTdHlsZVtoZWxwZXJzX3ByZWZpeChwcm9wKV07XG5cbiAgXHRcdFx0XHRpZiAoY3VycmVudCA9PT0gXCIwcHhcIikge1xuICBcdFx0XHRcdFx0Y3VycmVudCA9IDA7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0Ly8gd2UgbmVlZCB0byBrbm93IGlmIHdlJ3JlIGFjdHVhbGx5IGNoYW5naW5nIGFueXRoaW5nXG4gIFx0XHRcdFx0aWYgKGN1cnJlbnQgIT0gdG9bcHJvcF0pIHtcbiAgXHRcdFx0XHRcdC8vIHVzZSAhPSBpbnN0ZWFkIG9mICE9PSwgc28gd2UgY2FuIGNvbXBhcmUgc3RyaW5ncyB3aXRoIG51bWJlcnNcbiAgXHRcdFx0XHRcdGNoYW5nZWRQcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG5cbiAgXHRcdFx0XHRcdC8vIG1ha2UgdGhlIGNvbXB1dGVkIHN0eWxlIGV4cGxpY2l0LCBzbyB3ZSBjYW4gYW5pbWF0ZSB3aGVyZVxuICBcdFx0XHRcdFx0Ly8gZS5nLiBoZWlnaHQ9J2F1dG8nXG4gIFx0XHRcdFx0XHRfdGhpcy5ub2RlLnN0eWxlW2hlbHBlcnNfcHJlZml4KHByb3ApXSA9IGN1cnJlbnQ7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gSWYgd2UncmUgbm90IGFjdHVhbGx5IGNoYW5naW5nIGFueXRoaW5nLCB0aGUgdHJhbnNpdGlvbmVuZCBldmVudFxuICBcdFx0XHQvLyB3aWxsIG5ldmVyIGZpcmUhIFNvIHdlIGNvbXBsZXRlIGVhcmx5XG4gIFx0XHRcdGlmICghY2hhbmdlZFByb3BlcnRpZXMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0cmVzb2x2ZSgpO1xuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9ucyhfdGhpcywgdG8sIG9wdGlvbnMsIGNoYW5nZWRQcm9wZXJ0aWVzLCByZXNvbHZlKTtcbiAgXHRcdH0pO1xuXG4gIFx0XHRyZXR1cm4gcHJvbWlzZTtcbiAgXHR9O1xuICB9XG5cbiAgdmFyIF9hbmltYXRlU3R5bGUgPSBhbmltYXRlU3R5bGU7XG5cbiAgdmFyIHByb2Nlc3NQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCBkZWZhdWx0cykge1xuICBcdGlmICh0eXBlb2YgcGFyYW1zID09PSBcIm51bWJlclwiKSB7XG4gIFx0XHRwYXJhbXMgPSB7IGR1cmF0aW9uOiBwYXJhbXMgfTtcbiAgXHR9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGlmIChwYXJhbXMgPT09IFwic2xvd1wiKSB7XG4gIFx0XHRcdHBhcmFtcyA9IHsgZHVyYXRpb246IDYwMCB9O1xuICBcdFx0fSBlbHNlIGlmIChwYXJhbXMgPT09IFwiZmFzdFwiKSB7XG4gIFx0XHRcdHBhcmFtcyA9IHsgZHVyYXRpb246IDIwMCB9O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGFyYW1zID0geyBkdXJhdGlvbjogNDAwIH07XG4gIFx0XHR9XG4gIFx0fSBlbHNlIGlmICghcGFyYW1zKSB7XG4gIFx0XHRwYXJhbXMgPSB7fTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gZmlsbEdhcHMoe30sIHBhcmFtcywgZGVmYXVsdHMpO1xuICB9O1xuXG4gIHZhciBwcm90b3R5cGVfc3RhcnQgPSBUcmFuc2l0aW9uJHN0YXJ0O1xuXG4gIGZ1bmN0aW9uIFRyYW5zaXRpb24kc3RhcnQoKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciBub2RlLCBvcmlnaW5hbFN0eWxlLCBjb21wbGV0ZWQ7XG5cbiAgXHRub2RlID0gdGhpcy5ub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG4gIFx0b3JpZ2luYWxTdHlsZSA9IG5vZGUuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG5cbiAgXHQvLyBjcmVhdGUgdC5jb21wbGV0ZSgpIC0gd2UgZG9uJ3Qgd2FudCB0aGlzIG9uIHRoZSBwcm90b3R5cGUsXG4gIFx0Ly8gYmVjYXVzZSB3ZSBkb24ndCB3YW50IGB0aGlzYCBzaWxsaW5lc3Mgd2hlbiBwYXNzaW5nIGl0IGFzXG4gIFx0Ly8gYW4gYXJndW1lbnRcbiAgXHR0aGlzLmNvbXBsZXRlID0gZnVuY3Rpb24gKG5vUmVzZXQpIHtcbiAgXHRcdGlmIChjb21wbGV0ZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIW5vUmVzZXQgJiYgX3RoaXMuaXNJbnRybykge1xuICBcdFx0XHRyZXNldFN0eWxlKG5vZGUsIG9yaWdpbmFsU3R5bGUpO1xuICBcdFx0fVxuXG4gIFx0XHRub2RlLl9yYWN0aXZlLnRyYW5zaXRpb24gPSBudWxsO1xuICBcdFx0X3RoaXMuX21hbmFnZXIucmVtb3ZlKF90aGlzKTtcblxuICBcdFx0Y29tcGxldGVkID0gdHJ1ZTtcbiAgXHR9O1xuXG4gIFx0Ly8gSWYgdGhlIHRyYW5zaXRpb24gZnVuY3Rpb24gZG9lc24ndCBleGlzdCwgYWJvcnRcbiAgXHRpZiAoIXRoaXMuX2ZuKSB7XG4gIFx0XHR0aGlzLmNvbXBsZXRlKCk7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0dGhpcy5fZm4uYXBwbHkodGhpcy5yb290LCBbdGhpc10uY29uY2F0KHRoaXMucGFyYW1zKSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFN0eWxlKG5vZGUsIHN0eWxlKSB7XG4gIFx0aWYgKHN0eWxlKSB7XG4gIFx0XHRub2RlLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIHN0eWxlKTtcbiAgXHR9IGVsc2Uge1xuXG4gIFx0XHQvLyBOZXh0IGxpbmUgaXMgbmVjZXNzYXJ5LCB0byByZW1vdmUgZW1wdHkgc3R5bGUgYXR0cmlidXRlIVxuICBcdFx0Ly8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcxNjc1NTNcbiAgXHRcdG5vZGUuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gIFx0XHRub2RlLnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG93bmVyLCB0ZW1wbGF0ZSwgaXNJbnRybykge1xuICBcdHRoaXMuaW5pdChvd25lciwgdGVtcGxhdGUsIGlzSW50cm8pO1xuICB9O1xuXG4gIFRyYW5zaXRpb24ucHJvdG90eXBlID0ge1xuICBcdGluaXQ6IFRyYW5zaXRpb25fcHJvdG90eXBlX2luaXQsXG4gIFx0c3RhcnQ6IHByb3RvdHlwZV9zdGFydCxcbiAgXHRnZXRTdHlsZTogcHJvdG90eXBlX2dldFN0eWxlLFxuICBcdHNldFN0eWxlOiBzZXRTdHlsZSxcbiAgXHRhbmltYXRlU3R5bGU6IF9hbmltYXRlU3R5bGUsXG4gIFx0cHJvY2Vzc1BhcmFtczogcHJvY2Vzc1BhcmFtc1xuICB9O1xuXG4gIHZhciBfVHJhbnNpdGlvbiA9IFRyYW5zaXRpb247XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX3JlbmRlciA9IEVsZW1lbnQkcmVuZGVyO1xuXG4gIHZhciB1cGRhdGVDc3MsIHVwZGF0ZVNjcmlwdDtcblxuICB1cGRhdGVDc3MgPSBmdW5jdGlvbiAoKSB7XG4gIFx0dmFyIG5vZGUgPSB0aGlzLm5vZGUsXG4gIFx0ICAgIGNvbnRlbnQgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKGZhbHNlKTtcblxuICBcdC8vIElFOCBoYXMgbm8gc3R5bGVTaGVldCB1bmxlc3MgdGhlcmUncyBhIHR5cGUgdGV4dC9jc3NcbiAgXHRpZiAod2luZG93ICYmIHdpbmRvdy5hcHBlYXJzVG9CZUlFTGVzc0VxdWFsOCkge1xuICBcdFx0bm9kZS50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuICBcdH1cblxuICBcdGlmIChub2RlLnN0eWxlU2hlZXQpIHtcbiAgXHRcdG5vZGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY29udGVudDtcbiAgXHR9IGVsc2Uge1xuXG4gIFx0XHR3aGlsZSAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgXHRcdFx0bm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICBcdFx0fVxuXG4gIFx0XHRub2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvbnRlbnQpKTtcbiAgXHR9XG4gIH07XG5cbiAgdXBkYXRlU2NyaXB0ID0gZnVuY3Rpb24gKCkge1xuICBcdGlmICghdGhpcy5ub2RlLnR5cGUgfHwgdGhpcy5ub2RlLnR5cGUgPT09IFwidGV4dC9qYXZhc2NyaXB0XCIpIHtcbiAgXHRcdHdhcm5JZkRlYnVnKFwiU2NyaXB0IHRhZyB3YXMgdXBkYXRlZC4gVGhpcyBkb2VzIG5vdCBjYXVzZSB0aGUgY29kZSB0byBiZSByZS1ldmFsdWF0ZWQhXCIsIHsgcmFjdGl2ZTogdGhpcy5yb290IH0pO1xuICBcdFx0Ly8gQXMgaXQgaGFwcGVucywgd2UgQVJFIGluIGEgcG9zaXRpb24gdG8gcmUtZXZhbHVhdGUgdGhlIGNvZGUgaWYgd2Ugd2FudGVkXG4gIFx0XHQvLyB0byAtIHdlIGNvdWxkIGV2YWwoKSBpdCwgb3IgaW5zZXJ0IGl0IGludG8gYSBmcmVzaCAodGVtcG9yYXJ5KSBzY3JpcHQgdGFnLlxuICBcdFx0Ly8gQnV0IHRoaXMgd291bGQgYmUgYSB0ZXJyaWJsZSBpZGVhIHdpdGggdW5wcmVkaWN0YWJsZSByZXN1bHRzLCBzbyBsZXQncyBub3QuXG4gIFx0fVxuXG4gIFx0dGhpcy5ub2RlLnRleHQgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKGZhbHNlKTtcbiAgfTtcbiAgZnVuY3Rpb24gRWxlbWVudCRyZW5kZXIoKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciByb290ID0gdGhpcy5yb290LFxuICBcdCAgICBuYW1lc3BhY2UsXG4gIFx0ICAgIG5vZGUsXG4gIFx0ICAgIHRyYW5zaXRpb247XG5cbiAgXHRuYW1lc3BhY2UgPSBnZXROYW1lc3BhY2UodGhpcyk7XG4gIFx0bm9kZSA9IHRoaXMubm9kZSA9IGNyZWF0ZUVsZW1lbnQodGhpcy5uYW1lLCBuYW1lc3BhY2UpO1xuXG4gIFx0Ly8gSXMgdGhpcyBhIHRvcC1sZXZlbCBub2RlIG9mIGEgY29tcG9uZW50PyBJZiBzbywgd2UgbWF5IG5lZWQgdG8gYWRkXG4gIFx0Ly8gYSBkYXRhLXJhY3RpdmUtY3NzIGF0dHJpYnV0ZSwgZm9yIENTUyBlbmNhcHN1bGF0aW9uXG4gIFx0aWYgKHRoaXMucGFyZW50RnJhZ21lbnQuY3NzSWRzKSB7XG4gIFx0XHR0aGlzLm5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS1yYWN0aXZlLWNzc1wiLCB0aGlzLnBhcmVudEZyYWdtZW50LmNzc0lkcy5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgXHRcdFx0cmV0dXJuIFwie1wiICsgeCArIFwifVwiO1xuICBcdFx0fSkuam9pbihcIiBcIikpO1xuICBcdH1cblxuICBcdC8vIEFkZCBfcmFjdGl2ZSBwcm9wZXJ0eSB0byB0aGUgbm9kZSAtIHdlIHVzZSB0aGlzIG9iamVjdCB0byBzdG9yZSBzdHVmZlxuICBcdC8vIHJlbGF0ZWQgdG8gcHJveHkgZXZlbnRzLCB0d28td2F5IGJpbmRpbmdzIGV0Y1xuICBcdGRlZmluZVByb3BlcnR5KHRoaXMubm9kZSwgXCJfcmFjdGl2ZVwiLCB7XG4gIFx0XHR2YWx1ZToge1xuICBcdFx0XHRwcm94eTogdGhpcyxcbiAgXHRcdFx0a2V5cGF0aDogZ2V0SW5uZXJDb250ZXh0KHRoaXMucGFyZW50RnJhZ21lbnQpLFxuICBcdFx0XHRldmVudHM6IGNyZWF0ZShudWxsKSxcbiAgXHRcdFx0cm9vdDogcm9vdFxuICBcdFx0fVxuICBcdH0pO1xuXG4gIFx0Ly8gUmVuZGVyIGF0dHJpYnV0ZXNcbiAgXHR0aGlzLmF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICBcdFx0cmV0dXJuIGEucmVuZGVyKG5vZGUpO1xuICBcdH0pO1xuICBcdHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgXHRcdHJldHVybiBhLnJlbmRlcihub2RlKTtcbiAgXHR9KTtcblxuICBcdC8vIFJlbmRlciBjaGlsZHJlblxuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHQvLyBTcGVjaWFsIGNhc2UgLSA8c2NyaXB0PiBlbGVtZW50XG4gIFx0XHRpZiAodGhpcy5uYW1lID09PSBcInNjcmlwdFwiKSB7XG4gIFx0XHRcdHRoaXMuYnViYmxlID0gdXBkYXRlU2NyaXB0O1xuICBcdFx0XHR0aGlzLm5vZGUudGV4dCA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoZmFsc2UpOyAvLyBieXBhc3Mgd2FybmluZyBpbml0aWFsbHlcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciA9IG5vb3A7IC8vIFRPRE8gdGhpcyBpcyBhIGtsdWRnZVxuICBcdFx0fVxuXG4gIFx0XHQvLyBTcGVjaWFsIGNhc2UgLSA8c3R5bGU+IGVsZW1lbnRcbiAgXHRcdGVsc2UgaWYgKHRoaXMubmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gIFx0XHRcdHRoaXMuYnViYmxlID0gdXBkYXRlQ3NzO1xuICBcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyID0gbm9vcDtcbiAgXHRcdH1cblxuICBcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gY29udGVudGVkaXRhYmxlXG4gIFx0XHRlbHNlIGlmICh0aGlzLmJpbmRpbmcgJiYgdGhpcy5nZXRBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciA9IG5vb3A7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5mcmFnbWVudC5yZW5kZXIoKSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gZGVhbCB3aXRoIHR3by13YXkgYmluZGluZ3NcbiAgXHRpZiAodGhpcy5iaW5kaW5nKSB7XG4gIFx0XHR0aGlzLmJpbmRpbmcucmVuZGVyKCk7XG4gIFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUuYmluZGluZyA9IHRoaXMuYmluZGluZztcbiAgXHR9XG5cbiAgXHQvLyBBZGQgcHJveHkgZXZlbnQgaGFuZGxlcnNcbiAgXHRpZiAodGhpcy5ldmVudEhhbmRsZXJzKSB7XG4gIFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaCkge1xuICBcdFx0XHRyZXR1cm4gaC5yZW5kZXIoKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdGlmICh0aGlzLm5hbWUgPT09IFwib3B0aW9uXCIpIHtcbiAgXHRcdHByb2Nlc3NPcHRpb24odGhpcyk7XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlc1xuICBcdGlmICh0aGlzLm5hbWUgPT09IFwiaW1nXCIpIHtcbiAgXHRcdC8vIGlmIHRoaXMgaXMgYW4gPGltZz4sIGFuZCB3ZSdyZSBpbiBhIGNyYXAgYnJvd3Nlciwgd2UgbWF5XG4gIFx0XHQvLyBuZWVkIHRvIHByZXZlbnQgaXQgZnJvbSBvdmVycmlkaW5nIHdpZHRoIGFuZCBoZWlnaHQgd2hlblxuICBcdFx0Ly8gaXQgbG9hZHMgdGhlIHNyY1xuICBcdFx0c3BlY2lhbF9pbWdfX3JlbmRlcih0aGlzKTtcbiAgXHR9IGVsc2UgaWYgKHRoaXMubmFtZSA9PT0gXCJmb3JtXCIpIHtcbiAgXHRcdC8vIGZvcm1zIG5lZWQgdG8ga2VlcCB0cmFjayBvZiB0aGVpciBiaW5kaW5ncywgaW4gY2FzZSBvZiByZXNldFxuICBcdFx0Zm9ybV9fcmVuZGVyKHRoaXMpO1xuICBcdH0gZWxzZSBpZiAodGhpcy5uYW1lID09PSBcImlucHV0XCIgfHwgdGhpcy5uYW1lID09PSBcInRleHRhcmVhXCIpIHtcbiAgXHRcdC8vIGlucHV0cyBhbmQgdGV4dGFyZWFzIHNob3VsZCBzdG9yZSB0aGVpciBpbml0aWFsIHZhbHVlIGFzXG4gIFx0XHQvLyBgZGVmYXVsdFZhbHVlYCBpbiBjYXNlIG9mIHJlc2V0XG4gIFx0XHR0aGlzLm5vZGUuZGVmYXVsdFZhbHVlID0gdGhpcy5ub2RlLnZhbHVlO1xuICBcdH0gZWxzZSBpZiAodGhpcy5uYW1lID09PSBcIm9wdGlvblwiKSB7XG4gIFx0XHQvLyBzaW1pbGFybHkgZm9yIG9wdGlvbiBub2Rlc1xuICBcdFx0dGhpcy5ub2RlLmRlZmF1bHRTZWxlY3RlZCA9IHRoaXMubm9kZS5zZWxlY3RlZDtcbiAgXHR9XG5cbiAgXHQvLyBhcHBseSBkZWNvcmF0b3IocylcbiAgXHRpZiAodGhpcy5kZWNvcmF0b3IgJiYgdGhpcy5kZWNvcmF0b3IuZm4pIHtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdGlmICghX3RoaXMuZGVjb3JhdG9yLnRvcm5kb3duKSB7XG4gIFx0XHRcdFx0X3RoaXMuZGVjb3JhdG9yLmluaXQoKTtcbiAgXHRcdFx0fVxuICBcdFx0fSwgdHJ1ZSk7XG4gIFx0fVxuXG4gIFx0Ly8gdHJpZ2dlciBpbnRybyB0cmFuc2l0aW9uXG4gIFx0aWYgKHJvb3QudHJhbnNpdGlvbnNFbmFibGVkICYmIHRoaXMuaW50cm8pIHtcbiAgXHRcdHRyYW5zaXRpb24gPSBuZXcgX1RyYW5zaXRpb24odGhpcywgdGhpcy5pbnRybywgdHJ1ZSk7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5yZWdpc3RlclRyYW5zaXRpb24odHJhbnNpdGlvbik7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gdHJhbnNpdGlvbi5zdGFydCgpO1xuICBcdFx0fSwgdHJ1ZSk7XG5cbiAgXHRcdHRoaXMudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMubm9kZS5hdXRvZm9jdXMpIHtcbiAgXHRcdC8vIFNwZWNpYWwgY2FzZS4gU29tZSBicm93c2VycyAoKmNvdWdoKiBGaXJlZml4ICpjb3VnaCopIGhhdmUgYSBwcm9ibGVtXG4gIFx0XHQvLyB3aXRoIGR5bmFtaWNhbGx5LWdlbmVyYXRlZCBlbGVtZW50cyBoYXZpbmcgYXV0b2ZvY3VzLCBhbmQgdGhleSB3b24ndFxuICBcdFx0Ly8gYWxsb3cgeW91IHRvIHByb2dyYW1tYXRpY2FsbHkgZm9jdXMgdGhlIGVsZW1lbnQgdW50aWwgaXQncyBpbiB0aGUgRE9NXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gX3RoaXMubm9kZS5mb2N1cygpO1xuICBcdFx0fSwgdHJ1ZSk7XG4gIFx0fVxuXG4gIFx0dXBkYXRlTGl2ZVF1ZXJpZXModGhpcyk7XG4gIFx0cmV0dXJuIHRoaXMubm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5hbWVzcGFjZShlbGVtZW50KSB7XG4gIFx0dmFyIG5hbWVzcGFjZSwgeG1sbnMsIHBhcmVudDtcblxuICBcdC8vIFVzZSBzcGVjaWZpZWQgbmFtZXNwYWNlLi4uXG4gIFx0aWYgKHhtbG5zID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ4bWxuc1wiKSkge1xuICBcdFx0bmFtZXNwYWNlID0geG1sbnM7XG4gIFx0fVxuXG4gIFx0Ly8gLi4ub3IgU1ZHIG5hbWVzcGFjZSwgaWYgdGhpcyBpcyBhbiA8c3ZnPiBlbGVtZW50XG4gIFx0ZWxzZSBpZiAoZWxlbWVudC5uYW1lID09PSBcInN2Z1wiKSB7XG4gIFx0XHRuYW1lc3BhY2UgPSBuYW1lc3BhY2VzLnN2ZztcbiAgXHR9IGVsc2UgaWYgKHBhcmVudCA9IGVsZW1lbnQucGFyZW50KSB7XG4gIFx0XHQvLyAuLi5vciBIVE1MLCBpZiB0aGUgcGFyZW50IGlzIGEgPGZvcmVpZ25PYmplY3Q+XG4gIFx0XHRpZiAocGFyZW50Lm5hbWUgPT09IFwiZm9yZWlnbk9iamVjdFwiKSB7XG4gIFx0XHRcdG5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuaHRtbDtcbiAgXHRcdH1cblxuICBcdFx0Ly8gLi4ub3IgaW5oZXJpdCBmcm9tIHRoZSBwYXJlbnQgbm9kZVxuICBcdFx0ZWxzZSB7XG4gIFx0XHRcdG5hbWVzcGFjZSA9IHBhcmVudC5ub2RlLm5hbWVzcGFjZVVSSTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0bmFtZXNwYWNlID0gZWxlbWVudC5yb290LmVsLm5hbWVzcGFjZVVSSTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbmFtZXNwYWNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc09wdGlvbihvcHRpb24pIHtcbiAgXHR2YXIgb3B0aW9uVmFsdWUsIHNlbGVjdFZhbHVlLCBpO1xuXG4gIFx0aWYgKCFvcHRpb24uc2VsZWN0KSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0c2VsZWN0VmFsdWUgPSBvcHRpb24uc2VsZWN0LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICBcdGlmIChzZWxlY3RWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cbiAgXHRpZiAob3B0aW9uLnNlbGVjdC5ub2RlLm11bHRpcGxlICYmIGlzQXJyYXkoc2VsZWN0VmFsdWUpKSB7XG4gIFx0XHRpID0gc2VsZWN0VmFsdWUubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRpZiAob3B0aW9uVmFsdWUgPT0gc2VsZWN0VmFsdWVbaV0pIHtcbiAgXHRcdFx0XHRvcHRpb24ubm9kZS5zZWxlY3RlZCA9IHRydWU7XG4gIFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0b3B0aW9uLm5vZGUuc2VsZWN0ZWQgPSBvcHRpb25WYWx1ZSA9PSBzZWxlY3RWYWx1ZTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaXZlUXVlcmllcyhlbGVtZW50KSB7XG4gIFx0dmFyIGluc3RhbmNlLCBsaXZlUXVlcmllcywgaSwgc2VsZWN0b3IsIHF1ZXJ5O1xuXG4gIFx0Ly8gRG9lcyB0aGlzIG5lZWQgdG8gYmUgYWRkZWQgdG8gYW55IGxpdmUgcXVlcmllcz9cbiAgXHRpbnN0YW5jZSA9IGVsZW1lbnQucm9vdDtcblxuICBcdGRvIHtcbiAgXHRcdGxpdmVRdWVyaWVzID0gaW5zdGFuY2UuX2xpdmVRdWVyaWVzO1xuXG4gIFx0XHRpID0gbGl2ZVF1ZXJpZXMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRzZWxlY3RvciA9IGxpdmVRdWVyaWVzW2ldO1xuICBcdFx0XHRxdWVyeSA9IGxpdmVRdWVyaWVzW1wiX1wiICsgc2VsZWN0b3JdO1xuXG4gIFx0XHRcdGlmIChxdWVyeS5fdGVzdChlbGVtZW50KSkge1xuICBcdFx0XHRcdC8vIGtlZXAgcmVnaXN0ZXIgb2YgYXBwbGljYWJsZSBzZWxlY3RvcnMsIGZvciB3aGVuIHdlIHRlYXJkb3duXG4gIFx0XHRcdFx0KGVsZW1lbnQubGl2ZVF1ZXJpZXMgfHwgKGVsZW1lbnQubGl2ZVF1ZXJpZXMgPSBbXSkpLnB1c2gocXVlcnkpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoaW5zdGFuY2UgPSBpbnN0YW5jZS5wYXJlbnQpO1xuICB9XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX3RvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICBcdHZhciBzdHIsIGVzY2FwZTtcblxuICBcdGlmICh0aGlzLnRlbXBsYXRlLnkpIHtcbiAgXHRcdC8vIERPQ1RZUEUgZGVjbGFyYXRpb25cbiAgXHRcdHJldHVybiBcIjwhRE9DVFlQRVwiICsgdGhpcy50ZW1wbGF0ZS5kZCArIFwiPlwiO1xuICBcdH1cblxuICBcdHN0ciA9IFwiPFwiICsgdGhpcy50ZW1wbGF0ZS5lO1xuXG4gIFx0c3RyICs9IHRoaXMuYXR0cmlidXRlcy5tYXAoc3RyaW5naWZ5QXR0cmlidXRlKS5qb2luKFwiXCIpICsgdGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMubWFwKHN0cmluZ2lmeUF0dHJpYnV0ZSkuam9pbihcIlwiKTtcblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHNlbGVjdGVkIG9wdGlvbnNcbiAgXHRpZiAodGhpcy5uYW1lID09PSBcIm9wdGlvblwiICYmIG9wdGlvbklzU2VsZWN0ZWQodGhpcykpIHtcbiAgXHRcdHN0ciArPSBcIiBzZWxlY3RlZFwiO1xuICBcdH1cblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHR3by13YXkgcmFkaW8gbmFtZSBiaW5kaW5nc1xuICBcdGlmICh0aGlzLm5hbWUgPT09IFwiaW5wdXRcIiAmJiBpbnB1dElzQ2hlY2tlZFJhZGlvKHRoaXMpKSB7XG4gIFx0XHRzdHIgKz0gXCIgY2hlY2tlZFwiO1xuICBcdH1cblxuICBcdHN0ciArPSBcIj5cIjtcblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHRleHRhcmVhXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICYmIHRoaXMuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0c3RyICs9IGVzY2FwZUh0bWwodGhpcy5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSk7XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gY29udGVudGVkaXRhYmxlXG4gIFx0ZWxzZSBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0c3RyICs9IHRoaXMuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgfHwgXCJcIjtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0ZXNjYXBlID0gdGhpcy5uYW1lICE9PSBcInNjcmlwdFwiICYmIHRoaXMubmFtZSAhPT0gXCJzdHlsZVwiO1xuICBcdFx0c3RyICs9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoZXNjYXBlKTtcbiAgXHR9XG5cbiAgXHQvLyBhZGQgYSBjbG9zaW5nIHRhZyBpZiB0aGlzIGlzbid0IGEgdm9pZCBlbGVtZW50XG4gIFx0aWYgKCF2b2lkRWxlbWVudE5hbWVzLnRlc3QodGhpcy50ZW1wbGF0ZS5lKSkge1xuICBcdFx0c3RyICs9IFwiPC9cIiArIHRoaXMudGVtcGxhdGUuZSArIFwiPlwiO1xuICBcdH1cblxuICBcdHJldHVybiBzdHI7XG4gIH07XG5cbiAgZnVuY3Rpb24gb3B0aW9uSXNTZWxlY3RlZChlbGVtZW50KSB7XG4gIFx0dmFyIG9wdGlvblZhbHVlLCBzZWxlY3RWYWx1ZSwgaTtcblxuICBcdG9wdGlvblZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcblxuICBcdGlmIChvcHRpb25WYWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICFlbGVtZW50LnNlbGVjdCkge1xuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH1cblxuICBcdHNlbGVjdFZhbHVlID0gZWxlbWVudC5zZWxlY3QuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cbiAgXHRpZiAoc2VsZWN0VmFsdWUgPT0gb3B0aW9uVmFsdWUpIHtcbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cblxuICBcdGlmIChlbGVtZW50LnNlbGVjdC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSAmJiBpc0FycmF5KHNlbGVjdFZhbHVlKSkge1xuICBcdFx0aSA9IHNlbGVjdFZhbHVlLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0aWYgKHNlbGVjdFZhbHVlW2ldID09IG9wdGlvblZhbHVlKSB7XG4gIFx0XHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBpbnB1dElzQ2hlY2tlZFJhZGlvKGVsZW1lbnQpIHtcbiAgXHR2YXIgYXR0cmlidXRlcywgdHlwZUF0dHJpYnV0ZSwgdmFsdWVBdHRyaWJ1dGUsIG5hbWVBdHRyaWJ1dGU7XG5cbiAgXHRhdHRyaWJ1dGVzID0gZWxlbWVudC5hdHRyaWJ1dGVzO1xuXG4gIFx0dHlwZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMudHlwZTtcbiAgXHR2YWx1ZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMudmFsdWU7XG4gIFx0bmFtZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMubmFtZTtcblxuICBcdGlmICghdHlwZUF0dHJpYnV0ZSB8fCB0eXBlQXR0cmlidXRlLnZhbHVlICE9PSBcInJhZGlvXCIgfHwgIXZhbHVlQXR0cmlidXRlIHx8ICFuYW1lQXR0cmlidXRlLmludGVycG9sYXRvcikge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGlmICh2YWx1ZUF0dHJpYnV0ZS52YWx1ZSA9PT0gbmFtZUF0dHJpYnV0ZS5pbnRlcnBvbGF0b3IudmFsdWUpIHtcbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeUF0dHJpYnV0ZShhdHRyaWJ1dGUpIHtcbiAgXHR2YXIgc3RyID0gYXR0cmlidXRlLnRvU3RyaW5nKCk7XG4gIFx0cmV0dXJuIHN0ciA/IFwiIFwiICsgc3RyIDogXCJcIjtcbiAgfVxuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV91bmJpbmQgPSBFbGVtZW50JHVuYmluZDtcbiAgZnVuY3Rpb24gRWxlbWVudCR1bmJpbmQoKSB7XG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuYmluZGluZykge1xuICBcdFx0dGhpcy5iaW5kaW5nLnVuYmluZCgpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmV2ZW50SGFuZGxlcnMpIHtcbiAgXHRcdHRoaXMuZXZlbnRIYW5kbGVycy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gPG9wdGlvbj5cbiAgXHRpZiAodGhpcy5uYW1lID09PSBcIm9wdGlvblwiKSB7XG4gIFx0XHRzcGVjaWFsX29wdGlvbl9fdW5iaW5kKHRoaXMpO1xuICBcdH1cblxuICBcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIFx0dGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuICB9XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX3VucmVuZGVyID0gRWxlbWVudCR1bnJlbmRlcjtcblxuICBmdW5jdGlvbiBFbGVtZW50JHVucmVuZGVyKHNob3VsZERlc3Ryb3kpIHtcbiAgXHR2YXIgYmluZGluZywgYmluZGluZ3MsIHRyYW5zaXRpb247XG5cbiAgXHRpZiAodHJhbnNpdGlvbiA9IHRoaXMudHJhbnNpdGlvbikge1xuICBcdFx0dHJhbnNpdGlvbi5jb21wbGV0ZSgpO1xuICBcdH1cblxuICBcdC8vIERldGFjaCBhcyBzb29uIGFzIHdlIGNhblxuICBcdGlmICh0aGlzLm5hbWUgPT09IFwib3B0aW9uXCIpIHtcbiAgXHRcdC8vIDxvcHRpb24+IGVsZW1lbnRzIGRldGFjaCBpbW1lZGlhdGVseSwgc28gdGhhdFxuICBcdFx0Ly8gdGhlaXIgcGFyZW50IDxzZWxlY3Q+IGVsZW1lbnQgc3luY3MgY29ycmVjdGx5LCBhbmRcbiAgXHRcdC8vIHNpbmNlIG9wdGlvbiBlbGVtZW50cyBjYW4ndCBoYXZlIHRyYW5zaXRpb25zIGFueXdheVxuICBcdFx0dGhpcy5kZXRhY2goKTtcbiAgXHR9IGVsc2UgaWYgKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLmRldGFjaFdoZW5SZWFkeSh0aGlzKTtcbiAgXHR9XG5cbiAgXHQvLyBDaGlsZHJlbiBmaXJzdC4gdGhhdCB3YXksIGFueSB0cmFuc2l0aW9ucyBvbiBjaGlsZCBlbGVtZW50cyB3aWxsIGJlXG4gIFx0Ly8gaGFuZGxlZCBieSB0aGUgY3VycmVudCB0cmFuc2l0aW9uTWFuYWdlclxuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyKGZhbHNlKTtcbiAgXHR9XG5cbiAgXHRpZiAoYmluZGluZyA9IHRoaXMuYmluZGluZykge1xuICBcdFx0dGhpcy5iaW5kaW5nLnVucmVuZGVyKCk7XG5cbiAgXHRcdHRoaXMubm9kZS5fcmFjdGl2ZS5iaW5kaW5nID0gbnVsbDtcbiAgXHRcdGJpbmRpbmdzID0gdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1tiaW5kaW5nLmtleXBhdGguc3RyXTtcbiAgXHRcdGJpbmRpbmdzLnNwbGljZShiaW5kaW5ncy5pbmRleE9mKGJpbmRpbmcpLCAxKTtcbiAgXHR9XG5cbiAgXHQvLyBSZW1vdmUgZXZlbnQgaGFuZGxlcnNcbiAgXHRpZiAodGhpcy5ldmVudEhhbmRsZXJzKSB7XG4gIFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bnJlbmRlcik7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZGVjb3JhdG9yKSB7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5yZWdpc3RlckRlY29yYXRvcih0aGlzLmRlY29yYXRvcik7XG4gIFx0fVxuXG4gIFx0Ly8gdHJpZ2dlciBvdXRybyB0cmFuc2l0aW9uIGlmIG5lY2Vzc2FyeVxuICBcdGlmICh0aGlzLnJvb3QudHJhbnNpdGlvbnNFbmFibGVkICYmIHRoaXMub3V0cm8pIHtcbiAgXHRcdHRyYW5zaXRpb24gPSBuZXcgX1RyYW5zaXRpb24odGhpcywgdGhpcy5vdXRybywgZmFsc2UpO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3AucmVnaXN0ZXJUcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuIHRyYW5zaXRpb24uc3RhcnQoKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdC8vIFJlbW92ZSB0aGlzIG5vZGUgZnJvbSBhbnkgbGl2ZSBxdWVyaWVzXG4gIFx0aWYgKHRoaXMubGl2ZVF1ZXJpZXMpIHtcbiAgXHRcdHJlbW92ZUZyb21MaXZlUXVlcmllcyh0aGlzKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5uYW1lID09PSBcImZvcm1cIikge1xuICBcdFx0Zm9ybV9fdW5yZW5kZXIodGhpcyk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRnJvbUxpdmVRdWVyaWVzKGVsZW1lbnQpIHtcbiAgXHR2YXIgcXVlcnksIHNlbGVjdG9yLCBpO1xuXG4gIFx0aSA9IGVsZW1lbnQubGl2ZVF1ZXJpZXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdHF1ZXJ5ID0gZWxlbWVudC5saXZlUXVlcmllc1tpXTtcbiAgXHRcdHNlbGVjdG9yID0gcXVlcnkuc2VsZWN0b3I7XG5cbiAgXHRcdHF1ZXJ5Ll9yZW1vdmUoZWxlbWVudC5ub2RlKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgRWxlbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy5pbml0KG9wdGlvbnMpO1xuICB9O1xuXG4gIEVsZW1lbnQucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogRWxlbWVudF9wcm90b3R5cGVfYnViYmxlLFxuICBcdGRldGFjaDogRWxlbWVudF9wcm90b3R5cGVfZGV0YWNoLFxuICBcdGZpbmQ6IEVsZW1lbnRfcHJvdG90eXBlX2ZpbmQsXG4gIFx0ZmluZEFsbDogRWxlbWVudF9wcm90b3R5cGVfZmluZEFsbCxcbiAgXHRmaW5kQWxsQ29tcG9uZW50czogRWxlbWVudF9wcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMsXG4gIFx0ZmluZENvbXBvbmVudDogRWxlbWVudF9wcm90b3R5cGVfZmluZENvbXBvbmVudCxcbiAgXHRmaW5kTmV4dE5vZGU6IEVsZW1lbnRfcHJvdG90eXBlX2ZpbmROZXh0Tm9kZSxcbiAgXHRmaXJzdE5vZGU6IEVsZW1lbnRfcHJvdG90eXBlX2ZpcnN0Tm9kZSxcbiAgXHRnZXRBdHRyaWJ1dGU6IGdldEF0dHJpYnV0ZSxcbiAgXHRpbml0OiBFbGVtZW50X3Byb3RvdHlwZV9pbml0LFxuICBcdHJlYmluZDogRWxlbWVudF9wcm90b3R5cGVfcmViaW5kLFxuICBcdHJlbmRlcjogRWxlbWVudF9wcm90b3R5cGVfcmVuZGVyLFxuICBcdHRvU3RyaW5nOiBFbGVtZW50X3Byb3RvdHlwZV90b1N0cmluZyxcbiAgXHR1bmJpbmQ6IEVsZW1lbnRfcHJvdG90eXBlX3VuYmluZCxcbiAgXHR1bnJlbmRlcjogRWxlbWVudF9wcm90b3R5cGVfdW5yZW5kZXJcbiAgfTtcblxuICB2YXIgX0VsZW1lbnQgPSBFbGVtZW50O1xuXG4gIHZhciBkZUluZGVudF9fZW1wdHkgPSAvXlxccyokLyxcbiAgICAgIGRlSW5kZW50X19sZWFkaW5nV2hpdGVzcGFjZSA9IC9eXFxzKi87XG5cbiAgdmFyIGRlSW5kZW50ID0gZnVuY3Rpb24gKHN0cikge1xuICBcdHZhciBsaW5lcywgZmlyc3RMaW5lLCBsYXN0TGluZSwgbWluSW5kZW50O1xuXG4gIFx0bGluZXMgPSBzdHIuc3BsaXQoXCJcXG5cIik7XG5cbiAgXHQvLyByZW1vdmUgZmlyc3QgYW5kIGxhc3QgbGluZSwgaWYgdGhleSBvbmx5IGNvbnRhaW4gd2hpdGVzcGFjZVxuICBcdGZpcnN0TGluZSA9IGxpbmVzWzBdO1xuICBcdGlmIChmaXJzdExpbmUgIT09IHVuZGVmaW5lZCAmJiBkZUluZGVudF9fZW1wdHkudGVzdChmaXJzdExpbmUpKSB7XG4gIFx0XHRsaW5lcy5zaGlmdCgpO1xuICBcdH1cblxuICBcdGxhc3RMaW5lID0gbGFzdEl0ZW0obGluZXMpO1xuICBcdGlmIChsYXN0TGluZSAhPT0gdW5kZWZpbmVkICYmIGRlSW5kZW50X19lbXB0eS50ZXN0KGxhc3RMaW5lKSkge1xuICBcdFx0bGluZXMucG9wKCk7XG4gIFx0fVxuXG4gIFx0bWluSW5kZW50ID0gbGluZXMucmVkdWNlKHJlZHVjZXIsIG51bGwpO1xuXG4gIFx0aWYgKG1pbkluZGVudCkge1xuICBcdFx0c3RyID0gbGluZXMubWFwKGZ1bmN0aW9uIChsaW5lKSB7XG4gIFx0XHRcdHJldHVybiBsaW5lLnJlcGxhY2UobWluSW5kZW50LCBcIlwiKTtcbiAgXHRcdH0pLmpvaW4oXCJcXG5cIik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHN0cjtcbiAgfTtcblxuICBmdW5jdGlvbiByZWR1Y2VyKHByZXZpb3VzLCBsaW5lKSB7XG4gIFx0dmFyIGxpbmVJbmRlbnQgPSBkZUluZGVudF9fbGVhZGluZ1doaXRlc3BhY2UuZXhlYyhsaW5lKVswXTtcblxuICBcdGlmIChwcmV2aW91cyA9PT0gbnVsbCB8fCBsaW5lSW5kZW50Lmxlbmd0aCA8IHByZXZpb3VzLmxlbmd0aCkge1xuICBcdFx0cmV0dXJuIGxpbmVJbmRlbnQ7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHByZXZpb3VzO1xuICB9XG5cbiAgdmFyIFBhcnRpYWxfZ2V0UGFydGlhbFRlbXBsYXRlID0gZ2V0UGFydGlhbFRlbXBsYXRlO1xuXG4gIGZ1bmN0aW9uIGdldFBhcnRpYWxUZW1wbGF0ZShyYWN0aXZlLCBuYW1lLCBwYXJlbnRGcmFnbWVudCkge1xuICBcdHZhciBwYXJ0aWFsO1xuXG4gIFx0Ly8gSWYgdGhlIHBhcnRpYWwgaW4gaW5zdGFuY2Ugb3IgdmlldyBoZWlyYXJjaHkgaW5zdGFuY2VzLCBncmVhdFxuICBcdGlmIChwYXJ0aWFsID0gZ2V0UGFydGlhbEZyb21SZWdpc3RyeShyYWN0aXZlLCBuYW1lLCBwYXJlbnRGcmFnbWVudCB8fCB7fSkpIHtcbiAgXHRcdHJldHVybiBwYXJ0aWFsO1xuICBcdH1cblxuICBcdC8vIERvZXMgaXQgZXhpc3Qgb24gdGhlIHBhZ2UgYXMgYSBzY3JpcHQgdGFnP1xuICBcdHBhcnRpYWwgPSB0ZW1wbGF0ZV9wYXJzZXIuZnJvbUlkKG5hbWUsIHsgbm9UaHJvdzogdHJ1ZSB9KTtcblxuICBcdGlmIChwYXJ0aWFsKSB7XG4gIFx0XHQvLyBpcyB0aGlzIG5lY2Vzc2FyeT9cbiAgXHRcdHBhcnRpYWwgPSBkZUluZGVudChwYXJ0aWFsKTtcblxuICBcdFx0Ly8gcGFyc2UgYW5kIHJlZ2lzdGVyIHRvIHRoaXMgcmFjdGl2ZSBpbnN0YW5jZVxuICBcdFx0dmFyIHBhcnNlZCA9IHRlbXBsYXRlX3BhcnNlci5wYXJzZShwYXJ0aWFsLCB0ZW1wbGF0ZV9wYXJzZXIuZ2V0UGFyc2VPcHRpb25zKHJhY3RpdmUpKTtcblxuICBcdFx0Ly8gcmVnaXN0ZXIgKGFuZCByZXR1cm4gbWFpbiBwYXJ0aWFsIGlmIHRoZXJlIGFyZSBvdGhlcnMgaW4gdGhlIHRlbXBsYXRlKVxuICBcdFx0cmV0dXJuIHJhY3RpdmUucGFydGlhbHNbbmFtZV0gPSBwYXJzZWQudDtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXJ0aWFsRnJvbVJlZ2lzdHJ5KHJhY3RpdmUsIG5hbWUsIHBhcmVudEZyYWdtZW50KSB7XG4gIFx0dmFyIGZuID0gdW5kZWZpbmVkLFxuICBcdCAgICBwYXJ0aWFsID0gZmluZFBhcmVudFBhcnRpYWwobmFtZSwgcGFyZW50RnJhZ21lbnQub3duZXIpO1xuXG4gIFx0Ly8gaWYgdGhlcmUgd2FzIGFuIGluc3RhbmNlIHVwLWhpZXJhcmNoeSwgY29vbFxuICBcdGlmIChwYXJ0aWFsKSByZXR1cm4gcGFydGlhbDtcblxuICBcdC8vIGZpbmQgZmlyc3QgaW5zdGFuY2UgaW4gdGhlIHJhY3RpdmUgb3IgdmlldyBoaWVyYXJjaHkgdGhhdCBoYXMgdGhpcyBwYXJ0aWFsXG4gIFx0dmFyIGluc3RhbmNlID0gZmluZEluc3RhbmNlKFwicGFydGlhbHNcIiwgcmFjdGl2ZSwgbmFtZSk7XG5cbiAgXHRpZiAoIWluc3RhbmNlKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0cGFydGlhbCA9IGluc3RhbmNlLnBhcnRpYWxzW25hbWVdO1xuXG4gIFx0Ly8gcGFydGlhbCBpcyBhIGZ1bmN0aW9uP1xuICBcdGlmICh0eXBlb2YgcGFydGlhbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRmbiA9IHBhcnRpYWwuYmluZChpbnN0YW5jZSk7XG4gIFx0XHRmbi5pc093bmVyID0gaW5zdGFuY2UucGFydGlhbHMuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIFx0XHRwYXJ0aWFsID0gZm4uY2FsbChyYWN0aXZlLCB0ZW1wbGF0ZV9wYXJzZXIpO1xuICBcdH1cblxuICBcdGlmICghcGFydGlhbCAmJiBwYXJ0aWFsICE9PSBcIlwiKSB7XG4gIFx0XHR3YXJuSWZEZWJ1Zyhub1JlZ2lzdHJ5RnVuY3Rpb25SZXR1cm4sIG5hbWUsIFwicGFydGlhbFwiLCBcInBhcnRpYWxcIiwgeyByYWN0aXZlOiByYWN0aXZlIH0pO1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIElmIHRoaXMgd2FzIGFkZGVkIG1hbnVhbGx5IHRvIHRoZSByZWdpc3RyeSxcbiAgXHQvLyBidXQgaGFzbid0IGJlZW4gcGFyc2VkLCBwYXJzZSBpdCBub3dcbiAgXHRpZiAoIXRlbXBsYXRlX3BhcnNlci5pc1BhcnNlZChwYXJ0aWFsKSkge1xuXG4gIFx0XHQvLyB1c2UgdGhlIHBhcnNlT3B0aW9ucyBvZiB0aGUgcmFjdGl2ZSBpbnN0YW5jZSBvbiB3aGljaCBpdCB3YXMgZm91bmRcbiAgXHRcdHZhciBwYXJzZWQgPSB0ZW1wbGF0ZV9wYXJzZXIucGFyc2UocGFydGlhbCwgdGVtcGxhdGVfcGFyc2VyLmdldFBhcnNlT3B0aW9ucyhpbnN0YW5jZSkpO1xuXG4gIFx0XHQvLyBQYXJ0aWFscyBjYW5ub3QgY29udGFpbiBuZXN0ZWQgcGFydGlhbHMhXG4gIFx0XHQvLyBUT0RPIGFkZCBhIHRlc3QgZm9yIHRoaXNcbiAgXHRcdGlmIChwYXJzZWQucCkge1xuICBcdFx0XHR3YXJuSWZEZWJ1ZyhcIlBhcnRpYWxzICh7ez4lc319KSBjYW5ub3QgY29udGFpbiBuZXN0ZWQgaW5saW5lIHBhcnRpYWxzXCIsIG5hbWUsIHsgcmFjdGl2ZTogcmFjdGl2ZSB9KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gaWYgZm4sIHVzZSBpbnN0YW5jZSB0byBzdG9yZSByZXN1bHQsIG90aGVyd2lzZSBuZWVkcyB0byBnb1xuICBcdFx0Ly8gaW4gdGhlIGNvcnJlY3QgcG9pbnQgaW4gcHJvdG90eXBlIGNoYWluIG9uIGluc3RhbmNlIG9yIGNvbnN0cnVjdG9yXG4gIFx0XHR2YXIgdGFyZ2V0ID0gZm4gPyBpbnN0YW5jZSA6IGZpbmRPd25lcihpbnN0YW5jZSwgbmFtZSk7XG5cbiAgXHRcdC8vIG1heSBiZSBhIHRlbXBsYXRlIHdpdGggcGFydGlhbHMsIHdoaWNoIG5lZWQgdG8gYmUgcmVnaXN0ZXJlZCBhbmQgbWFpbiB0ZW1wbGF0ZSBleHRyYWN0ZWRcbiAgXHRcdHRhcmdldC5wYXJ0aWFsc1tuYW1lXSA9IHBhcnRpYWwgPSBwYXJzZWQudDtcbiAgXHR9XG5cbiAgXHQvLyBzdG9yZSBmb3IgcmVzZXRcbiAgXHRpZiAoZm4pIHtcbiAgXHRcdHBhcnRpYWwuX2ZuID0gZm47XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHBhcnRpYWwudiA/IHBhcnRpYWwudCA6IHBhcnRpYWw7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kT3duZXIocmFjdGl2ZSwga2V5KSB7XG4gIFx0cmV0dXJuIHJhY3RpdmUucGFydGlhbHMuaGFzT3duUHJvcGVydHkoa2V5KSA/IHJhY3RpdmUgOiBmaW5kQ29uc3RydWN0b3IocmFjdGl2ZS5jb25zdHJ1Y3Rvciwga2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRDb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvciwga2V5KSB7XG4gIFx0aWYgKCFjb25zdHJ1Y3Rvcikge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cbiAgXHRyZXR1cm4gY29uc3RydWN0b3IucGFydGlhbHMuaGFzT3duUHJvcGVydHkoa2V5KSA/IGNvbnN0cnVjdG9yIDogZmluZENvbnN0cnVjdG9yKGNvbnN0cnVjdG9yLl9QYXJlbnQsIGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kUGFyZW50UGFydGlhbChuYW1lLCBwYXJlbnQpIHtcbiAgXHRpZiAocGFyZW50KSB7XG4gIFx0XHRpZiAocGFyZW50LnRlbXBsYXRlICYmIHBhcmVudC50ZW1wbGF0ZS5wICYmIHBhcmVudC50ZW1wbGF0ZS5wW25hbWVdKSB7XG4gIFx0XHRcdHJldHVybiBwYXJlbnQudGVtcGxhdGUucFtuYW1lXTtcbiAgXHRcdH0gZWxzZSBpZiAocGFyZW50LnBhcmVudEZyYWdtZW50ICYmIHBhcmVudC5wYXJlbnRGcmFnbWVudC5vd25lcikge1xuICBcdFx0XHRyZXR1cm4gZmluZFBhcmVudFBhcnRpYWwobmFtZSwgcGFyZW50LnBhcmVudEZyYWdtZW50Lm93bmVyKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgYXBwbHlJbmRlbnQgPSBmdW5jdGlvbiAoc3RyaW5nLCBpbmRlbnQpIHtcbiAgXHR2YXIgaW5kZW50ZWQ7XG5cbiAgXHRpZiAoIWluZGVudCkge1xuICBcdFx0cmV0dXJuIHN0cmluZztcbiAgXHR9XG5cbiAgXHRpbmRlbnRlZCA9IHN0cmluZy5zcGxpdChcIlxcblwiKS5tYXAoZnVuY3Rpb24gKGxpbmUsIG5vdEZpcnN0TGluZSkge1xuICBcdFx0cmV0dXJuIG5vdEZpcnN0TGluZSA/IGluZGVudCArIGxpbmUgOiBsaW5lO1xuICBcdH0pLmpvaW4oXCJcXG5cIik7XG5cbiAgXHRyZXR1cm4gaW5kZW50ZWQ7XG4gIH07XG5cbiAgdmFyIG1pc3NpbmdQYXJ0aWFsTWVzc2FnZSA9IFwiQ291bGQgbm90IGZpbmQgdGVtcGxhdGUgZm9yIHBhcnRpYWwgXFxcIiVzXFxcIlwiO1xuXG4gIHZhciBQYXJ0aWFsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR2YXIgcGFyZW50RnJhZ21lbnQsIHRlbXBsYXRlO1xuXG4gIFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcblxuICBcdHRoaXMucm9vdCA9IHBhcmVudEZyYWdtZW50LnJvb3Q7XG4gIFx0dGhpcy50eXBlID0gUEFSVElBTDtcbiAgXHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcbiAgXHR0aGlzLm5hbWUgPSBvcHRpb25zLnRlbXBsYXRlLnI7XG4gIFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuXG4gIFx0dGhpcy5mcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRUb1JlbmRlciA9IHRoaXMuZnJhZ21lbnRUb1VucmVuZGVyID0gbnVsbDtcblxuICBcdE11c3RhY2hlLmluaXQodGhpcywgb3B0aW9ucyk7XG5cbiAgXHQvLyBJZiB0aGlzIGRpZG4ndCByZXNvbHZlLCBpdCBtb3N0IGxpa2VseSBtZWFucyB3ZSBoYXZlIGEgbmFtZWQgcGFydGlhbFxuICBcdC8vIChpLmUuIGB7ez5mb299fWAgbWVhbnMgJ3VzZSB0aGUgZm9vIHBhcnRpYWwnLCBub3QgJ3VzZSB0aGUgcGFydGlhbFxuICBcdC8vIHdob3NlIG5hbWUgaXMgdGhlIHZhbHVlIG9mIGBmb29gJylcbiAgXHRpZiAoIXRoaXMua2V5cGF0aCkge1xuICBcdFx0aWYgKHRlbXBsYXRlID0gUGFydGlhbF9nZXRQYXJ0aWFsVGVtcGxhdGUodGhpcy5yb290LCB0aGlzLm5hbWUsIHBhcmVudEZyYWdtZW50KSkge1xuICBcdFx0XHRzaGFyZWRfdW5iaW5kLmNhbGwodGhpcyk7IC8vIHByZXZlbnQgYW55IGZ1cnRoZXIgY2hhbmdlc1xuICBcdFx0XHR0aGlzLmlzTmFtZWQgPSB0cnVlO1xuICBcdFx0XHR0aGlzLnNldFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyhtaXNzaW5nUGFydGlhbE1lc3NhZ2UsIHRoaXMubmFtZSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIFBhcnRpYWwucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcbiAgXHR9LFxuXG4gIFx0ZGV0YWNoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5kZXRhY2goKTtcbiAgXHR9LFxuXG4gIFx0ZmluZDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kKHNlbGVjdG9yKTtcbiAgXHR9LFxuXG4gIFx0ZmluZEFsbDogZnVuY3Rpb24gKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZEFsbChzZWxlY3RvciwgcXVlcnkpO1xuICBcdH0sXG5cbiAgXHRmaW5kQ29tcG9uZW50OiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRDb21wb25lbnQoc2VsZWN0b3IpO1xuICBcdH0sXG5cbiAgXHRmaW5kQWxsQ29tcG9uZW50czogZnVuY3Rpb24gKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9LFxuXG4gIFx0Zmlyc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maXJzdE5vZGUoKTtcbiAgXHR9LFxuXG4gIFx0ZmluZE5leHROb2RlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUodGhpcyk7XG4gIFx0fSxcblxuICBcdGdldFBhcnRpYWxOYW1lOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5pc05hbWVkICYmIHRoaXMubmFtZSkgcmV0dXJuIHRoaXMubmFtZTtlbHNlIGlmICh0aGlzLnZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLm5hbWU7ZWxzZSByZXR1cm4gdGhpcy52YWx1ZTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCk7XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdC8vIG5hbWVkIHBhcnRpYWxzIGFyZW4ndCBib3VuZCwgc28gZG9uJ3QgcmViaW5kXG4gIFx0XHRpZiAoIXRoaXMuaXNOYW1lZCkge1xuICBcdFx0XHRNdXN0YWNoZV9yZWJpbmQuY2FsbCh0aGlzLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5kb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBcdFx0dGhpcy51cGRhdGUoKTtcblxuICBcdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gIFx0XHRyZXR1cm4gdGhpcy5kb2NGcmFnO1xuICBcdH0sXG5cbiAgXHRyZXNvbHZlOiBNdXN0YWNoZS5yZXNvbHZlLFxuXG4gIFx0c2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0dmFyIHRlbXBsYXRlO1xuXG4gIFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA9PT0gdGhpcy52YWx1ZSkge1xuICBcdFx0XHQvLyBub3RoaW5nIGhhcyBjaGFuZ2VkLCBzbyBubyB3b3JrIHRvIGJlIGRvbmVcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0ZW1wbGF0ZSA9IFBhcnRpYWxfZ2V0UGFydGlhbFRlbXBsYXRlKHRoaXMucm9vdCwgXCJcIiArIHZhbHVlLCB0aGlzLnBhcmVudEZyYWdtZW50KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gd2UgbWF5IGJlIGhlcmUgaWYgd2UgaGF2ZSBhIHBhcnRpYWwgbGlrZSBge3s+Zm9vfX1gIGFuZCBgZm9vYCBpcyB0aGVcbiAgXHRcdC8vIG5hbWUgb2YgYm90aCBhIGRhdGEgcHJvcGVydHkgKHdob3NlIHZhbHVlIElTTidUIHRoZSBuYW1lIG9mIGEgcGFydGlhbClcbiAgXHRcdC8vIGFuZCBhIHBhcnRpYWwuIEluIHRob3NlIGNhc2VzLCB0aGlzIGJlY29tZXMgYSBuYW1lZCBwYXJ0aWFsXG4gIFx0XHRpZiAoIXRlbXBsYXRlICYmIHRoaXMubmFtZSAmJiAodGVtcGxhdGUgPSBQYXJ0aWFsX2dldFBhcnRpYWxUZW1wbGF0ZSh0aGlzLnJvb3QsIHRoaXMubmFtZSwgdGhpcy5wYXJlbnRGcmFnbWVudCkpKSB7XG4gIFx0XHRcdHNoYXJlZF91bmJpbmQuY2FsbCh0aGlzKTtcbiAgXHRcdFx0dGhpcy5pc05hbWVkID0gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCF0ZW1wbGF0ZSkge1xuICBcdFx0XHR3YXJuT25jZUlmRGVidWcobWlzc2luZ1BhcnRpYWxNZXNzYWdlLCB0aGlzLm5hbWUsIHsgcmFjdGl2ZTogdGhpcy5yb290IH0pO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cbiAgXHRcdHRoaXMuc2V0VGVtcGxhdGUodGVtcGxhdGUgfHwgW10pO1xuXG4gIFx0XHR0aGlzLmJ1YmJsZSgpO1xuXG4gIFx0XHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRWaWV3KHRoaXMpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRzZXRUZW1wbGF0ZTogZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gIFx0XHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdFx0XHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0XHRcdHRoaXMuZnJhZ21lbnRUb1VucmVuZGVyID0gdGhpcy5mcmFnbWVudDtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gIFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcbiAgXHRcdFx0b3duZXI6IHRoaXMsXG4gIFx0XHRcdHBFbGVtZW50OiB0aGlzLnBhcmVudEZyYWdtZW50LnBFbGVtZW50XG4gIFx0XHR9KTtcblxuICBcdFx0dGhpcy5mcmFnbWVudFRvUmVuZGVyID0gdGhpcy5mcmFnbWVudDtcbiAgXHR9LFxuXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uICh0b1N0cmluZykge1xuICBcdFx0dmFyIHN0cmluZywgcHJldmlvdXNJdGVtLCBsYXN0TGluZSwgbWF0Y2g7XG5cbiAgXHRcdHN0cmluZyA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcodG9TdHJpbmcpO1xuXG4gIFx0XHRwcmV2aW91c0l0ZW0gPSB0aGlzLnBhcmVudEZyYWdtZW50Lml0ZW1zW3RoaXMuaW5kZXggLSAxXTtcblxuICBcdFx0aWYgKCFwcmV2aW91c0l0ZW0gfHwgcHJldmlvdXNJdGVtLnR5cGUgIT09IFRFWFQpIHtcbiAgXHRcdFx0cmV0dXJuIHN0cmluZztcbiAgXHRcdH1cblxuICBcdFx0bGFzdExpbmUgPSBwcmV2aW91c0l0ZW0udGV4dC5zcGxpdChcIlxcblwiKS5wb3AoKTtcblxuICBcdFx0aWYgKG1hdGNoID0gL15cXHMrJC8uZXhlYyhsYXN0TGluZSkpIHtcbiAgXHRcdFx0cmV0dXJuIGFwcGx5SW5kZW50KHN0cmluZywgbWF0Y2hbMF0pO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gc3RyaW5nO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5pc05hbWVkKSB7XG4gIFx0XHRcdC8vIGR5bmFtaWMgcGFydGlhbCAtIG5lZWQgdG8gdW5iaW5kIHNlbGZcbiAgXHRcdFx0c2hhcmVkX3VuYmluZC5jYWxsKHRoaXMpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlcihzaG91bGREZXN0cm95KTtcbiAgXHRcdFx0fVxuICBcdFx0XHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHRhcmdldCwgYW5jaG9yO1xuXG4gIFx0XHRpZiAodGhpcy5mcmFnbWVudFRvVW5yZW5kZXIpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudFRvVW5yZW5kZXIudW5yZW5kZXIodHJ1ZSk7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnRUb1VucmVuZGVyID0gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMuZnJhZ21lbnRUb1JlbmRlcikge1xuICBcdFx0XHR0aGlzLmRvY0ZyYWcuYXBwZW5kQ2hpbGQodGhpcy5mcmFnbWVudFRvUmVuZGVyLnJlbmRlcigpKTtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudFRvUmVuZGVyID0gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdFx0dGFyZ2V0ID0gdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCk7XG4gIFx0XHRcdGFuY2hvciA9IHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICBcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHRoaXMuZG9jRnJhZywgYW5jaG9yKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIF9QYXJ0aWFsID0gUGFydGlhbDtcblxuICAvLyBmaW5kcyB0aGUgY29tcG9uZW50IGNvbnN0cnVjdG9yIGluIHRoZSByZWdpc3RyeSBvciB2aWV3IGhpZXJhcmNoeSByZWdpc3RyaWVzXG5cbiAgdmFyIENvbXBvbmVudF9nZXRDb21wb25lbnQgPSBnZXRDb21wb25lbnQ7XG4gIGZ1bmN0aW9uIGdldENvbXBvbmVudChyYWN0aXZlLCBuYW1lKSB7XG5cbiAgXHR2YXIgQ29tcG9uZW50LFxuICBcdCAgICBpbnN0YW5jZSA9IGZpbmRJbnN0YW5jZShcImNvbXBvbmVudHNcIiwgcmFjdGl2ZSwgbmFtZSk7XG5cbiAgXHRpZiAoaW5zdGFuY2UpIHtcbiAgXHRcdENvbXBvbmVudCA9IGluc3RhbmNlLmNvbXBvbmVudHNbbmFtZV07XG5cbiAgXHRcdC8vIGJlc3QgdGVzdCB3ZSBoYXZlIGZvciBub3QgUmFjdGl2ZS5leHRlbmRcbiAgXHRcdGlmICghQ29tcG9uZW50Ll9QYXJlbnQpIHtcbiAgXHRcdFx0Ly8gZnVuY3Rpb24gb3B0aW9uLCBleGVjdXRlIGFuZCBzdG9yZSBmb3IgcmVzZXRcbiAgXHRcdFx0dmFyIGZuID0gQ29tcG9uZW50LmJpbmQoaW5zdGFuY2UpO1xuICBcdFx0XHRmbi5pc093bmVyID0gaW5zdGFuY2UuY29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgXHRcdFx0Q29tcG9uZW50ID0gZm4oKTtcblxuICBcdFx0XHRpZiAoIUNvbXBvbmVudCkge1xuICBcdFx0XHRcdHdhcm5JZkRlYnVnKG5vUmVnaXN0cnlGdW5jdGlvblJldHVybiwgbmFtZSwgXCJjb21wb25lbnRcIiwgXCJjb21wb25lbnRcIiwgeyByYWN0aXZlOiByYWN0aXZlIH0pO1xuXG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKHR5cGVvZiBDb21wb25lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0XHQvLyBhbGxvdyBzdHJpbmcgbG9va3VwXG4gIFx0XHRcdFx0Q29tcG9uZW50ID0gZ2V0Q29tcG9uZW50KHJhY3RpdmUsIENvbXBvbmVudCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRDb21wb25lbnQuX2ZuID0gZm47XG4gIFx0XHRcdGluc3RhbmNlLmNvbXBvbmVudHNbbmFtZV0gPSBDb21wb25lbnQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIENvbXBvbmVudDtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2RldGFjaCA9IENvbXBvbmVudCRkZXRhY2g7XG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2RldGFjaF9fZGV0YWNoSG9vayA9IG5ldyBob29rc19Ib29rKFwiZGV0YWNoXCIpO1xuICBmdW5jdGlvbiBDb21wb25lbnQkZGV0YWNoKCkge1xuICBcdHZhciBkZXRhY2hlZCA9IHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZGV0YWNoKCk7XG4gIFx0Q29tcG9uZW50X3Byb3RvdHlwZV9kZXRhY2hfX2RldGFjaEhvb2suZmlyZSh0aGlzLmluc3RhbmNlKTtcbiAgXHRyZXR1cm4gZGV0YWNoZWQ7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kID0gQ29tcG9uZW50JGZpbmQ7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JGZpbmQoc2VsZWN0b3IpIHtcbiAgXHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kKHNlbGVjdG9yKTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmRBbGwgPSBDb21wb25lbnQkZmluZEFsbDtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkZmluZEFsbChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kQWxsKHNlbGVjdG9yLCBxdWVyeSk7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kQWxsQ29tcG9uZW50cyA9IENvbXBvbmVudCRmaW5kQWxsQ29tcG9uZW50cztcblxuICBmdW5jdGlvbiBDb21wb25lbnQkZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0cXVlcnkuX3Rlc3QodGhpcywgdHJ1ZSk7XG5cbiAgXHRpZiAodGhpcy5pbnN0YW5jZS5mcmFnbWVudCkge1xuICBcdFx0dGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmRDb21wb25lbnQgPSBDb21wb25lbnQkZmluZENvbXBvbmVudDtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkZmluZENvbXBvbmVudChzZWxlY3Rvcikge1xuICBcdGlmICghc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IHRoaXMubmFtZSkge1xuICBcdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQpIHtcbiAgXHRcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpbmRDb21wb25lbnQoc2VsZWN0b3IpO1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfZmluZE5leHROb2RlID0gQ29tcG9uZW50JGZpbmROZXh0Tm9kZTtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkZmluZE5leHROb2RlKCkge1xuICBcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2ZpcnN0Tm9kZSA9IENvbXBvbmVudCRmaXJzdE5vZGU7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JGZpcnN0Tm9kZSgpIHtcbiAgXHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmlyc3ROb2RlKCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcHJvY2Vzc1dyYXBwZXIgPSBmdW5jdGlvbiAod3JhcHBlciwgYXJyYXksIG1ldGhvZE5hbWUsIG5ld0luZGljZXMpIHtcbiAgXHR2YXIgcm9vdCA9IHdyYXBwZXIucm9vdDtcbiAgXHR2YXIga2V5cGF0aCA9IHdyYXBwZXIua2V5cGF0aDtcblxuICBcdGlmICghIW5ld0luZGljZXMpIHtcbiAgXHRcdHJvb3Qudmlld21vZGVsLnNtYXJ0VXBkYXRlKGtleXBhdGgsIGFycmF5LCBuZXdJbmRpY2VzKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0Ly8gSWYgdGhpcyBpcyBhIHNvcnQgb3IgcmV2ZXJzZSwgd2UganVzdCBkbyByb290LnNldCgpLi4uXG4gIFx0XHQvLyBUT0RPIHVzZSBtZXJnZSBsb2dpYz9cbiAgXHRcdHJvb3Qudmlld21vZGVsLm1hcmsoa2V5cGF0aCk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBwYXRjaGVkQXJyYXlQcm90byA9IFtdLFxuICAgICAgbXV0YXRvck1ldGhvZHMgPSBbXCJwb3BcIiwgXCJwdXNoXCIsIFwicmV2ZXJzZVwiLCBcInNoaWZ0XCIsIFwic29ydFwiLCBcInNwbGljZVwiLCBcInVuc2hpZnRcIl0sXG4gICAgICB0ZXN0T2JqLFxuICAgICAgcGF0Y2hBcnJheU1ldGhvZHMsXG4gICAgICB1bnBhdGNoQXJyYXlNZXRob2RzO1xuXG4gIG11dGF0b3JNZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgXHR2YXIgbWV0aG9kID0gZnVuY3Rpb24gKCkge1xuICBcdFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgXHRcdFx0YXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIG5ld0luZGljZXMsIHJlc3VsdCwgd3JhcHBlciwgaTtcblxuICBcdFx0bmV3SW5kaWNlcyA9IHNoYXJlZF9nZXROZXdJbmRpY2VzKHRoaXMsIG1ldGhvZE5hbWUsIGFyZ3MpO1xuXG4gIFx0XHQvLyBhcHBseSB0aGUgdW5kZXJseWluZyBtZXRob2RcbiAgXHRcdHJlc3VsdCA9IEFycmF5LnByb3RvdHlwZVttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIFx0XHQvLyB0cmlnZ2VyIGNoYW5nZXNcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnN0YXJ0KCk7XG5cbiAgXHRcdHRoaXMuX3JhY3RpdmUuc2V0dGluZyA9IHRydWU7XG4gIFx0XHRpID0gdGhpcy5fcmFjdGl2ZS53cmFwcGVycy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdHdyYXBwZXIgPSB0aGlzLl9yYWN0aXZlLndyYXBwZXJzW2ldO1xuXG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFJhY3RpdmUod3JhcHBlci5yb290KTtcbiAgXHRcdFx0cHJvY2Vzc1dyYXBwZXIod3JhcHBlciwgdGhpcywgbWV0aG9kTmFtZSwgbmV3SW5kaWNlcyk7XG4gIFx0XHR9XG5cbiAgXHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0XHR0aGlzLl9yYWN0aXZlLnNldHRpbmcgPSBmYWxzZTtcbiAgXHRcdHJldHVybiByZXN1bHQ7XG4gIFx0fTtcblxuICBcdGRlZmluZVByb3BlcnR5KHBhdGNoZWRBcnJheVByb3RvLCBtZXRob2ROYW1lLCB7XG4gIFx0XHR2YWx1ZTogbWV0aG9kXG4gIFx0fSk7XG4gIH0pO1xuXG4gIC8vIGNhbiB3ZSB1c2UgcHJvdG90eXBlIGNoYWluIGluamVjdGlvbj9cbiAgLy8gaHR0cDovL3BlcmZlY3Rpb25raWxscy5jb20vaG93LWVjbWFzY3JpcHQtNS1zdGlsbC1kb2VzLW5vdC1hbGxvdy10by1zdWJjbGFzcy1hbi1hcnJheS8jd3JhcHBlcnNfcHJvdG90eXBlX2NoYWluX2luamVjdGlvblxuICB0ZXN0T2JqID0ge307XG5cbiAgaWYgKHRlc3RPYmouX19wcm90b19fKSB7XG4gIFx0Ly8geWVzLCB3ZSBjYW5cbiAgXHRwYXRjaEFycmF5TWV0aG9kcyA9IGZ1bmN0aW9uIChhcnJheSkge1xuICBcdFx0YXJyYXkuX19wcm90b19fID0gcGF0Y2hlZEFycmF5UHJvdG87XG4gIFx0fTtcblxuICBcdHVucGF0Y2hBcnJheU1ldGhvZHMgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgXHRcdGFycmF5Ll9fcHJvdG9fXyA9IEFycmF5LnByb3RvdHlwZTtcbiAgXHR9O1xuICB9IGVsc2Uge1xuICBcdC8vIG5vLCB3ZSBjYW4ndFxuICBcdHBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gIFx0XHR2YXIgaSwgbWV0aG9kTmFtZTtcblxuICBcdFx0aSA9IG11dGF0b3JNZXRob2RzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0bWV0aG9kTmFtZSA9IG11dGF0b3JNZXRob2RzW2ldO1xuICBcdFx0XHRkZWZpbmVQcm9wZXJ0eShhcnJheSwgbWV0aG9kTmFtZSwge1xuICBcdFx0XHRcdHZhbHVlOiBwYXRjaGVkQXJyYXlQcm90b1ttZXRob2ROYW1lXSxcbiAgXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdHVucGF0Y2hBcnJheU1ldGhvZHMgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgXHRcdHZhciBpO1xuXG4gIFx0XHRpID0gbXV0YXRvck1ldGhvZHMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRkZWxldGUgYXJyYXlbbXV0YXRvck1ldGhvZHNbaV1dO1xuICBcdFx0fVxuICBcdH07XG4gIH1cblxuICBwYXRjaEFycmF5TWV0aG9kcy51bnBhdGNoID0gdW5wYXRjaEFycmF5TWV0aG9kcztcbiAgdmFyIHBhdGNoID0gcGF0Y2hBcnJheU1ldGhvZHM7XG5cbiAgdmFyIGFycmF5QWRhcHRvcixcblxuICAvLyBoZWxwZXJzXG4gIEFycmF5V3JhcHBlciwgYXJyYXlfaW5kZXhfX2Vycm9yTWVzc2FnZTtcblxuICBhcnJheUFkYXB0b3IgPSB7XG4gIFx0ZmlsdGVyOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIFx0XHQvLyB3cmFwIHRoZSBhcnJheSBpZiBhKSBiKSBpdCdzIGFuIGFycmF5LCBhbmQgYikgZWl0aGVyIGl0IGhhc24ndCBiZWVuIHdyYXBwZWQgYWxyZWFkeSxcbiAgXHRcdC8vIG9yIHRoZSBhcnJheSBkaWRuJ3QgdHJpZ2dlciB0aGUgZ2V0KCkgaXRzZWxmXG4gIFx0XHRyZXR1cm4gaXNBcnJheShvYmplY3QpICYmICghb2JqZWN0Ll9yYWN0aXZlIHx8ICFvYmplY3QuX3JhY3RpdmUuc2V0dGluZyk7XG4gIFx0fSxcbiAgXHR3cmFwOiBmdW5jdGlvbiAocmFjdGl2ZSwgYXJyYXksIGtleXBhdGgpIHtcbiAgXHRcdHJldHVybiBuZXcgQXJyYXlXcmFwcGVyKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKTtcbiAgXHR9XG4gIH07XG5cbiAgQXJyYXlXcmFwcGVyID0gZnVuY3Rpb24gKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKSB7XG4gIFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcbiAgXHR0aGlzLnZhbHVlID0gYXJyYXk7XG4gIFx0dGhpcy5rZXlwYXRoID0gZ2V0S2V5cGF0aChrZXlwYXRoKTtcblxuICBcdC8vIGlmIHRoaXMgYXJyYXkgaGFzbid0IGFscmVhZHkgYmVlbiByYWN0aWZpZWQsIHJhY3RpZnkgaXRcbiAgXHRpZiAoIWFycmF5Ll9yYWN0aXZlKSB7XG5cbiAgXHRcdC8vIGRlZmluZSBhIG5vbi1lbnVtZXJhYmxlIF9yYWN0aXZlIHByb3BlcnR5IHRvIHN0b3JlIHRoZSB3cmFwcGVyc1xuICBcdFx0ZGVmaW5lUHJvcGVydHkoYXJyYXksIFwiX3JhY3RpdmVcIiwge1xuICBcdFx0XHR2YWx1ZToge1xuICBcdFx0XHRcdHdyYXBwZXJzOiBbXSxcbiAgXHRcdFx0XHRpbnN0YW5jZXM6IFtdLFxuICBcdFx0XHRcdHNldHRpbmc6IGZhbHNlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICBcdFx0fSk7XG5cbiAgXHRcdHBhdGNoKGFycmF5KTtcbiAgXHR9XG5cbiAgXHQvLyBzdG9yZSB0aGUgcmFjdGl2ZSBpbnN0YW5jZSwgc28gd2UgY2FuIGhhbmRsZSB0cmFuc2l0aW9ucyBsYXRlclxuICBcdGlmICghYXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzW3JhY3RpdmUuX2d1aWRdKSB7XG4gIFx0XHRhcnJheS5fcmFjdGl2ZS5pbnN0YW5jZXNbcmFjdGl2ZS5fZ3VpZF0gPSAwO1xuICBcdFx0YXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzLnB1c2gocmFjdGl2ZSk7XG4gIFx0fVxuXG4gIFx0YXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzW3JhY3RpdmUuX2d1aWRdICs9IDE7XG4gIFx0YXJyYXkuX3JhY3RpdmUud3JhcHBlcnMucHVzaCh0aGlzKTtcbiAgfTtcblxuICBBcnJheVdyYXBwZXIucHJvdG90eXBlID0ge1xuICBcdGdldDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG4gIFx0fSxcbiAgXHR0ZWFyZG93bjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGFycmF5LCBzdG9yYWdlLCB3cmFwcGVycywgaW5zdGFuY2VzLCBpbmRleDtcblxuICBcdFx0YXJyYXkgPSB0aGlzLnZhbHVlO1xuICBcdFx0c3RvcmFnZSA9IGFycmF5Ll9yYWN0aXZlO1xuICBcdFx0d3JhcHBlcnMgPSBzdG9yYWdlLndyYXBwZXJzO1xuICBcdFx0aW5zdGFuY2VzID0gc3RvcmFnZS5pbnN0YW5jZXM7XG5cbiAgXHRcdC8vIGlmIHRlYXJkb3duKCkgd2FzIGludm9rZWQgYmVjYXVzZSB3ZSdyZSBjbGVhcmluZyB0aGUgY2FjaGUgYXMgYSByZXN1bHQgb2ZcbiAgXHRcdC8vIGEgY2hhbmdlIHRoYXQgdGhlIGFycmF5IGl0c2VsZiB0cmlnZ2VyZWQsIHdlIGNhbiBzYXZlIG91cnNlbHZlcyB0aGUgdGVhcmRvd25cbiAgXHRcdC8vIGFuZCBpbW1lZGlhdGUgc2V0dXBcbiAgXHRcdGlmIChzdG9yYWdlLnNldHRpbmcpIHtcbiAgXHRcdFx0cmV0dXJuIGZhbHNlOyAvLyBzbyB0aGF0IHdlIGRvbid0IHJlbW92ZSBpdCBmcm9tIHRoaXMucm9vdC52aWV3bW9kZWwud3JhcHBlZFxuICBcdFx0fVxuXG4gIFx0XHRpbmRleCA9IHdyYXBwZXJzLmluZGV4T2YodGhpcyk7XG4gIFx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihhcnJheV9pbmRleF9fZXJyb3JNZXNzYWdlKTtcbiAgXHRcdH1cblxuICBcdFx0d3JhcHBlcnMuc3BsaWNlKGluZGV4LCAxKTtcblxuICBcdFx0Ly8gaWYgbm90aGluZyBlbHNlIGRlcGVuZHMgb24gdGhpcyBhcnJheSwgd2UgY2FuIHJldmVydCBpdCB0byBpdHNcbiAgXHRcdC8vIG5hdHVyYWwgc3RhdGVcbiAgXHRcdGlmICghd3JhcHBlcnMubGVuZ3RoKSB7XG4gIFx0XHRcdGRlbGV0ZSBhcnJheS5fcmFjdGl2ZTtcbiAgXHRcdFx0cGF0Y2gudW5wYXRjaCh0aGlzLnZhbHVlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdC8vIHJlbW92ZSByYWN0aXZlIGluc3RhbmNlIGlmIHBvc3NpYmxlXG4gIFx0XHRcdGluc3RhbmNlc1t0aGlzLnJvb3QuX2d1aWRdIC09IDE7XG4gIFx0XHRcdGlmICghaW5zdGFuY2VzW3RoaXMucm9vdC5fZ3VpZF0pIHtcbiAgXHRcdFx0XHRpbmRleCA9IGluc3RhbmNlcy5pbmRleE9mKHRoaXMucm9vdCk7XG5cbiAgXHRcdFx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYXJyYXlfaW5kZXhfX2Vycm9yTWVzc2FnZSk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0aW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgYXJyYXlfaW5kZXhfX2Vycm9yTWVzc2FnZSA9IFwiU29tZXRoaW5nIHdlbnQgd3JvbmcgaW4gYSByYXRoZXIgaW50ZXJlc3Rpbmcgd2F5XCI7XG4gIHZhciBhcnJheV9pbmRleCA9IGFycmF5QWRhcHRvcjtcblxuICB2YXIgbnVtZXJpYyA9IC9eXFxzKlswLTldK1xccyokLztcblxuICB2YXIgY3JlYXRlQnJhbmNoID0gZnVuY3Rpb24gKGtleSkge1xuICBcdHJldHVybiBudW1lcmljLnRlc3Qoa2V5KSA/IFtdIDoge307XG4gIH07XG5cbiAgdmFyIG1hZ2ljQWRhcHRvciwgTWFnaWNXcmFwcGVyO1xuXG4gIHRyeSB7XG4gIFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInRlc3RcIiwgeyB2YWx1ZTogMCB9KTtcblxuICBcdG1hZ2ljQWRhcHRvciA9IHtcbiAgXHRcdGZpbHRlcjogZnVuY3Rpb24gKG9iamVjdCwga2V5cGF0aCwgcmFjdGl2ZSkge1xuICBcdFx0XHR2YXIgcGFyZW50V3JhcHBlciwgcGFyZW50VmFsdWU7XG5cbiAgXHRcdFx0aWYgKCFrZXlwYXRoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0a2V5cGF0aCA9IGdldEtleXBhdGgoa2V5cGF0aCk7XG5cbiAgXHRcdFx0Ly8gSWYgdGhlIHBhcmVudCB2YWx1ZSBpcyBhIHdyYXBwZXIsIG90aGVyIHRoYW4gYSBtYWdpYyB3cmFwcGVyLFxuICBcdFx0XHQvLyB3ZSBzaG91bGRuJ3Qgd3JhcCB0aGlzIHByb3BlcnR5XG4gIFx0XHRcdGlmICgocGFyZW50V3JhcHBlciA9IHJhY3RpdmUudmlld21vZGVsLndyYXBwZWRba2V5cGF0aC5wYXJlbnQuc3RyXSkgJiYgIXBhcmVudFdyYXBwZXIubWFnaWMpIHtcbiAgXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRwYXJlbnRWYWx1ZSA9IHJhY3RpdmUudmlld21vZGVsLmdldChrZXlwYXRoLnBhcmVudCk7XG5cbiAgXHRcdFx0Ly8gaWYgcGFyZW50VmFsdWUgaXMgYW4gYXJyYXkgdGhhdCBkb2Vzbid0IGluY2x1ZGUgdGhpcyBtZW1iZXIsXG4gIFx0XHRcdC8vIHdlIHNob3VsZCByZXR1cm4gZmFsc2Ugb3RoZXJ3aXNlIGxlbmd0aHMgd2lsbCBnZXQgbWVzc2VkIHVwXG4gIFx0XHRcdGlmIChpc0FycmF5KHBhcmVudFZhbHVlKSAmJiAvXlswLTldKyQvLnRlc3Qoa2V5cGF0aC5sYXN0S2V5KSkge1xuICBcdFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBwYXJlbnRWYWx1ZSAmJiAodHlwZW9mIHBhcmVudFZhbHVlID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gXCJmdW5jdGlvblwiKTtcbiAgXHRcdH0sXG4gIFx0XHR3cmFwOiBmdW5jdGlvbiAocmFjdGl2ZSwgcHJvcGVydHksIGtleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuIG5ldyBNYWdpY1dyYXBwZXIocmFjdGl2ZSwgcHJvcGVydHksIGtleXBhdGgpO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRNYWdpY1dyYXBwZXIgPSBmdW5jdGlvbiAocmFjdGl2ZSwgdmFsdWUsIGtleXBhdGgpIHtcbiAgXHRcdHZhciBvYmpLZXlwYXRoLCB0ZW1wbGF0ZSwgc2libGluZ3M7XG5cbiAgXHRcdGtleXBhdGggPSBnZXRLZXlwYXRoKGtleXBhdGgpO1xuXG4gIFx0XHR0aGlzLm1hZ2ljID0gdHJ1ZTtcblxuICBcdFx0dGhpcy5yYWN0aXZlID0gcmFjdGl2ZTtcbiAgXHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cbiAgXHRcdHRoaXMucHJvcCA9IGtleXBhdGgubGFzdEtleTtcblxuICBcdFx0b2JqS2V5cGF0aCA9IGtleXBhdGgucGFyZW50O1xuICBcdFx0dGhpcy5vYmogPSBvYmpLZXlwYXRoLmlzUm9vdCA/IHJhY3RpdmUudmlld21vZGVsLmRhdGEgOiByYWN0aXZlLnZpZXdtb2RlbC5nZXQob2JqS2V5cGF0aCk7XG5cbiAgXHRcdHRlbXBsYXRlID0gdGhpcy5vcmlnaW5hbERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMub2JqLCB0aGlzLnByb3ApO1xuXG4gIFx0XHQvLyBIYXMgdGhpcyBwcm9wZXJ0eSBhbHJlYWR5IGJlZW4gd3JhcHBlZD9cbiAgXHRcdGlmICh0ZW1wbGF0ZSAmJiB0ZW1wbGF0ZS5zZXQgJiYgKHNpYmxpbmdzID0gdGVtcGxhdGUuc2V0Ll9yYWN0aXZlV3JhcHBlcnMpKSB7XG5cbiAgXHRcdFx0Ly8gWWVzLiBSZWdpc3RlciB0aGlzIHdyYXBwZXIgdG8gdGhpcyBwcm9wZXJ0eSwgaWYgaXQgaGFzbid0IGJlZW4gYWxyZWFkeVxuICBcdFx0XHRpZiAoc2libGluZ3MuaW5kZXhPZih0aGlzKSA9PT0gLTEpIHtcbiAgXHRcdFx0XHRzaWJsaW5ncy5wdXNoKHRoaXMpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuOyAvLyBhbHJlYWR5IHdyYXBwZWRcbiAgXHRcdH1cblxuICBcdFx0Ly8gTm8sIGl0IGhhc24ndCBiZWVuIHdyYXBwZWRcbiAgXHRcdGNyZWF0ZUFjY2Vzc29ycyh0aGlzLCB2YWx1ZSwgdGVtcGxhdGUpO1xuICBcdH07XG5cbiAgXHRNYWdpY1dyYXBwZXIucHJvdG90eXBlID0ge1xuICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLnZhbHVlO1xuICBcdFx0fSxcbiAgXHRcdHJlc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdFx0aWYgKHRoaXMudXBkYXRpbmcpIHtcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcbiAgXHRcdFx0dGhpcy5vYmpbdGhpcy5wcm9wXSA9IHZhbHVlOyAvLyB0cmlnZ2VyIHNldCgpIGFjY2Vzc29yXG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFJhY3RpdmUodGhpcy5yYWN0aXZlKTtcbiAgXHRcdFx0dGhpcy5yYWN0aXZlLnZpZXdtb2RlbC5tYXJrKHRoaXMua2V5cGF0aCwgeyBrZWVwRXhpc3RpbmdXcmFwcGVyOiB0cnVlIH0pO1xuICBcdFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG4gIFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0fSxcbiAgXHRcdHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgXHRcdFx0aWYgKHRoaXMudXBkYXRpbmcpIHtcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIXRoaXMub2JqW3RoaXMucHJvcF0pIHtcbiAgXHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcbiAgXHRcdFx0XHR0aGlzLm9ialt0aGlzLnByb3BdID0gY3JlYXRlQnJhbmNoKGtleSk7XG4gIFx0XHRcdFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGhpcy5vYmpbdGhpcy5wcm9wXVtrZXldID0gdmFsdWU7XG4gIFx0XHR9LFxuICBcdFx0dGVhcmRvd246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dmFyIHRlbXBsYXRlLCBzZXQsIHZhbHVlLCB3cmFwcGVycywgaW5kZXg7XG5cbiAgXHRcdFx0Ly8gSWYgdGhpcyBtZXRob2Qgd2FzIGNhbGxlZCBiZWNhdXNlIHRoZSBjYWNoZSB3YXMgYmVpbmcgY2xlYXJlZCBhcyBhXG4gIFx0XHRcdC8vIHJlc3VsdCBvZiBhIHNldCgpL3VwZGF0ZSgpIGNhbGwgbWFkZSBieSB0aGlzIHdyYXBwZXIsIHdlIHJldHVybiBmYWxzZVxuICBcdFx0XHQvLyBzbyB0aGF0IGl0IGRvZXNuJ3QgZ2V0IHRvcm4gZG93blxuICBcdFx0XHRpZiAodGhpcy51cGRhdGluZykge1xuICBcdFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRlbXBsYXRlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLm9iaiwgdGhpcy5wcm9wKTtcbiAgXHRcdFx0c2V0ID0gdGVtcGxhdGUgJiYgdGVtcGxhdGUuc2V0O1xuXG4gIFx0XHRcdGlmICghc2V0KSB7XG4gIFx0XHRcdFx0Ly8gbW9zdCBsaWtlbHksIHRoaXMgd2FzIGFuIGFycmF5IG1lbWJlciB0aGF0IHdhcyBzcGxpY2VkIG91dFxuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHdyYXBwZXJzID0gc2V0Ll9yYWN0aXZlV3JhcHBlcnM7XG5cbiAgXHRcdFx0aW5kZXggPSB3cmFwcGVycy5pbmRleE9mKHRoaXMpO1xuICBcdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG4gIFx0XHRcdFx0d3JhcHBlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIExhc3Qgb25lIG91dCwgdHVybiBvZmYgdGhlIGxpZ2h0c1xuICBcdFx0XHRpZiAoIXdyYXBwZXJzLmxlbmd0aCkge1xuICBcdFx0XHRcdHZhbHVlID0gdGhpcy5vYmpbdGhpcy5wcm9wXTtcblxuICBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLm9iaiwgdGhpcy5wcm9wLCB0aGlzLm9yaWdpbmFsRGVzY3JpcHRvciB8fCB7XG4gIFx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcbiAgXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gIFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcbiAgXHRcdFx0XHR9KTtcblxuICBcdFx0XHRcdHRoaXMub2JqW3RoaXMucHJvcF0gPSB2YWx1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH07XG4gIH0gY2F0Y2ggKGVycikge1xuICBcdG1hZ2ljQWRhcHRvciA9IGZhbHNlOyAvLyBubyBtYWdpYyBpbiB0aGlzIGJyb3dzZXJcbiAgfVxuXG4gIHZhciBhZGFwdG9yc19tYWdpYyA9IG1hZ2ljQWRhcHRvcjtcblxuICBmdW5jdGlvbiBjcmVhdGVBY2Nlc3NvcnMob3JpZ2luYWxXcmFwcGVyLCB2YWx1ZSwgdGVtcGxhdGUpIHtcblxuICBcdHZhciBvYmplY3QsIHByb3BlcnR5LCBvbGRHZXQsIG9sZFNldCwgZ2V0LCBzZXQ7XG5cbiAgXHRvYmplY3QgPSBvcmlnaW5hbFdyYXBwZXIub2JqO1xuICBcdHByb3BlcnR5ID0gb3JpZ2luYWxXcmFwcGVyLnByb3A7XG5cbiAgXHQvLyBJcyB0aGlzIHRlbXBsYXRlIGNvbmZpZ3VyYWJsZT9cbiAgXHRpZiAodGVtcGxhdGUgJiYgIXRlbXBsYXRlLmNvbmZpZ3VyYWJsZSkge1xuICBcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gYXJyYXkgbGVuZ3RoXG4gIFx0XHRpZiAocHJvcGVydHkgPT09IFwibGVuZ3RoXCIpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIG1hZ2ljIG1vZGUgd2l0aCBwcm9wZXJ0eSBcXFwiXCIgKyBwcm9wZXJ0eSArIFwiXFxcIiAtIG9iamVjdCBpcyBub3QgY29uZmlndXJhYmxlXCIpO1xuICBcdH1cblxuICBcdC8vIFRpbWUgdG8gd3JhcCB0aGlzIHByb3BlcnR5XG4gIFx0aWYgKHRlbXBsYXRlKSB7XG4gIFx0XHRvbGRHZXQgPSB0ZW1wbGF0ZS5nZXQ7XG4gIFx0XHRvbGRTZXQgPSB0ZW1wbGF0ZS5zZXQ7XG4gIFx0fVxuXG4gIFx0Z2V0ID0gb2xkR2V0IHx8IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB2YWx1ZTtcbiAgXHR9O1xuXG4gIFx0c2V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgXHRcdGlmIChvbGRTZXQpIHtcbiAgXHRcdFx0b2xkU2V0KHYpO1xuICBcdFx0fVxuXG4gIFx0XHR2YWx1ZSA9IG9sZEdldCA/IG9sZEdldCgpIDogdjtcbiAgXHRcdHNldC5fcmFjdGl2ZVdyYXBwZXJzLmZvckVhY2godXBkYXRlV3JhcHBlcik7XG4gIFx0fTtcblxuICBcdGZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIod3JhcHBlcikge1xuICBcdFx0dmFyIGtleXBhdGgsIHJhY3RpdmU7XG5cbiAgXHRcdHdyYXBwZXIudmFsdWUgPSB2YWx1ZTtcblxuICBcdFx0aWYgKHdyYXBwZXIudXBkYXRpbmcpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRyYWN0aXZlID0gd3JhcHBlci5yYWN0aXZlO1xuICBcdFx0a2V5cGF0aCA9IHdyYXBwZXIua2V5cGF0aDtcblxuICBcdFx0d3JhcHBlci51cGRhdGluZyA9IHRydWU7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zdGFydChyYWN0aXZlKTtcblxuICBcdFx0cmFjdGl2ZS52aWV3bW9kZWwubWFyayhrZXlwYXRoKTtcblxuICBcdFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIFx0XHR3cmFwcGVyLnVwZGF0aW5nID0gZmFsc2U7XG4gIFx0fVxuXG4gIFx0Ly8gQ3JlYXRlIGFuIGFycmF5IG9mIHdyYXBwZXJzLCBpbiBjYXNlIG90aGVyIGtleXBhdGhzL3JhY3RpdmVzIGRlcGVuZCBvbiB0aGlzIHByb3BlcnR5LlxuICBcdC8vIEhhbmRpbHksIHdlIGNhbiBzdG9yZSB0aGVtIGFzIGEgcHJvcGVydHkgb2YgdGhlIHNldCBmdW5jdGlvbi4gWWF5IEphdmFTY3JpcHQuXG4gIFx0c2V0Ll9yYWN0aXZlV3JhcHBlcnMgPSBbb3JpZ2luYWxXcmFwcGVyXTtcbiAgXHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgeyBnZXQ6IGdldCwgc2V0OiBzZXQsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIHZhciBtYWdpY0FycmF5QWRhcHRvciwgTWFnaWNBcnJheVdyYXBwZXI7XG5cbiAgaWYgKGFkYXB0b3JzX21hZ2ljKSB7XG4gIFx0bWFnaWNBcnJheUFkYXB0b3IgPSB7XG4gIFx0XHRmaWx0ZXI6IGZ1bmN0aW9uIChvYmplY3QsIGtleXBhdGgsIHJhY3RpdmUpIHtcbiAgXHRcdFx0cmV0dXJuIGFkYXB0b3JzX21hZ2ljLmZpbHRlcihvYmplY3QsIGtleXBhdGgsIHJhY3RpdmUpICYmIGFycmF5X2luZGV4LmZpbHRlcihvYmplY3QpO1xuICBcdFx0fSxcblxuICBcdFx0d3JhcDogZnVuY3Rpb24gKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybiBuZXcgTWFnaWNBcnJheVdyYXBwZXIocmFjdGl2ZSwgYXJyYXksIGtleXBhdGgpO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRNYWdpY0FycmF5V3JhcHBlciA9IGZ1bmN0aW9uIChyYWN0aXZlLCBhcnJheSwga2V5cGF0aCkge1xuICBcdFx0dGhpcy52YWx1ZSA9IGFycmF5O1xuXG4gIFx0XHR0aGlzLm1hZ2ljID0gdHJ1ZTtcblxuICBcdFx0dGhpcy5tYWdpY1dyYXBwZXIgPSBhZGFwdG9yc19tYWdpYy53cmFwKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKTtcbiAgXHRcdHRoaXMuYXJyYXlXcmFwcGVyID0gYXJyYXlfaW5kZXgud3JhcChyYWN0aXZlLCBhcnJheSwga2V5cGF0aCk7XG4gIFx0fTtcblxuICBcdE1hZ2ljQXJyYXlXcmFwcGVyLnByb3RvdHlwZSA9IHtcbiAgXHRcdGdldDogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcbiAgXHRcdH0sXG4gIFx0XHR0ZWFyZG93bjogZnVuY3Rpb24gKCkge1xuICBcdFx0XHR0aGlzLmFycmF5V3JhcHBlci50ZWFyZG93bigpO1xuICBcdFx0XHR0aGlzLm1hZ2ljV3JhcHBlci50ZWFyZG93bigpO1xuICBcdFx0fSxcbiAgXHRcdHJlc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMubWFnaWNXcmFwcGVyLnJlc2V0KHZhbHVlKTtcbiAgXHRcdH1cbiAgXHR9O1xuICB9XG5cbiAgdmFyIG1hZ2ljQXJyYXkgPSBtYWdpY0FycmF5QWRhcHRvcjtcblxuICB2YXIgcHJvdG90eXBlX2FkYXB0ID0gVmlld21vZGVsJGFkYXB0O1xuXG4gIHZhciBwcmVmaXhlcnMgPSB7fTtcbiAgZnVuY3Rpb24gVmlld21vZGVsJGFkYXB0KGtleXBhdGgsIHZhbHVlKSB7XG4gIFx0dmFyIGxlbiwgaSwgYWRhcHRvciwgd3JhcHBlZDtcblxuICBcdGlmICghdGhpcy5hZGFwdG9ycykgcmV0dXJuO1xuXG4gIFx0Ly8gRG8gd2UgaGF2ZSBhbiBhZGFwdG9yIGZvciB0aGlzIHZhbHVlP1xuICBcdGxlbiA9IHRoaXMuYWRhcHRvcnMubGVuZ3RoO1xuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0YWRhcHRvciA9IHRoaXMuYWRhcHRvcnNbaV07XG5cbiAgXHRcdGlmIChhZGFwdG9yLmZpbHRlcih2YWx1ZSwga2V5cGF0aCwgdGhpcy5yYWN0aXZlKSkge1xuICBcdFx0XHR3cmFwcGVkID0gdGhpcy53cmFwcGVkW2tleXBhdGhdID0gYWRhcHRvci53cmFwKHRoaXMucmFjdGl2ZSwgdmFsdWUsIGtleXBhdGgsIGdldFByZWZpeGVyKGtleXBhdGgpKTtcbiAgXHRcdFx0d3JhcHBlZC52YWx1ZSA9IHZhbHVlO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcHJlZml4S2V5cGF0aChvYmosIHByZWZpeCkge1xuICBcdHZhciBwcmVmaXhlZCA9IHt9LFxuICBcdCAgICBrZXk7XG5cbiAgXHRpZiAoIXByZWZpeCkge1xuICBcdFx0cmV0dXJuIG9iajtcbiAgXHR9XG5cbiAgXHRwcmVmaXggKz0gXCIuXCI7XG5cbiAgXHRmb3IgKGtleSBpbiBvYmopIHtcbiAgXHRcdGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICBcdFx0XHRwcmVmaXhlZFtwcmVmaXggKyBrZXldID0gb2JqW2tleV07XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHByZWZpeGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UHJlZml4ZXIocm9vdEtleXBhdGgpIHtcbiAgXHR2YXIgcm9vdERvdDtcblxuICBcdGlmICghcHJlZml4ZXJzW3Jvb3RLZXlwYXRoXSkge1xuICBcdFx0cm9vdERvdCA9IHJvb3RLZXlwYXRoID8gcm9vdEtleXBhdGggKyBcIi5cIiA6IFwiXCI7XG5cbiAgXHRcdHByZWZpeGVyc1tyb290S2V5cGF0aF0gPSBmdW5jdGlvbiAocmVsYXRpdmVLZXlwYXRoLCB2YWx1ZSkge1xuICBcdFx0XHR2YXIgb2JqO1xuXG4gIFx0XHRcdGlmICh0eXBlb2YgcmVsYXRpdmVLZXlwYXRoID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdFx0b2JqID0ge307XG4gIFx0XHRcdFx0b2JqW3Jvb3REb3QgKyByZWxhdGl2ZUtleXBhdGhdID0gdmFsdWU7XG4gIFx0XHRcdFx0cmV0dXJuIG9iajtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICh0eXBlb2YgcmVsYXRpdmVLZXlwYXRoID09PSBcIm9iamVjdFwiKSB7XG4gIFx0XHRcdFx0Ly8gJ3JlbGF0aXZlS2V5cGF0aCcgaXMgaW4gZmFjdCBhIGhhc2gsIG5vdCBhIGtleXBhdGhcbiAgXHRcdFx0XHRyZXR1cm4gcm9vdERvdCA/IHByZWZpeEtleXBhdGgocmVsYXRpdmVLZXlwYXRoLCByb290S2V5cGF0aCkgOiByZWxhdGl2ZUtleXBhdGg7XG4gIFx0XHRcdH1cbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHByZWZpeGVyc1tyb290S2V5cGF0aF07XG4gIH1cblxuICAvLyBURU1QXG5cbiAgdmFyIGhlbHBlcnNfZ2V0VXBzdHJlYW1DaGFuZ2VzID0gZ2V0VXBzdHJlYW1DaGFuZ2VzO1xuICBmdW5jdGlvbiBnZXRVcHN0cmVhbUNoYW5nZXMoY2hhbmdlcykge1xuICBcdHZhciB1cHN0cmVhbUNoYW5nZXMgPSBbcm9vdEtleXBhdGhdLFxuICBcdCAgICBpLFxuICBcdCAgICBrZXlwYXRoO1xuXG4gIFx0aSA9IGNoYW5nZXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGtleXBhdGggPSBjaGFuZ2VzW2ldLnBhcmVudDtcblxuICBcdFx0d2hpbGUgKGtleXBhdGggJiYgIWtleXBhdGguaXNSb290KSB7XG4gIFx0XHRcdGlmIChjaGFuZ2VzLmluZGV4T2Yoa2V5cGF0aCkgPT09IC0xKSB7XG4gIFx0XHRcdFx0YWRkVG9BcnJheSh1cHN0cmVhbUNoYW5nZXMsIGtleXBhdGgpO1xuICBcdFx0XHR9XG4gIFx0XHRcdGtleXBhdGggPSBrZXlwYXRoLnBhcmVudDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdXBzdHJlYW1DaGFuZ2VzO1xuICB9XG5cbiAgdmFyIGFwcGx5Q2hhbmdlc19ub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzID0gbm90aWZ5UGF0dGVybk9ic2VydmVycztcblxuICBmdW5jdGlvbiBub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzKHZpZXdtb2RlbCwga2V5cGF0aCwgb25seURpcmVjdCkge1xuICBcdHZhciBwb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXM7XG5cbiAgXHR1cGRhdGVNYXRjaGluZ1BhdHRlcm5PYnNlcnZlcnModmlld21vZGVsLCBrZXlwYXRoKTtcblxuICBcdGlmIChvbmx5RGlyZWN0KSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0cG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzID0ga2V5cGF0aC53aWxkY2FyZE1hdGNoZXMoKTtcbiAgXHRwb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAodXBzdHJlYW1QYXR0ZXJuKSB7XG4gIFx0XHRjYXNjYWRlKHZpZXdtb2RlbCwgdXBzdHJlYW1QYXR0ZXJuLCBrZXlwYXRoKTtcbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhc2NhZGUodmlld21vZGVsLCB1cHN0cmVhbVBhdHRlcm4sIGtleXBhdGgpIHtcbiAgXHR2YXIgZ3JvdXAsIG1hcCwgYWN0dWFsQ2hpbGRLZXlwYXRoO1xuXG4gIFx0Ly8gVE9ETyBzaG91bGQgYmUgb25lIG9yIHRoZSBvdGhlclxuICBcdHVwc3RyZWFtUGF0dGVybiA9IHVwc3RyZWFtUGF0dGVybi5zdHIgfHwgdXBzdHJlYW1QYXR0ZXJuO1xuXG4gIFx0Z3JvdXAgPSB2aWV3bW9kZWwuZGVwc01hcC5wYXR0ZXJuT2JzZXJ2ZXJzO1xuICBcdG1hcCA9IGdyb3VwICYmIGdyb3VwW3Vwc3RyZWFtUGF0dGVybl07XG5cbiAgXHRpZiAoIW1hcCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdG1hcC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZEtleXBhdGgpIHtcbiAgXHRcdGFjdHVhbENoaWxkS2V5cGF0aCA9IGtleXBhdGguam9pbihjaGlsZEtleXBhdGgubGFzdEtleSk7IC8vICdmb28uYmFyLmJheidcblxuICBcdFx0dXBkYXRlTWF0Y2hpbmdQYXR0ZXJuT2JzZXJ2ZXJzKHZpZXdtb2RlbCwgYWN0dWFsQ2hpbGRLZXlwYXRoKTtcbiAgXHRcdGNhc2NhZGUodmlld21vZGVsLCBjaGlsZEtleXBhdGgsIGFjdHVhbENoaWxkS2V5cGF0aCk7XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVNYXRjaGluZ1BhdHRlcm5PYnNlcnZlcnModmlld21vZGVsLCBrZXlwYXRoKSB7XG4gIFx0dmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgXHRcdGlmIChvYnNlcnZlci5yZWdleC50ZXN0KGtleXBhdGguc3RyKSkge1xuICBcdFx0XHRvYnNlcnZlci51cGRhdGUoa2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fSk7XG4gIH1cblxuICB2YXIgYXBwbHlDaGFuZ2VzID0gVmlld21vZGVsJGFwcGx5Q2hhbmdlcztcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkYXBwbHlDaGFuZ2VzKCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgc2VsZiA9IHRoaXMsXG4gIFx0ICAgIGNoYW5nZXMsXG4gIFx0ICAgIHVwc3RyZWFtQ2hhbmdlcyxcbiAgXHQgICAgaGFzaCA9IHt9LFxuICBcdCAgICBiaW5kaW5ncztcblxuICBcdGNoYW5nZXMgPSB0aGlzLmNoYW5nZXM7XG5cbiAgXHRpZiAoIWNoYW5nZXMubGVuZ3RoKSB7XG4gIFx0XHQvLyBUT0RPIHdlIGVuZCB1cCBoZXJlIG9uIGluaXRpYWwgcmVuZGVyLiBQZXJoYXBzIHdlIHNob3VsZG4ndD9cbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiBpbnZhbGlkYXRlQ29tcHV0YXRpb24oY29tcHV0YXRpb24pIHtcbiAgXHRcdHZhciBrZXkgPSBjb21wdXRhdGlvbi5rZXk7XG5cbiAgXHRcdGlmIChjb21wdXRhdGlvbi52aWV3bW9kZWwgPT09IHNlbGYpIHtcbiAgXHRcdFx0c2VsZi5jbGVhckNhY2hlKGtleS5zdHIpO1xuICBcdFx0XHRjb21wdXRhdGlvbi5pbnZhbGlkYXRlKCk7XG5cbiAgXHRcdFx0Y2hhbmdlcy5wdXNoKGtleSk7XG4gIFx0XHRcdGNhc2NhZGUoa2V5KTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGNvbXB1dGF0aW9uLnZpZXdtb2RlbC5tYXJrKGtleSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gY2FzY2FkZShrZXlwYXRoKSB7XG4gIFx0XHR2YXIgbWFwLCBjb21wdXRhdGlvbnM7XG5cbiAgXHRcdGlmIChzZWxmLm5vQ2FzY2FkZS5oYXNPd25Qcm9wZXJ0eShrZXlwYXRoLnN0cikpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoY29tcHV0YXRpb25zID0gc2VsZi5kZXBzLmNvbXB1dGVkW2tleXBhdGguc3RyXSkge1xuICBcdFx0XHRjb21wdXRhdGlvbnMuZm9yRWFjaChpbnZhbGlkYXRlQ29tcHV0YXRpb24pO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAobWFwID0gc2VsZi5kZXBzTWFwLmNvbXB1dGVkW2tleXBhdGguc3RyXSkge1xuICBcdFx0XHRtYXAuZm9yRWFjaChjYXNjYWRlKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRjaGFuZ2VzLnNsaWNlKCkuZm9yRWFjaChjYXNjYWRlKTtcblxuICBcdHVwc3RyZWFtQ2hhbmdlcyA9IGhlbHBlcnNfZ2V0VXBzdHJlYW1DaGFuZ2VzKGNoYW5nZXMpO1xuICBcdHVwc3RyZWFtQ2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHR2YXIgY29tcHV0YXRpb25zO1xuXG4gIFx0XHQvLyBtYWtlIHN1cmUgd2UgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gZG93biB0aGlzIHBhcnRpY3VsYXIga2V5cGF0aCBpbiB0aGlzIHR1cm5cbiAgXHRcdGlmIChjaGFuZ2VzLmluZGV4T2Yoa2V5cGF0aCkgPT09IC0xICYmIChjb21wdXRhdGlvbnMgPSBzZWxmLmRlcHMuY29tcHV0ZWRba2V5cGF0aC5zdHJdKSkge1xuICBcdFx0XHRjb21wdXRhdGlvbnMuZm9yRWFjaChpbnZhbGlkYXRlQ29tcHV0YXRpb24pO1xuICBcdFx0fVxuICBcdH0pO1xuXG4gIFx0dGhpcy5jaGFuZ2VzID0gW107XG5cbiAgXHQvLyBQYXR0ZXJuIG9ic2VydmVycyBhcmUgYSB3ZWlyZCBzcGVjaWFsIGNhc2VcbiAgXHRpZiAodGhpcy5wYXR0ZXJuT2JzZXJ2ZXJzLmxlbmd0aCkge1xuICBcdFx0dXBzdHJlYW1DaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuIGFwcGx5Q2hhbmdlc19ub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzKF90aGlzLCBrZXlwYXRoLCB0cnVlKTtcbiAgXHRcdH0pO1xuICBcdFx0Y2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybiBhcHBseUNoYW5nZXNfbm90aWZ5UGF0dGVybk9ic2VydmVycyhfdGhpcywga2V5cGF0aCk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5kZXBzLm9ic2VydmVycykge1xuICBcdFx0dXBzdHJlYW1DaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuIG5vdGlmeVVwc3RyZWFtRGVwZW5kYW50cyhfdGhpcywgbnVsbCwga2V5cGF0aCwgXCJvYnNlcnZlcnNcIik7XG4gIFx0XHR9KTtcbiAgXHRcdG5vdGlmeUFsbERlcGVuZGFudHModGhpcywgY2hhbmdlcywgXCJvYnNlcnZlcnNcIik7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZGVwc1tcImRlZmF1bHRcIl0pIHtcbiAgXHRcdGJpbmRpbmdzID0gW107XG4gIFx0XHR1cHN0cmVhbUNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRyZXR1cm4gbm90aWZ5VXBzdHJlYW1EZXBlbmRhbnRzKF90aGlzLCBiaW5kaW5ncywga2V5cGF0aCwgXCJkZWZhdWx0XCIpO1xuICBcdFx0fSk7XG5cbiAgXHRcdGlmIChiaW5kaW5ncy5sZW5ndGgpIHtcbiAgXHRcdFx0bm90aWZ5QmluZGluZ3ModGhpcywgYmluZGluZ3MsIGNoYW5nZXMpO1xuICBcdFx0fVxuXG4gIFx0XHRub3RpZnlBbGxEZXBlbmRhbnRzKHRoaXMsIGNoYW5nZXMsIFwiZGVmYXVsdFwiKTtcbiAgXHR9XG5cbiAgXHQvLyBSZXR1cm4gYSBoYXNoIG9mIGtleXBhdGhzIHRvIHVwZGF0ZWQgdmFsdWVzXG4gIFx0Y2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRoYXNoW2tleXBhdGguc3RyXSA9IF90aGlzLmdldChrZXlwYXRoKTtcbiAgXHR9KTtcblxuICBcdHRoaXMuaW1wbGljaXRDaGFuZ2VzID0ge307XG4gIFx0dGhpcy5ub0Nhc2NhZGUgPSB7fTtcblxuICBcdHJldHVybiBoYXNoO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90aWZ5VXBzdHJlYW1EZXBlbmRhbnRzKHZpZXdtb2RlbCwgYmluZGluZ3MsIGtleXBhdGgsIGdyb3VwTmFtZSkge1xuICBcdHZhciBkZXBlbmRhbnRzLCB2YWx1ZTtcblxuICBcdGlmIChkZXBlbmRhbnRzID0gZmluZERlcGVuZGFudHModmlld21vZGVsLCBrZXlwYXRoLCBncm91cE5hbWUpKSB7XG4gIFx0XHR2YWx1ZSA9IHZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRcdGRlcGVuZGFudHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICBcdFx0XHQvLyBkb24ndCBcInNldFwiIHRoZSBwYXJlbnQgdmFsdWUsIHJlZmluZSBpdFxuICBcdFx0XHQvLyBpLmUuIG5vdCBkYXRhID0gdmFsdWUsIGJ1dCBkYXRhW2Zvb10gPSBmb29WYWx1ZVxuICBcdFx0XHRpZiAoYmluZGluZ3MgJiYgZC5yZWZpbmVWYWx1ZSkge1xuICBcdFx0XHRcdGJpbmRpbmdzLnB1c2goZCk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0ZC5zZXRWYWx1ZSh2YWx1ZSk7XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeUJpbmRpbmdzKHZpZXdtb2RlbCwgYmluZGluZ3MsIGNoYW5nZXMpIHtcblxuICBcdGJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgXHRcdHZhciB1c2VTZXQgPSBmYWxzZSxcbiAgXHRcdCAgICBpID0gMCxcbiAgXHRcdCAgICBsZW5ndGggPSBjaGFuZ2VzLmxlbmd0aCxcbiAgXHRcdCAgICByZWZpbmVtZW50cyA9IFtdO1xuXG4gIFx0XHR3aGlsZSAoaSA8IGxlbmd0aCkge1xuICBcdFx0XHR2YXIga2V5cGF0aCA9IGNoYW5nZXNbaV07XG5cbiAgXHRcdFx0aWYgKGtleXBhdGggPT09IGJpbmRpbmcua2V5cGF0aCkge1xuICBcdFx0XHRcdHVzZVNldCA9IHRydWU7XG4gIFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoa2V5cGF0aC5zbGljZSgwLCBiaW5kaW5nLmtleXBhdGgubGVuZ3RoKSA9PT0gYmluZGluZy5rZXlwYXRoKSB7XG4gIFx0XHRcdFx0cmVmaW5lbWVudHMucHVzaChrZXlwYXRoKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGkrKztcbiAgXHRcdH1cblxuICBcdFx0aWYgKHVzZVNldCkge1xuICBcdFx0XHRiaW5kaW5nLnNldFZhbHVlKHZpZXdtb2RlbC5nZXQoYmluZGluZy5rZXlwYXRoKSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChyZWZpbmVtZW50cy5sZW5ndGgpIHtcbiAgXHRcdFx0YmluZGluZy5yZWZpbmVWYWx1ZShyZWZpbmVtZW50cyk7XG4gIFx0XHR9XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiBub3RpZnlBbGxEZXBlbmRhbnRzKHZpZXdtb2RlbCwga2V5cGF0aHMsIGdyb3VwTmFtZSkge1xuICBcdHZhciBxdWV1ZSA9IFtdO1xuXG4gIFx0YWRkS2V5cGF0aHMoa2V5cGF0aHMpO1xuICBcdHF1ZXVlLmZvckVhY2goZGlzcGF0Y2gpO1xuXG4gIFx0ZnVuY3Rpb24gYWRkS2V5cGF0aHMoa2V5cGF0aHMpIHtcbiAgXHRcdGtleXBhdGhzLmZvckVhY2goYWRkS2V5cGF0aCk7XG4gIFx0XHRrZXlwYXRocy5mb3JFYWNoKGNhc2NhZGUpO1xuICBcdH1cblxuICBcdGZ1bmN0aW9uIGFkZEtleXBhdGgoa2V5cGF0aCkge1xuICBcdFx0dmFyIGRlcHMgPSBmaW5kRGVwZW5kYW50cyh2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwTmFtZSk7XG5cbiAgXHRcdGlmIChkZXBzKSB7XG4gIFx0XHRcdHF1ZXVlLnB1c2goe1xuICBcdFx0XHRcdGtleXBhdGg6IGtleXBhdGgsXG4gIFx0XHRcdFx0ZGVwczogZGVwc1xuICBcdFx0XHR9KTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiBjYXNjYWRlKGtleXBhdGgpIHtcbiAgXHRcdHZhciBjaGlsZERlcHM7XG5cbiAgXHRcdGlmIChjaGlsZERlcHMgPSB2aWV3bW9kZWwuZGVwc01hcFtncm91cE5hbWVdW2tleXBhdGguc3RyXSkge1xuICBcdFx0XHRhZGRLZXlwYXRocyhjaGlsZERlcHMpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGZ1bmN0aW9uIGRpc3BhdGNoKHNldCkge1xuICBcdFx0dmFyIHZhbHVlID0gdmlld21vZGVsLmdldChzZXQua2V5cGF0aCk7XG4gIFx0XHRzZXQuZGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gIFx0XHRcdHJldHVybiBkLnNldFZhbHVlKHZhbHVlKTtcbiAgXHRcdH0pO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmREZXBlbmRhbnRzKHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXBOYW1lKSB7XG4gIFx0dmFyIGdyb3VwID0gdmlld21vZGVsLmRlcHNbZ3JvdXBOYW1lXTtcbiAgXHRyZXR1cm4gZ3JvdXAgPyBncm91cFtrZXlwYXRoLnN0cl0gOiBudWxsO1xuICB9XG5cbiAgdmFyIGNhcHR1cmUgPSBWaWV3bW9kZWwkY2FwdHVyZTtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkY2FwdHVyZSgpIHtcbiAgXHR0aGlzLmNhcHR1cmVHcm91cHMucHVzaChbXSk7XG4gIH1cblxuICB2YXIgY2xlYXJDYWNoZSA9IFZpZXdtb2RlbCRjbGVhckNhY2hlO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRjbGVhckNhY2hlKGtleXBhdGgsIGtlZXBFeGlzdGluZ1dyYXBwZXIpIHtcbiAgXHR2YXIgY2FjaGVNYXAsIHdyYXBwZXI7XG5cbiAgXHRpZiAoIWtlZXBFeGlzdGluZ1dyYXBwZXIpIHtcbiAgXHRcdC8vIElzIHRoZXJlIGEgd3JhcHBlZCBwcm9wZXJ0eSBhdCB0aGlzIGtleXBhdGg/XG4gIFx0XHRpZiAod3JhcHBlciA9IHRoaXMud3JhcHBlZFtrZXlwYXRoXSkge1xuICBcdFx0XHQvLyBEaWQgd2UgdW53cmFwIGl0P1xuICBcdFx0XHRpZiAod3JhcHBlci50ZWFyZG93bigpICE9PSBmYWxzZSkge1xuICBcdFx0XHRcdC8vIElzIHRoaXMgcmlnaHQ/XG4gIFx0XHRcdFx0Ly8gV2hhdCdzIHRoZSBtZWFuaW5nIG9mIHJldHVybmluZyBmYWxzZSBmcm9tIHRlYXJkb3duP1xuICBcdFx0XHRcdC8vIENvdWxkIHRoZXJlIGJlIGEgR0MgcmFtaWZpY2F0aW9uIGlmIHRoaXMgaXMgYSBcInJlYWxcIiByYWN0aXZlLnRlYXJkb3duKCk/XG4gIFx0XHRcdFx0dGhpcy53cmFwcGVkW2tleXBhdGhdID0gbnVsbDtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHRoaXMuY2FjaGVba2V5cGF0aF0gPSB1bmRlZmluZWQ7XG5cbiAgXHRpZiAoY2FjaGVNYXAgPSB0aGlzLmNhY2hlTWFwW2tleXBhdGhdKSB7XG4gIFx0XHR3aGlsZSAoY2FjaGVNYXAubGVuZ3RoKSB7XG4gIFx0XHRcdHRoaXMuY2xlYXJDYWNoZShjYWNoZU1hcC5wb3AoKSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIFVucmVzb2x2ZWREZXBlbmRlbmN5ID0gZnVuY3Rpb24gKGNvbXB1dGF0aW9uLCByZWYpIHtcbiAgXHR0aGlzLmNvbXB1dGF0aW9uID0gY29tcHV0YXRpb247XG4gIFx0dGhpcy52aWV3bW9kZWwgPSBjb21wdXRhdGlvbi52aWV3bW9kZWw7XG4gIFx0dGhpcy5yZWYgPSByZWY7XG5cbiAgXHQvLyBUT0RPIHRoaXMgc2VlbXMgbGlrZSBhIHJlZCBmbGFnIVxuICBcdHRoaXMucm9vdCA9IHRoaXMudmlld21vZGVsLnJhY3RpdmU7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IHRoaXMucm9vdC5jb21wb25lbnQgJiYgdGhpcy5yb290LmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcbiAgfTtcblxuICBVbnJlc29sdmVkRGVwZW5kZW5jeS5wcm90b3R5cGUgPSB7XG4gIFx0cmVzb2x2ZTogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHRoaXMuY29tcHV0YXRpb24uc29mdERlcHMucHVzaChrZXlwYXRoKTtcbiAgXHRcdHRoaXMuY29tcHV0YXRpb24udW5yZXNvbHZlZERlcHNba2V5cGF0aC5zdHJdID0gbnVsbDtcbiAgXHRcdHRoaXMudmlld21vZGVsLnJlZ2lzdGVyKGtleXBhdGgsIHRoaXMuY29tcHV0YXRpb24sIFwiY29tcHV0ZWRcIik7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBDb21wdXRhdGlvbl9VbnJlc29sdmVkRGVwZW5kZW5jeSA9IFVucmVzb2x2ZWREZXBlbmRlbmN5O1xuXG4gIHZhciBDb21wdXRhdGlvbiA9IGZ1bmN0aW9uIChrZXksIHNpZ25hdHVyZSkge1xuICBcdHRoaXMua2V5ID0ga2V5O1xuXG4gIFx0dGhpcy5nZXR0ZXIgPSBzaWduYXR1cmUuZ2V0dGVyO1xuICBcdHRoaXMuc2V0dGVyID0gc2lnbmF0dXJlLnNldHRlcjtcblxuICBcdHRoaXMuaGFyZERlcHMgPSBzaWduYXR1cmUuZGVwcyB8fCBbXTtcbiAgXHR0aGlzLnNvZnREZXBzID0gW107XG4gIFx0dGhpcy51bnJlc29sdmVkRGVwcyA9IHt9O1xuXG4gIFx0dGhpcy5kZXBWYWx1ZXMgPSB7fTtcblxuICBcdHRoaXMuX2RpcnR5ID0gdGhpcy5fZmlyc3RSdW4gPSB0cnVlO1xuICB9O1xuXG4gIENvbXB1dGF0aW9uLnByb3RvdHlwZSA9IHtcbiAgXHRjb25zdHJ1Y3RvcjogQ29tcHV0YXRpb24sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAodmlld21vZGVsKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgaW5pdGlhbDtcblxuICBcdFx0dGhpcy52aWV3bW9kZWwgPSB2aWV3bW9kZWw7XG4gIFx0XHR0aGlzLmJ5cGFzcyA9IHRydWU7XG5cbiAgXHRcdGluaXRpYWwgPSB2aWV3bW9kZWwuZ2V0KHRoaXMua2V5KTtcbiAgXHRcdHZpZXdtb2RlbC5jbGVhckNhY2hlKHRoaXMua2V5LnN0cik7XG5cbiAgXHRcdHRoaXMuYnlwYXNzID0gZmFsc2U7XG5cbiAgXHRcdGlmICh0aGlzLnNldHRlciAmJiBpbml0aWFsICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy5zZXQoaW5pdGlhbCk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLmhhcmREZXBzKSB7XG4gIFx0XHRcdHRoaXMuaGFyZERlcHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICBcdFx0XHRcdHJldHVybiB2aWV3bW9kZWwucmVnaXN0ZXIoZCwgX3RoaXMsIFwiY29tcHV0ZWRcIik7XG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRpbnZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9kaXJ0eSA9IHRydWU7XG4gIFx0fSxcblxuICBcdGdldDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0dmFyIG5ld0RlcHMsXG4gIFx0XHQgICAgZGVwZW5kZW5jaWVzQ2hhbmdlZCxcbiAgXHRcdCAgICBkZXBlbmRlbmN5VmFsdWVzQ2hhbmdlZCA9IGZhbHNlO1xuXG4gIFx0XHRpZiAodGhpcy5nZXR0aW5nKSB7XG4gIFx0XHRcdC8vIHByZXZlbnQgZG91YmxlLWNvbXB1dGF0aW9uIChlLmcuIGNhdXNlZCBieSBhcnJheSBtdXRhdGlvbiBpbnNpZGUgY29tcHV0YXRpb24pXG4gIFx0XHRcdHZhciBtc2cgPSBcIlRoZSBcIiArIHRoaXMua2V5LnN0ciArIFwiIGNvbXB1dGF0aW9uIGluZGlyZWN0bHkgY2FsbGVkIGl0c2VsZi4gVGhpcyBwcm9iYWJseSBpbmRpY2F0ZXMgYSBidWcgaW4gdGhlIGNvbXB1dGF0aW9uLiBJdCBpcyBjb21tb25seSBjYXVzZWQgYnkgYGFycmF5LnNvcnQoLi4uKWAgLSBpZiB0aGF0J3MgdGhlIGNhc2UsIGNsb25lIHRoZSBhcnJheSBmaXJzdCB3aXRoIGBhcnJheS5zbGljZSgpLnNvcnQoLi4uKWBcIjtcbiAgXHRcdFx0d2Fybk9uY2UobXNnKTtcbiAgXHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZ2V0dGluZyA9IHRydWU7XG5cbiAgXHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuICBcdFx0XHQvLyBkZXRlcm1pbmUgd2hldGhlciB0aGUgaW5wdXRzIGhhdmUgY2hhbmdlZCwgaW4gY2FzZSB0aGlzIGRlcGVuZHMgb25cbiAgXHRcdFx0Ly8gb3RoZXIgY29tcHV0ZWQgdmFsdWVzXG4gIFx0XHRcdGlmICh0aGlzLl9maXJzdFJ1biB8fCAhdGhpcy5oYXJkRGVwcy5sZW5ndGggJiYgIXRoaXMuc29mdERlcHMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0ZGVwZW5kZW5jeVZhbHVlc0NoYW5nZWQgPSB0cnVlO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFt0aGlzLmhhcmREZXBzLCB0aGlzLnNvZnREZXBzXS5mb3JFYWNoKGZ1bmN0aW9uIChkZXBzKSB7XG4gIFx0XHRcdFx0XHR2YXIga2V5cGF0aCwgdmFsdWUsIGk7XG5cbiAgXHRcdFx0XHRcdGlmIChkZXBlbmRlbmN5VmFsdWVzQ2hhbmdlZCkge1xuICBcdFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdGkgPSBkZXBzLmxlbmd0aDtcbiAgXHRcdFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRcdFx0a2V5cGF0aCA9IGRlcHNbaV07XG4gIFx0XHRcdFx0XHRcdHZhbHVlID0gX3RoaXMudmlld21vZGVsLmdldChrZXlwYXRoKTtcblxuICBcdFx0XHRcdFx0XHRpZiAoIWlzRXF1YWwodmFsdWUsIF90aGlzLmRlcFZhbHVlc1trZXlwYXRoLnN0cl0pKSB7XG4gIFx0XHRcdFx0XHRcdFx0X3RoaXMuZGVwVmFsdWVzW2tleXBhdGguc3RyXSA9IHZhbHVlO1xuICBcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY3lWYWx1ZXNDaGFuZ2VkID0gdHJ1ZTtcblxuICBcdFx0XHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH0pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGRlcGVuZGVuY3lWYWx1ZXNDaGFuZ2VkKSB7XG4gIFx0XHRcdFx0dGhpcy52aWV3bW9kZWwuY2FwdHVyZSgpO1xuXG4gIFx0XHRcdFx0dHJ5IHtcbiAgXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLmdldHRlcigpO1xuICBcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuICBcdFx0XHRcdFx0d2FybklmRGVidWcoXCJGYWlsZWQgdG8gY29tcHV0ZSBcXFwiJXNcXFwiXCIsIHRoaXMua2V5LnN0cik7XG4gIFx0XHRcdFx0XHRsb2dJZkRlYnVnKGVyci5zdGFjayB8fCBlcnIpO1xuXG4gIFx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdm9pZCAwO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdG5ld0RlcHMgPSB0aGlzLnZpZXdtb2RlbC5yZWxlYXNlKCk7XG4gIFx0XHRcdFx0ZGVwZW5kZW5jaWVzQ2hhbmdlZCA9IHRoaXMudXBkYXRlRGVwZW5kZW5jaWVzKG5ld0RlcHMpO1xuXG4gIFx0XHRcdFx0aWYgKGRlcGVuZGVuY2llc0NoYW5nZWQpIHtcbiAgXHRcdFx0XHRcdFt0aGlzLmhhcmREZXBzLCB0aGlzLnNvZnREZXBzXS5mb3JFYWNoKGZ1bmN0aW9uIChkZXBzKSB7XG4gIFx0XHRcdFx0XHRcdGRlcHMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRcdFx0XHRcdF90aGlzLmRlcFZhbHVlc1trZXlwYXRoLnN0cl0gPSBfdGhpcy52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuICBcdFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHRcdH0pO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZ2V0dGluZyA9IHRoaXMuX2ZpcnN0UnVuID0gZmFsc2U7XG4gIFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcbiAgXHR9LFxuXG4gIFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdGlmICh0aGlzLnNldHRpbmcpIHtcbiAgXHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghdGhpcy5zZXR0ZXIpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ29tcHV0ZWQgcHJvcGVydGllcyB3aXRob3V0IHNldHRlcnMgYXJlIHJlYWQtb25seS4gKFRoaXMgbWF5IGNoYW5nZSBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIFJhY3RpdmUhKVwiKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5zZXR0ZXIodmFsdWUpO1xuICBcdH0sXG5cbiAgXHR1cGRhdGVEZXBlbmRlbmNpZXM6IGZ1bmN0aW9uIChuZXdEZXBzKSB7XG4gIFx0XHR2YXIgaSwgb2xkRGVwcywga2V5cGF0aCwgZGVwZW5kZW5jaWVzQ2hhbmdlZCwgdW5yZXNvbHZlZDtcblxuICBcdFx0b2xkRGVwcyA9IHRoaXMuc29mdERlcHM7XG5cbiAgXHRcdC8vIHJlbW92ZSBkZXBlbmRlbmNpZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHVzZWRcbiAgXHRcdGkgPSBvbGREZXBzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0a2V5cGF0aCA9IG9sZERlcHNbaV07XG5cbiAgXHRcdFx0aWYgKG5ld0RlcHMuaW5kZXhPZihrZXlwYXRoKSA9PT0gLTEpIHtcbiAgXHRcdFx0XHRkZXBlbmRlbmNpZXNDaGFuZ2VkID0gdHJ1ZTtcbiAgXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC51bnJlZ2lzdGVyKGtleXBhdGgsIHRoaXMsIFwiY29tcHV0ZWRcIik7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gY3JlYXRlIHJlZmVyZW5jZXMgZm9yIGFueSBuZXcgZGVwZW5kZW5jaWVzXG4gIFx0XHRpID0gbmV3RGVwcy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGtleXBhdGggPSBuZXdEZXBzW2ldO1xuXG4gIFx0XHRcdGlmIChvbGREZXBzLmluZGV4T2Yoa2V5cGF0aCkgPT09IC0xICYmICghdGhpcy5oYXJkRGVwcyB8fCB0aGlzLmhhcmREZXBzLmluZGV4T2Yoa2V5cGF0aCkgPT09IC0xKSkge1xuICBcdFx0XHRcdGRlcGVuZGVuY2llc0NoYW5nZWQgPSB0cnVlO1xuXG4gIFx0XHRcdFx0Ly8gaWYgdGhpcyBrZXlwYXRoIGlzIGN1cnJlbnRseSB1bnJlc29sdmVkLCB3ZSBuZWVkIHRvIG1hcmtcbiAgXHRcdFx0XHQvLyBpdCBhcyBzdWNoLiBUT0RPIHRoaXMgaXMgYSBiaXQgbXVkZHkuLi5cbiAgXHRcdFx0XHRpZiAoaXNVbnJlc29sdmVkKHRoaXMudmlld21vZGVsLCBrZXlwYXRoKSAmJiAhdGhpcy51bnJlc29sdmVkRGVwc1trZXlwYXRoLnN0cl0pIHtcbiAgXHRcdFx0XHRcdHVucmVzb2x2ZWQgPSBuZXcgQ29tcHV0YXRpb25fVW5yZXNvbHZlZERlcGVuZGVuY3kodGhpcywga2V5cGF0aC5zdHIpO1xuICBcdFx0XHRcdFx0bmV3RGVwcy5zcGxpY2UoaSwgMSk7XG5cbiAgXHRcdFx0XHRcdHRoaXMudW5yZXNvbHZlZERlcHNba2V5cGF0aC5zdHJdID0gdW5yZXNvbHZlZDtcbiAgXHRcdFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFVucmVzb2x2ZWQodW5yZXNvbHZlZCk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdHRoaXMudmlld21vZGVsLnJlZ2lzdGVyKGtleXBhdGgsIHRoaXMsIFwiY29tcHV0ZWRcIik7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChkZXBlbmRlbmNpZXNDaGFuZ2VkKSB7XG4gIFx0XHRcdHRoaXMuc29mdERlcHMgPSBuZXdEZXBzLnNsaWNlKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBkZXBlbmRlbmNpZXNDaGFuZ2VkO1xuICBcdH1cbiAgfTtcblxuICBmdW5jdGlvbiBpc1VucmVzb2x2ZWQodmlld21vZGVsLCBrZXlwYXRoKSB7XG4gIFx0dmFyIGtleSA9IGtleXBhdGguZmlyc3RLZXk7XG5cbiAgXHRyZXR1cm4gIShrZXkgaW4gdmlld21vZGVsLmRhdGEpICYmICEoa2V5IGluIHZpZXdtb2RlbC5jb21wdXRhdGlvbnMpICYmICEoa2V5IGluIHZpZXdtb2RlbC5tYXBwaW5ncyk7XG4gIH1cblxuICB2YXIgQ29tcHV0YXRpb25fQ29tcHV0YXRpb24gPSBDb21wdXRhdGlvbjtcblxuICB2YXIgY29tcHV0ZSA9IFZpZXdtb2RlbCRjb21wdXRlO1xuICBmdW5jdGlvbiBWaWV3bW9kZWwkY29tcHV0ZShrZXksIHNpZ25hdHVyZSkge1xuICBcdHZhciBjb21wdXRhdGlvbiA9IG5ldyBDb21wdXRhdGlvbl9Db21wdXRhdGlvbihrZXksIHNpZ25hdHVyZSk7XG5cbiAgXHRpZiAodGhpcy5yZWFkeSkge1xuICBcdFx0Y29tcHV0YXRpb24uaW5pdCh0aGlzKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5jb21wdXRhdGlvbnNba2V5LnN0cl0gPSBjb21wdXRhdGlvbjtcbiAgfVxuXG4gIHZhciBGQUlMRURfTE9PS1VQID0geyBGQUlMRURfTE9PS1VQOiB0cnVlIH07XG5cbiAgdmFyIHZpZXdtb2RlbF9wcm90b3R5cGVfZ2V0ID0gVmlld21vZGVsJGdldDtcblxuICB2YXIgdmlld21vZGVsX3Byb3RvdHlwZV9nZXRfX2VtcHR5ID0ge307XG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRnZXQoa2V5cGF0aCwgb3B0aW9ucykge1xuICBcdHZhciBjYWNoZSA9IHRoaXMuY2FjaGUsXG4gIFx0ICAgIHZhbHVlLFxuICBcdCAgICBjb21wdXRhdGlvbixcbiAgXHQgICAgd3JhcHBlZCxcbiAgXHQgICAgY2FwdHVyZUdyb3VwLFxuICBcdCAgICBrZXlwYXRoU3RyID0ga2V5cGF0aC5zdHIsXG4gIFx0ICAgIGtleTtcblxuICBcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHZpZXdtb2RlbF9wcm90b3R5cGVfZ2V0X19lbXB0eTtcblxuICBcdC8vIGNhcHR1cmUgdGhlIGtleXBhdGgsIGlmIHdlJ3JlIGluc2lkZSBhIGNvbXB1dGF0aW9uXG4gIFx0aWYgKG9wdGlvbnMuY2FwdHVyZSAmJiAoY2FwdHVyZUdyb3VwID0gbGFzdEl0ZW0odGhpcy5jYXB0dXJlR3JvdXBzKSkpIHtcbiAgXHRcdGlmICghIH5jYXB0dXJlR3JvdXAuaW5kZXhPZihrZXlwYXRoKSkge1xuICBcdFx0XHRjYXB0dXJlR3JvdXAucHVzaChrZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoaGFzT3duLmNhbGwodGhpcy5tYXBwaW5ncywga2V5cGF0aC5maXJzdEtleSkpIHtcbiAgXHRcdHJldHVybiB0aGlzLm1hcHBpbmdzW2tleXBhdGguZmlyc3RLZXldLmdldChrZXlwYXRoLCBvcHRpb25zKTtcbiAgXHR9XG5cbiAgXHRpZiAoa2V5cGF0aC5pc1NwZWNpYWwpIHtcbiAgXHRcdHJldHVybiBrZXlwYXRoLnZhbHVlO1xuICBcdH1cblxuICBcdGlmIChjYWNoZVtrZXlwYXRoU3RyXSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgXHRcdC8vIElzIHRoaXMgYSBjb21wdXRlZCBwcm9wZXJ0eT9cbiAgXHRcdGlmICgoY29tcHV0YXRpb24gPSB0aGlzLmNvbXB1dGF0aW9uc1trZXlwYXRoU3RyXSkgJiYgIWNvbXB1dGF0aW9uLmJ5cGFzcykge1xuICBcdFx0XHR2YWx1ZSA9IGNvbXB1dGF0aW9uLmdldCgpO1xuICBcdFx0XHR0aGlzLmFkYXB0KGtleXBhdGhTdHIsIHZhbHVlKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gSXMgdGhpcyBhIHdyYXBwZWQgcHJvcGVydHk/XG4gIFx0XHRlbHNlIGlmICh3cmFwcGVkID0gdGhpcy53cmFwcGVkW2tleXBhdGhTdHJdKSB7XG4gIFx0XHRcdHZhbHVlID0gd3JhcHBlZC52YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gSXMgaXQgdGhlIHJvb3Q/XG4gIFx0XHRlbHNlIGlmIChrZXlwYXRoLmlzUm9vdCkge1xuICBcdFx0XHR0aGlzLmFkYXB0KFwiXCIsIHRoaXMuZGF0YSk7XG4gIFx0XHRcdHZhbHVlID0gdGhpcy5kYXRhO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBObz8gVGhlbiB3ZSBuZWVkIHRvIHJldHJpZXZlIHRoZSB2YWx1ZSBvbmUga2V5IGF0IGEgdGltZVxuICBcdFx0ZWxzZSB7XG4gIFx0XHRcdHZhbHVlID0gcmV0cmlldmUodGhpcywga2V5cGF0aCk7XG4gIFx0XHR9XG5cbiAgXHRcdGNhY2hlW2tleXBhdGhTdHJdID0gdmFsdWU7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHZhbHVlID0gY2FjaGVba2V5cGF0aFN0cl07XG4gIFx0fVxuXG4gIFx0aWYgKCFvcHRpb25zLm5vVW53cmFwICYmICh3cmFwcGVkID0gdGhpcy53cmFwcGVkW2tleXBhdGhTdHJdKSkge1xuICBcdFx0dmFsdWUgPSB3cmFwcGVkLmdldCgpO1xuICBcdH1cblxuICBcdGlmIChrZXlwYXRoLmlzUm9vdCAmJiBvcHRpb25zLmZ1bGxSb290R2V0KSB7XG4gIFx0XHRmb3IgKGtleSBpbiB0aGlzLm1hcHBpbmdzKSB7XG4gIFx0XHRcdHZhbHVlW2tleV0gPSB0aGlzLm1hcHBpbmdzW2tleV0uZ2V0VmFsdWUoKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdmFsdWUgPT09IEZBSUxFRF9MT09LVVAgPyB2b2lkIDAgOiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldHJpZXZlKHZpZXdtb2RlbCwga2V5cGF0aCkge1xuXG4gIFx0dmFyIHBhcmVudFZhbHVlLCBjYWNoZU1hcCwgdmFsdWUsIHdyYXBwZWQ7XG5cbiAgXHRwYXJlbnRWYWx1ZSA9IHZpZXdtb2RlbC5nZXQoa2V5cGF0aC5wYXJlbnQpO1xuXG4gIFx0aWYgKHdyYXBwZWQgPSB2aWV3bW9kZWwud3JhcHBlZFtrZXlwYXRoLnBhcmVudC5zdHJdKSB7XG4gIFx0XHRwYXJlbnRWYWx1ZSA9IHdyYXBwZWQuZ2V0KCk7XG4gIFx0fVxuXG4gIFx0aWYgKHBhcmVudFZhbHVlID09PSBudWxsIHx8IHBhcmVudFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHQvLyB1cGRhdGUgY2FjaGUgbWFwXG4gIFx0aWYgKCEoY2FjaGVNYXAgPSB2aWV3bW9kZWwuY2FjaGVNYXBba2V5cGF0aC5wYXJlbnQuc3RyXSkpIHtcbiAgXHRcdHZpZXdtb2RlbC5jYWNoZU1hcFtrZXlwYXRoLnBhcmVudC5zdHJdID0gW2tleXBhdGguc3RyXTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0aWYgKGNhY2hlTWFwLmluZGV4T2Yoa2V5cGF0aC5zdHIpID09PSAtMSkge1xuICBcdFx0XHRjYWNoZU1hcC5wdXNoKGtleXBhdGguc3RyKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBJZiB0aGlzIHByb3BlcnR5IGRvZXNuJ3QgZXhpc3QsIHdlIHJldHVybiBhIHNlbnRpbmVsIHZhbHVlXG4gIFx0Ly8gc28gdGhhdCB3ZSBrbm93IHRvIHF1ZXJ5IHBhcmVudCBzY29wZSAoaWYgc3VjaCB0aGVyZSBiZSlcbiAgXHRpZiAodHlwZW9mIHBhcmVudFZhbHVlID09PSBcIm9iamVjdFwiICYmICEoa2V5cGF0aC5sYXN0S2V5IGluIHBhcmVudFZhbHVlKSkge1xuICBcdFx0cmV0dXJuIHZpZXdtb2RlbC5jYWNoZVtrZXlwYXRoLnN0cl0gPSBGQUlMRURfTE9PS1VQO1xuICBcdH1cblxuICBcdHZhbHVlID0gcGFyZW50VmFsdWVba2V5cGF0aC5sYXN0S2V5XTtcblxuICBcdC8vIERvIHdlIGhhdmUgYW4gYWRhcHRvciBmb3IgdGhpcyB2YWx1ZT9cbiAgXHR2aWV3bW9kZWwuYWRhcHQoa2V5cGF0aC5zdHIsIHZhbHVlLCBmYWxzZSk7XG5cbiAgXHQvLyBVcGRhdGUgY2FjaGVcbiAgXHR2aWV3bW9kZWwuY2FjaGVba2V5cGF0aC5zdHJdID0gdmFsdWU7XG4gIFx0cmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgdmFyIHZpZXdtb2RlbF9wcm90b3R5cGVfaW5pdCA9IFZpZXdtb2RlbCRpbml0O1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRpbml0KCkge1xuICBcdHZhciBrZXk7XG5cbiAgXHRmb3IgKGtleSBpbiB0aGlzLmNvbXB1dGF0aW9ucykge1xuICBcdFx0dGhpcy5jb21wdXRhdGlvbnNba2V5XS5pbml0KHRoaXMpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfbWFwID0gVmlld21vZGVsJG1hcDtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkbWFwKGtleSwgb3B0aW9ucykge1xuICBcdHZhciBtYXBwaW5nID0gdGhpcy5tYXBwaW5nc1trZXkuc3RyXSA9IG5ldyBNYXBwaW5nKGtleSwgb3B0aW9ucyk7XG4gIFx0bWFwcGluZy5pbml0Vmlld21vZGVsKHRoaXMpO1xuICBcdHJldHVybiBtYXBwaW5nO1xuICB9XG5cbiAgdmFyIE1hcHBpbmcgPSBmdW5jdGlvbiAobG9jYWxLZXksIG9wdGlvbnMpIHtcbiAgXHR0aGlzLmxvY2FsS2V5ID0gbG9jYWxLZXk7XG4gIFx0dGhpcy5rZXlwYXRoID0gb3B0aW9ucy5rZXlwYXRoO1xuICBcdHRoaXMub3JpZ2luID0gb3B0aW9ucy5vcmlnaW47XG5cbiAgXHR0aGlzLmRlcHMgPSBbXTtcbiAgXHR0aGlzLnVucmVzb2x2ZWQgPSBbXTtcblxuICBcdHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcbiAgfTtcblxuICBNYXBwaW5nLnByb3RvdHlwZSA9IHtcbiAgXHRmb3JjZVJlc29sdXRpb246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIFRPRE8gd2FybiwgYXMgcGVyICMxNjkyP1xuICBcdFx0dGhpcy5rZXlwYXRoID0gdGhpcy5sb2NhbEtleTtcbiAgXHRcdHRoaXMuc2V0dXAoKTtcbiAgXHR9LFxuXG4gIFx0Z2V0OiBmdW5jdGlvbiAoa2V5cGF0aCwgb3B0aW9ucykge1xuICBcdFx0aWYgKCF0aGlzLnJlc29sdmVkKSB7XG4gIFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcy5vcmlnaW4uZ2V0KHRoaXMubWFwKGtleXBhdGgpLCBvcHRpb25zKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5rZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcy5vcmlnaW4uZ2V0KHRoaXMua2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdGluaXRWaWV3bW9kZWw6IGZ1bmN0aW9uICh2aWV3bW9kZWwpIHtcbiAgXHRcdHRoaXMubG9jYWwgPSB2aWV3bW9kZWw7XG4gIFx0XHR0aGlzLnNldHVwKCk7XG4gIFx0fSxcblxuICBcdG1hcDogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdGlmICh0eXBlb2YgdGhpcy5rZXlwYXRoID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMubG9jYWxLZXk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4ga2V5cGF0aC5yZXBsYWNlKHRoaXMubG9jYWxLZXksIHRoaXMua2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdHJlZ2lzdGVyOiBmdW5jdGlvbiAoa2V5cGF0aCwgZGVwZW5kYW50LCBncm91cCkge1xuICBcdFx0dGhpcy5kZXBzLnB1c2goeyBrZXlwYXRoOiBrZXlwYXRoLCBkZXA6IGRlcGVuZGFudCwgZ3JvdXA6IGdyb3VwIH0pO1xuXG4gIFx0XHRpZiAodGhpcy5yZXNvbHZlZCkge1xuICBcdFx0XHR0aGlzLm9yaWdpbi5yZWdpc3Rlcih0aGlzLm1hcChrZXlwYXRoKSwgZGVwZW5kYW50LCBncm91cCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlc29sdmU6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRpZiAodGhpcy5rZXlwYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy51bmJpbmQodHJ1ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0XHR0aGlzLnNldHVwKCk7XG4gIFx0fSxcblxuICBcdHNldDogZnVuY3Rpb24gKGtleXBhdGgsIHZhbHVlKSB7XG4gIFx0XHRpZiAoIXRoaXMucmVzb2x2ZWQpIHtcbiAgXHRcdFx0dGhpcy5mb3JjZVJlc29sdXRpb24oKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5vcmlnaW4uc2V0KHRoaXMubWFwKGtleXBhdGgpLCB2YWx1ZSk7XG4gIFx0fSxcblxuICBcdHNldHVwOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHRpZiAodGhpcy5rZXlwYXRoID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnJlc29sdmVkID0gdHJ1ZTtcblxuICBcdFx0Ly8gYWNjdW11bGF0ZWQgZGVwZW5kYW50cyBjYW4gbm93IGJlIHJlZ2lzdGVyZWRcbiAgXHRcdGlmICh0aGlzLmRlcHMubGVuZ3RoKSB7XG4gIFx0XHRcdHRoaXMuZGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gIFx0XHRcdFx0dmFyIGtleXBhdGggPSBfdGhpcy5tYXAoZC5rZXlwYXRoKTtcbiAgXHRcdFx0XHRfdGhpcy5vcmlnaW4ucmVnaXN0ZXIoa2V5cGF0aCwgZC5kZXAsIGQuZ3JvdXApO1xuXG4gIFx0XHRcdFx0Ly8gVE9ETyB0aGlzIGlzIGEgYml0IG9mIGEgcmVkIGZsYWcuLi4gYWxsIGRlcHMgc2hvdWxkIGJlIHRoZSBzYW1lP1xuICBcdFx0XHRcdGlmIChkLmRlcC5zZXRWYWx1ZSkge1xuICBcdFx0XHRcdFx0ZC5kZXAuc2V0VmFsdWUoX3RoaXMub3JpZ2luLmdldChrZXlwYXRoKSk7XG4gIFx0XHRcdFx0fSBlbHNlIGlmIChkLmRlcC5pbnZhbGlkYXRlKSB7XG4gIFx0XHRcdFx0XHRkLmRlcC5pbnZhbGlkYXRlKCk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkFuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQuIFBsZWFzZSByYWlzZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzIC0gdGhhbmtzIVwiKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0pO1xuXG4gIFx0XHRcdHRoaXMub3JpZ2luLm1hcmsodGhpcy5rZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0c2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0aWYgKCF0aGlzLmtleXBhdGgpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTWFwcGluZyBkb2VzIG5vdCBoYXZlIGtleXBhdGgsIGNhbm5vdCBzZXQgdmFsdWUuIFBsZWFzZSByYWlzZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzIC0gdGhhbmtzIVwiKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5vcmlnaW4uc2V0KHRoaXMua2V5cGF0aCwgdmFsdWUpO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uIChrZWVwTG9jYWwpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdGlmICgha2VlcExvY2FsKSB7XG4gIFx0XHRcdGRlbGV0ZSB0aGlzLmxvY2FsLm1hcHBpbmdzW3RoaXMubG9jYWxLZXldO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXRoaXMucmVzb2x2ZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmRlcHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICBcdFx0XHRfdGhpcy5vcmlnaW4udW5yZWdpc3RlcihfdGhpcy5tYXAoZC5rZXlwYXRoKSwgZC5kZXAsIGQuZ3JvdXApO1xuICBcdFx0fSk7XG5cbiAgXHRcdGlmICh0aGlzLnRyYWNrZXIpIHtcbiAgXHRcdFx0dGhpcy5vcmlnaW4udW5yZWdpc3Rlcih0aGlzLmtleXBhdGgsIHRoaXMudHJhY2tlcik7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVucmVnaXN0ZXI6IGZ1bmN0aW9uIChrZXlwYXRoLCBkZXBlbmRhbnQsIGdyb3VwKSB7XG4gIFx0XHR2YXIgZGVwcywgaTtcblxuICBcdFx0aWYgKCF0aGlzLnJlc29sdmVkKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0ZGVwcyA9IHRoaXMuZGVwcztcbiAgXHRcdGkgPSBkZXBzLmxlbmd0aDtcblxuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRpZiAoZGVwc1tpXS5kZXAgPT09IGRlcGVuZGFudCkge1xuICBcdFx0XHRcdGRlcHMuc3BsaWNlKGksIDEpO1xuICBcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHR0aGlzLm9yaWdpbi51bnJlZ2lzdGVyKHRoaXMubWFwKGtleXBhdGgpLCBkZXBlbmRhbnQsIGdyb3VwKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIG1hcmsgPSBWaWV3bW9kZWwkbWFyaztcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkbWFyayhrZXlwYXRoLCBvcHRpb25zKSB7XG4gIFx0dmFyIGNvbXB1dGF0aW9uLFxuICBcdCAgICBrZXlwYXRoU3RyID0ga2V5cGF0aC5zdHI7XG5cbiAgXHQvLyBpbXBsaWNpdCBjaGFuZ2VzIChpLmUuIGBmb28ubGVuZ3RoYCBvbiBgcmFjdGl2ZS5wdXNoKCdmb28nLDQyKWApXG4gIFx0Ly8gc2hvdWxkIG5vdCBiZSBwaWNrZWQgdXAgYnkgcGF0dGVybiBvYnNlcnZlcnNcbiAgXHRpZiAob3B0aW9ucykge1xuICBcdFx0aWYgKG9wdGlvbnMuaW1wbGljaXQpIHtcbiAgXHRcdFx0dGhpcy5pbXBsaWNpdENoYW5nZXNba2V5cGF0aFN0cl0gPSB0cnVlO1xuICBcdFx0fVxuICBcdFx0aWYgKG9wdGlvbnMubm9DYXNjYWRlKSB7XG4gIFx0XHRcdHRoaXMubm9DYXNjYWRlW2tleXBhdGhTdHJdID0gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoY29tcHV0YXRpb24gPSB0aGlzLmNvbXB1dGF0aW9uc1trZXlwYXRoU3RyXSkge1xuICBcdFx0Y29tcHV0YXRpb24uaW52YWxpZGF0ZSgpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmNoYW5nZXMuaW5kZXhPZihrZXlwYXRoKSA9PT0gLTEpIHtcbiAgXHRcdHRoaXMuY2hhbmdlcy5wdXNoKGtleXBhdGgpO1xuICBcdH1cblxuICBcdC8vIHBhc3Mgb24ga2VlcEV4aXN0aW5nV3JhcHBlciwgaWYgd2UgY2FuXG4gIFx0dmFyIGtlZXBFeGlzdGluZ1dyYXBwZXIgPSBvcHRpb25zID8gb3B0aW9ucy5rZWVwRXhpc3RpbmdXcmFwcGVyIDogZmFsc2U7XG5cbiAgXHR0aGlzLmNsZWFyQ2FjaGUoa2V5cGF0aFN0ciwga2VlcEV4aXN0aW5nV3JhcHBlcik7XG5cbiAgXHRpZiAodGhpcy5yZWFkeSkge1xuICBcdFx0dGhpcy5vbmNoYW5nZSgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBtYXBPbGRUb05ld0luZGV4ID0gZnVuY3Rpb24gKG9sZEFycmF5LCBuZXdBcnJheSkge1xuICBcdHZhciB1c2VkSW5kaWNlcywgZmlyc3RVbnVzZWRJbmRleCwgbmV3SW5kaWNlcywgY2hhbmdlZDtcblxuICBcdHVzZWRJbmRpY2VzID0ge307XG4gIFx0Zmlyc3RVbnVzZWRJbmRleCA9IDA7XG5cbiAgXHRuZXdJbmRpY2VzID0gb2xkQXJyYXkubWFwKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gIFx0XHR2YXIgaW5kZXgsIHN0YXJ0LCBsZW47XG5cbiAgXHRcdHN0YXJ0ID0gZmlyc3RVbnVzZWRJbmRleDtcbiAgXHRcdGxlbiA9IG5ld0FycmF5Lmxlbmd0aDtcblxuICBcdFx0ZG8ge1xuICBcdFx0XHRpbmRleCA9IG5ld0FycmF5LmluZGV4T2YoaXRlbSwgc3RhcnQpO1xuXG4gIFx0XHRcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcbiAgXHRcdFx0XHRyZXR1cm4gLTE7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRzdGFydCA9IGluZGV4ICsgMTtcbiAgXHRcdH0gd2hpbGUgKHVzZWRJbmRpY2VzW2luZGV4XSAmJiBzdGFydCA8IGxlbik7XG5cbiAgXHRcdC8vIGtlZXAgdHJhY2sgb2YgdGhlIGZpcnN0IHVudXNlZCBpbmRleCwgc28gd2UgZG9uJ3Qgc2VhcmNoXG4gIFx0XHQvLyB0aGUgd2hvbGUgb2YgbmV3QXJyYXkgZm9yIGVhY2ggaXRlbSBpbiBvbGRBcnJheSB1bm5lY2Vzc2FyaWx5XG4gIFx0XHRpZiAoaW5kZXggPT09IGZpcnN0VW51c2VkSW5kZXgpIHtcbiAgXHRcdFx0Zmlyc3RVbnVzZWRJbmRleCArPSAxO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoaW5kZXggIT09IGkpIHtcbiAgXHRcdFx0Y2hhbmdlZCA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdHVzZWRJbmRpY2VzW2luZGV4XSA9IHRydWU7XG4gIFx0XHRyZXR1cm4gaW5kZXg7XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gbmV3SW5kaWNlcztcbiAgfTtcblxuICB2YXIgbWVyZ2UgPSBWaWV3bW9kZWwkbWVyZ2U7XG5cbiAgdmFyIGNvbXBhcmF0b3JzID0ge307XG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRtZXJnZShrZXlwYXRoLCBjdXJyZW50QXJyYXksIGFycmF5LCBvcHRpb25zKSB7XG4gIFx0dmFyIG9sZEFycmF5LCBuZXdBcnJheSwgY29tcGFyYXRvciwgbmV3SW5kaWNlcztcblxuICBcdHRoaXMubWFyayhrZXlwYXRoKTtcblxuICBcdGlmIChvcHRpb25zICYmIG9wdGlvbnMuY29tcGFyZSkge1xuXG4gIFx0XHRjb21wYXJhdG9yID0gZ2V0Q29tcGFyYXRvckZ1bmN0aW9uKG9wdGlvbnMuY29tcGFyZSk7XG5cbiAgXHRcdHRyeSB7XG4gIFx0XHRcdG9sZEFycmF5ID0gY3VycmVudEFycmF5Lm1hcChjb21wYXJhdG9yKTtcbiAgXHRcdFx0bmV3QXJyYXkgPSBhcnJheS5tYXAoY29tcGFyYXRvcik7XG4gIFx0XHR9IGNhdGNoIChlcnIpIHtcbiAgXHRcdFx0Ly8gZmFsbGJhY2sgdG8gYW4gaWRlbnRpdHkgY2hlY2sgLSB3b3JzdCBjYXNlIHNjZW5hcmlvIHdlIGhhdmVcbiAgXHRcdFx0Ly8gdG8gZG8gbW9yZSBET00gbWFuaXB1bGF0aW9uIHRoYW4gd2UgdGhvdWdodC4uLlxuICBcdFx0XHR3YXJuSWZEZWJ1ZyhcIm1lcmdlKCk6IFxcXCIlc1xcXCIgY29tcGFyaXNvbiBmYWlsZWQuIEZhbGxpbmcgYmFjayB0byBpZGVudGl0eSBjaGVja2luZ1wiLCBrZXlwYXRoKTtcblxuICBcdFx0XHRvbGRBcnJheSA9IGN1cnJlbnRBcnJheTtcbiAgXHRcdFx0bmV3QXJyYXkgPSBhcnJheTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0b2xkQXJyYXkgPSBjdXJyZW50QXJyYXk7XG4gIFx0XHRuZXdBcnJheSA9IGFycmF5O1xuICBcdH1cblxuICBcdC8vIGZpbmQgbmV3IGluZGljZXMgZm9yIG1lbWJlcnMgb2Ygb2xkQXJyYXlcbiAgXHRuZXdJbmRpY2VzID0gbWFwT2xkVG9OZXdJbmRleChvbGRBcnJheSwgbmV3QXJyYXkpO1xuXG4gIFx0dGhpcy5zbWFydFVwZGF0ZShrZXlwYXRoLCBhcnJheSwgbmV3SW5kaWNlcywgY3VycmVudEFycmF5Lmxlbmd0aCAhPT0gYXJyYXkubGVuZ3RoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeShpdGVtKSB7XG4gIFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KGl0ZW0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q29tcGFyYXRvckZ1bmN0aW9uKGNvbXBhcmF0b3IpIHtcbiAgXHQvLyBJZiBgY29tcGFyZWAgaXMgYHRydWVgLCB3ZSB1c2UgSlNPTi5zdHJpbmdpZnkgdG8gY29tcGFyZVxuICBcdC8vIG9iamVjdHMgdGhhdCBhcmUgdGhlIHNhbWUgc2hhcGUsIGJ1dCBub24taWRlbnRpY2FsIC0gaS5lLlxuICBcdC8vIHsgZm9vOiAnYmFyJyB9ICE9PSB7IGZvbzogJ2JhcicgfVxuICBcdGlmIChjb21wYXJhdG9yID09PSB0cnVlKSB7XG4gIFx0XHRyZXR1cm4gc3RyaW5naWZ5O1xuICBcdH1cblxuICBcdGlmICh0eXBlb2YgY29tcGFyYXRvciA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0aWYgKCFjb21wYXJhdG9yc1tjb21wYXJhdG9yXSkge1xuICBcdFx0XHRjb21wYXJhdG9yc1tjb21wYXJhdG9yXSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGl0ZW1bY29tcGFyYXRvcl07XG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBjb21wYXJhdG9yc1tjb21wYXJhdG9yXTtcbiAgXHR9XG5cbiAgXHRpZiAodHlwZW9mIGNvbXBhcmF0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0cmV0dXJuIGNvbXBhcmF0b3I7XG4gIFx0fVxuXG4gIFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIGBjb21wYXJlYCBvcHRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uLCBvciBhIHN0cmluZyByZXByZXNlbnRpbmcgYW4gaWRlbnRpZnlpbmcgZmllbGQgKG9yIGB0cnVlYCB0byB1c2UgSlNPTi5zdHJpbmdpZnkpXCIpO1xuICB9XG5cbiAgdmFyIHJlZ2lzdGVyID0gVmlld21vZGVsJHJlZ2lzdGVyO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRyZWdpc3RlcihrZXlwYXRoLCBkZXBlbmRhbnQpIHtcbiAgXHR2YXIgZ3JvdXAgPSBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IFwiZGVmYXVsdFwiIDogYXJndW1lbnRzWzJdO1xuXG4gIFx0dmFyIG1hcHBpbmcsIGRlcHNCeUtleXBhdGgsIGRlcHM7XG5cbiAgXHRpZiAoZGVwZW5kYW50LmlzU3RhdGljKSB7XG4gIFx0XHRyZXR1cm47IC8vIFRPRE8gd2Ugc2hvdWxkIG5ldmVyIGdldCBoZXJlIGlmIGEgZGVwZW5kYW50IGlzIHN0YXRpYy4uLlxuICBcdH1cblxuICBcdGlmIChtYXBwaW5nID0gdGhpcy5tYXBwaW5nc1trZXlwYXRoLmZpcnN0S2V5XSkge1xuICBcdFx0bWFwcGluZy5yZWdpc3RlcihrZXlwYXRoLCBkZXBlbmRhbnQsIGdyb3VwKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0ZGVwc0J5S2V5cGF0aCA9IHRoaXMuZGVwc1tncm91cF0gfHwgKHRoaXMuZGVwc1tncm91cF0gPSB7fSk7XG4gIFx0XHRkZXBzID0gZGVwc0J5S2V5cGF0aFtrZXlwYXRoLnN0cl0gfHwgKGRlcHNCeUtleXBhdGhba2V5cGF0aC5zdHJdID0gW10pO1xuXG4gIFx0XHRkZXBzLnB1c2goZGVwZW5kYW50KTtcblxuICBcdFx0aWYgKCF0aGlzLmRlcHNNYXBbZ3JvdXBdKSB7XG4gIFx0XHRcdHRoaXMuZGVwc01hcFtncm91cF0gPSB7fTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFrZXlwYXRoLmlzUm9vdCkge1xuICBcdFx0XHRyZWdpc3Rlcl9fdXBkYXRlRGVwZW5kYW50c01hcCh0aGlzLCBrZXlwYXRoLCBncm91cCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJfX3VwZGF0ZURlcGVuZGFudHNNYXAodmlld21vZGVsLCBrZXlwYXRoLCBncm91cCkge1xuICBcdHZhciBtYXAsIHBhcmVudCwga2V5cGF0aFN0cjtcblxuICBcdC8vIHVwZGF0ZSBkZXBlbmRhbnRzIG1hcFxuICBcdHdoaWxlICgha2V5cGF0aC5pc1Jvb3QpIHtcbiAgXHRcdG1hcCA9IHZpZXdtb2RlbC5kZXBzTWFwW2dyb3VwXTtcbiAgXHRcdHBhcmVudCA9IG1hcFtrZXlwYXRoLnBhcmVudC5zdHJdIHx8IChtYXBba2V5cGF0aC5wYXJlbnQuc3RyXSA9IFtdKTtcblxuICBcdFx0a2V5cGF0aFN0ciA9IGtleXBhdGguc3RyO1xuXG4gIFx0XHQvLyBUT0RPIGZpbmQgYW4gYWx0ZXJuYXRpdmUgdG8gdGhpcyBuYXN0eSBhcHByb2FjaFxuICBcdFx0aWYgKHBhcmVudFtcIl9cIiArIGtleXBhdGhTdHJdID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cGFyZW50W1wiX1wiICsga2V5cGF0aFN0cl0gPSAwO1xuICBcdFx0XHRwYXJlbnQucHVzaChrZXlwYXRoKTtcbiAgXHRcdH1cblxuICBcdFx0cGFyZW50W1wiX1wiICsga2V5cGF0aFN0cl0gKz0gMTtcbiAgXHRcdGtleXBhdGggPSBrZXlwYXRoLnBhcmVudDtcbiAgXHR9XG4gIH1cblxuICB2YXIgcmVsZWFzZSA9IFZpZXdtb2RlbCRyZWxlYXNlO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRyZWxlYXNlKCkge1xuICBcdHJldHVybiB0aGlzLmNhcHR1cmVHcm91cHMucG9wKCk7XG4gIH1cblxuICB2YXIgcmVzZXQgPSBWaWV3bW9kZWwkcmVzZXQ7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJHJlc2V0KGRhdGEpIHtcbiAgXHR0aGlzLmRhdGEgPSBkYXRhO1xuICBcdHRoaXMuY2xlYXJDYWNoZShcIlwiKTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfc2V0ID0gVmlld21vZGVsJHNldDtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkc2V0KGtleXBhdGgsIHZhbHVlKSB7XG4gIFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzJdO1xuXG4gIFx0dmFyIG1hcHBpbmcsIGNvbXB1dGF0aW9uLCB3cmFwcGVyLCBrZWVwRXhpc3RpbmdXcmFwcGVyO1xuXG4gIFx0Ly8gdW5sZXNzIGRhdGEgaXMgYmVpbmcgc2V0IGZvciBkYXRhIHRyYWNraW5nIHB1cnBvc2VzXG4gIFx0aWYgKCFvcHRpb25zLm5vTWFwcGluZykge1xuICBcdFx0Ly8gSWYgdGhpcyBkYXRhIGJlbG9uZ3MgdG8gYSBkaWZmZXJlbnQgdmlld21vZGVsLFxuICBcdFx0Ly8gcGFzcyB0aGUgY2hhbmdlIGFsb25nXG4gIFx0XHRpZiAobWFwcGluZyA9IHRoaXMubWFwcGluZ3Nba2V5cGF0aC5maXJzdEtleV0pIHtcbiAgXHRcdFx0cmV0dXJuIG1hcHBpbmcuc2V0KGtleXBhdGgsIHZhbHVlKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRjb21wdXRhdGlvbiA9IHRoaXMuY29tcHV0YXRpb25zW2tleXBhdGguc3RyXTtcbiAgXHRpZiAoY29tcHV0YXRpb24pIHtcbiAgXHRcdGlmIChjb21wdXRhdGlvbi5zZXR0aW5nKSB7XG4gIFx0XHRcdC8vIGxldCB0aGUgb3RoZXIgY29tcHV0YXRpb24gc2V0KCkgaGFuZGxlIHRoaW5ncy4uLlxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0XHRjb21wdXRhdGlvbi5zZXQodmFsdWUpO1xuICBcdFx0dmFsdWUgPSBjb21wdXRhdGlvbi5nZXQoKTtcbiAgXHR9XG5cbiAgXHRpZiAoaXNFcXVhbCh0aGlzLmNhY2hlW2tleXBhdGguc3RyXSwgdmFsdWUpKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0d3JhcHBlciA9IHRoaXMud3JhcHBlZFtrZXlwYXRoLnN0cl07XG5cbiAgXHQvLyBJZiB3ZSBoYXZlIGEgd3JhcHBlciB3aXRoIGEgYHJlc2V0KClgIG1ldGhvZCwgd2UgdHJ5IGFuZCB1c2UgaXQuIElmIHRoZVxuICBcdC8vIGByZXNldCgpYCBtZXRob2QgcmV0dXJucyBmYWxzZSwgdGhlIHdyYXBwZXIgc2hvdWxkIGJlIHRvcm4gZG93biwgYW5kXG4gIFx0Ly8gKG1vc3QgbGlrZWx5KSBhIG5ldyBvbmUgc2hvdWxkIGJlIGNyZWF0ZWQgbGF0ZXJcbiAgXHRpZiAod3JhcHBlciAmJiB3cmFwcGVyLnJlc2V0KSB7XG4gIFx0XHRrZWVwRXhpc3RpbmdXcmFwcGVyID0gd3JhcHBlci5yZXNldCh2YWx1ZSkgIT09IGZhbHNlO1xuXG4gIFx0XHRpZiAoa2VlcEV4aXN0aW5nV3JhcHBlcikge1xuICBcdFx0XHR2YWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKCFjb21wdXRhdGlvbiAmJiAha2VlcEV4aXN0aW5nV3JhcHBlcikge1xuICBcdFx0cmVzb2x2ZVNldCh0aGlzLCBrZXlwYXRoLCB2YWx1ZSk7XG4gIFx0fVxuXG4gIFx0aWYgKCFvcHRpb25zLnNpbGVudCkge1xuICBcdFx0dGhpcy5tYXJrKGtleXBhdGgpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHQvLyBXZSdyZSBzZXR0aW5nIGEgcGFyZW50IG9mIHRoZSBvcmlnaW5hbCB0YXJnZXQga2V5cGF0aCAoaS5lLlxuICBcdFx0Ly8gY3JlYXRpbmcgYSBmcmVzaCBicmFuY2gpIC0gd2UgbmVlZCB0byBjbGVhciB0aGUgY2FjaGUsIGJ1dFxuICBcdFx0Ly8gbm90IG1hcmsgaXQgYXMgYSBjaGFuZ2VcbiAgXHRcdHRoaXMuY2xlYXJDYWNoZShrZXlwYXRoLnN0cik7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVNldCh2aWV3bW9kZWwsIGtleXBhdGgsIHZhbHVlKSB7XG4gIFx0dmFyIHdyYXBwZXIsIHBhcmVudFZhbHVlLCB3cmFwcGVyU2V0LCB2YWx1ZVNldDtcblxuICBcdHdyYXBwZXJTZXQgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAod3JhcHBlci5zZXQpIHtcbiAgXHRcdFx0d3JhcHBlci5zZXQoa2V5cGF0aC5sYXN0S2V5LCB2YWx1ZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRwYXJlbnRWYWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG4gIFx0XHRcdHZhbHVlU2V0KCk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdHZhbHVlU2V0ID0gZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCFwYXJlbnRWYWx1ZSkge1xuICBcdFx0XHRwYXJlbnRWYWx1ZSA9IGNyZWF0ZUJyYW5jaChrZXlwYXRoLmxhc3RLZXkpO1xuICBcdFx0XHR2aWV3bW9kZWwuc2V0KGtleXBhdGgucGFyZW50LCBwYXJlbnRWYWx1ZSwgeyBzaWxlbnQ6IHRydWUgfSk7XG4gIFx0XHR9XG4gIFx0XHRwYXJlbnRWYWx1ZVtrZXlwYXRoLmxhc3RLZXldID0gdmFsdWU7XG4gIFx0fTtcblxuICBcdHdyYXBwZXIgPSB2aWV3bW9kZWwud3JhcHBlZFtrZXlwYXRoLnBhcmVudC5zdHJdO1xuXG4gIFx0aWYgKHdyYXBwZXIpIHtcbiAgXHRcdHdyYXBwZXJTZXQoKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cGFyZW50VmFsdWUgPSB2aWV3bW9kZWwuZ2V0KGtleXBhdGgucGFyZW50KTtcblxuICBcdFx0Ly8gbWF5IGhhdmUgYmVlbiB3cmFwcGVkIHZpYSB0aGUgYWJvdmUgLmdldCgpXG4gIFx0XHQvLyBjYWxsIG9uIHZpZXdtb2RlbCBpZiB0aGlzIGlzIGZpcnN0IGFjY2VzcyB2aWEgLnNldCgpIVxuICBcdFx0aWYgKHdyYXBwZXIgPSB2aWV3bW9kZWwud3JhcHBlZFtrZXlwYXRoLnBhcmVudC5zdHJdKSB7XG4gIFx0XHRcdHdyYXBwZXJTZXQoKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHZhbHVlU2V0KCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIHNtYXJ0VXBkYXRlID0gVmlld21vZGVsJHNtYXJ0VXBkYXRlO1xuXG4gIHZhciBpbXBsaWNpdE9wdGlvbiA9IHsgaW1wbGljaXQ6IHRydWUgfSxcbiAgICAgIG5vQ2FzY2FkZU9wdGlvbiA9IHsgbm9DYXNjYWRlOiB0cnVlIH07XG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRzbWFydFVwZGF0ZShrZXlwYXRoLCBhcnJheSwgbmV3SW5kaWNlcykge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgZGVwZW5kYW50cywgb2xkTGVuZ3RoLCBpO1xuXG4gIFx0b2xkTGVuZ3RoID0gbmV3SW5kaWNlcy5sZW5ndGg7XG5cbiAgXHQvLyBJbmRpY2VzIHRoYXQgYXJlIGJlaW5nIHJlbW92ZWQgc2hvdWxkIGJlIG1hcmtlZCBhcyBkaXJ0eVxuICBcdG5ld0luZGljZXMuZm9yRWFjaChmdW5jdGlvbiAobmV3SW5kZXgsIG9sZEluZGV4KSB7XG4gIFx0XHRpZiAobmV3SW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdF90aGlzLm1hcmsoa2V5cGF0aC5qb2luKG9sZEluZGV4KSwgbm9DYXNjYWRlT3B0aW9uKTtcbiAgXHRcdH1cbiAgXHR9KTtcblxuICBcdC8vIFVwZGF0ZSB0aGUgbW9kZWxcbiAgXHQvLyBUT0RPIGFsbG93IGV4aXN0aW5nIGFycmF5IHRvIGJlIHVwZGF0ZWQgaW4gcGxhY2UsIHJhdGhlciB0aGFuIHJlcGxhY2VkP1xuICBcdHRoaXMuc2V0KGtleXBhdGgsIGFycmF5LCB7IHNpbGVudDogdHJ1ZSB9KTtcblxuICBcdGlmIChkZXBlbmRhbnRzID0gdGhpcy5kZXBzW1wiZGVmYXVsdFwiXVtrZXlwYXRoLnN0cl0pIHtcbiAgXHRcdGRlcGVuZGFudHMuZmlsdGVyKGNhblNodWZmbGUpLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgXHRcdFx0cmV0dXJuIGQuc2h1ZmZsZShuZXdJbmRpY2VzLCBhcnJheSk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRpZiAob2xkTGVuZ3RoICE9PSBhcnJheS5sZW5ndGgpIHtcbiAgXHRcdHRoaXMubWFyayhrZXlwYXRoLmpvaW4oXCJsZW5ndGhcIiksIGltcGxpY2l0T3B0aW9uKTtcblxuICBcdFx0Zm9yIChpID0gbmV3SW5kaWNlcy50b3VjaGVkRnJvbTsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRcdHRoaXMubWFyayhrZXlwYXRoLmpvaW4oaSkpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBkb24ndCBhbGxvdyByZW1vdmVkIGluZGV4ZXMgYmV5b25kIGVuZCBvZiBuZXcgYXJyYXkgdG8gdHJpZ2dlciByZWNvbXB1dGF0aW9uc1xuICBcdFx0Ly8gVE9ETyBpcyB0aGlzIHN0aWxsIG5lY2Vzc2FyeSwgbm93IHRoYXQgY29tcHV0YXRpb25zIGFyZSBsYXp5P1xuICBcdFx0Zm9yIChpID0gYXJyYXkubGVuZ3RoOyBpIDwgb2xkTGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdFx0dGhpcy5tYXJrKGtleXBhdGguam9pbihpKSwgbm9DYXNjYWRlT3B0aW9uKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBjYW5TaHVmZmxlKGRlcGVuZGFudCkge1xuICBcdHJldHVybiB0eXBlb2YgZGVwZW5kYW50LnNodWZmbGUgPT09IFwiZnVuY3Rpb25cIjtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfdGVhcmRvd24gPSBWaWV3bW9kZWwkdGVhcmRvd247XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJHRlYXJkb3duKCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgdW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeTtcblxuICBcdC8vIENsZWFyIGVudGlyZSBjYWNoZSAtIHRoaXMgaGFzIHRoZSBkZXNpcmVkIHNpZGUtZWZmZWN0XG4gIFx0Ly8gb2YgdW53cmFwcGluZyBhZGFwdGVkIHZhbHVlcyAoZS5nLiBhcnJheXMpXG4gIFx0T2JqZWN0LmtleXModGhpcy5jYWNoZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0cmV0dXJuIF90aGlzLmNsZWFyQ2FjaGUoa2V5cGF0aCk7XG4gIFx0fSk7XG5cbiAgXHQvLyBUZWFyZG93biBhbnkgZmFpbGVkIGxvb2t1cHMgLSB3ZSBkb24ndCBuZWVkIHRoZW0gdG8gcmVzb2x2ZSBhbnkgbW9yZVxuICBcdHdoaWxlICh1bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5ID0gdGhpcy51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXMucG9wKCkpIHtcbiAgXHRcdHVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kudGVhcmRvd24oKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgdW5yZWdpc3RlciA9IFZpZXdtb2RlbCR1bnJlZ2lzdGVyO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCR1bnJlZ2lzdGVyKGtleXBhdGgsIGRlcGVuZGFudCkge1xuICBcdHZhciBncm91cCA9IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gXCJkZWZhdWx0XCIgOiBhcmd1bWVudHNbMl07XG5cbiAgXHR2YXIgbWFwcGluZywgZGVwcywgaW5kZXg7XG5cbiAgXHRpZiAoZGVwZW5kYW50LmlzU3RhdGljKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKG1hcHBpbmcgPSB0aGlzLm1hcHBpbmdzW2tleXBhdGguZmlyc3RLZXldKSB7XG4gIFx0XHRyZXR1cm4gbWFwcGluZy51bnJlZ2lzdGVyKGtleXBhdGgsIGRlcGVuZGFudCwgZ3JvdXApO1xuICBcdH1cblxuICBcdGRlcHMgPSB0aGlzLmRlcHNbZ3JvdXBdW2tleXBhdGguc3RyXTtcbiAgXHRpbmRleCA9IGRlcHMuaW5kZXhPZihkZXBlbmRhbnQpO1xuXG4gIFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIHJlbW92ZSBhIGRlcGVuZGFudCB0aGF0IHdhcyBubyBsb25nZXIgcmVnaXN0ZXJlZCEgVGhpcyBzaG91bGQgbm90IGhhcHBlbi4gSWYgeW91IGFyZSBzZWVpbmcgdGhpcyBidWcgaW4gZGV2ZWxvcG1lbnQgcGxlYXNlIHJhaXNlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9SYWN0aXZlSlMvUmFjdGl2ZS9pc3N1ZXMgLSB0aGFua3NcIik7XG4gIFx0fVxuXG4gIFx0ZGVwcy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gIFx0aWYgKGtleXBhdGguaXNSb290KSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0dW5yZWdpc3Rlcl9fdXBkYXRlRGVwZW5kYW50c01hcCh0aGlzLCBrZXlwYXRoLCBncm91cCk7XG4gIH1cblxuICBmdW5jdGlvbiB1bnJlZ2lzdGVyX191cGRhdGVEZXBlbmRhbnRzTWFwKHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXApIHtcbiAgXHR2YXIgbWFwLCBwYXJlbnQ7XG5cbiAgXHQvLyB1cGRhdGUgZGVwZW5kYW50cyBtYXBcbiAgXHR3aGlsZSAoIWtleXBhdGguaXNSb290KSB7XG4gIFx0XHRtYXAgPSB2aWV3bW9kZWwuZGVwc01hcFtncm91cF07XG4gIFx0XHRwYXJlbnQgPSBtYXBba2V5cGF0aC5wYXJlbnQuc3RyXTtcblxuICBcdFx0cGFyZW50W1wiX1wiICsga2V5cGF0aC5zdHJdIC09IDE7XG5cbiAgXHRcdGlmICghcGFyZW50W1wiX1wiICsga2V5cGF0aC5zdHJdKSB7XG4gIFx0XHRcdC8vIHJlbW92ZSBmcm9tIHBhcmVudCBkZXBzIG1hcFxuICBcdFx0XHRyZW1vdmVGcm9tQXJyYXkocGFyZW50LCBrZXlwYXRoKTtcbiAgXHRcdFx0cGFyZW50W1wiX1wiICsga2V5cGF0aC5zdHJdID0gdW5kZWZpbmVkO1xuICBcdFx0fVxuXG4gIFx0XHRrZXlwYXRoID0ga2V5cGF0aC5wYXJlbnQ7XG4gIFx0fVxuICB9XG5cbiAgdmFyIFZpZXdtb2RlbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dmFyIGFkYXB0ID0gb3B0aW9ucy5hZGFwdDtcbiAgXHR2YXIgZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgXHR2YXIgcmFjdGl2ZSA9IG9wdGlvbnMucmFjdGl2ZTtcbiAgXHR2YXIgY29tcHV0ZWQgPSBvcHRpb25zLmNvbXB1dGVkO1xuICBcdHZhciBtYXBwaW5ncyA9IG9wdGlvbnMubWFwcGluZ3M7XG4gIFx0dmFyIGtleTtcbiAgXHR2YXIgbWFwcGluZztcblxuICBcdC8vIFRPRE8gaXMgaXQgcG9zc2libGUgdG8gcmVtb3ZlIHRoaXMgcmVmZXJlbmNlP1xuICBcdHRoaXMucmFjdGl2ZSA9IHJhY3RpdmU7XG5cbiAgXHR0aGlzLmFkYXB0b3JzID0gYWRhcHQ7XG4gIFx0dGhpcy5vbmNoYW5nZSA9IG9wdGlvbnMub25jaGFuZ2U7XG5cbiAgXHR0aGlzLmNhY2hlID0ge307IC8vIHdlIG5lZWQgdG8gYmUgYWJsZSB0byB1c2UgaGFzT3duUHJvcGVydHksIHNvIGNhbid0IGluaGVyaXQgZnJvbSBudWxsXG4gIFx0dGhpcy5jYWNoZU1hcCA9IGNyZWF0ZShudWxsKTtcblxuICBcdHRoaXMuZGVwcyA9IHtcbiAgXHRcdGNvbXB1dGVkOiBjcmVhdGUobnVsbCksXG4gIFx0XHRcImRlZmF1bHRcIjogY3JlYXRlKG51bGwpXG4gIFx0fTtcbiAgXHR0aGlzLmRlcHNNYXAgPSB7XG4gIFx0XHRjb21wdXRlZDogY3JlYXRlKG51bGwpLFxuICBcdFx0XCJkZWZhdWx0XCI6IGNyZWF0ZShudWxsKVxuICBcdH07XG5cbiAgXHR0aGlzLnBhdHRlcm5PYnNlcnZlcnMgPSBbXTtcblxuICBcdHRoaXMuc3BlY2lhbHMgPSBjcmVhdGUobnVsbCk7XG5cbiAgXHR0aGlzLndyYXBwZWQgPSBjcmVhdGUobnVsbCk7XG4gIFx0dGhpcy5jb21wdXRhdGlvbnMgPSBjcmVhdGUobnVsbCk7XG5cbiAgXHR0aGlzLmNhcHR1cmVHcm91cHMgPSBbXTtcbiAgXHR0aGlzLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llcyA9IFtdO1xuXG4gIFx0dGhpcy5jaGFuZ2VzID0gW107XG4gIFx0dGhpcy5pbXBsaWNpdENoYW5nZXMgPSB7fTtcbiAgXHR0aGlzLm5vQ2FzY2FkZSA9IHt9O1xuXG4gIFx0dGhpcy5kYXRhID0gZGF0YTtcblxuICBcdC8vIHNldCB1cCBleHBsaWNpdCBtYXBwaW5nc1xuICBcdHRoaXMubWFwcGluZ3MgPSBjcmVhdGUobnVsbCk7XG4gIFx0Zm9yIChrZXkgaW4gbWFwcGluZ3MpIHtcbiAgXHRcdHRoaXMubWFwKGdldEtleXBhdGgoa2V5KSwgbWFwcGluZ3Nba2V5XSk7XG4gIFx0fVxuXG4gIFx0aWYgKGRhdGEpIHtcbiAgXHRcdC8vIGlmIGRhdGEgZXhpc3RzIGxvY2FsbHksIGJ1dCBpcyBtaXNzaW5nIG9uIHRoZSBwYXJlbnQsXG4gIFx0XHQvLyB3ZSB0cmFuc2ZlciBvd25lcnNoaXAgdG8gdGhlIHBhcmVudFxuICBcdFx0Zm9yIChrZXkgaW4gZGF0YSkge1xuICBcdFx0XHRpZiAoKG1hcHBpbmcgPSB0aGlzLm1hcHBpbmdzW2tleV0pICYmIG1hcHBpbmcuZ2V0VmFsdWUoKSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0bWFwcGluZy5zZXRWYWx1ZShkYXRhW2tleV0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Zm9yIChrZXkgaW4gY29tcHV0ZWQpIHtcbiAgXHRcdGlmIChtYXBwaW5ncyAmJiBrZXkgaW4gbWFwcGluZ3MpIHtcbiAgXHRcdFx0ZmF0YWwoXCJDYW5ub3QgbWFwIHRvIGEgY29tcHV0ZWQgcHJvcGVydHkgKCclcycpXCIsIGtleSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuY29tcHV0ZShnZXRLZXlwYXRoKGtleSksIGNvbXB1dGVkW2tleV0pO1xuICBcdH1cblxuICBcdHRoaXMucmVhZHkgPSB0cnVlO1xuICB9O1xuXG4gIFZpZXdtb2RlbC5wcm90b3R5cGUgPSB7XG4gIFx0YWRhcHQ6IHByb3RvdHlwZV9hZGFwdCxcbiAgXHRhcHBseUNoYW5nZXM6IGFwcGx5Q2hhbmdlcyxcbiAgXHRjYXB0dXJlOiBjYXB0dXJlLFxuICBcdGNsZWFyQ2FjaGU6IGNsZWFyQ2FjaGUsXG4gIFx0Y29tcHV0ZTogY29tcHV0ZSxcbiAgXHRnZXQ6IHZpZXdtb2RlbF9wcm90b3R5cGVfZ2V0LFxuICBcdGluaXQ6IHZpZXdtb2RlbF9wcm90b3R5cGVfaW5pdCxcbiAgXHRtYXA6IHByb3RvdHlwZV9tYXAsXG4gIFx0bWFyazogbWFyayxcbiAgXHRtZXJnZTogbWVyZ2UsXG4gIFx0cmVnaXN0ZXI6IHJlZ2lzdGVyLFxuICBcdHJlbGVhc2U6IHJlbGVhc2UsXG4gIFx0cmVzZXQ6IHJlc2V0LFxuICBcdHNldDogcHJvdG90eXBlX3NldCxcbiAgXHRzbWFydFVwZGF0ZTogc21hcnRVcGRhdGUsXG4gIFx0dGVhcmRvd246IHByb3RvdHlwZV90ZWFyZG93bixcbiAgXHR1bnJlZ2lzdGVyOiB1bnJlZ2lzdGVyXG4gIH07XG5cbiAgdmFyIHZpZXdtb2RlbF9WaWV3bW9kZWwgPSBWaWV3bW9kZWw7XG5cbiAgZnVuY3Rpb24gSG9va1F1ZXVlKGV2ZW50KSB7XG4gIFx0dGhpcy5ob29rID0gbmV3IGhvb2tzX0hvb2soZXZlbnQpO1xuICBcdHRoaXMuaW5Qcm9jZXNzID0ge307XG4gIFx0dGhpcy5xdWV1ZSA9IHt9O1xuICB9XG5cbiAgSG9va1F1ZXVlLnByb3RvdHlwZSA9IHtcblxuICBcdGNvbnN0cnVjdG9yOiBIb29rUXVldWUsXG5cbiAgXHRiZWdpbjogZnVuY3Rpb24gKHJhY3RpdmUpIHtcbiAgXHRcdHRoaXMuaW5Qcm9jZXNzW3JhY3RpdmUuX2d1aWRdID0gdHJ1ZTtcbiAgXHR9LFxuXG4gIFx0ZW5kOiBmdW5jdGlvbiAocmFjdGl2ZSkge1xuXG4gIFx0XHR2YXIgcGFyZW50ID0gcmFjdGl2ZS5wYXJlbnQ7XG5cbiAgXHRcdC8vIElmIHRoaXMgaXMgKmlzbid0KiBhIGNoaWxkIG9mIGEgY29tcG9uZW50IHRoYXQncyBpbiBwcm9jZXNzLFxuICBcdFx0Ly8gaXQgc2hvdWxkIGNhbGwgbWV0aG9kcyBvciBmaXJlIGF0IHRoaXMgcG9pbnRcbiAgXHRcdGlmICghcGFyZW50IHx8ICF0aGlzLmluUHJvY2Vzc1twYXJlbnQuX2d1aWRdKSB7XG4gIFx0XHRcdGZpcmUodGhpcywgcmFjdGl2ZSk7XG4gIFx0XHR9XG4gIFx0XHQvLyBlbHNld2lzZSwgaGFuZG9mZiB0byBwYXJlbnQgdG8gZmlyZSB3aGVuIHJlYWR5XG4gIFx0XHRlbHNlIHtcbiAgXHRcdFx0Z2V0Q2hpbGRRdWV1ZSh0aGlzLnF1ZXVlLCBwYXJlbnQpLnB1c2gocmFjdGl2ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdGRlbGV0ZSB0aGlzLmluUHJvY2Vzc1tyYWN0aXZlLl9ndWlkXTtcbiAgXHR9XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0Q2hpbGRRdWV1ZShxdWV1ZSwgcmFjdGl2ZSkge1xuICBcdHJldHVybiBxdWV1ZVtyYWN0aXZlLl9ndWlkXSB8fCAocXVldWVbcmFjdGl2ZS5fZ3VpZF0gPSBbXSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlKGhvb2tRdWV1ZSwgcmFjdGl2ZSkge1xuXG4gIFx0dmFyIGNoaWxkUXVldWUgPSBnZXRDaGlsZFF1ZXVlKGhvb2tRdWV1ZS5xdWV1ZSwgcmFjdGl2ZSk7XG5cbiAgXHRob29rUXVldWUuaG9vay5maXJlKHJhY3RpdmUpO1xuXG4gIFx0Ly8gcXVldWUgaXMgXCJsaXZlXCIgYmVjYXVzZSBjb21wb25lbnRzIGNhbiBlbmQgdXAgYmVpbmdcbiAgXHQvLyBhZGRlZCB3aGlsZSBob29rcyBmaXJlIG9uIHBhcmVudHMgdGhhdCBtb2RpZnkgZGF0YSB2YWx1ZXMuXG4gIFx0d2hpbGUgKGNoaWxkUXVldWUubGVuZ3RoKSB7XG4gIFx0XHRmaXJlKGhvb2tRdWV1ZSwgY2hpbGRRdWV1ZS5zaGlmdCgpKTtcbiAgXHR9XG5cbiAgXHRkZWxldGUgaG9va1F1ZXVlLnF1ZXVlW3JhY3RpdmUuX2d1aWRdO1xuICB9XG5cbiAgdmFyIGhvb2tzX0hvb2tRdWV1ZSA9IEhvb2tRdWV1ZTtcblxuICB2YXIgaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXMgPSBnZXRDb21wdXRhdGlvblNpZ25hdHVyZXM7XG5cbiAgdmFyIGhlbHBlcnNfZ2V0Q29tcHV0YXRpb25TaWduYXR1cmVzX19wYXR0ZXJuID0gL1xcJFxceyhbXlxcfV0rKVxcfS9nO1xuICBmdW5jdGlvbiBnZXRDb21wdXRhdGlvblNpZ25hdHVyZXMocmFjdGl2ZSwgY29tcHV0ZWQpIHtcbiAgXHR2YXIgc2lnbmF0dXJlcyA9IHt9LFxuICBcdCAgICBrZXk7XG5cbiAgXHRmb3IgKGtleSBpbiBjb21wdXRlZCkge1xuICBcdFx0c2lnbmF0dXJlc1trZXldID0gZ2V0Q29tcHV0YXRpb25TaWduYXR1cmUocmFjdGl2ZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc2lnbmF0dXJlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENvbXB1dGF0aW9uU2lnbmF0dXJlKHJhY3RpdmUsIGtleSwgc2lnbmF0dXJlKSB7XG4gIFx0dmFyIGdldHRlciwgc2V0dGVyO1xuXG4gIFx0aWYgKHR5cGVvZiBzaWduYXR1cmUgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0Z2V0dGVyID0gaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXNfX2JpbmQoc2lnbmF0dXJlLCByYWN0aXZlKTtcbiAgXHR9XG5cbiAgXHRpZiAodHlwZW9mIHNpZ25hdHVyZSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0Z2V0dGVyID0gY3JlYXRlRnVuY3Rpb25Gcm9tU3RyaW5nKHJhY3RpdmUsIHNpZ25hdHVyZSk7XG4gIFx0fVxuXG4gIFx0aWYgKHR5cGVvZiBzaWduYXR1cmUgPT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdGlmICh0eXBlb2Ygc2lnbmF0dXJlLmdldCA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRnZXR0ZXIgPSBjcmVhdGVGdW5jdGlvbkZyb21TdHJpbmcocmFjdGl2ZSwgc2lnbmF0dXJlLmdldCk7XG4gIFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBzaWduYXR1cmUuZ2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0Z2V0dGVyID0gaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXNfX2JpbmQoc2lnbmF0dXJlLmdldCwgcmFjdGl2ZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRmYXRhbChcImAlc2AgY29tcHV0YXRpb24gbXVzdCBoYXZlIGEgYGdldCgpYCBtZXRob2RcIiwga2V5KTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHR5cGVvZiBzaWduYXR1cmUuc2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0c2V0dGVyID0gaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXNfX2JpbmQoc2lnbmF0dXJlLnNldCwgcmFjdGl2ZSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHsgZ2V0dGVyOiBnZXR0ZXIsIHNldHRlcjogc2V0dGVyIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkZyb21TdHJpbmcocmFjdGl2ZSwgc3RyKSB7XG4gIFx0dmFyIGZ1bmN0aW9uQm9keSwgaGFzVGhpcywgZm47XG5cbiAgXHRmdW5jdGlvbkJvZHkgPSBcInJldHVybiAoXCIgKyBzdHIucmVwbGFjZShoZWxwZXJzX2dldENvbXB1dGF0aW9uU2lnbmF0dXJlc19fcGF0dGVybiwgZnVuY3Rpb24gKG1hdGNoLCBrZXlwYXRoKSB7XG4gIFx0XHRoYXNUaGlzID0gdHJ1ZTtcbiAgXHRcdHJldHVybiBcIl9fcmFjdGl2ZS5nZXQoXFxcIlwiICsga2V5cGF0aCArIFwiXFxcIilcIjtcbiAgXHR9KSArIFwiKTtcIjtcblxuICBcdGlmIChoYXNUaGlzKSB7XG4gIFx0XHRmdW5jdGlvbkJvZHkgPSBcInZhciBfX3JhY3RpdmUgPSB0aGlzOyBcIiArIGZ1bmN0aW9uQm9keTtcbiAgXHR9XG5cbiAgXHRmbiA9IG5ldyBGdW5jdGlvbihmdW5jdGlvbkJvZHkpO1xuICBcdHJldHVybiBoYXNUaGlzID8gZm4uYmluZChyYWN0aXZlKSA6IGZuO1xuICB9XG5cbiAgZnVuY3Rpb24gaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXNfX2JpbmQoZm4sIGNvbnRleHQpIHtcbiAgXHRyZXR1cm4gL3RoaXMvLnRlc3QoZm4udG9TdHJpbmcoKSkgPyBmbi5iaW5kKGNvbnRleHQpIDogZm47XG4gIH1cblxuICB2YXIgY29uc3RydWN0SG9vayA9IG5ldyBob29rc19Ib29rKFwiY29uc3RydWN0XCIpO1xuICB2YXIgY29uZmlnSG9vayA9IG5ldyBob29rc19Ib29rKFwiY29uZmlnXCIpO1xuICB2YXIgaW5pdEhvb2sgPSBuZXcgaG9va3NfSG9va1F1ZXVlKFwiaW5pdFwiKTtcbiAgdmFyIGluaXRpYWxpc2VfX3VpZCA9IDA7XG5cbiAgdmFyIGluaXRpYWxpc2VfX3JlZ2lzdHJ5TmFtZXMgPSBbXCJhZGFwdG9yc1wiLCBcImNvbXBvbmVudHNcIiwgXCJkZWNvcmF0b3JzXCIsIFwiZWFzaW5nXCIsIFwiZXZlbnRzXCIsIFwiaW50ZXJwb2xhdG9yc1wiLCBcInBhcnRpYWxzXCIsIFwidHJhbnNpdGlvbnNcIl07XG5cbiAgdmFyIGluaXRpYWxpc2UgPSBpbml0aWFsaXNlUmFjdGl2ZUluc3RhbmNlO1xuXG4gIGZ1bmN0aW9uIGluaXRpYWxpc2VSYWN0aXZlSW5zdGFuY2UocmFjdGl2ZSkge1xuICBcdHZhciB1c2VyT3B0aW9ucyA9IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG4gIFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzJdO1xuXG4gIFx0dmFyIGVsLCB2aWV3bW9kZWw7XG5cbiAgXHRpZiAoX1JhY3RpdmUuREVCVUcpIHtcbiAgXHRcdHdlbGNvbWUoKTtcbiAgXHR9XG5cbiAgXHRpbml0aWFsaXNlUHJvcGVydGllcyhyYWN0aXZlLCBvcHRpb25zKTtcblxuICBcdC8vIFRPRE8gcmVtb3ZlIHRoaXMsIGV2ZW50dWFsbHlcbiAgXHRkZWZpbmVQcm9wZXJ0eShyYWN0aXZlLCBcImRhdGFcIiwgeyBnZXQ6IGRlcHJlY2F0ZVJhY3RpdmVEYXRhIH0pO1xuXG4gIFx0Ly8gVE9ETyBkb24ndCBhbGxvdyBgb25jb25zdHJ1Y3RgIHdpdGggYG5ldyBSYWN0aXZlKClgLCB0aGVyZSdzIG5vIG5lZWQgZm9yIGl0XG4gIFx0Y29uc3RydWN0SG9vay5maXJlKHJhY3RpdmUsIHVzZXJPcHRpb25zKTtcblxuICBcdC8vIEFkZCByZWdpc3RyaWVzXG4gIFx0aW5pdGlhbGlzZV9fcmVnaXN0cnlOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIFx0XHRyYWN0aXZlW25hbWVdID0gdXRpbHNfb2JqZWN0X19leHRlbmQoY3JlYXRlKHJhY3RpdmUuY29uc3RydWN0b3JbbmFtZV0gfHwgbnVsbCksIHVzZXJPcHRpb25zW25hbWVdKTtcbiAgXHR9KTtcblxuICBcdC8vIENyZWF0ZSBhIHZpZXdtb2RlbFxuICBcdHZpZXdtb2RlbCA9IG5ldyB2aWV3bW9kZWxfVmlld21vZGVsKHtcbiAgXHRcdGFkYXB0OiBnZXRBZGFwdG9ycyhyYWN0aXZlLCByYWN0aXZlLmFkYXB0LCB1c2VyT3B0aW9ucyksXG4gIFx0XHRkYXRhOiBjdXN0b21fZGF0YS5pbml0KHJhY3RpdmUuY29uc3RydWN0b3IsIHJhY3RpdmUsIHVzZXJPcHRpb25zKSxcbiAgXHRcdGNvbXB1dGVkOiBoZWxwZXJzX2dldENvbXB1dGF0aW9uU2lnbmF0dXJlcyhyYWN0aXZlLCB1dGlsc19vYmplY3RfX2V4dGVuZChjcmVhdGUocmFjdGl2ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcHV0ZWQpLCB1c2VyT3B0aW9ucy5jb21wdXRlZCkpLFxuICBcdFx0bWFwcGluZ3M6IG9wdGlvbnMubWFwcGluZ3MsXG4gIFx0XHRyYWN0aXZlOiByYWN0aXZlLFxuICBcdFx0b25jaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuIGdsb2JhbF9ydW5sb29wLmFkZFJhY3RpdmUocmFjdGl2ZSk7XG4gIFx0XHR9XG4gIFx0fSk7XG5cbiAgXHRyYWN0aXZlLnZpZXdtb2RlbCA9IHZpZXdtb2RlbDtcblxuICBcdC8vIFRoaXMgY2FuJ3QgaGFwcGVuIGVhcmxpZXIsIGJlY2F1c2UgY29tcHV0ZWQgcHJvcGVydGllcyBtYXkgY2FsbCBgcmFjdGl2ZS5nZXQoKWAsIGV0Y1xuICBcdHZpZXdtb2RlbC5pbml0KCk7XG5cbiAgXHQvLyBpbml0IGNvbmZpZyBmcm9tIFBhcmVudCBhbmQgb3B0aW9uc1xuICBcdGNvbmZpZ19jb25maWcuaW5pdChyYWN0aXZlLmNvbnN0cnVjdG9yLCByYWN0aXZlLCB1c2VyT3B0aW9ucyk7XG5cbiAgXHRjb25maWdIb29rLmZpcmUocmFjdGl2ZSk7XG4gIFx0aW5pdEhvb2suYmVnaW4ocmFjdGl2ZSk7XG5cbiAgXHQvLyAvLyBJZiB0aGlzIGlzIGEgY29tcG9uZW50IHdpdGggYSBmdW5jdGlvbiBgZGF0YWAgcHJvcGVydHksIGNhbGwgdGhlIGZ1bmN0aW9uXG4gIFx0Ly8gLy8gd2l0aCBgcmFjdGl2ZWAgYXMgY29udGV4dCAodW5sZXNzIHRoZSBjaGlsZCB3YXMgYWxzbyBhIGZ1bmN0aW9uKVxuICBcdC8vIGlmICggdHlwZW9mIHJhY3RpdmUuY29uc3RydWN0b3IucHJvdG90eXBlLmRhdGEgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHVzZXJPcHRpb25zLmRhdGEgIT09ICdmdW5jdGlvbicgKSB7XG4gIFx0Ly8gXHR2aWV3bW9kZWwucmVzZXQoIHJhY3RpdmUuY29uc3RydWN0b3IucHJvdG90eXBlLmRhdGEuY2FsbCggcmFjdGl2ZSApIHx8IGZhdGFsKCAnYGRhdGFgIGZ1bmN0aW9ucyBtdXN0IHJldHVybiBhIGRhdGEgb2JqZWN0JyApICk7XG4gIFx0Ly8gfVxuXG4gIFx0Ly8gUmVuZGVyIHZpcnR1YWwgRE9NXG4gIFx0aWYgKHJhY3RpdmUudGVtcGxhdGUpIHtcbiAgXHRcdHZhciBjc3NJZHMgPSB1bmRlZmluZWQ7XG5cbiAgXHRcdGlmIChvcHRpb25zLmNzc0lkcyB8fCByYWN0aXZlLmNzc0lkKSB7XG4gIFx0XHRcdGNzc0lkcyA9IG9wdGlvbnMuY3NzSWRzID8gb3B0aW9ucy5jc3NJZHMuc2xpY2UoKSA6IFtdO1xuXG4gIFx0XHRcdGlmIChyYWN0aXZlLmNzc0lkKSB7XG4gIFx0XHRcdFx0Y3NzSWRzLnB1c2gocmFjdGl2ZS5jc3NJZCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmFjdGl2ZS5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0dGVtcGxhdGU6IHJhY3RpdmUudGVtcGxhdGUsXG4gIFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG4gIFx0XHRcdG93bmVyOiByYWN0aXZlLCAvLyBzYXZlcyBkb2luZyBgaWYgKCB0aGlzLnBhcmVudCApIHsgLyouLi4qLyB9YCBsYXRlciBvblxuICBcdFx0XHRjc3NJZHM6IGNzc0lkc1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0aW5pdEhvb2suZW5kKHJhY3RpdmUpO1xuXG4gIFx0Ly8gcmVuZGVyIGF1dG9tYXRpY2FsbHkgKCBpZiBgZWxgIGlzIHNwZWNpZmllZCApXG4gIFx0aWYgKGVsID0gZ2V0RWxlbWVudChyYWN0aXZlLmVsKSkge1xuICBcdFx0dmFyIHByb21pc2UgPSByYWN0aXZlLnJlbmRlcihlbCwgcmFjdGl2ZS5hcHBlbmQpO1xuXG4gIFx0XHRpZiAoX1JhY3RpdmUuREVCVUdfUFJPTUlTRVMpIHtcbiAgXHRcdFx0cHJvbWlzZVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgXHRcdFx0XHR3YXJuT25jZUlmRGVidWcoXCJQcm9taXNlIGRlYnVnZ2luZyBpcyBlbmFibGVkLCB0byBoZWxwIHNvbHZlIGVycm9ycyB0aGF0IGhhcHBlbiBhc3luY2hyb25vdXNseS4gU29tZSBicm93c2VycyB3aWxsIGxvZyB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb25zLCBpbiB3aGljaCBjYXNlIHlvdSBjYW4gc2FmZWx5IGRpc2FibGUgcHJvbWlzZSBkZWJ1Z2dpbmc6XFxuICBSYWN0aXZlLkRFQlVHX1BST01JU0VTID0gZmFsc2U7XCIpO1xuICBcdFx0XHRcdHdhcm5JZkRlYnVnKFwiQW4gZXJyb3IgaGFwcGVuZWQgZHVyaW5nIHJlbmRlcmluZ1wiLCB7IHJhY3RpdmU6IHJhY3RpdmUgfSk7XG4gIFx0XHRcdFx0ZXJyLnN0YWNrICYmIGxvZ0lmRGVidWcoZXJyLnN0YWNrKTtcblxuICBcdFx0XHRcdHRocm93IGVycjtcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QWRhcHRvcnMocmFjdGl2ZSwgcHJvdG9BZGFwdCwgdXNlck9wdGlvbnMpIHtcbiAgXHR2YXIgYWRhcHQsIG1hZ2ljLCBtb2RpZnlBcnJheXM7XG5cbiAgXHRwcm90b0FkYXB0ID0gcHJvdG9BZGFwdC5tYXAobG9va3VwKTtcbiAgXHRhZGFwdCA9IGVuc3VyZUFycmF5KHVzZXJPcHRpb25zLmFkYXB0KS5tYXAobG9va3VwKTtcblxuICBcdGFkYXB0ID0gaW5pdGlhbGlzZV9fY29tYmluZShwcm90b0FkYXB0LCBhZGFwdCk7XG5cbiAgXHRtYWdpYyA9IFwibWFnaWNcIiBpbiB1c2VyT3B0aW9ucyA/IHVzZXJPcHRpb25zLm1hZ2ljIDogcmFjdGl2ZS5tYWdpYztcbiAgXHRtb2RpZnlBcnJheXMgPSBcIm1vZGlmeUFycmF5c1wiIGluIHVzZXJPcHRpb25zID8gdXNlck9wdGlvbnMubW9kaWZ5QXJyYXlzIDogcmFjdGl2ZS5tb2RpZnlBcnJheXM7XG5cbiAgXHRpZiAobWFnaWMpIHtcbiAgXHRcdGlmICghZW52aXJvbm1lbnRfX21hZ2ljKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkdldHRlcnMgYW5kIHNldHRlcnMgKG1hZ2ljIG1vZGUpIGFyZSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKG1vZGlmeUFycmF5cykge1xuICBcdFx0XHRhZGFwdC5wdXNoKG1hZ2ljQXJyYXkpO1xuICBcdFx0fVxuXG4gIFx0XHRhZGFwdC5wdXNoKGFkYXB0b3JzX21hZ2ljKTtcbiAgXHR9XG5cbiAgXHRpZiAobW9kaWZ5QXJyYXlzKSB7XG4gIFx0XHRhZGFwdC5wdXNoKGFycmF5X2luZGV4KTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gYWRhcHQ7XG5cbiAgXHRmdW5jdGlvbiBsb29rdXAoYWRhcHRvcikge1xuICBcdFx0aWYgKHR5cGVvZiBhZGFwdG9yID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdGFkYXB0b3IgPSBmaW5kSW5WaWV3SGllcmFyY2h5KFwiYWRhcHRvcnNcIiwgcmFjdGl2ZSwgYWRhcHRvcik7XG5cbiAgXHRcdFx0aWYgKCFhZGFwdG9yKSB7XG4gIFx0XHRcdFx0ZmF0YWwobWlzc2luZ1BsdWdpbihhZGFwdG9yLCBcImFkYXB0b3JcIikpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBhZGFwdG9yO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpc2VfX2NvbWJpbmUoYSwgYikge1xuICBcdHZhciBjID0gYS5zbGljZSgpLFxuICBcdCAgICBpID0gYi5sZW5ndGg7XG5cbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpZiAoISB+Yy5pbmRleE9mKGJbaV0pKSB7XG4gIFx0XHRcdGMucHVzaChiW2ldKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gYztcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpc2VQcm9wZXJ0aWVzKHJhY3RpdmUsIG9wdGlvbnMpIHtcbiAgXHQvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpZGVudGlmaWVyLCBmb3IgcGxhY2VzIHdoZXJlIHlvdSdkIHVzZSBhIHdlYWsgbWFwIGlmIGl0XG4gIFx0Ly8gZXhpc3RlZFxuICBcdHJhY3RpdmUuX2d1aWQgPSBcInItXCIgKyBpbml0aWFsaXNlX191aWQrKztcblxuICBcdC8vIGV2ZW50c1xuICBcdHJhY3RpdmUuX3N1YnMgPSBjcmVhdGUobnVsbCk7XG5cbiAgXHQvLyBzdG9yYWdlIGZvciBpdGVtIGNvbmZpZ3VyYXRpb24gZnJvbSBpbnN0YW50aWF0aW9uIHRvIHJlc2V0LFxuICBcdC8vIGxpa2UgZHluYW1pYyBmdW5jdGlvbnMgb3Igb3JpZ2luYWwgdmFsdWVzXG4gIFx0cmFjdGl2ZS5fY29uZmlnID0ge307XG5cbiAgXHQvLyB0d28td2F5IGJpbmRpbmdzXG4gIFx0cmFjdGl2ZS5fdHdvd2F5QmluZGluZ3MgPSBjcmVhdGUobnVsbCk7XG5cbiAgXHQvLyBhbmltYXRpb25zIChzbyB3ZSBjYW4gc3RvcCBhbnkgaW4gcHJvZ3Jlc3MgYXQgdGVhcmRvd24pXG4gIFx0cmFjdGl2ZS5fYW5pbWF0aW9ucyA9IFtdO1xuXG4gIFx0Ly8gbm9kZXMgcmVnaXN0cnlcbiAgXHRyYWN0aXZlLm5vZGVzID0ge307XG5cbiAgXHQvLyBsaXZlIHF1ZXJpZXNcbiAgXHRyYWN0aXZlLl9saXZlUXVlcmllcyA9IFtdO1xuICBcdHJhY3RpdmUuX2xpdmVDb21wb25lbnRRdWVyaWVzID0gW107XG5cbiAgXHQvLyBib3VuZCBkYXRhIGZ1bmN0aW9uc1xuICBcdHJhY3RpdmUuX2JvdW5kRnVuY3Rpb25zID0gW107XG5cbiAgXHQvLyBvYnNlcnZlcnNcbiAgXHRyYWN0aXZlLl9vYnNlcnZlcnMgPSBbXTtcblxuICBcdC8vIHByb3BlcnRpZXMgc3BlY2lmaWMgdG8gaW5saW5lIGNvbXBvbmVudHNcbiAgXHRpZiAob3B0aW9ucy5jb21wb25lbnQpIHtcbiAgXHRcdHJhY3RpdmUucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIFx0XHRyYWN0aXZlLmNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyIHx8IG51bGw7XG4gIFx0XHRyYWN0aXZlLnJvb3QgPSByYWN0aXZlLnBhcmVudC5yb290O1xuXG4gIFx0XHRyYWN0aXZlLmNvbXBvbmVudCA9IG9wdGlvbnMuY29tcG9uZW50O1xuICBcdFx0b3B0aW9ucy5jb21wb25lbnQuaW5zdGFuY2UgPSByYWN0aXZlO1xuXG4gIFx0XHQvLyBmb3IgaGFja2FiaWxpdHksIHRoaXMgY291bGQgYmUgYW4gb3BlbiBvcHRpb25cbiAgXHRcdC8vIGZvciBhbnkgcmFjdGl2ZSBpbnN0YW5jZSwgYnV0IGZvciBub3csIGp1c3RcbiAgXHRcdC8vIGZvciBjb21wb25lbnRzIGFuZCBqdXN0IGZvciByYWN0aXZlLi4uXG4gIFx0XHRyYWN0aXZlLl9pbmxpbmVQYXJ0aWFscyA9IG9wdGlvbnMuaW5saW5lUGFydGlhbHM7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJhY3RpdmUucm9vdCA9IHJhY3RpdmU7XG4gIFx0XHRyYWN0aXZlLnBhcmVudCA9IHJhY3RpdmUuY29udGFpbmVyID0gbnVsbDtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBkZXByZWNhdGVSYWN0aXZlRGF0YSgpIHtcbiAgXHR0aHJvdyBuZXcgRXJyb3IoXCJVc2luZyBgcmFjdGl2ZS5kYXRhYCBpcyBubyBsb25nZXIgc3VwcG9ydGVkIC0geW91IG11c3QgdXNlIHRoZSBgcmFjdGl2ZS5nZXQoKWAgQVBJIGluc3RlYWRcIik7XG4gIH1cblxuICBmdW5jdGlvbiBDb21wbGV4UGFyYW1ldGVyKGNvbXBvbmVudCwgdGVtcGxhdGUsIGNhbGxiYWNrKSB7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgXHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLFxuICBcdFx0cm9vdDogY29tcG9uZW50LnJvb3QsXG4gIFx0XHRvd25lcjogdGhpc1xuICBcdH0pO1xuXG4gIFx0dGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIHZhciBpbml0aWFsaXNlX0NvbXBsZXhQYXJhbWV0ZXIgPSBDb21wbGV4UGFyYW1ldGVyO1xuXG4gIENvbXBsZXhQYXJhbWV0ZXIucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLmRpcnR5KSB7XG4gIFx0XHRcdHRoaXMuZGlydHkgPSB0cnVlO1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRWaWV3KHRoaXMpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuY2FsbGJhY2sodGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpKTtcbiAgXHRcdHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUluc3RhbmNlID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgQ29tcG9uZW50LCBhdHRyaWJ1dGVzLCB5aWVsZFRlbXBsYXRlLCBwYXJ0aWFscykge1xuICBcdHZhciBpbnN0YW5jZSxcbiAgXHQgICAgcGFyZW50RnJhZ21lbnQsXG4gIFx0ICAgIHJhY3RpdmUsXG4gIFx0ICAgIGZyYWdtZW50LFxuICBcdCAgICBjb250YWluZXIsXG4gIFx0ICAgIGlubGluZVBhcnRpYWxzID0ge30sXG4gIFx0ICAgIGRhdGEgPSB7fSxcbiAgXHQgICAgbWFwcGluZ3MgPSB7fSxcbiAgXHQgICAgcmVhZHksXG4gIFx0ICAgIHJlc29sdmVycyA9IFtdO1xuXG4gIFx0cGFyZW50RnJhZ21lbnQgPSBjb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG4gIFx0cmFjdGl2ZSA9IGNvbXBvbmVudC5yb290O1xuXG4gIFx0cGFydGlhbHMgPSBwYXJ0aWFscyB8fCB7fTtcbiAgXHR1dGlsc19vYmplY3RfX2V4dGVuZChpbmxpbmVQYXJ0aWFscywgcGFydGlhbHMpO1xuXG4gIFx0Ly8gTWFrZSBjb250ZW50cyBhdmFpbGFibGUgYXMgYSB7ez5jb250ZW50fX0gcGFydGlhbFxuICBcdHBhcnRpYWxzLmNvbnRlbnQgPSB5aWVsZFRlbXBsYXRlIHx8IFtdO1xuXG4gIFx0Ly8gc2V0IGEgZGVmYXVsdCBwYXJ0aWFsIGZvciB5aWVsZHMgd2l0aCBubyBuYW1lXG4gIFx0aW5saW5lUGFydGlhbHNbXCJcIl0gPSBwYXJ0aWFscy5jb250ZW50O1xuXG4gIFx0aWYgKENvbXBvbmVudC5kZWZhdWx0cy5lbCkge1xuICBcdFx0d2FybklmRGVidWcoXCJUaGUgPCVzLz4gY29tcG9uZW50IGhhcyBhIGRlZmF1bHQgYGVsYCBwcm9wZXJ0eTsgaXQgaGFzIGJlZW4gZGlzcmVnYXJkZWRcIiwgY29tcG9uZW50Lm5hbWUpO1xuICBcdH1cblxuICBcdC8vIGZpbmQgY29udGFpbmVyXG4gIFx0ZnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudDtcbiAgXHR3aGlsZSAoZnJhZ21lbnQpIHtcbiAgXHRcdGlmIChmcmFnbWVudC5vd25lci50eXBlID09PSBZSUVMREVSKSB7XG4gIFx0XHRcdGNvbnRhaW5lciA9IGZyYWdtZW50Lm93bmVyLmNvbnRhaW5lcjtcbiAgXHRcdFx0YnJlYWs7XG4gIFx0XHR9XG5cbiAgXHRcdGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50O1xuICBcdH1cblxuICBcdC8vIGVhY2ggYXR0cmlidXRlIHJlcHJlc2VudHMgZWl0aGVyIGEpIGRhdGEgb3IgYikgYSBtYXBwaW5nXG4gIFx0aWYgKGF0dHJpYnV0ZXMpIHtcbiAgXHRcdE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBcdFx0XHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1trZXldLFxuICBcdFx0XHQgICAgcGFyc2VkLFxuICBcdFx0XHQgICAgcmVzb2x2ZXI7XG5cbiAgXHRcdFx0aWYgKHR5cGVvZiBhdHRyaWJ1dGUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0XHQvLyBpdCdzIHN0YXRpYyBkYXRhXG4gIFx0XHRcdFx0cGFyc2VkID0gcGFyc2VKU09OKGF0dHJpYnV0ZSk7XG4gIFx0XHRcdFx0ZGF0YVtrZXldID0gcGFyc2VkID8gcGFyc2VkLnZhbHVlIDogYXR0cmlidXRlO1xuICBcdFx0XHR9IGVsc2UgaWYgKGF0dHJpYnV0ZSA9PT0gMCkge1xuICBcdFx0XHRcdC8vIGl0IGhhZCBubyAnPScsIHNvIHdlJ2xsIGNhbGwgaXQgdHJ1ZVxuICBcdFx0XHRcdGRhdGFba2V5XSA9IHRydWU7XG4gIFx0XHRcdH0gZWxzZSBpZiAoaXNBcnJheShhdHRyaWJ1dGUpKSB7XG4gIFx0XHRcdFx0Ly8gdGhpcyByZXByZXNlbnRzIGR5bmFtaWMgZGF0YVxuICBcdFx0XHRcdGlmIChpc1NpbmdsZUludGVycG9sYXRvcihhdHRyaWJ1dGUpKSB7XG4gIFx0XHRcdFx0XHRtYXBwaW5nc1trZXldID0ge1xuICBcdFx0XHRcdFx0XHRvcmlnaW46IGNvbXBvbmVudC5yb290LnZpZXdtb2RlbCxcbiAgXHRcdFx0XHRcdFx0a2V5cGF0aDogdW5kZWZpbmVkXG4gIFx0XHRcdFx0XHR9O1xuXG4gIFx0XHRcdFx0XHRyZXNvbHZlciA9IGNyZWF0ZVJlc29sdmVyKGNvbXBvbmVudCwgYXR0cmlidXRlWzBdLCBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRcdFx0XHRpZiAoa2V5cGF0aC5pc1NwZWNpYWwpIHtcbiAgXHRcdFx0XHRcdFx0XHRpZiAocmVhZHkpIHtcbiAgXHRcdFx0XHRcdFx0XHRcdGluc3RhbmNlLnNldChrZXksIGtleXBhdGgudmFsdWUpOyAvLyBUT0RPIHVzZSB2aWV3bW9kZWw/XG4gIFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0XHRcdGRhdGFba2V5XSA9IGtleXBhdGgudmFsdWU7XG5cbiAgXHRcdFx0XHRcdFx0XHRcdC8vIFRPRE8gZXJyci4uLi4gd291bGQgYmUgYmV0dGVyIGlmIHdlIGRpZG4ndCBoYXZlIHRvIGRvIHRoaXNcbiAgXHRcdFx0XHRcdFx0XHRcdGRlbGV0ZSBtYXBwaW5nc1trZXldO1xuICBcdFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0XHRpZiAocmVhZHkpIHtcbiAgXHRcdFx0XHRcdFx0XHRcdGluc3RhbmNlLnZpZXdtb2RlbC5tYXBwaW5nc1trZXldLnJlc29sdmUoa2V5cGF0aCk7XG4gIFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0XHRcdC8vIHJlc29sdmVkIGltbWVkaWF0ZWx5XG4gIFx0XHRcdFx0XHRcdFx0XHRtYXBwaW5nc1trZXldLmtleXBhdGggPSBrZXlwYXRoO1xuICBcdFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdHJlc29sdmVyID0gbmV3IGluaXRpYWxpc2VfQ29tcGxleFBhcmFtZXRlcihjb21wb25lbnQsIGF0dHJpYnV0ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHRcdFx0XHRcdGlmIChyZWFkeSkge1xuICBcdFx0XHRcdFx0XHRcdGluc3RhbmNlLnNldChrZXksIHZhbHVlKTsgLy8gVE9ETyB1c2Ugdmlld21vZGVsP1xuICBcdFx0XHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0XHRcdGRhdGFba2V5XSA9IHZhbHVlO1xuICBcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRyZXNvbHZlcnMucHVzaChyZXNvbHZlcik7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZXJtIHd1dFwiKTtcbiAgXHRcdFx0fVxuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0aW5zdGFuY2UgPSBjcmVhdGUoQ29tcG9uZW50LnByb3RvdHlwZSk7XG5cbiAgXHRpbml0aWFsaXNlKGluc3RhbmNlLCB7XG4gIFx0XHRlbDogbnVsbCxcbiAgXHRcdGFwcGVuZDogdHJ1ZSxcbiAgXHRcdGRhdGE6IGRhdGEsXG4gIFx0XHRwYXJ0aWFsczogcGFydGlhbHMsXG4gIFx0XHRtYWdpYzogcmFjdGl2ZS5tYWdpYyB8fCBDb21wb25lbnQuZGVmYXVsdHMubWFnaWMsXG4gIFx0XHRtb2RpZnlBcnJheXM6IHJhY3RpdmUubW9kaWZ5QXJyYXlzLFxuICBcdFx0Ly8gbmVlZCB0byBpbmhlcml0IHJ1bnRpbWUgcGFyZW50IGFkYXB0b3JzXG4gIFx0XHRhZGFwdDogcmFjdGl2ZS5hZGFwdFxuICBcdH0sIHtcbiAgXHRcdHBhcmVudDogcmFjdGl2ZSxcbiAgXHRcdGNvbXBvbmVudDogY29tcG9uZW50LFxuICBcdFx0Y29udGFpbmVyOiBjb250YWluZXIsXG4gIFx0XHRtYXBwaW5nczogbWFwcGluZ3MsXG4gIFx0XHRpbmxpbmVQYXJ0aWFsczogaW5saW5lUGFydGlhbHMsXG4gIFx0XHRjc3NJZHM6IHBhcmVudEZyYWdtZW50LmNzc0lkc1xuICBcdH0pO1xuXG4gIFx0cmVhZHkgPSB0cnVlO1xuICBcdGNvbXBvbmVudC5yZXNvbHZlcnMgPSByZXNvbHZlcnM7XG5cbiAgXHRyZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgZnVuY3Rpb24gY3JlYXRlUmVzb2x2ZXIoY29tcG9uZW50LCB0ZW1wbGF0ZSwgY2FsbGJhY2spIHtcbiAgXHR2YXIgcmVzb2x2ZXI7XG5cbiAgXHRpZiAodGVtcGxhdGUucikge1xuICBcdFx0cmVzb2x2ZXIgPSBSZXNvbHZlcnNfY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIoY29tcG9uZW50LCB0ZW1wbGF0ZS5yLCBjYWxsYmFjayk7XG4gIFx0fSBlbHNlIGlmICh0ZW1wbGF0ZS54KSB7XG4gIFx0XHRyZXNvbHZlciA9IG5ldyBSZXNvbHZlcnNfRXhwcmVzc2lvblJlc29sdmVyKGNvbXBvbmVudCwgY29tcG9uZW50LnBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZS54LCBjYWxsYmFjayk7XG4gIFx0fSBlbHNlIGlmICh0ZW1wbGF0ZS5yeCkge1xuICBcdFx0cmVzb2x2ZXIgPSBuZXcgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX1JlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcihjb21wb25lbnQsIHRlbXBsYXRlLnJ4LCBjYWxsYmFjayk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHJlc29sdmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTaW5nbGVJbnRlcnBvbGF0b3IodGVtcGxhdGUpIHtcbiAgXHRyZXR1cm4gdGVtcGxhdGUubGVuZ3RoID09PSAxICYmIHRlbXBsYXRlWzBdLnQgPT09IElOVEVSUE9MQVRPUjtcbiAgfVxuXG4gIC8vIFRPRE8gaG93IHNob3VsZCBldmVudCBhcmd1bWVudHMgYmUgaGFuZGxlZD8gZS5nLlxuICAvLyA8d2lkZ2V0IG9uLWZvbz0nYmFyOjEsMiwzJy8+XG4gIC8vIFRoZSBldmVudCAnYmFyJyB3aWxsIGJlIGZpcmVkIG9uIHRoZSBwYXJlbnQgaW5zdGFuY2VcbiAgLy8gd2hlbiAnZm9vJyBmaXJlcyBvbiB0aGUgY2hpbGQsIGJ1dCB0aGUgMSwyLDMgYXJndW1lbnRzXG4gIC8vIHdpbGwgYmUgbG9zdFxuXG4gIHZhciBpbml0aWFsaXNlX3Byb3BhZ2F0ZUV2ZW50cyA9IHByb3BhZ2F0ZUV2ZW50cztcblxuICBmdW5jdGlvbiBwcm9wYWdhdGVFdmVudHMoY29tcG9uZW50LCBldmVudHNEZXNjcmlwdG9yKSB7XG4gIFx0dmFyIGV2ZW50TmFtZTtcblxuICBcdGZvciAoZXZlbnROYW1lIGluIGV2ZW50c0Rlc2NyaXB0b3IpIHtcbiAgXHRcdGlmIChldmVudHNEZXNjcmlwdG9yLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgXHRcdFx0cHJvcGFnYXRlRXZlbnQoY29tcG9uZW50Lmluc3RhbmNlLCBjb21wb25lbnQucm9vdCwgZXZlbnROYW1lLCBldmVudHNEZXNjcmlwdG9yW2V2ZW50TmFtZV0pO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb3BhZ2F0ZUV2ZW50KGNoaWxkSW5zdGFuY2UsIHBhcmVudEluc3RhbmNlLCBldmVudE5hbWUsIHByb3h5RXZlbnROYW1lKSB7XG4gIFx0aWYgKHR5cGVvZiBwcm94eUV2ZW50TmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0ZmF0YWwoXCJDb21wb25lbnRzIGN1cnJlbnRseSBvbmx5IHN1cHBvcnQgc2ltcGxlIGV2ZW50cyAtIHlvdSBjYW5ub3QgaW5jbHVkZSBhcmd1bWVudHMuIFNvcnJ5IVwiKTtcbiAgXHR9XG5cbiAgXHRjaGlsZEluc3RhbmNlLm9uKGV2ZW50TmFtZSwgZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGV2ZW50LCBhcmdzO1xuXG4gIFx0XHQvLyBzZW1pLXdlYWsgdGVzdCwgYnV0IHdoYXQgZWxzZT8gdGFnIHRoZSBldmVudCBvYmogLl9pc0V2ZW50ID9cbiAgXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1swXSAmJiBhcmd1bWVudHNbMF0ubm9kZSkge1xuICBcdFx0XHRldmVudCA9IEFycmF5LnByb3RvdHlwZS5zaGlmdC5jYWxsKGFyZ3VtZW50cyk7XG4gIFx0XHR9XG5cbiAgXHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gIFx0XHRzaGFyZWRfZmlyZUV2ZW50KHBhcmVudEluc3RhbmNlLCBwcm94eUV2ZW50TmFtZSwgeyBldmVudDogZXZlbnQsIGFyZ3M6IGFyZ3MgfSk7XG5cbiAgXHRcdC8vIGNhbmNlbCBidWJibGluZ1xuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH0pO1xuICB9XG5cbiAgdmFyIGluaXRpYWxpc2VfdXBkYXRlTGl2ZVF1ZXJpZXMgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gIFx0dmFyIGFuY2VzdG9yLCBxdWVyeTtcblxuICBcdC8vIElmIHRoZXJlJ3MgYSBsaXZlIHF1ZXJ5IGZvciB0aGlzIGNvbXBvbmVudCB0eXBlLCBhZGQgaXRcbiAgXHRhbmNlc3RvciA9IGNvbXBvbmVudC5yb290O1xuICBcdHdoaWxlIChhbmNlc3Rvcikge1xuICBcdFx0aWYgKHF1ZXJ5ID0gYW5jZXN0b3IuX2xpdmVDb21wb25lbnRRdWVyaWVzW1wiX1wiICsgY29tcG9uZW50Lm5hbWVdKSB7XG4gIFx0XHRcdHF1ZXJ5LnB1c2goY29tcG9uZW50Lmluc3RhbmNlKTtcbiAgXHRcdH1cblxuICBcdFx0YW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2luaXQgPSBDb21wb25lbnQkaW5pdDtcbiAgZnVuY3Rpb24gQ29tcG9uZW50JGluaXQob3B0aW9ucywgQ29tcG9uZW50KSB7XG4gIFx0dmFyIHBhcmVudEZyYWdtZW50LCByb290O1xuXG4gIFx0aWYgKCFDb21wb25lbnQpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkNvbXBvbmVudCBcXFwiXCIgKyB0aGlzLm5hbWUgKyBcIlxcXCIgbm90IGZvdW5kXCIpO1xuICBcdH1cblxuICBcdHBhcmVudEZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG4gIFx0cm9vdCA9IHBhcmVudEZyYWdtZW50LnJvb3Q7XG5cbiAgXHR0aGlzLnJvb3QgPSByb290O1xuICBcdHRoaXMudHlwZSA9IENPTVBPTkVOVDtcbiAgXHR0aGlzLm5hbWUgPSBvcHRpb25zLnRlbXBsYXRlLmU7XG4gIFx0dGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG4gIFx0dGhpcy5pbmRleFJlZkJpbmRpbmdzID0ge307XG4gIFx0dGhpcy55aWVsZGVycyA9IHt9O1xuICBcdHRoaXMucmVzb2x2ZXJzID0gW107XG5cbiAgXHRjcmVhdGVJbnN0YW5jZSh0aGlzLCBDb21wb25lbnQsIG9wdGlvbnMudGVtcGxhdGUuYSwgb3B0aW9ucy50ZW1wbGF0ZS5mLCBvcHRpb25zLnRlbXBsYXRlLnApO1xuICBcdGluaXRpYWxpc2VfcHJvcGFnYXRlRXZlbnRzKHRoaXMsIG9wdGlvbnMudGVtcGxhdGUudik7XG5cbiAgXHQvLyBpbnRybywgb3V0cm8gYW5kIGRlY29yYXRvciBkaXJlY3RpdmVzIGhhdmUgbm8gZWZmZWN0XG4gIFx0aWYgKG9wdGlvbnMudGVtcGxhdGUudDAgfHwgb3B0aW9ucy50ZW1wbGF0ZS50MSB8fCBvcHRpb25zLnRlbXBsYXRlLnQyIHx8IG9wdGlvbnMudGVtcGxhdGUubykge1xuICBcdFx0d2FybklmRGVidWcoXCJUaGUgXFxcImludHJvXFxcIiwgXFxcIm91dHJvXFxcIiBhbmQgXFxcImRlY29yYXRvclxcXCIgZGlyZWN0aXZlcyBoYXZlIG5vIGVmZmVjdCBvbiBjb21wb25lbnRzXCIsIHsgcmFjdGl2ZTogdGhpcy5pbnN0YW5jZSB9KTtcbiAgXHR9XG5cbiAgXHRpbml0aWFsaXNlX3VwZGF0ZUxpdmVRdWVyaWVzKHRoaXMpO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfcmViaW5kID0gQ29tcG9uZW50JHJlYmluZDtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkcmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHR2YXIgcXVlcnk7XG5cbiAgXHR0aGlzLnJlc29sdmVycy5mb3JFYWNoKHJlYmluZCk7XG5cbiAgXHRmb3IgKHZhciBrIGluIHRoaXMueWllbGRlcnMpIHtcbiAgXHRcdGlmICh0aGlzLnlpZWxkZXJzW2tdWzBdKSB7XG4gIFx0XHRcdHJlYmluZCh0aGlzLnlpZWxkZXJzW2tdWzBdKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAocXVlcnkgPSB0aGlzLnJvb3QuX2xpdmVDb21wb25lbnRRdWVyaWVzW1wiX1wiICsgdGhpcy5uYW1lXSkge1xuICBcdFx0cXVlcnkuX21ha2VEaXJ0eSgpO1xuICBcdH1cblxuICBcdGZ1bmN0aW9uIHJlYmluZCh4KSB7XG4gIFx0XHR4LnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9yZW5kZXIgPSBDb21wb25lbnQkcmVuZGVyO1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCRyZW5kZXIoKSB7XG4gIFx0dmFyIGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZTtcblxuICBcdGluc3RhbmNlLnJlbmRlcih0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKSk7XG5cbiAgXHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgXHRyZXR1cm4gaW5zdGFuY2UuZnJhZ21lbnQuZGV0YWNoKCk7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV90b1N0cmluZyA9IENvbXBvbmVudCR0b1N0cmluZztcblxuICBmdW5jdGlvbiBDb21wb25lbnQkdG9TdHJpbmcoKSB7XG4gIFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX3VuYmluZCA9IENvbXBvbmVudCR1bmJpbmQ7XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfdW5iaW5kX190ZWFyZG93bkhvb2sgPSBuZXcgaG9va3NfSG9vayhcInRlYXJkb3duXCIpO1xuICBmdW5jdGlvbiBDb21wb25lbnQkdW5iaW5kKCkge1xuICBcdHZhciBpbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2U7XG5cbiAgXHR0aGlzLnJlc29sdmVycy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG5cbiAgXHRyZW1vdmVGcm9tTGl2ZUNvbXBvbmVudFF1ZXJpZXModGhpcyk7XG5cbiAgXHRpbnN0YW5jZS5fb2JzZXJ2ZXJzLmZvckVhY2goY2FuY2VsKTtcblxuICBcdC8vIHRlYXJkb3duIHRoZSBpbnN0YW5jZVxuICBcdGluc3RhbmNlLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdGluc3RhbmNlLnZpZXdtb2RlbC50ZWFyZG93bigpO1xuXG4gIFx0aWYgKGluc3RhbmNlLmZyYWdtZW50LnJlbmRlcmVkICYmIGluc3RhbmNlLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXykge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KGluc3RhbmNlLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXywgaW5zdGFuY2UpO1xuICBcdH1cblxuICBcdENvbXBvbmVudF9wcm90b3R5cGVfdW5iaW5kX190ZWFyZG93bkhvb2suZmlyZShpbnN0YW5jZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVGcm9tTGl2ZUNvbXBvbmVudFF1ZXJpZXMoY29tcG9uZW50KSB7XG4gIFx0dmFyIGluc3RhbmNlLCBxdWVyeTtcblxuICBcdGluc3RhbmNlID0gY29tcG9uZW50LnJvb3Q7XG5cbiAgXHRkbyB7XG4gIFx0XHRpZiAocXVlcnkgPSBpbnN0YW5jZS5fbGl2ZUNvbXBvbmVudFF1ZXJpZXNbXCJfXCIgKyBjb21wb25lbnQubmFtZV0pIHtcbiAgXHRcdFx0cXVlcnkuX3JlbW92ZShjb21wb25lbnQpO1xuICBcdFx0fVxuICBcdH0gd2hpbGUgKGluc3RhbmNlID0gaW5zdGFuY2UucGFyZW50KTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX3VucmVuZGVyID0gQ29tcG9uZW50JHVucmVuZGVyO1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCR1bnJlbmRlcihzaG91bGREZXN0cm95KSB7XG4gIFx0dGhpcy5zaG91bGREZXN0cm95ID0gc2hvdWxkRGVzdHJveTtcbiAgXHR0aGlzLmluc3RhbmNlLnVucmVuZGVyKCk7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMsIENvbnN0cnVjdG9yKSB7XG4gIFx0dGhpcy5pbml0KG9wdGlvbnMsIENvbnN0cnVjdG9yKTtcbiAgfTtcblxuICBDb21wb25lbnQucHJvdG90eXBlID0ge1xuICBcdGRldGFjaDogQ29tcG9uZW50X3Byb3RvdHlwZV9kZXRhY2gsXG4gIFx0ZmluZDogQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kLFxuICBcdGZpbmRBbGw6IENvbXBvbmVudF9wcm90b3R5cGVfZmluZEFsbCxcbiAgXHRmaW5kQWxsQ29tcG9uZW50czogQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kQWxsQ29tcG9uZW50cyxcbiAgXHRmaW5kQ29tcG9uZW50OiBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmRDb21wb25lbnQsXG4gIFx0ZmluZE5leHROb2RlOiBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmROZXh0Tm9kZSxcbiAgXHRmaXJzdE5vZGU6IENvbXBvbmVudF9wcm90b3R5cGVfZmlyc3ROb2RlLFxuICBcdGluaXQ6IENvbXBvbmVudF9wcm90b3R5cGVfaW5pdCxcbiAgXHRyZWJpbmQ6IENvbXBvbmVudF9wcm90b3R5cGVfcmViaW5kLFxuICBcdHJlbmRlcjogQ29tcG9uZW50X3Byb3RvdHlwZV9yZW5kZXIsXG4gIFx0dG9TdHJpbmc6IENvbXBvbmVudF9wcm90b3R5cGVfdG9TdHJpbmcsXG4gIFx0dW5iaW5kOiBDb21wb25lbnRfcHJvdG90eXBlX3VuYmluZCxcbiAgXHR1bnJlbmRlcjogQ29tcG9uZW50X3Byb3RvdHlwZV91bnJlbmRlclxuICB9O1xuXG4gIHZhciBfQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuXG4gIHZhciBDb21tZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLnR5cGUgPSBDT01NRU5UO1xuICBcdHRoaXMudmFsdWUgPSBvcHRpb25zLnRlbXBsYXRlLmM7XG4gIH07XG5cbiAgQ29tbWVudC5wcm90b3R5cGUgPSB7XG4gIFx0ZGV0YWNoOiBzaGFyZWRfZGV0YWNoLFxuXG4gIFx0Zmlyc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5ub2RlKSB7XG4gIFx0XHRcdHRoaXMubm9kZSA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGhpcy52YWx1ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzLm5vZGU7XG4gIFx0fSxcblxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gXCI8IS0tXCIgKyB0aGlzLnZhbHVlICsgXCItLT5cIjtcbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHRpZiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0XHR0aGlzLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUpO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgaXRlbXNfQ29tbWVudCA9IENvbW1lbnQ7XG5cbiAgdmFyIFlpZWxkZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHZhciBjb250YWluZXIsIGNvbXBvbmVudDtcblxuICBcdHRoaXMudHlwZSA9IFlJRUxERVI7XG5cbiAgXHR0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lciA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQucm9vdDtcbiAgXHR0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudCA9IGNvbnRhaW5lci5jb21wb25lbnQ7XG5cbiAgXHR0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgXHR0aGlzLmNvbnRhaW5lckZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuXG4gIFx0dmFyIG5hbWUgPSB0aGlzLm5hbWUgPSBvcHRpb25zLnRlbXBsYXRlLm4gfHwgXCJcIjtcblxuICBcdHZhciB0ZW1wbGF0ZSA9IGNvbnRhaW5lci5faW5saW5lUGFydGlhbHNbbmFtZV07XG5cbiAgXHRpZiAoIXRlbXBsYXRlKSB7XG4gIFx0XHR3YXJuSWZEZWJ1ZyhcIkNvdWxkIG5vdCBmaW5kIHRlbXBsYXRlIGZvciBwYXJ0aWFsIFxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIiwgeyByYWN0aXZlOiBvcHRpb25zLnJvb3QgfSk7XG4gIFx0XHR0ZW1wbGF0ZSA9IFtdO1xuICBcdH1cblxuICBcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRvd25lcjogdGhpcyxcbiAgXHRcdHJvb3Q6IGNvbnRhaW5lci5wYXJlbnQsXG4gIFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gIFx0XHRwRWxlbWVudDogdGhpcy5jb250YWluZXJGcmFnbWVudC5wRWxlbWVudFxuICBcdH0pO1xuXG4gIFx0Ly8gZXZlbiB0aG91Z2ggb25seSBvbmUgeWllbGRlciBpcyBhbGxvd2VkLCB3ZSBuZWVkIHRvIGhhdmUgYW4gYXJyYXkgb2YgdGhlbVxuICBcdC8vIGFzIGl0J3MgcG9zc2libGUgdG8gY2F1c2UgYSB5aWVsZGVyIHRvIGJlIGNyZWF0ZWQgYmVmb3JlIHRoZSBsYXN0IG9uZVxuICBcdC8vIHdhcyBkZXN0cm95ZWQgaW4gdGhlIHNhbWUgdHVybiBvZiB0aGUgcnVubG9vcFxuICBcdGlmICghaXNBcnJheShjb21wb25lbnQueWllbGRlcnNbbmFtZV0pKSB7XG4gIFx0XHRjb21wb25lbnQueWllbGRlcnNbbmFtZV0gPSBbdGhpc107XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGNvbXBvbmVudC55aWVsZGVyc1tuYW1lXS5wdXNoKHRoaXMpO1xuICBcdH1cblxuICBcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoY29tcG9uZW50LnlpZWxkZXJzW25hbWVdLmxlbmd0aCA+IDEpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQSBjb21wb25lbnQgdGVtcGxhdGUgY2FuIG9ubHkgaGF2ZSBvbmUge3t5aWVsZFwiICsgKG5hbWUgPyBcIiBcIiArIG5hbWUgOiBcIlwiKSArIFwifX0gZGVjbGFyYXRpb24gYXQgYSB0aW1lXCIpO1xuICBcdFx0fVxuICBcdH0pO1xuICB9O1xuXG4gIFlpZWxkZXIucHJvdG90eXBlID0ge1xuICBcdGRldGFjaDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZGV0YWNoKCk7XG4gIFx0fSxcblxuICBcdGZpbmQ6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZChzZWxlY3Rvcik7XG4gIFx0fSxcblxuICBcdGZpbmRBbGw6IGZ1bmN0aW9uIChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9LFxuXG4gIFx0ZmluZENvbXBvbmVudDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQ29tcG9uZW50KHNlbGVjdG9yKTtcbiAgXHR9LFxuXG4gIFx0ZmluZEFsbENvbXBvbmVudHM6IGZ1bmN0aW9uIChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0fSxcblxuICBcdGZpbmROZXh0Tm9kZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyRnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRmaXJzdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpcnN0Tm9kZSgpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmdldFZhbHVlKG9wdGlvbnMpO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LnJlbmRlcigpO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlcihzaG91bGREZXN0cm95KTtcbiAgXHRcdHJlbW92ZUZyb21BcnJheSh0aGlzLmNvbXBvbmVudC55aWVsZGVyc1t0aGlzLm5hbWVdLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC50b1N0cmluZygpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgaXRlbXNfWWllbGRlciA9IFlpZWxkZXI7XG5cbiAgdmFyIERvY3R5cGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHRoaXMuZGVjbGFyYXRpb24gPSBvcHRpb25zLnRlbXBsYXRlLmE7XG4gIH07XG5cbiAgRG9jdHlwZS5wcm90b3R5cGUgPSB7XG4gIFx0aW5pdDogbm9vcCxcbiAgXHRyZW5kZXI6IG5vb3AsXG4gIFx0dW5yZW5kZXI6IG5vb3AsXG4gIFx0dGVhcmRvd246IG5vb3AsXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBcIjwhRE9DVFlQRVwiICsgdGhpcy5kZWNsYXJhdGlvbiArIFwiPlwiO1xuICBcdH1cbiAgfTtcblxuICB2YXIgaXRlbXNfRG9jdHlwZSA9IERvY3R5cGU7XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV9pbml0ID0gRnJhZ21lbnQkaW5pdDtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRpbml0KG9wdGlvbnMpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dGhpcy5vd25lciA9IG9wdGlvbnMub3duZXI7IC8vIFRoZSBpdGVtIHRoYXQgb3ducyB0aGlzIGZyYWdtZW50IC0gYW4gZWxlbWVudCwgc2VjdGlvbiwgcGFydGlhbCwgb3IgYXR0cmlidXRlXG4gIFx0dGhpcy5wYXJlbnQgPSB0aGlzLm93bmVyLnBhcmVudEZyYWdtZW50O1xuXG4gIFx0Ly8gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAgXHR0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3Q7XG4gIFx0dGhpcy5wRWxlbWVudCA9IG9wdGlvbnMucEVsZW1lbnQ7XG4gIFx0dGhpcy5jb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0O1xuICBcdHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuICBcdHRoaXMua2V5ID0gb3B0aW9ucy5rZXk7XG4gIFx0dGhpcy5yZWdpc3RlcmVkSW5kZXhSZWZzID0gW107XG5cbiAgXHQvLyBlbmNhcHN1bGF0ZWQgc3R5bGVzIHNob3VsZCBiZSBpbmhlcml0ZWQgdW50aWwgdGhleSBnZXQgYXBwbGllZCBieSBhbiBlbGVtZW50XG4gIFx0dGhpcy5jc3NJZHMgPSBcImNzc0lkc1wiIGluIG9wdGlvbnMgPyBvcHRpb25zLmNzc0lkcyA6IHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuY3NzSWRzIDogbnVsbDtcblxuICBcdHRoaXMuaXRlbXMgPSBvcHRpb25zLnRlbXBsYXRlLm1hcChmdW5jdGlvbiAodGVtcGxhdGUsIGkpIHtcbiAgXHRcdHJldHVybiBjcmVhdGVJdGVtKHtcbiAgXHRcdFx0cGFyZW50RnJhZ21lbnQ6IF90aGlzLFxuICBcdFx0XHRwRWxlbWVudDogb3B0aW9ucy5wRWxlbWVudCxcbiAgXHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLFxuICBcdFx0XHRpbmRleDogaVxuICBcdFx0fSk7XG4gIFx0fSk7XG5cbiAgXHR0aGlzLnZhbHVlID0gdGhpcy5hcmdzTGlzdCA9IG51bGw7XG4gIFx0dGhpcy5kaXJ0eUFyZ3MgPSB0aGlzLmRpcnR5VmFsdWUgPSB0cnVlO1xuXG4gIFx0dGhpcy5ib3VuZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJdGVtKG9wdGlvbnMpIHtcbiAgXHRpZiAodHlwZW9mIG9wdGlvbnMudGVtcGxhdGUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHJldHVybiBuZXcgaXRlbXNfVGV4dChvcHRpb25zKTtcbiAgXHR9XG5cbiAgXHRzd2l0Y2ggKG9wdGlvbnMudGVtcGxhdGUudCkge1xuICBcdFx0Y2FzZSBZSUVMREVSOlxuICBcdFx0XHRyZXR1cm4gbmV3IGl0ZW1zX1lpZWxkZXIob3B0aW9ucyk7XG4gIFx0XHRjYXNlIElOVEVSUE9MQVRPUjpcbiAgXHRcdFx0cmV0dXJuIG5ldyBpdGVtc19JbnRlcnBvbGF0b3Iob3B0aW9ucyk7XG4gIFx0XHRjYXNlIFNFQ1RJT046XG4gIFx0XHRcdHJldHVybiBuZXcgX1NlY3Rpb24ob3B0aW9ucyk7XG4gIFx0XHRjYXNlIFRSSVBMRTpcbiAgXHRcdFx0cmV0dXJuIG5ldyBfVHJpcGxlKG9wdGlvbnMpO1xuICBcdFx0Y2FzZSBFTEVNRU5UOlxuICBcdFx0XHR2YXIgY29uc3RydWN0b3IgPSB1bmRlZmluZWQ7XG4gIFx0XHRcdGlmIChjb25zdHJ1Y3RvciA9IENvbXBvbmVudF9nZXRDb21wb25lbnQob3B0aW9ucy5wYXJlbnRGcmFnbWVudC5yb290LCBvcHRpb25zLnRlbXBsYXRlLmUpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIG5ldyBfQ29tcG9uZW50KG9wdGlvbnMsIGNvbnN0cnVjdG9yKTtcbiAgXHRcdFx0fVxuICBcdFx0XHRyZXR1cm4gbmV3IF9FbGVtZW50KG9wdGlvbnMpO1xuICBcdFx0Y2FzZSBQQVJUSUFMOlxuICBcdFx0XHRyZXR1cm4gbmV3IF9QYXJ0aWFsKG9wdGlvbnMpO1xuICBcdFx0Y2FzZSBDT01NRU5UOlxuICBcdFx0XHRyZXR1cm4gbmV3IGl0ZW1zX0NvbW1lbnQob3B0aW9ucyk7XG4gIFx0XHRjYXNlIERPQ1RZUEU6XG4gIFx0XHRcdHJldHVybiBuZXcgaXRlbXNfRG9jdHlwZShvcHRpb25zKTtcblxuICBcdFx0ZGVmYXVsdDpcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiU29tZXRoaW5nIHZlcnkgc3RyYW5nZSBoYXBwZW5lZC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3Vlcy4gVGhhbmtzIVwiKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX3JlYmluZCA9IEZyYWdtZW50JHJlYmluZDtcbiAgZnVuY3Rpb24gRnJhZ21lbnQkcmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcblxuICBcdC8vIGFzc2lnbiBuZXcgY29udGV4dCBrZXlwYXRoIGlmIG5lZWRlZFxuICBcdGlmICghdGhpcy5vd25lciB8fCB0aGlzLm93bmVyLmhhc0NvbnRleHQpIHtcbiAgXHRcdGFzc2lnbk5ld0tleXBhdGgodGhpcywgXCJjb250ZXh0XCIsIG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH1cblxuICBcdHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0aWYgKGl0ZW0ucmViaW5kKSB7XG4gIFx0XHRcdGl0ZW0ucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0fVxuICBcdH0pO1xuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV9yZW5kZXIgPSBGcmFnbWVudCRyZW5kZXI7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkcmVuZGVyKCkge1xuICBcdHZhciByZXN1bHQ7XG5cbiAgXHRpZiAodGhpcy5pdGVtcy5sZW5ndGggPT09IDEpIHtcbiAgXHRcdHJlc3VsdCA9IHRoaXMuaXRlbXNbMF0ucmVuZGVyKCk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJlc3VsdCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICBcdFx0dGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gIFx0XHRcdHJlc3VsdC5hcHBlbmRDaGlsZChpdGVtLnJlbmRlcigpKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICBcdHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX3RvU3RyaW5nID0gRnJhZ21lbnQkdG9TdHJpbmc7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkdG9TdHJpbmcoZXNjYXBlKSB7XG4gIFx0aWYgKCF0aGlzLml0ZW1zKSB7XG4gIFx0XHRyZXR1cm4gXCJcIjtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5pdGVtcy5tYXAoZXNjYXBlID8gdG9Fc2NhcGVkU3RyaW5nIDogRnJhZ21lbnRfcHJvdG90eXBlX3RvU3RyaW5nX190b1N0cmluZykuam9pbihcIlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEZyYWdtZW50X3Byb3RvdHlwZV90b1N0cmluZ19fdG9TdHJpbmcoaXRlbSkge1xuICBcdHJldHVybiBpdGVtLnRvU3RyaW5nKCk7XG4gIH1cblxuICBmdW5jdGlvbiB0b0VzY2FwZWRTdHJpbmcoaXRlbSkge1xuICBcdHJldHVybiBpdGVtLnRvU3RyaW5nKHRydWUpO1xuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV91bmJpbmQgPSBGcmFnbWVudCR1bmJpbmQ7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkdW5iaW5kKCkge1xuICBcdGlmICghdGhpcy5ib3VuZCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHRoaXMuaXRlbXMuZm9yRWFjaCh1bmJpbmRJdGVtKTtcbiAgXHR0aGlzLmJvdW5kID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiB1bmJpbmRJdGVtKGl0ZW0pIHtcbiAgXHRpZiAoaXRlbS51bmJpbmQpIHtcbiAgXHRcdGl0ZW0udW5iaW5kKCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV91bnJlbmRlciA9IEZyYWdtZW50JHVucmVuZGVyO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JHVucmVuZGVyKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRpZiAoIXRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byB1bnJlbmRlciBhIGZyYWdtZW50IHRoYXQgd2FzIG5vdCByZW5kZXJlZFwiKTtcbiAgXHR9XG5cbiAgXHR0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgXHRcdHJldHVybiBpLnVucmVuZGVyKHNob3VsZERlc3Ryb3kpO1xuICBcdH0pO1xuICBcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBGcmFnbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy5pbml0KG9wdGlvbnMpO1xuICB9O1xuXG4gIEZyYWdtZW50LnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IHByb3RvdHlwZV9idWJibGUsXG4gIFx0ZGV0YWNoOiBGcmFnbWVudF9wcm90b3R5cGVfZGV0YWNoLFxuICBcdGZpbmQ6IEZyYWdtZW50X3Byb3RvdHlwZV9maW5kLFxuICBcdGZpbmRBbGw6IEZyYWdtZW50X3Byb3RvdHlwZV9maW5kQWxsLFxuICBcdGZpbmRBbGxDb21wb25lbnRzOiBGcmFnbWVudF9wcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMsXG4gIFx0ZmluZENvbXBvbmVudDogRnJhZ21lbnRfcHJvdG90eXBlX2ZpbmRDb21wb25lbnQsXG4gIFx0ZmluZE5leHROb2RlOiBwcm90b3R5cGVfZmluZE5leHROb2RlLFxuICBcdGZpcnN0Tm9kZTogcHJvdG90eXBlX2ZpcnN0Tm9kZSxcbiAgXHRnZXRBcmdzTGlzdDogZ2V0QXJnc0xpc3QsXG4gIFx0Z2V0Tm9kZTogZ2V0Tm9kZSxcbiAgXHRnZXRWYWx1ZTogcHJvdG90eXBlX2dldFZhbHVlLFxuICBcdGluaXQ6IEZyYWdtZW50X3Byb3RvdHlwZV9pbml0LFxuICBcdHJlYmluZDogRnJhZ21lbnRfcHJvdG90eXBlX3JlYmluZCxcbiAgXHRyZWdpc3RlckluZGV4UmVmOiBmdW5jdGlvbiAoaWR4KSB7XG4gIFx0XHR2YXIgaWR4cyA9IHRoaXMucmVnaXN0ZXJlZEluZGV4UmVmcztcbiAgXHRcdGlmIChpZHhzLmluZGV4T2YoaWR4KSA9PT0gLTEpIHtcbiAgXHRcdFx0aWR4cy5wdXNoKGlkeCk7XG4gIFx0XHR9XG4gIFx0fSxcbiAgXHRyZW5kZXI6IEZyYWdtZW50X3Byb3RvdHlwZV9yZW5kZXIsXG4gIFx0dG9TdHJpbmc6IEZyYWdtZW50X3Byb3RvdHlwZV90b1N0cmluZyxcbiAgXHR1bmJpbmQ6IEZyYWdtZW50X3Byb3RvdHlwZV91bmJpbmQsXG4gIFx0dW5yZWdpc3RlckluZGV4UmVmOiBmdW5jdGlvbiAoaWR4KSB7XG4gIFx0XHR2YXIgaWR4cyA9IHRoaXMucmVnaXN0ZXJlZEluZGV4UmVmcztcbiAgXHRcdGlkeHMuc3BsaWNlKGlkeHMuaW5kZXhPZihpZHgpLCAxKTtcbiAgXHR9LFxuICBcdHVucmVuZGVyOiBGcmFnbWVudF9wcm90b3R5cGVfdW5yZW5kZXJcbiAgfTtcblxuICB2YXIgdmlydHVhbGRvbV9GcmFnbWVudCA9IEZyYWdtZW50O1xuXG4gIHZhciBwcm90b3R5cGVfcmVzZXQgPSBSYWN0aXZlJHJlc2V0O1xuICB2YXIgc2hvdWxkUmVyZW5kZXIgPSBbXCJ0ZW1wbGF0ZVwiLCBcInBhcnRpYWxzXCIsIFwiY29tcG9uZW50c1wiLCBcImRlY29yYXRvcnNcIiwgXCJldmVudHNcIl0sXG4gICAgICByZXNldEhvb2sgPSBuZXcgaG9va3NfSG9vayhcInJlc2V0XCIpO1xuICBmdW5jdGlvbiBSYWN0aXZlJHJlc2V0KGRhdGEpIHtcbiAgXHR2YXIgcHJvbWlzZSwgd3JhcHBlciwgY2hhbmdlcywgaSwgcmVyZW5kZXI7XG5cbiAgXHRkYXRhID0gZGF0YSB8fCB7fTtcblxuICBcdGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIikge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc2V0IG1ldGhvZCB0YWtlcyBlaXRoZXIgbm8gYXJndW1lbnRzLCBvciBhbiBvYmplY3QgY29udGFpbmluZyBuZXcgZGF0YVwiKTtcbiAgXHR9XG5cbiAgXHQvLyBJZiB0aGUgcm9vdCBvYmplY3QgaXMgd3JhcHBlZCwgdHJ5IGFuZCB1c2UgdGhlIHdyYXBwZXIncyByZXNldCB2YWx1ZVxuICBcdGlmICgod3JhcHBlciA9IHRoaXMudmlld21vZGVsLndyYXBwZWRbXCJcIl0pICYmIHdyYXBwZXIucmVzZXQpIHtcbiAgXHRcdGlmICh3cmFwcGVyLnJlc2V0KGRhdGEpID09PSBmYWxzZSkge1xuICBcdFx0XHQvLyByZXNldCB3YXMgcmVqZWN0ZWQsIHdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgb2JqZWN0XG4gIFx0XHRcdHRoaXMudmlld21vZGVsLnJlc2V0KGRhdGEpO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHR0aGlzLnZpZXdtb2RlbC5yZXNldChkYXRhKTtcbiAgXHR9XG5cbiAgXHQvLyByZXNldCBjb25maWcgaXRlbXMgYW5kIHRyYWNrIGlmIG5lZWQgdG8gcmVyZW5kZXJcbiAgXHRjaGFuZ2VzID0gY29uZmlnX2NvbmZpZy5yZXNldCh0aGlzKTtcblxuICBcdGkgPSBjaGFuZ2VzLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpZiAoc2hvdWxkUmVyZW5kZXIuaW5kZXhPZihjaGFuZ2VzW2ldKSA+IC0xKSB7XG4gIFx0XHRcdHJlcmVuZGVyID0gdHJ1ZTtcbiAgXHRcdFx0YnJlYWs7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKHJlcmVuZGVyKSB7XG4gIFx0XHR2YXIgY29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG4gIFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKHJvb3RLZXlwYXRoKTtcblxuICBcdFx0Ly8gSXMgdGhpcyBpcyBhIGNvbXBvbmVudCwgd2UgbmVlZCB0byBzZXQgdGhlIGBzaG91bGREZXN0cm95YFxuICBcdFx0Ly8gZmxhZywgb3RoZXJ3aXNlIGl0IHdpbGwgYXNzdW1lIGJ5IGRlZmF1bHQgdGhhdCBhIHBhcmVudCBub2RlXG4gIFx0XHQvLyB3aWxsIGJlIGRldGFjaGVkLCBhbmQgdGhlcmVmb3JlIGl0IGRvZXNuJ3QgbmVlZCB0byBib3RoZXJcbiAgXHRcdC8vIGRldGFjaGluZyBpdHMgb3duIG5vZGVzXG4gIFx0XHRpZiAoY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQpIHtcbiAgXHRcdFx0Y29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSB0cnVlO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnVucmVuZGVyKCk7XG5cbiAgXHRcdGlmIChjb21wb25lbnQpIHtcbiAgXHRcdFx0Y29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSBmYWxzZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gSWYgdGhlIHRlbXBsYXRlIGNoYW5nZWQsIHdlIG5lZWQgdG8gZGVzdHJveSB0aGUgcGFyYWxsZWwgRE9NXG4gIFx0XHQvLyBUT0RPIGlmIHdlJ3JlIGhlcmUsIHByZXN1bWFibHkgaXQgZGlkP1xuICBcdFx0aWYgKHRoaXMuZnJhZ21lbnQudGVtcGxhdGUgIT09IHRoaXMudGVtcGxhdGUpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblxuICBcdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLFxuICBcdFx0XHRcdHJvb3Q6IHRoaXMsXG4gIFx0XHRcdFx0b3duZXI6IHRoaXNcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdHByb21pc2UgPSB0aGlzLnJlbmRlcih0aGlzLmVsLCB0aGlzLmFuY2hvcik7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHByb21pc2UgPSBnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLCB0cnVlKTtcbiAgXHRcdHRoaXMudmlld21vZGVsLm1hcmsocm9vdEtleXBhdGgpO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIFx0fVxuXG4gIFx0cmVzZXRIb29rLmZpcmUodGhpcywgZGF0YSk7XG5cbiAgXHRyZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHZhciByZXNldFBhcnRpYWwgPSBmdW5jdGlvbiAobmFtZSwgcGFydGlhbCkge1xuICBcdHZhciBwcm9taXNlLFxuICBcdCAgICBjb2xsZWN0aW9uID0gW107XG5cbiAgXHRmdW5jdGlvbiBjb2xsZWN0KHNvdXJjZSwgZGVzdCwgcmFjdGl2ZSkge1xuICBcdFx0Ly8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCBhbmQgaXQgaGFzIGl0cyBvd24gcGFydGlhbCwgYmFpbFxuICBcdFx0aWYgKHJhY3RpdmUgJiYgcmFjdGl2ZS5wYXJ0aWFsc1tuYW1lXSkgcmV0dXJuO1xuXG4gIFx0XHRzb3VyY2UuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0XHQvLyBxdWV1ZSB0byByZXJlbmRlciBpZiB0aGUgaXRlbSBpcyBhIHBhcnRpYWwgYW5kIHRoZSBjdXJyZW50IG5hbWUgbWF0Y2hlc1xuICBcdFx0XHRpZiAoaXRlbS50eXBlID09PSBQQVJUSUFMICYmIGl0ZW0uZ2V0UGFydGlhbE5hbWUoKSA9PT0gbmFtZSkge1xuICBcdFx0XHRcdGRlc3QucHVzaChpdGVtKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIGlmIGl0IGhhcyBhIGZyYWdtZW50LCBwcm9jZXNzIGl0cyBpdGVtc1xuICBcdFx0XHRpZiAoaXRlbS5mcmFnbWVudCkge1xuICBcdFx0XHRcdGNvbGxlY3QoaXRlbS5mcmFnbWVudC5pdGVtcywgZGVzdCwgcmFjdGl2ZSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBvciBpZiBpdCBoYXMgZnJhZ21lbnRzXG4gIFx0XHRcdGlmIChpc0FycmF5KGl0ZW0uZnJhZ21lbnRzKSkge1xuICBcdFx0XHRcdGNvbGxlY3QoaXRlbS5mcmFnbWVudHMsIGRlc3QsIHJhY3RpdmUpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gb3IgaWYgaXQgaXMgaXRzZWxmIGEgZnJhZ21lbnQsIHByb2Nlc3MgaXRzIGl0ZW1zXG4gIFx0XHRcdGVsc2UgaWYgKGlzQXJyYXkoaXRlbS5pdGVtcykpIHtcbiAgXHRcdFx0XHRjb2xsZWN0KGl0ZW0uaXRlbXMsIGRlc3QsIHJhY3RpdmUpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gb3IgaWYgaXQgaXMgYSBjb21wb25lbnQsIHN0ZXAgaW4gYW5kIHByb2Nlc3MgaXRzIGl0ZW1zXG4gIFx0XHRcdGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gQ09NUE9ORU5UICYmIGl0ZW0uaW5zdGFuY2UpIHtcbiAgXHRcdFx0XHRjb2xsZWN0KGl0ZW0uaW5zdGFuY2UuZnJhZ21lbnQuaXRlbXMsIGRlc3QsIGl0ZW0uaW5zdGFuY2UpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gaWYgdGhlIGl0ZW0gaXMgYW4gZWxlbWVudCwgcHJvY2VzcyBpdHMgYXR0cmlidXRlcyB0b29cbiAgXHRcdFx0aWYgKGl0ZW0udHlwZSA9PT0gRUxFTUVOVCkge1xuICBcdFx0XHRcdGlmIChpc0FycmF5KGl0ZW0uYXR0cmlidXRlcykpIHtcbiAgXHRcdFx0XHRcdGNvbGxlY3QoaXRlbS5hdHRyaWJ1dGVzLCBkZXN0LCByYWN0aXZlKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAoaXNBcnJheShpdGVtLmNvbmRpdGlvbmFsQXR0cmlidXRlcykpIHtcbiAgXHRcdFx0XHRcdGNvbGxlY3QoaXRlbS5jb25kaXRpb25hbEF0dHJpYnV0ZXMsIGRlc3QsIHJhY3RpdmUpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0Y29sbGVjdCh0aGlzLmZyYWdtZW50Lml0ZW1zLCBjb2xsZWN0aW9uKTtcbiAgXHR0aGlzLnBhcnRpYWxzW25hbWVdID0gcGFydGlhbDtcblxuICBcdHByb21pc2UgPSBnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLCB0cnVlKTtcblxuICBcdGNvbGxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0aXRlbS52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgXHRcdGl0ZW0uc2V0VmFsdWUobmFtZSk7XG4gIFx0fSk7XG5cbiAgXHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcblxuICBcdHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIC8vIFRPRE8gc2hvdWxkIHJlc2V0VGVtcGxhdGUgYmUgYXN5bmNocm9ub3VzPyBpLmUuIHNob3VsZCBpdCBiZSBhIGNhc2VcbiAgLy8gb2Ygb3V0cm8sIHVwZGF0ZSB0ZW1wbGF0ZSwgaW50cm8/IEkgcmVja29uIHByb2JhYmx5IG5vdCwgc2luY2UgdGhhdFxuICAvLyBjb3VsZCBiZSBhY2hpZXZlZCB3aXRoIHVucmVuZGVyLXJlc2V0VGVtcGxhdGUtcmVuZGVyLiBBbHNvLCBpdCBzaG91bGRcbiAgLy8gY29uY2VwdHVhbGx5IGJlIHNpbWlsYXIgdG8gcmVzZXRQYXJ0aWFsLCB3aGljaCBjb3VsZG4ndCBiZSBhc3luY1xuXG4gIHZhciByZXNldFRlbXBsYXRlID0gUmFjdGl2ZSRyZXNldFRlbXBsYXRlO1xuICBmdW5jdGlvbiBSYWN0aXZlJHJlc2V0VGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgXHR2YXIgdHJhbnNpdGlvbnNFbmFibGVkLCBjb21wb25lbnQ7XG5cbiAgXHR0ZW1wbGF0ZV90ZW1wbGF0ZS5pbml0KG51bGwsIHRoaXMsIHsgdGVtcGxhdGU6IHRlbXBsYXRlIH0pO1xuXG4gIFx0dHJhbnNpdGlvbnNFbmFibGVkID0gdGhpcy50cmFuc2l0aW9uc0VuYWJsZWQ7XG4gIFx0dGhpcy50cmFuc2l0aW9uc0VuYWJsZWQgPSBmYWxzZTtcblxuICBcdC8vIElzIHRoaXMgaXMgYSBjb21wb25lbnQsIHdlIG5lZWQgdG8gc2V0IHRoZSBgc2hvdWxkRGVzdHJveWBcbiAgXHQvLyBmbGFnLCBvdGhlcndpc2UgaXQgd2lsbCBhc3N1bWUgYnkgZGVmYXVsdCB0aGF0IGEgcGFyZW50IG5vZGVcbiAgXHQvLyB3aWxsIGJlIGRldGFjaGVkLCBhbmQgdGhlcmVmb3JlIGl0IGRvZXNuJ3QgbmVlZCB0byBib3RoZXJcbiAgXHQvLyBkZXRhY2hpbmcgaXRzIG93biBub2Rlc1xuICBcdGlmIChjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudCkge1xuICBcdFx0Y29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSB0cnVlO1xuICBcdH1cblxuICBcdHRoaXMudW5yZW5kZXIoKTtcblxuICBcdGlmIChjb21wb25lbnQpIHtcbiAgXHRcdGNvbXBvbmVudC5zaG91bGREZXN0cm95ID0gZmFsc2U7XG4gIFx0fVxuXG4gIFx0Ly8gcmVtb3ZlIGV4aXN0aW5nIGZyYWdtZW50IGFuZCBjcmVhdGUgbmV3IG9uZVxuICBcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0dGhpcy5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLFxuICBcdFx0cm9vdDogdGhpcyxcbiAgXHRcdG93bmVyOiB0aGlzXG4gIFx0fSk7XG5cbiAgXHR0aGlzLnJlbmRlcih0aGlzLmVsLCB0aGlzLmFuY2hvcik7XG5cbiAgXHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IHRyYW5zaXRpb25zRW5hYmxlZDtcbiAgfVxuXG4gIHZhciByZXZlcnNlID0gbWFrZUFycmF5TWV0aG9kKFwicmV2ZXJzZVwiKTtcblxuICB2YXIgUmFjdGl2ZV9wcm90b3R5cGVfc2V0ID0gUmFjdGl2ZSRzZXQ7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRzZXQoa2V5cGF0aCwgdmFsdWUpIHtcbiAgXHR2YXIgbWFwLCBwcm9taXNlO1xuXG4gIFx0cHJvbWlzZSA9IGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMsIHRydWUpO1xuXG4gIFx0Ly8gU2V0IG11bHRpcGxlIGtleXBhdGhzIGluIG9uZSBnb1xuICBcdGlmIChpc09iamVjdChrZXlwYXRoKSkge1xuICBcdFx0bWFwID0ga2V5cGF0aDtcblxuICBcdFx0Zm9yIChrZXlwYXRoIGluIG1hcCkge1xuICBcdFx0XHRpZiAobWFwLmhhc093blByb3BlcnR5KGtleXBhdGgpKSB7XG4gIFx0XHRcdFx0dmFsdWUgPSBtYXBba2V5cGF0aF07XG4gIFx0XHRcdFx0c2V0KHRoaXMsIGtleXBhdGgsIHZhbHVlKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIFNldCBhIHNpbmdsZSBrZXlwYXRoXG4gIFx0ZWxzZSB7XG4gIFx0XHRzZXQodGhpcywga2V5cGF0aCwgdmFsdWUpO1xuICBcdH1cblxuICBcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBzZXQocmFjdGl2ZSwga2V5cGF0aCwgdmFsdWUpIHtcbiAgXHRrZXlwYXRoID0gZ2V0S2V5cGF0aChub3JtYWxpc2Uoa2V5cGF0aCkpO1xuXG4gIFx0aWYgKGtleXBhdGguaXNQYXR0ZXJuKSB7XG4gIFx0XHRnZXRNYXRjaGluZ0tleXBhdGhzKHJhY3RpdmUsIGtleXBhdGgpLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwuc2V0KGtleXBhdGgsIHZhbHVlKTtcbiAgXHRcdH0pO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5zZXQoa2V5cGF0aCwgdmFsdWUpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBzaGlmdCA9IG1ha2VBcnJheU1ldGhvZChcInNoaWZ0XCIpO1xuXG4gIHZhciBwcm90b3R5cGVfc29ydCA9IG1ha2VBcnJheU1ldGhvZChcInNvcnRcIik7XG5cbiAgdmFyIHNwbGljZSA9IG1ha2VBcnJheU1ldGhvZChcInNwbGljZVwiKTtcblxuICB2YXIgc3VidHJhY3QgPSBSYWN0aXZlJHN1YnRyYWN0O1xuICBmdW5jdGlvbiBSYWN0aXZlJHN1YnRyYWN0KGtleXBhdGgsIGQpIHtcbiAgXHRyZXR1cm4gc2hhcmVkX2FkZCh0aGlzLCBrZXlwYXRoLCBkID09PSB1bmRlZmluZWQgPyAtMSA6IC1kKTtcbiAgfVxuXG4gIC8vIFRlYXJkb3duLiBUaGlzIGdvZXMgdGhyb3VnaCB0aGUgcm9vdCBmcmFnbWVudCBhbmQgYWxsIGl0cyBjaGlsZHJlbiwgcmVtb3Zpbmcgb2JzZXJ2ZXJzXG4gIC8vIGFuZCBnZW5lcmFsbHkgY2xlYW5pbmcgdXAgYWZ0ZXIgaXRzZWxmXG5cbiAgdmFyIFJhY3RpdmVfcHJvdG90eXBlX3RlYXJkb3duID0gUmFjdGl2ZSR0ZWFyZG93bjtcblxuICB2YXIgUmFjdGl2ZV9wcm90b3R5cGVfdGVhcmRvd25fX3RlYXJkb3duSG9vayA9IG5ldyBob29rc19Ib29rKFwidGVhcmRvd25cIik7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkdGVhcmRvd24oKSB7XG4gIFx0dmFyIHByb21pc2U7XG5cbiAgXHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdHRoaXMudmlld21vZGVsLnRlYXJkb3duKCk7XG5cbiAgXHR0aGlzLl9vYnNlcnZlcnMuZm9yRWFjaChjYW5jZWwpO1xuXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQucmVuZGVyZWQgJiYgdGhpcy5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18pIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheSh0aGlzLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXywgdGhpcyk7XG4gIFx0fVxuXG4gIFx0dGhpcy5zaG91bGREZXN0cm95ID0gdHJ1ZTtcbiAgXHRwcm9taXNlID0gdGhpcy5mcmFnbWVudC5yZW5kZXJlZCA/IHRoaXMudW5yZW5kZXIoKSA6IHV0aWxzX1Byb21pc2UucmVzb2x2ZSgpO1xuXG4gIFx0UmFjdGl2ZV9wcm90b3R5cGVfdGVhcmRvd25fX3RlYXJkb3duSG9vay5maXJlKHRoaXMpO1xuXG4gIFx0dGhpcy5fYm91bmRGdW5jdGlvbnMuZm9yRWFjaChkZWxldGVGdW5jdGlvbkNvcHkpO1xuXG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVGdW5jdGlvbkNvcHkoYm91bmQpIHtcbiAgXHRkZWxldGUgYm91bmQuZm5bYm91bmQucHJvcF07XG4gIH1cblxuICB2YXIgdG9nZ2xlID0gUmFjdGl2ZSR0b2dnbGU7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkdG9nZ2xlKGtleXBhdGgpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0aWYgKHR5cGVvZiBrZXlwYXRoICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGJhZEFyZ3VtZW50cyk7XG4gIFx0fVxuXG4gIFx0dmFyIGNoYW5nZXMgPSB1bmRlZmluZWQ7XG5cbiAgXHRpZiAoL1xcKi8udGVzdChrZXlwYXRoKSkge1xuICBcdFx0Y2hhbmdlcyA9IHt9O1xuXG4gIFx0XHRnZXRNYXRjaGluZ0tleXBhdGhzKHRoaXMsIGdldEtleXBhdGgobm9ybWFsaXNlKGtleXBhdGgpKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRjaGFuZ2VzW2tleXBhdGguc3RyXSA9ICFfdGhpcy52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuICBcdFx0fSk7XG5cbiAgXHRcdHJldHVybiB0aGlzLnNldChjaGFuZ2VzKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5zZXQoa2V5cGF0aCwgIXRoaXMuZ2V0KGtleXBhdGgpKTtcbiAgfVxuXG4gIHZhciB0b0hUTUwgPSBSYWN0aXZlJHRvSFRNTDtcblxuICBmdW5jdGlvbiBSYWN0aXZlJHRvSFRNTCgpIHtcbiAgXHRyZXR1cm4gdGhpcy5mcmFnbWVudC50b1N0cmluZyh0cnVlKTtcbiAgfVxuXG4gIHZhciBSYWN0aXZlX3Byb3RvdHlwZV91bnJlbmRlciA9IFJhY3RpdmUkdW5yZW5kZXI7XG4gIHZhciB1bnJlbmRlckhvb2sgPSBuZXcgaG9va3NfSG9vayhcInVucmVuZGVyXCIpO1xuICBmdW5jdGlvbiBSYWN0aXZlJHVucmVuZGVyKCkge1xuICBcdHZhciBwcm9taXNlLCBzaG91bGREZXN0cm95O1xuXG4gIFx0aWYgKCF0aGlzLmZyYWdtZW50LnJlbmRlcmVkKSB7XG4gIFx0XHR3YXJuSWZEZWJ1ZyhcInJhY3RpdmUudW5yZW5kZXIoKSB3YXMgY2FsbGVkIG9uIGEgUmFjdGl2ZSBpbnN0YW5jZSB0aGF0IHdhcyBub3QgcmVuZGVyZWRcIik7XG4gIFx0XHRyZXR1cm4gdXRpbHNfUHJvbWlzZS5yZXNvbHZlKCk7XG4gIFx0fVxuXG4gIFx0cHJvbWlzZSA9IGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMsIHRydWUpO1xuXG4gIFx0Ly8gSWYgdGhpcyBpcyBhIGNvbXBvbmVudCwgYW5kIHRoZSBjb21wb25lbnQgaXNuJ3QgbWFya2VkIGZvciBkZXN0cnVjdGlvbixcbiAgXHQvLyBkb24ndCBkZXRhY2ggbm9kZXMgZnJvbSB0aGUgRE9NIHVubmVjZXNzYXJpbHlcbiAgXHRzaG91bGREZXN0cm95ID0gIXRoaXMuY29tcG9uZW50IHx8IHRoaXMuY29tcG9uZW50LnNob3VsZERlc3Ryb3kgfHwgdGhpcy5zaG91bGREZXN0cm95O1xuXG4gIFx0Ly8gQ2FuY2VsIGFueSBhbmltYXRpb25zIGluIHByb2dyZXNzXG4gIFx0d2hpbGUgKHRoaXMuX2FuaW1hdGlvbnNbMF0pIHtcbiAgXHRcdHRoaXMuX2FuaW1hdGlvbnNbMF0uc3RvcCgpOyAvLyBpdCB3aWxsIHJlbW92ZSBpdHNlbGYgZnJvbSB0aGUgaW5kZXhcbiAgXHR9XG5cbiAgXHR0aGlzLmZyYWdtZW50LnVucmVuZGVyKHNob3VsZERlc3Ryb3kpO1xuXG4gIFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLCB0aGlzKTtcblxuICBcdHVucmVuZGVySG9vay5maXJlKHRoaXMpO1xuXG4gIFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICB2YXIgdW5zaGlmdCA9IG1ha2VBcnJheU1ldGhvZChcInVuc2hpZnRcIik7XG5cbiAgdmFyIFJhY3RpdmVfcHJvdG90eXBlX3VwZGF0ZSA9IFJhY3RpdmUkdXBkYXRlO1xuICB2YXIgdXBkYXRlSG9vayA9IG5ldyBob29rc19Ib29rKFwidXBkYXRlXCIpO1xuICBmdW5jdGlvbiBSYWN0aXZlJHVwZGF0ZShrZXlwYXRoKSB7XG4gIFx0dmFyIHByb21pc2U7XG5cbiAgXHRrZXlwYXRoID0gZ2V0S2V5cGF0aChrZXlwYXRoKSB8fCByb290S2V5cGF0aDtcblxuICBcdHByb21pc2UgPSBnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLCB0cnVlKTtcbiAgXHR0aGlzLnZpZXdtb2RlbC5tYXJrKGtleXBhdGgpO1xuICBcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0dXBkYXRlSG9vay5maXJlKHRoaXMsIGtleXBhdGgpO1xuXG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3VwZGF0ZU1vZGVsID0gUmFjdGl2ZSR1cGRhdGVNb2RlbDtcblxuICBmdW5jdGlvbiBSYWN0aXZlJHVwZGF0ZU1vZGVsKGtleXBhdGgsIGNhc2NhZGUpIHtcbiAgXHR2YXIgdmFsdWVzLCBrZXksIGJpbmRpbmdzO1xuXG4gIFx0aWYgKHR5cGVvZiBrZXlwYXRoID09PSBcInN0cmluZ1wiICYmICFjYXNjYWRlKSB7XG4gIFx0XHRiaW5kaW5ncyA9IHRoaXMuX3R3b3dheUJpbmRpbmdzW2tleXBhdGhdO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRiaW5kaW5ncyA9IFtdO1xuXG4gIFx0XHRmb3IgKGtleSBpbiB0aGlzLl90d293YXlCaW5kaW5ncykge1xuICBcdFx0XHRpZiAoIWtleXBhdGggfHwgZ2V0S2V5cGF0aChrZXkpLmVxdWFsc09yU3RhcnRzV2l0aChrZXlwYXRoKSkge1xuICBcdFx0XHRcdC8vIFRPRE8gaXMgdGhpcyByaWdodD9cbiAgXHRcdFx0XHRiaW5kaW5ncy5wdXNoLmFwcGx5KGJpbmRpbmdzLCB0aGlzLl90d293YXlCaW5kaW5nc1trZXldKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHZhbHVlcyA9IGNvbnNvbGlkYXRlKHRoaXMsIGJpbmRpbmdzKTtcbiAgXHRyZXR1cm4gdGhpcy5zZXQodmFsdWVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnNvbGlkYXRlKHJhY3RpdmUsIGJpbmRpbmdzKSB7XG4gIFx0dmFyIHZhbHVlcyA9IHt9LFxuICBcdCAgICBjaGVja2JveEdyb3VwcyA9IFtdO1xuXG4gIFx0YmluZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICBcdFx0dmFyIG9sZFZhbHVlLCBuZXdWYWx1ZTtcblxuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gcmFkaW8gbmFtZSBiaW5kaW5nc1xuICBcdFx0aWYgKGIucmFkaW9OYW1lICYmICFiLmVsZW1lbnQubm9kZS5jaGVja2VkKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gY2hlY2tib3ggbmFtZSBiaW5kaW5ncyBjb21lIGluIGdyb3Vwcywgc29cbiAgXHRcdC8vIHdlIHdhbnQgdG8gZ2V0IHRoZSB2YWx1ZSBvbmNlIGF0IG1vc3RcbiAgXHRcdGlmIChiLmNoZWNrYm94TmFtZSkge1xuICBcdFx0XHRpZiAoIWNoZWNrYm94R3JvdXBzW2Iua2V5cGF0aC5zdHJdICYmICFiLmNoYW5nZWQoKSkge1xuICBcdFx0XHRcdGNoZWNrYm94R3JvdXBzLnB1c2goYi5rZXlwYXRoKTtcbiAgXHRcdFx0XHRjaGVja2JveEdyb3Vwc1tiLmtleXBhdGguc3RyXSA9IGI7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdG9sZFZhbHVlID0gYi5hdHRyaWJ1dGUudmFsdWU7XG4gIFx0XHRuZXdWYWx1ZSA9IGIuZ2V0VmFsdWUoKTtcblxuICBcdFx0aWYgKGFycmF5Q29udGVudHNNYXRjaChvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFpc0VxdWFsKG9sZFZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgXHRcdFx0dmFsdWVzW2Iua2V5cGF0aC5zdHJdID0gbmV3VmFsdWU7XG4gIFx0XHR9XG4gIFx0fSk7XG5cbiAgXHQvLyBIYW5kbGUgZ3JvdXBzIG9mIGA8aW5wdXQgdHlwZT0nY2hlY2tib3gnIG5hbWU9J3t7Zm9vfX0nIC4uLj5gXG4gIFx0aWYgKGNoZWNrYm94R3JvdXBzLmxlbmd0aCkge1xuICBcdFx0Y2hlY2tib3hHcm91cHMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHR2YXIgYmluZGluZywgb2xkVmFsdWUsIG5ld1ZhbHVlO1xuXG4gIFx0XHRcdGJpbmRpbmcgPSBjaGVja2JveEdyb3Vwc1trZXlwYXRoLnN0cl07IC8vIG9uZSB0byByZXByZXNlbnQgdGhlIGVudGlyZSBncm91cFxuICBcdFx0XHRvbGRWYWx1ZSA9IGJpbmRpbmcuYXR0cmlidXRlLnZhbHVlO1xuICBcdFx0XHRuZXdWYWx1ZSA9IGJpbmRpbmcuZ2V0VmFsdWUoKTtcblxuICBcdFx0XHRpZiAoIWFycmF5Q29udGVudHNNYXRjaChvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gIFx0XHRcdFx0dmFsdWVzW2tleXBhdGguc3RyXSA9IG5ld1ZhbHVlO1xuICBcdFx0XHR9XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZSA9IHtcbiAgXHRhZGQ6IHByb3RvdHlwZV9hZGQsXG4gIFx0YW5pbWF0ZTogcHJvdG90eXBlX2FuaW1hdGUsXG4gIFx0ZGV0YWNoOiBwcm90b3R5cGVfZGV0YWNoLFxuICBcdGZpbmQ6IHByb3RvdHlwZV9maW5kLFxuICBcdGZpbmRBbGw6IHByb3RvdHlwZV9maW5kQWxsLFxuICBcdGZpbmRBbGxDb21wb25lbnRzOiBwcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMsXG4gIFx0ZmluZENvbXBvbmVudDogcHJvdG90eXBlX2ZpbmRDb21wb25lbnQsXG4gIFx0ZmluZENvbnRhaW5lcjogZmluZENvbnRhaW5lcixcbiAgXHRmaW5kUGFyZW50OiBmaW5kUGFyZW50LFxuICBcdGZpcmU6IHByb3RvdHlwZV9maXJlLFxuICBcdGdldDogcHJvdG90eXBlX2dldCxcbiAgXHRpbnNlcnQ6IGluc2VydCxcbiAgXHRtZXJnZTogcHJvdG90eXBlX21lcmdlLFxuICBcdG9ic2VydmU6IG9ic2VydmUsXG4gIFx0b2JzZXJ2ZU9uY2U6IG9ic2VydmVPbmNlLFxuICBcdG9mZjogb2ZmLFxuICBcdG9uOiBvbixcbiAgXHRvbmNlOiBvbmNlLFxuICBcdHBvcDogcG9wLFxuICBcdHB1c2g6IHB1c2gsXG4gIFx0cmVuZGVyOiBwcm90b3R5cGVfcmVuZGVyLFxuICBcdHJlc2V0OiBwcm90b3R5cGVfcmVzZXQsXG4gIFx0cmVzZXRQYXJ0aWFsOiByZXNldFBhcnRpYWwsXG4gIFx0cmVzZXRUZW1wbGF0ZTogcmVzZXRUZW1wbGF0ZSxcbiAgXHRyZXZlcnNlOiByZXZlcnNlLFxuICBcdHNldDogUmFjdGl2ZV9wcm90b3R5cGVfc2V0LFxuICBcdHNoaWZ0OiBzaGlmdCxcbiAgXHRzb3J0OiBwcm90b3R5cGVfc29ydCxcbiAgXHRzcGxpY2U6IHNwbGljZSxcbiAgXHRzdWJ0cmFjdDogc3VidHJhY3QsXG4gIFx0dGVhcmRvd246IFJhY3RpdmVfcHJvdG90eXBlX3RlYXJkb3duLFxuICBcdHRvZ2dsZTogdG9nZ2xlLFxuICBcdHRvSFRNTDogdG9IVE1MLFxuICBcdHRvSHRtbDogdG9IVE1MLFxuICBcdHVucmVuZGVyOiBSYWN0aXZlX3Byb3RvdHlwZV91bnJlbmRlcixcbiAgXHR1bnNoaWZ0OiB1bnNoaWZ0LFxuICBcdHVwZGF0ZTogUmFjdGl2ZV9wcm90b3R5cGVfdXBkYXRlLFxuICBcdHVwZGF0ZU1vZGVsOiBwcm90b3R5cGVfdXBkYXRlTW9kZWxcbiAgfTtcblxuICB2YXIgd3JhcE1ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2QsIHN1cGVyTWV0aG9kLCBmb3JjZSkge1xuXG4gIFx0aWYgKGZvcmNlIHx8IG5lZWRzU3VwZXIobWV0aG9kLCBzdXBlck1ldGhvZCkpIHtcblxuICBcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuICBcdFx0XHR2YXIgaGFzU3VwZXIgPSAoXCJfc3VwZXJcIiBpbiB0aGlzKSxcbiAgXHRcdFx0ICAgIF9zdXBlciA9IHRoaXMuX3N1cGVyLFxuICBcdFx0XHQgICAgcmVzdWx0O1xuXG4gIFx0XHRcdHRoaXMuX3N1cGVyID0gc3VwZXJNZXRob2Q7XG5cbiAgXHRcdFx0cmVzdWx0ID0gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgXHRcdFx0aWYgKGhhc1N1cGVyKSB7XG4gIFx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfc3VwZXI7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdFx0fTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cmV0dXJuIG1ldGhvZDtcbiAgXHR9XG4gIH07XG5cbiAgZnVuY3Rpb24gbmVlZHNTdXBlcihtZXRob2QsIHN1cGVyTWV0aG9kKSB7XG4gIFx0cmV0dXJuIHR5cGVvZiBzdXBlck1ldGhvZCA9PT0gXCJmdW5jdGlvblwiICYmIC9fc3VwZXIvLnRlc3QobWV0aG9kKTtcbiAgfVxuXG4gIHZhciB1bndyYXBFeHRlbmRlZCA9IHVud3JhcDtcblxuICBmdW5jdGlvbiB1bndyYXAoQ2hpbGQpIHtcbiAgXHR2YXIgb3B0aW9ucyA9IHt9O1xuXG4gIFx0d2hpbGUgKENoaWxkKSB7XG4gIFx0XHRhZGRSZWdpc3RyaWVzKENoaWxkLCBvcHRpb25zKTtcbiAgXHRcdGFkZE90aGVyT3B0aW9ucyhDaGlsZCwgb3B0aW9ucyk7XG5cbiAgXHRcdGlmIChDaGlsZC5fUGFyZW50ICE9PSBfUmFjdGl2ZSkge1xuICBcdFx0XHRDaGlsZCA9IENoaWxkLl9QYXJlbnQ7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRDaGlsZCA9IGZhbHNlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBvcHRpb25zO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkUmVnaXN0cmllcyhDaGlsZCwgb3B0aW9ucykge1xuICBcdGNvbmZpZ19yZWdpc3RyaWVzLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgXHRcdGFkZFJlZ2lzdHJ5KHIudXNlRGVmYXVsdHMgPyBDaGlsZC5wcm90b3R5cGUgOiBDaGlsZCwgb3B0aW9ucywgci5uYW1lKTtcbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFJlZ2lzdHJ5KHRhcmdldCwgb3B0aW9ucywgbmFtZSkge1xuICBcdHZhciByZWdpc3RyeSxcbiAgXHQgICAga2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldFtuYW1lXSk7XG5cbiAgXHRpZiAoIWtleXMubGVuZ3RoKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKCEocmVnaXN0cnkgPSBvcHRpb25zW25hbWVdKSkge1xuICBcdFx0cmVnaXN0cnkgPSBvcHRpb25zW25hbWVdID0ge307XG4gIFx0fVxuXG4gIFx0a2V5cy5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICBcdFx0cmV0dXJuICEoa2V5IGluIHJlZ2lzdHJ5KTtcbiAgXHR9KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdHJldHVybiByZWdpc3RyeVtrZXldID0gdGFyZ2V0W25hbWVdW2tleV07XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRPdGhlck9wdGlvbnMoQ2hpbGQsIG9wdGlvbnMpIHtcbiAgXHRPYmplY3Qua2V5cyhDaGlsZC5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBcdFx0aWYgKGtleSA9PT0gXCJjb21wdXRlZFwiKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dmFyIHZhbHVlID0gQ2hpbGQucHJvdG90eXBlW2tleV07XG5cbiAgXHRcdGlmICghKGtleSBpbiBvcHRpb25zKSkge1xuICBcdFx0XHRvcHRpb25zW2tleV0gPSB2YWx1ZS5fbWV0aG9kID8gdmFsdWUuX21ldGhvZCA6IHZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBpcyBpdCBhIHdyYXBwZWQgZnVuY3Rpb24/XG4gIFx0XHRlbHNlIGlmICh0eXBlb2Ygb3B0aW9uc1trZXldID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiYgb3B0aW9uc1trZXldLl9tZXRob2QpIHtcblxuICBcdFx0XHR2YXIgcmVzdWx0ID0gdW5kZWZpbmVkLFxuICBcdFx0XHQgICAgbmVlZHNTdXBlciA9IHZhbHVlLl9tZXRob2Q7XG5cbiAgXHRcdFx0aWYgKG5lZWRzU3VwZXIpIHtcbiAgXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLl9tZXRob2Q7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyByZXdyYXAgYm91bmQgZGlyZWN0bHkgdG8gcGFyZW50IGZuXG4gIFx0XHRcdHJlc3VsdCA9IHdyYXBNZXRob2Qob3B0aW9uc1trZXldLl9tZXRob2QsIHZhbHVlKTtcblxuICBcdFx0XHRpZiAobmVlZHNTdXBlcikge1xuICBcdFx0XHRcdHJlc3VsdC5fbWV0aG9kID0gcmVzdWx0O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0b3B0aW9uc1trZXldID0gcmVzdWx0O1xuICBcdFx0fVxuICBcdH0pO1xuICB9XG5cbiAgdmFyIF9leHRlbmQgPSBfZXh0ZW5kX19leHRlbmQ7XG5cbiAgZnVuY3Rpb24gX2V4dGVuZF9fZXh0ZW5kKCkge1xuICBcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBvcHRpb25zID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gIFx0XHRvcHRpb25zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICBcdH1cblxuICBcdGlmICghb3B0aW9ucy5sZW5ndGgpIHtcbiAgXHRcdHJldHVybiBleHRlbmRPbmUodGhpcyk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJldHVybiBvcHRpb25zLnJlZHVjZShleHRlbmRPbmUsIHRoaXMpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZE9uZShQYXJlbnQpIHtcbiAgXHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgXHR2YXIgQ2hpbGQsIHByb3RvO1xuXG4gIFx0Ly8gaWYgd2UncmUgZXh0ZW5kaW5nIHdpdGggYW5vdGhlciBSYWN0aXZlIGluc3RhbmNlLi4uXG4gIFx0Ly9cbiAgXHQvLyAgIHZhciBIdW1hbiA9IFJhY3RpdmUuZXh0ZW5kKC4uLiksIFNwaWRlciA9IFJhY3RpdmUuZXh0ZW5kKC4uLik7XG4gIFx0Ly8gICB2YXIgU3BpZGVybWFuID0gSHVtYW4uZXh0ZW5kKCBTcGlkZXIgKTtcbiAgXHQvL1xuICBcdC8vIC4uLmluaGVyaXQgcHJvdG90eXBlIG1ldGhvZHMgYW5kIGRlZmF1bHQgb3B0aW9ucyBhcyB3ZWxsXG4gIFx0aWYgKG9wdGlvbnMucHJvdG90eXBlIGluc3RhbmNlb2YgX1JhY3RpdmUpIHtcbiAgXHRcdG9wdGlvbnMgPSB1bndyYXBFeHRlbmRlZChvcHRpb25zKTtcbiAgXHR9XG5cbiAgXHRDaGlsZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0XHRpZiAoISh0aGlzIGluc3RhbmNlb2YgQ2hpbGQpKSByZXR1cm4gbmV3IENoaWxkKG9wdGlvbnMpO1xuICBcdFx0aW5pdGlhbGlzZSh0aGlzLCBvcHRpb25zKTtcbiAgXHR9O1xuXG4gIFx0cHJvdG8gPSBjcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XG4gIFx0cHJvdG8uY29uc3RydWN0b3IgPSBDaGlsZDtcblxuICBcdC8vIFN0YXRpYyBwcm9wZXJ0aWVzXG4gIFx0ZGVmaW5lUHJvcGVydGllcyhDaGlsZCwge1xuICBcdFx0Ly8gYWxpYXMgcHJvdG90eXBlIGFzIGRlZmF1bHRzXG4gIFx0XHRkZWZhdWx0czogeyB2YWx1ZTogcHJvdG8gfSxcblxuICBcdFx0Ly8gZXh0ZW5kYWJsZVxuICBcdFx0ZXh0ZW5kOiB7IHZhbHVlOiBfZXh0ZW5kX19leHRlbmQsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSxcblxuICBcdFx0Ly8gUGFyZW50IC0gZm9yIElFOCwgY2FuJ3QgdXNlIE9iamVjdC5nZXRQcm90b3R5cGVPZlxuICBcdFx0X1BhcmVudDogeyB2YWx1ZTogUGFyZW50IH1cbiAgXHR9KTtcblxuICBcdC8vIGV4dGVuZCBjb25maWd1cmF0aW9uXG4gIFx0Y29uZmlnX2NvbmZpZy5leHRlbmQoUGFyZW50LCBwcm90bywgb3B0aW9ucyk7XG5cbiAgXHRjdXN0b21fZGF0YS5leHRlbmQoUGFyZW50LCBwcm90bywgb3B0aW9ucyk7XG5cbiAgXHRpZiAob3B0aW9ucy5jb21wdXRlZCkge1xuICBcdFx0cHJvdG8uY29tcHV0ZWQgPSB1dGlsc19vYmplY3RfX2V4dGVuZChjcmVhdGUoUGFyZW50LnByb3RvdHlwZS5jb21wdXRlZCksIG9wdGlvbnMuY29tcHV0ZWQpO1xuICBcdH1cblxuICBcdENoaWxkLnByb3RvdHlwZSA9IHByb3RvO1xuXG4gIFx0cmV0dXJuIENoaWxkO1xuICB9XG5cbiAgdmFyIGdldE5vZGVJbmZvID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgXHR2YXIgaW5mbyA9IHt9LFxuICBcdCAgICBwcml2LFxuICBcdCAgICBpbmRpY2VzO1xuXG4gIFx0aWYgKCFub2RlIHx8ICEocHJpdiA9IG5vZGUuX3JhY3RpdmUpKSB7XG4gIFx0XHRyZXR1cm4gaW5mbztcbiAgXHR9XG5cbiAgXHRpbmZvLnJhY3RpdmUgPSBwcml2LnJvb3Q7XG4gIFx0aW5mby5rZXlwYXRoID0gcHJpdi5rZXlwYXRoLnN0cjtcbiAgXHRpbmZvLmluZGV4ID0ge307XG5cbiAgXHQvLyBmaW5kIGFsbCBpbmRleCByZWZlcmVuY2VzIGFuZCByZXNvbHZlIHRoZW1cbiAgXHRpZiAoaW5kaWNlcyA9IFJlc29sdmVyc19maW5kSW5kZXhSZWZzKHByaXYucHJveHkucGFyZW50RnJhZ21lbnQpKSB7XG4gIFx0XHRpbmZvLmluZGV4ID0gUmVzb2x2ZXJzX2ZpbmRJbmRleFJlZnMucmVzb2x2ZShpbmRpY2VzKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gaW5mbztcbiAgfTtcblxuICB2YXIgUmFjdGl2ZSwgcHJvcGVydGllcztcblxuICAvLyBNYWluIFJhY3RpdmUgcmVxdWlyZWQgb2JqZWN0XG4gIFJhY3RpdmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBSYWN0aXZlKSkgcmV0dXJuIG5ldyBSYWN0aXZlKG9wdGlvbnMpO1xuICBcdGluaXRpYWxpc2UodGhpcywgb3B0aW9ucyk7XG4gIH07XG5cbiAgLy8gUmFjdGl2ZSBwcm9wZXJ0aWVzXG4gIHByb3BlcnRpZXMgPSB7XG5cbiAgXHQvLyBkZWJ1ZyBmbGFnXG4gIFx0REVCVUc6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0cnVlIH0sXG4gIFx0REVCVUdfUFJPTUlTRVM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0cnVlIH0sXG5cbiAgXHQvLyBzdGF0aWMgbWV0aG9kczpcbiAgXHRleHRlbmQ6IHsgdmFsdWU6IF9leHRlbmQgfSxcbiAgXHRnZXROb2RlSW5mbzogeyB2YWx1ZTogZ2V0Tm9kZUluZm8gfSxcbiAgXHRwYXJzZTogeyB2YWx1ZTogX3BhcnNlIH0sXG5cbiAgXHQvLyBOYW1lc3BhY2VkIGNvbnN0cnVjdG9yc1xuICBcdFByb21pc2U6IHsgdmFsdWU6IHV0aWxzX1Byb21pc2UgfSxcblxuICBcdC8vIHN1cHBvcnRcbiAgXHRzdmc6IHsgdmFsdWU6IHN2ZyB9LFxuICBcdG1hZ2ljOiB7IHZhbHVlOiBlbnZpcm9ubWVudF9fbWFnaWMgfSxcblxuICBcdC8vIHZlcnNpb25cbiAgXHRWRVJTSU9OOiB7IHZhbHVlOiBcIjAuNy4zXCIgfSxcblxuICBcdC8vIFBsdWdpbnNcbiAgXHRhZGFwdG9yczogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG4gIFx0Y29tcG9uZW50czogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG4gIFx0ZGVjb3JhdG9yczogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG4gIFx0ZWFzaW5nOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogc3RhdGljX2Vhc2luZyB9LFxuICBcdGV2ZW50czogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG4gIFx0aW50ZXJwb2xhdG9yczogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHN0YXRpY19pbnRlcnBvbGF0b3JzIH0sXG4gIFx0cGFydGlhbHM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9LFxuICBcdHRyYW5zaXRpb25zOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfVxuICB9O1xuXG4gIC8vIFJhY3RpdmUgcHJvcGVydGllc1xuICBkZWZpbmVQcm9wZXJ0aWVzKFJhY3RpdmUsIHByb3BlcnRpZXMpO1xuXG4gIFJhY3RpdmUucHJvdG90eXBlID0gdXRpbHNfb2JqZWN0X19leHRlbmQocHJvdG90eXBlLCBjb25maWdfZGVmYXVsdHMpO1xuXG4gIFJhY3RpdmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmFjdGl2ZTtcblxuICAvLyBhbGlhcyBwcm90b3R5cGUgYXMgZGVmYXVsdHNcbiAgUmFjdGl2ZS5kZWZhdWx0cyA9IFJhY3RpdmUucHJvdG90eXBlO1xuXG4gIC8vIFJhY3RpdmUuanMgbWFrZXMgbGliZXJhbCB1c2Ugb2YgdGhpbmdzIGxpa2UgQXJyYXkucHJvdG90eXBlLmluZGV4T2YuIEluXG4gIC8vIG9sZGVyIGJyb3dzZXJzLCB0aGVzZSBhcmUgbWFkZSBhdmFpbGFibGUgdmlhIGEgc2hpbSAtIGhlcmUsIHdlIGRvIGEgcXVpY2tcbiAgLy8gcHJlLWZsaWdodCBjaGVjayB0byBtYWtlIHN1cmUgdGhhdCBlaXRoZXIgYSkgd2UncmUgbm90IGluIGEgc2hpdCBicm93c2VyLFxuICAvLyBvciBiKSB3ZSdyZSB1c2luZyBhIFJhY3RpdmUtbGVnYWN5LmpzIGJ1aWxkXG4gIHZhciBGVU5DVElPTiA9IFwiZnVuY3Rpb25cIjtcblxuICBpZiAodHlwZW9mIERhdGUubm93ICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgU3RyaW5nLnByb3RvdHlwZS50cmltICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgT2JqZWN0LmtleXMgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgQXJyYXkucHJvdG90eXBlLm1hcCAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIEFycmF5LnByb3RvdHlwZS5maWx0ZXIgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICE9PSBGVU5DVElPTikge1xuICBcdHRocm93IG5ldyBFcnJvcihcIkl0IGxvb2tzIGxpa2UgeW91J3JlIGF0dGVtcHRpbmcgdG8gdXNlIFJhY3RpdmUuanMgaW4gYW4gb2xkZXIgYnJvd3Nlci4gWW91J2xsIG5lZWQgdG8gdXNlIG9uZSBvZiB0aGUgJ2xlZ2FjeSBidWlsZHMnIGluIG9yZGVyIHRvIGNvbnRpbnVlIC0gc2VlIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L2xlZ2FjeS1idWlsZHMgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCIpO1xuICB9XG5cbiAgdmFyIF9SYWN0aXZlID0gUmFjdGl2ZTtcblxuICByZXR1cm4gX1JhY3RpdmU7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhY3RpdmUuanMubWFwXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlbm9kZWlmeShmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzXG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0YXJncy5wdXNoKGZ1bmN0aW9uKGVyciwgcmVzKSB7XG5cdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRyZWplY3QoZXJyKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc29sdmUocmVzKVxuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXG5cdFx0XHR2YXIgcmVzID0gZm4uYXBwbHkoc2VsZiwgYXJncylcblxuXHRcdFx0dmFyIGlzUHJvbWlzZSA9IHJlc1xuXHRcdFx0XHQmJiAodHlwZW9mIHJlcyA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHJlcyA9PT0gJ2Z1bmN0aW9uJylcblx0XHRcdFx0JiYgdHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nXG5cblx0XHRcdGlmIChpc1Byb21pc2UpIHtcblx0XHRcdFx0cmVzb2x2ZShyZXMpXG5cdFx0XHR9XG5cdFx0fSlcblx0fVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBleHRlbmRcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIHZhciB0YXJnZXQgPSB7fVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRcbn1cbiIsImZ1bmN0aW9uIHRpbWUoYWN0aW9uLCBzZWNvbmRzKSB7XG5cdHJldHVybiB7IGFjdGlvbiwgc2Vjb25kcyB9XG59XG5mdW5jdGlvbiB3YWxrKHNlY29uZHMpIHtcblx0cmV0dXJuIHRpbWUoJ3dhbGsnLCBzZWNvbmRzKVxufVxuZnVuY3Rpb24gam9nKHNlY29uZHMpIHtcblx0cmV0dXJuIHRpbWUoJ2pvZycsIHNlY29uZHMpXG59XG5mdW5jdGlvbiB3YXJtdXAoc2Vjb25kcykge1xuXHRyZXR1cm4gdGltZSgnd2FybXVwJywgc2Vjb25kcylcbn1cbmZ1bmN0aW9uIGNvb2xkb3duKHNlY29uZHMpIHtcblx0cmV0dXJuIHRpbWUoJ2Nvb2xkb3duJywgc2Vjb25kcylcbn1cblxuY29uc3QgZmlyc3RXZWVrID0gW1xuXHR3YXJtdXAoMC4wNSAqIDYwKSxcblx0am9nKDYwKSwgd2Fsayg2MCksXG5cdGpvZyg2MCksIHdhbGsoNjApLFxuXHRqb2coNjApLCB3YWxrKDYwKSxcblx0am9nKDYwKSwgd2Fsayg2MCksXG5cdGpvZyg2MCksIHdhbGsoNjApLFxuXHRqb2coNjApLCB3YWxrKDYwKSxcblx0am9nKDYwKSwgd2Fsayg2MCksXG5cdGpvZyg2MCksIHdhbGsoNjApLFxuXHRjb29sZG93big1ICogNjApXG5dXG5jb25zdCBzZWNvbmRXZWVrID0gW1xuXHR3YXJtdXAoNSAqIDYwKSxcblx0am9nKDkwKSwgd2FsaygxMjApLFxuXHRqb2coOTApLCB3YWxrKDEyMCksXG5cdGpvZyg5MCksIHdhbGsoMTIwKSxcblx0am9nKDkwKSwgd2FsaygxMjApLFxuXHRqb2coOTApLCB3YWxrKDEyMCksXG5cdGpvZyg5MCksIHdhbGsoMTIwKSxcblx0Y29vbGRvd24oNCAqIDYwKVxuXVxuY29uc3QgdGhpcmRXZWVrID0gW1xuXHR3YXJtdXAoNSAqIDYwKSxcblx0am9nKDkwKSwgd2FsaygxMjApLFxuXHRqb2coOTApLCB3YWxrKDEyMCksXG5cdGpvZygzICogNjApLCB3YWxrKDMgKiA2MCksXG5cdGpvZygzICogNjApLCB3YWxrKDMgKiA2MCksXG5cdGpvZyg5MCksIHdhbGsoMTIwKSxcblx0am9nKDkwKSwgd2FsaygxMjApLFxuXHRqb2coMyAqIDYwKSwgd2FsaygzICogNjApLFxuXHRqb2coMyAqIDYwKSwgd2FsaygzICogNjApLFxuXHRjb29sZG93big1ICogNjApXG5dXG5jb25zdCBmb3VydGhXZWVrID0gW1xuXHR3YXJtdXAoNSAqIDYwKSxcblx0am9nKDUgKiA2MCksIHdhbGsoOTApLFxuXHRqb2coNSAqIDYwKSwgd2FsaygxNTApLFxuXHRqb2coMyAqIDYwKSwgd2Fsayg5MCksXG5cdGpvZyg1ICogNjApLFxuXHRjb29sZG93bigzICogNjAgKyAzMClcbl1cbmNvbnN0IGZpZnRoV2Vla0RheU9uZSA9IFtcblx0d2FybXVwKDUgKiA2MCksXG5cdGpvZyg1ICogNjApLCB3YWxrKDMgKiA2MCksXG5cdGpvZyg1ICogNjApLCB3YWxrKDMgKiA2MCksXG5cdGpvZyg1ICogNjApLFxuXHRjb29sZG93big0ICogNjApXG5dXG5jb25zdCBmaWZ0aFdlZWtEYXlUd28gPSBbXG5cdHdhcm11cCg1ICogNjApLFxuXHRqb2coOCAqIDYwKSwgd2Fsayg1ICogNjApLFxuXHRqb2coOCAqIDYwKSxcblx0Y29vbGRvd24oNCAqIDYwKVxuXVxuY29uc3QgZmlmdGhXZWVrRGF5VGhyZWUgPSBbXG5cdHdhcm11cCg1ICogNjApLFxuXHRqb2coMjAgKiA2MCksXG5cdGNvb2xkb3duKDUgKiA2MClcbl1cblxuY29uc3Qgc2l4dGhXZWVrRGF5T25lID0gW1xuXHR3YXJtdXAoNSAqIDYwKSxcblx0am9nKDUgKiA2MCksIHdhbGsoMyAqIDYwKSxcblx0am9nKDggKiA2MCksIHdhbGsoMyAqIDYwKSxcblx0am9nKDUgKiA2MCksXG5cdGNvb2xkb3duKDQgKiA2MClcbl1cbmNvbnN0IHNpeHRoV2Vla0RheVR3byA9IFtcblx0d2FybXVwKDUgKiA2MCksXG5cdGpvZygxMCAqIDYwKSwgd2FsaygzICogNjApLFxuXHRqb2coMTAgKiA2MCksXG5cdGNvb2xkb3duKDQgKiA2MClcbl1cbmNvbnN0IHNpeHRoV2Vla0RheVRocmVlID0gW1xuXHR3YXJtdXAoNSAqIDYwKSxcblx0am9nKDIyICogNjApLFxuXHRjb29sZG93big1ICogNjApXG5dXG5cbmNvbnN0IHNldmVudGhXZWVrID0gW1xuXHR3YXJtdXAoNSAqIDYwKSxcblx0am9nKDI1KVxuXVxuXG5jb25zdCBlaWdodFdlZWsgPSBbXG5cdHdhcm11cCg1ICogNjApLFxuXHRqb2coMjgpXG5dXG5cbmNvbnN0IG5pbnRoV2VlayA9IFtcblx0d2FybXVwKDUgKiA2MCksXG5cdGpvZygzMClcbl1cblxubW9kdWxlLmV4cG9ydHMgPSBbXG5cdFtmaXJzdFdlZWssIGZpcnN0V2VlaywgZmlyc3RXZWVrXSxcblx0W3NlY29uZFdlZWssIHNlY29uZFdlZWssIHNlY29uZFdlZWtdLFxuXHRbdGhpcmRXZWVrLCB0aGlyZFdlZWssIHRoaXJkV2Vla10sXG5cdFtmb3VydGhXZWVrLCBmb3VydGhXZWVrLCBmb3VydGhXZWVrXSxcblx0W2ZpZnRoV2Vla0RheU9uZSwgZmlmdGhXZWVrRGF5VHdvLCBmaWZ0aFdlZWtEYXlUaHJlZV0sXG5cdFtzaXh0aFdlZWtEYXlPbmUsIHNpeHRoV2Vla0RheVR3bywgc2l4dGhXZWVrRGF5VGhyZWVdLFxuXHRbc2V2ZW50aFdlZWssIHNldmVudGhXZWVrLCBzZXZlbnRoV2Vla10sXG5cdFtlaWdodFdlZWssIGVpZ2h0V2VlaywgZWlnaHRXZWVrXSxcblx0W25pbnRoV2VlaywgbmludGhXZWVrLCBuaW50aFdlZWtdXG5dXG4iXX0=
